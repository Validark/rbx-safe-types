// THIS FILE IS GENERATED AUTOMATICALLY AND SHOULD NOT BE EDITED BY HAND!

/// <reference no-default-lib="true"/>
/// <reference path="roblox.d.ts" />
/// <reference path="generated_enums.d.ts" />

interface CreatableInstancesInternal {
	Accessory: Accessory;
	Hat: Hat;
	AdvancedDragger: AdvancedDragger;
	Animation: Animation;
	AnimationController: AnimationController;
	Animator: Animator;
	Attachment: Attachment;
	Backpack: Backpack;
	HopperBin: HopperBin;
	Flag: Flag;
	Beam: Beam;
	BindableEvent: BindableEvent;
	BindableFunction: BindableFunction;
	BodyAngularVelocity: BodyAngularVelocity;
	BodyForce: BodyForce;
	BodyGyro: BodyGyro;
	BodyPosition: BodyPosition;
	BodyThrust: BodyThrust;
	BodyVelocity: BodyVelocity;
	RocketPropulsion: RocketPropulsion;
	Camera: Camera;
	BodyColors: BodyColors;
	CharacterMesh: CharacterMesh;
	Pants: Pants;
	Shirt: Shirt;
	ShirtGraphic: ShirtGraphic;
	Skin: Skin;
	ClickDetector: ClickDetector;
	Configuration: Configuration;
	AlignOrientation: AlignOrientation;
	AlignPosition: AlignPosition;
	AngularVelocity: AngularVelocity;
	BallSocketConstraint: BallSocketConstraint;
	HingeConstraint: HingeConstraint;
	LineForce: LineForce;
	RodConstraint: RodConstraint;
	RopeConstraint: RopeConstraint;
	CylindricalConstraint: CylindricalConstraint;
	PrismaticConstraint: PrismaticConstraint;
	SpringConstraint: SpringConstraint;
	Torque: Torque;
	VectorForce: VectorForce;
	HumanoidController: HumanoidController;
	SkateboardController: SkateboardController;
	VehicleController: VehicleController;
	CustomEvent: CustomEvent;
	CustomEventReceiver: CustomEventReceiver;
	BlockMesh: BlockMesh;
	CylinderMesh: CylinderMesh;
	SpecialMesh: SpecialMesh;
	DebuggerWatch: DebuggerWatch;
	Dialog: Dialog;
	DialogChoice: DialogChoice;
	Dragger: Dragger;
	Explosion: Explosion;
	Texture: Texture;
	Hole: Hole;
	MotorFeature: MotorFeature;
	Fire: Fire;
	Folder: Folder;
	ForceField: ForceField;
	FunctionalTest: FunctionalTest;
	Frame: Frame;
	ImageButton: ImageButton;
	TextButton: TextButton;
	ImageLabel: ImageLabel;
	TextLabel: TextLabel;
	ScrollingFrame: ScrollingFrame;
	TextBox: TextBox;
	ViewportFrame: ViewportFrame;
	BillboardGui: BillboardGui;
	GuiMain: GuiMain;
	SurfaceGui: SurfaceGui;
	FloorWire: FloorWire;
	BoxHandleAdornment: BoxHandleAdornment;
	ConeHandleAdornment: ConeHandleAdornment;
	CylinderHandleAdornment: CylinderHandleAdornment;
	ImageHandleAdornment: ImageHandleAdornment;
	LineHandleAdornment: LineHandleAdornment;
	SphereHandleAdornment: SphereHandleAdornment;
	SelectionBox: SelectionBox;
	SelectionSphere: SelectionSphere;
	ArcHandles: ArcHandles;
	Handles: Handles;
	SurfaceSelection: SurfaceSelection;
	SelectionPartLasso: SelectionPartLasso;
	SelectionPointLasso: SelectionPointLasso;
	Humanoid: Humanoid;
	HumanoidDescription: HumanoidDescription;
	RotateP: RotateP;
	RotateV: RotateV;
	Glue: Glue;
	ManualGlue: ManualGlue;
	ManualWeld: ManualWeld;
	Motor6D: Motor6D;
	Rotate: Rotate;
	Snap: Snap;
	VelocityMotor: VelocityMotor;
	Weld: Weld;
	Keyframe: Keyframe;
	KeyframeMarker: KeyframeMarker;
	KeyframeSequence: KeyframeSequence;
	PointLight: PointLight;
	SpotLight: SpotLight;
	SurfaceLight: SurfaceLight;
	LocalizationTable: LocalizationTable;
	LocalScript: LocalScript;
	ModuleScript: ModuleScript;
	Hint: Hint;
	CornerWedgePart: CornerWedgePart;
	FlagStand: FlagStand;
	Seat: Seat;
	SkateboardPlatform: SkateboardPlatform;
	SpawnLocation: SpawnLocation;
	WedgePart: WedgePart;
	MeshPart: MeshPart;
	NegateOperation: NegateOperation;
	UnionOperation: UnionOperation;
	TrussPart: TrussPart;
	VehicleSeat: VehicleSeat;
	PartOperationAsset: PartOperationAsset;
	ParticleEmitter: ParticleEmitter;
	PluginAction: PluginAction;
	Pose: Pose;
	BloomEffect: BloomEffect;
	BlurEffect: BlurEffect;
	ColorCorrectionEffect: ColorCorrectionEffect;
	SunRaysEffect: SunRaysEffect;
	ReflectionMetadata: ReflectionMetadata;
	ReflectionMetadataCallbacks: ReflectionMetadataCallbacks;
	ReflectionMetadataClasses: ReflectionMetadataClasses;
	ReflectionMetadataEnums: ReflectionMetadataEnums;
	ReflectionMetadataEvents: ReflectionMetadataEvents;
	ReflectionMetadataFunctions: ReflectionMetadataFunctions;
	ReflectionMetadataClass: ReflectionMetadataClass;
	ReflectionMetadataEnum: ReflectionMetadataEnum;
	ReflectionMetadataEnumItem: ReflectionMetadataEnumItem;
	ReflectionMetadataMember: ReflectionMetadataMember;
	ReflectionMetadataProperties: ReflectionMetadataProperties;
	ReflectionMetadataYieldFunctions: ReflectionMetadataYieldFunctions;
	RemoteEvent: RemoteEvent;
	RemoteFunction: RemoteFunction;
	RenderingTest: RenderingTest;
	Sky: Sky;
	Smoke: Smoke;
	Sound: Sound;
	ChorusSoundEffect: ChorusSoundEffect;
	CompressorSoundEffect: CompressorSoundEffect;
	DistortionSoundEffect: DistortionSoundEffect;
	EchoSoundEffect: EchoSoundEffect;
	EqualizerSoundEffect: EqualizerSoundEffect;
	FlangeSoundEffect: FlangeSoundEffect;
	PitchShiftSoundEffect: PitchShiftSoundEffect;
	ReverbSoundEffect: ReverbSoundEffect;
	TremoloSoundEffect: TremoloSoundEffect;
	SoundGroup: SoundGroup;
	Sparkles: Sparkles;
	StarterGear: StarterGear;
	StarterCharacterScripts: StarterCharacterScripts;
	Team: Team;
	TerrainRegion: TerrainRegion;
	Trail: Trail;
	Tween: Tween;
	UIAspectRatioConstraint: UIAspectRatioConstraint;
	UISizeConstraint: UISizeConstraint;
	UITextSizeConstraint: UITextSizeConstraint;
	UIGridLayout: UIGridLayout;
	UIListLayout: UIListLayout;
	UIPageLayout: UIPageLayout;
	UITableLayout: UITableLayout;
	UIPadding: UIPadding;
	UIScale: UIScale;
	BinaryStringValue: BinaryStringValue;
	BoolValue: BoolValue;
	BrickColorValue: BrickColorValue;
	CFrameValue: CFrameValue;
	Color3Value: Color3Value;
	DoubleConstrainedValue: DoubleConstrainedValue;
	IntConstrainedValue: IntConstrainedValue;
	IntValue: IntValue;
	NumberValue: NumberValue;
	ObjectValue: ObjectValue;
	RayValue: RayValue;
	StringValue: StringValue;
	Vector3Value: Vector3Value;
	WeldConstraint: WeldConstraint;
}

interface Services {
	ABTestService: ABTestService;
	AdService: AdService;
	AnalyticsService: AnalyticsService;
	AssetService: AssetService;
	BadgeService: BadgeService;
	CoreGui: CoreGui;
	StarterGui: StarterGui;
	BrowserService: BrowserService;
	CacheableContentProvider: CacheableContentProvider;
	MeshContentProvider: MeshContentProvider;
	SolidModelContentProvider: SolidModelContentProvider;
	ChangeHistoryService: ChangeHistoryService;
	Chat: Chat;
	ClusterPacketCache: ClusterPacketCache;
	CollectionService: CollectionService;
	ContentProvider: ContentProvider;
	ContextActionService: ContextActionService;
	ControllerService: ControllerService;
	CookiesService: CookiesService;
	CorePackages: CorePackages;
	CoreScriptSyncService: CoreScriptSyncService;
	DataStoreService: DataStoreService;
	Debris: Debris;
	FlagStandService: FlagStandService;
	FlyweightService: FlyweightService;
	CSGDictionaryService: CSGDictionaryService;
	NonReplicatedCSGDictionaryService: NonReplicatedCSGDictionaryService;
	FriendService: FriendService;
	GamePassService: GamePassService;
	GamepadService: GamepadService;
	Geometry: Geometry;
	GoogleAnalyticsConfiguration: GoogleAnalyticsConfiguration;
	GroupService: GroupService;
	GuiService: GuiService;
	GuidRegistryService: GuidRegistryService;
	HapticService: HapticService;
	Hopper: Hopper;
	HttpRbxApiService: HttpRbxApiService;
	HttpService: HttpService;
	InsertService: InsertService;
	JointsService: JointsService;
	KeyboardService: KeyboardService;
	KeyframeSequenceProvider: KeyframeSequenceProvider;
	Lighting: Lighting;
	LocalStorageService: LocalStorageService;
	AppStorageService: AppStorageService;
	UserStorageService: UserStorageService;
	LocalizationService: LocalizationService;
	LogService: LogService;
	LoginService: LoginService;
	LuaWebService: LuaWebService;
	MarketplaceService: MarketplaceService;
	MessagingService: MessagingService;
	MouseService: MouseService;
	NetworkClient: NetworkClient;
	NetworkServer: NetworkServer;
	NetworkSettings: NetworkSettings;
	NotificationService: NotificationService;
	Workspace: Workspace;
	PackageService: PackageService;
	PathfindingService: PathfindingService;
	PhysicsPacketCache: PhysicsPacketCache;
	PhysicsService: PhysicsService;
	Players: Players;
	PluginGuiService: PluginGuiService;
	PointsService: PointsService;
	RenderSettings: RenderSettings;
	ReplicatedFirst: ReplicatedFirst;
	ReplicatedStorage: ReplicatedStorage;
	RobloxReplicatedStorage: RobloxReplicatedStorage;
	RunService: RunService;
	RuntimeScriptService: RuntimeScriptService;
	ScriptContext: ScriptContext;
	ScriptService: ScriptService;
	Selection: Selection;
	ServerScriptService: ServerScriptService;
	ServerStorage: ServerStorage;
	SocialService: SocialService;
	SoundService: SoundService;
	SpawnerService: SpawnerService;
	StarterPack: StarterPack;
	StarterPlayer: StarterPlayer;
	Stats: Stats;
	StopWatchReporter: StopWatchReporter;
	Studio: Studio;
	StudioService: StudioService;
	TaskScheduler: TaskScheduler;
	Teams: Teams;
	TeleportService: TeleportService;
	TestService: TestService;
	TextService: TextService;
	ThirdPartyUserService: ThirdPartyUserService;
	TimerService: TimerService;
	TouchInputService: TouchInputService;
	TweenService: TweenService;
	UserGameSettings: UserGameSettings;
	UserInputService: UserInputService;
	VRService: VRService;
	VirtualInputManager: VirtualInputManager;
	VirtualUser: VirtualUser;
	Visit: Visit;
}

interface InstancesInternal extends CreatableInstancesInternal, Services {
	Instance: Instance;
	AnimationTrack: AnimationTrack;
	BackpackItem: BackpackItem;
	BasePlayerGui: BasePlayerGui;
	PlayerGui: PlayerGui;
	BodyMover: BodyMover;
	CharacterAppearance: CharacterAppearance;
	Clothing: Clothing;
	Constraint: Constraint;
	SlidingBallConstraint: SlidingBallConstraint;
	Controller: Controller;
	DataModelMesh: DataModelMesh;
	BevelMesh: BevelMesh;
	DebugSettings: DebugSettings;
	DebuggerBreakpoint: DebuggerBreakpoint;
	DebuggerManager: DebuggerManager;
	FaceInstance: FaceInstance;
	Feature: Feature;
	File: File;
	GameSettings: GameSettings;
	GlobalDataStore: GlobalDataStore;
	OrderedDataStore: OrderedDataStore;
	GuiBase: GuiBase;
	GuiBase2d: GuiBase2d;
	GuiObject: GuiObject;
	GuiButton: GuiButton;
	GuiLabel: GuiLabel;
	LayerCollector: LayerCollector;
	PluginGui: PluginGui;
	DockWidgetPluginGui: DockWidgetPluginGui;
	QWidgetPluginGui: QWidgetPluginGui;
	GuiBase3d: GuiBase3d;
	PVAdornment: PVAdornment;
	HandleAdornment: HandleAdornment;
	ParabolaAdornment: ParabolaAdornment;
	PartAdornment: PartAdornment;
	HandlesBase: HandlesBase;
	SelectionLasso: SelectionLasso;
	HttpRequest: HttpRequest;
	InputObject: InputObject;
	JointInstance: JointInstance;
	DynamicRotate: DynamicRotate;
	ManualSurfaceJointInstance: ManualSurfaceJointInstance;
	Light: Light;
	LuaSettings: LuaSettings;
	LuaSourceContainer: LuaSourceContainer;
	BaseScript: BaseScript;
	CoreScript: CoreScript;
	Mouse: Mouse;
	PlayerMouse: PlayerMouse;
	PluginMouse: PluginMouse;
	NetworkMarker: NetworkMarker;
	NetworkPeer: NetworkPeer;
	NetworkReplicator: NetworkReplicator;
	ClientReplicator: ClientReplicator;
	ServerReplicator: ServerReplicator;
	PVInstance: PVInstance;
	BasePart: BasePart;
	FormFactorPart: FormFactorPart;
	Platform: Platform;
	Terrain: Terrain;
	TriangleMeshPart: TriangleMeshPart;
	Status: Status;
	PackageLink: PackageLink;
	Pages: Pages;
	DataStorePages: DataStorePages;
	FriendPages: FriendPages;
	InventoryPages: InventoryPages;
	StandardPages: StandardPages;
	Path: Path;
	PhysicsSettings: PhysicsSettings;
	Player: Player;
	PlayerScripts: PlayerScripts;
	Plugin: Plugin;
	PluginDragEvent: PluginDragEvent;
	PluginManager: PluginManager;
	PluginMenu: PluginMenu;
	PluginToolbar: PluginToolbar;
	PluginToolbarButton: PluginToolbarButton;
	PostEffect: PostEffect;
	ReflectionMetadataItem: ReflectionMetadataItem;
	ScriptDebugger: ScriptDebugger;
	ServiceProvider: ServiceProvider;
	DataModel: DataModel;
	GenericSettings: GenericSettings;
	AnalysticsSettings: AnalysticsSettings;
	GlobalSettings: GlobalSettings;
	UserSettings: UserSettings;
	SoundEffect: SoundEffect;
	StatsItem: StatsItem;
	RunningAverageItemDouble: RunningAverageItemDouble;
	RunningAverageItemInt: RunningAverageItemInt;
	RunningAverageTimeIntervalItem: RunningAverageTimeIntervalItem;
	TotalCountTimeIntervalItem: TotalCountTimeIntervalItem;
	StudioTheme: StudioTheme;
	TextFilterResult: TextFilterResult;
	TouchTransmitter: TouchTransmitter;
	Translator: Translator;
	TweenBase: TweenBase;
	UIBase: UIBase;
	UIComponent: UIComponent;
	UIConstraint: UIConstraint;
	UILayout: UILayout;
	UIGridStyleLayout: UIGridStyleLayout;
	ValueBase: ValueBase;
}

interface InstanceBases extends InstancesInternal {
	Accoutrement: Accoutrement | Accessory | Hat;
	Tool: Tool | Flag;
	FileMesh: FileMesh | SpecialMesh;
	Decal: Decal | Texture;
	ScreenGui: ScreenGui | GuiMain;
	Motor: Motor | Motor6D;
	Script: Script | LocalScript;
	Message: Message | Hint;
	Part: Part | FlagStand | Platform | Seat | SkateboardPlatform | SpawnLocation;
	PartOperation: PartOperation | NegateOperation | UnionOperation;
	Model: Model | Status | Workspace;
	StarterPlayerScripts: StarterPlayerScripts | StarterCharacterScripts;
}

interface CreatableInstances extends CreatableInstancesInternal {
	Accoutrement: Accoutrement;
	Tool: Tool;
	FileMesh: FileMesh;
	Decal: Decal;
	ScreenGui: ScreenGui;
	Motor: Motor;
	Script: Script;
	Message: Message;
	Part: Part;
	PartOperation: PartOperation;
	Model: Model;
	StarterPlayerScripts: StarterPlayerScripts;
}

interface Instances extends InstancesInternal, CreatableInstances {}

// GENERATED ROBLOX INSTANCE CLASSES

interface RbxInternalInstance {
	/** Determines if an `Instance` can be cloned using `/Instance/Clone` or saved to file.

This property determines whether an object should be included when the game is published or saved, or when `Clone` is called on one of the objects ancestors. Calling Clone directly on an object will return nil if the cloned object is not archivable. Copying an object in Studio (using the 'Duplicate' or 'Copy' options) will ignore the Archivable property and set Archivable to true for the copy.

```lua
local part = Instance.new("Part")
print(part:Clone()) --&gt; Part
part.Archivable = false
print(part:Clone()) --&gt; nil
``` */
	Archivable: boolean;
	/** A non-unique identifier of the `Instance`.

This property is an identifier that describes an object. Names are not necessarily unique identifiers however; multiple children of an object may share the same name. Names are used to keep the object hierarchy organized, along with allowing scripts to access specific objects.

The name of an object is often used to access the object through the data model hierarchy using the following methods:

```lua
local baseplate = workspace.Baseplate
local baseplate = workspace["Baseplate"]
local baseplate = workspace:FindFirstChild("BasePlate")
```

In order to make an object accessible using the dot operator, an object's Name must follow a certain syntax. The objects name must start with an underscore or letter. The rest of the name can only contain letters, numbers, or underscores (no other special characters). If an objects name does not follow this syntax it will not be accessible using the dot operator and Lua will not interpret its name as an identifier.

If more than one object with the same name are siblings then any attempt to index an object by that name will return the only one of the objects found similar to `FindFirstChild`, but not always the desired object. If a specific object needs to be accessed through code, it is recommended to give it a unique name, or guarantee that none of its siblings share the same name as it. 

Note, a full name showing the instance's hierarchy can be obtained using `GetFullName`. */
	Name: string;
	/** The Parent property determines the hierarchical parent of the `Instance`. The following terminology is commonly used when talking about how this property is set:
  - An object is a **child** (**parented to**) another object when its Parent is set to that object.
  - The **descendants** of an `Instance` are the children of that object, plus the descendants of the children as well.
  - The **ancestors** of an `Instance` are all the objects that the Instance is a descendant of.

It is from this property that many other API members get their name, such as `GetChildren` and `FindFirstChild`.

The `Remove` function sets this property to nil. Calling `Destroy` will set the Parent of an `Instance` and all of its descendants to `nil`, and also **lock** the Parent property. An error is raised when setting the Parent of a destroyed object.

This property is also used to manage whether an object exists in the game or needs be be removed. As long as an objects parent is in the `DataModel`, is stored in a variable, or is referenced by another objects property, then the object remains in the game. Otherwise, the object will automatically be removed. The top level `DataModel` object (the one referred to as the `game` by scripts) has no parent, but always has a reference held to it by the game engine, and exists for the duration of a session.

Newly created objects using `Instance.new` will not have a parent, and usually will not be visible or function until one is set. The most elementary creation of an object has two steps: creating the object, then setting its parent.
```lua
-- Create a part and parent it to the workspace
local part = Instance.new("Part")
part.Parent = workspace
-- Instance new can also take Parent as a second parameter
Instance.new("NumberValue", workspace)
```


# Object Replication
An object created by server will not replicate to clients until it is parented to some object that is replicated. When creating an object then setting many properties, it's recommended to **set Parent last**. This ensures the object replicates once, instead of replicating many property changes.
```lua
local part = Instance.new("Part") -- Avoid using the second parameter here
part.Anchored = true
part.BrickColor = BrickColor.new("Really red")
-- Potentially many other property changes could go here here...
-- Always set parent last!
part.Parent = workspace
```

However, if you were parenting your parts to a `Model` whose parent hasn't been set yet, then setting the parent first would not matter as the model would not have replicated yet. */
	Parent?: Instance;
	/** This function destroys all of an `Instance`'s children.

As `Destroy` also calls itself on the children of an object it is used on, this function will destroy all descendants.

## Alternatives to ClearAllChildren 

If the developer does not wish to destroy all descendants, they should use `GetChildren` or `GetDescendants` to loop through an object and select what to destroy. For example, the following code sample will destroy all parts in an object.

```lua
for _, instance in pairs(object:GetDescendants()) do
	if instance:IsA("BasePart") then
		instance:Destroy()
	end
end
```

## Code Samples

### Instance:ClearAllChildren

This example creates a Part and adds a few sparkle objects to the part. Then it calls Part:ClearAllChildren() to remove all of the children.
```lua

local part = Instance.new("Part")

-- add some sparkles
for i = 1, 3 do
  Instance.new("Sparkles", part)
end

print("Part has " .. #part:GetChildren() .. " children")
--> Part has 3 children

part:ClearAllChildren()

print("Part has " .. #part:GetChildren() .. " children")
--> Part has 0 children

```
 */
	ClearAllChildren(): void;
	/** Create a deep copy of a Roblox Instance and all of its descendants, with all the same property values. Returns a new, separate object whose Parent property is `nil`. The next step after cloning an object is setting the Parent, and optionally re-positioning the new object if it has 3d geometry.

Any references to objects not in the cloned hierarchy are maintained (i.e. if an ObjectValue refers to an external object it will refer to the same external object). Any internal references are relative (ie if an ObjectValue refers to an internal object it will refer to a similar internal object in the copy).

Any objects in the cloned object's hierarchy (including the object itself) that does not have the `Archivable` property enabled are ignored. If the root object is not Archivable, the function returns `nil`.

Clone is useful for regenerating models by saving the original and spawning copies. It's also useful for taking a snapshot of the current state of a model if it is changing over time.

## Code Samples

### Clone Example

This code first references an existing object in the `original` variable. Then, it makes a copy of the object, sets the parent to that of the original, and finally moves the copy to (0, 50, 0).
```lua
    -- Get a reference to an existing object
    local original = workspace.Model
    -- Create the model copy
    local copy = original:Clone()
    -- Parent the copy to the same parent as the original
    copy.Parent = original.Parent
    -- Move the copy so it's not overlapping the original
    copy:SetPrimaryPartCFrame(CFrame.new(0, 50, 0))
```
 */
	Clone(): this;
	/** Sets the `Parent` property to nil, locks the `Parent` property, disconnects all connections and calls Destroy on all children. This function is the correct way to dispose of objects that are no longer required. Disposing of unneeded objects is important, since unnecessary objects and connections in a place use up memory (this is called a **memory leak**) which can lead to serious performance issues over time.

**Tip:** After calling Destroy on an object, set any variables referencing the object (or its descendants) to nil. This prevents your code from accessing anything to do with the object.

```lua
local part = Instance.new("Part")
part.Name = "Hello, world"
part:Destroy()
-- Don't do this:
print(part.Name) --> "Hello, world"
-- Do this to prevent the above line from working:
part = nil
```


Once an `Instance` has been destroyed by this method it cannot be reused because the `Parent` property is locked. To temporarily remove an object, set `Parent` it to nil instead. For example:

```lua
object.Parent = nil
wait(2)
object.Parent = workspace
```


To Destroy an object after a set amount of time, use `AddItem`.

## Code Samples

### Instance:Destroy


```lua

local Part = Workspace.Part
Part:Destroy()
Part.Parent = Workspace --> The Parent property of Part is locked

```
 */
	Destroy(): void;
	/** Returns the first ancestor of the `Instance` whose `Name` is equal to the given name.

This function works upwards, meaning it starts at the `Instance`'s immediate `Parent` and works up towards the `DataModel`. If no matching ancestor is found, it returns nil.

The following code snippet would find the first ancestor of the object named 'Car'.

```lua
local car = object:FindFirstAncestor("Car")
```


For variants of this function that find ancestors of a specific class, please see `FindFirstAncestorOfClass` and `FindFirstAncestorWhichIsA`.
@param name The `Instance/Name` to be looked for.
@returns The `Instance` found. */
	FindFirstAncestor<T extends Instance = Instance>(name: string): T | undefined;
	/** Returns the first ancestor of the `Instance` whose `ClassName` is equal to the given className.

This function works upwards, meaning it starts at the `Instance`'s immediate `Parent` and works up towards the `DataModel`. If no matching ancestor is found, it returns nil.

A common use of this function is finding the `Model` a `BasePart` belongs to. For example:
```lua
local model = part:FindFirstAncestorOfClass("Model")
```


This function is a variant of `FindFirstAncestor` which checks the `ClassName` property rather than `Name`. `FindFirstAncestorWhichIsA` also exists, using the `IsA` method instead to respect class inheritance.
@param className The `Instance/ClassName` to be looked for.
@returns The `Instance` found. */
	FindFirstAncestorOfClass<T extends keyof Instances>(className: T): Instances[T] | undefined;
	FindFirstAncestorOfClass(className: string): Instance | undefined;
	/** Returns the first ancestor of the `Instance` for whom `IsA` returns true for the given className.

This function works upwards, meaning it starts at the `Instance`'s immediate `Parent` and works up towards the `DataModel`. If no matching ancestor is found, it returns nil.

Unlike `FindFirstAncestorOfClass`, this function uses `IsA` which respects class inheritance. For example:

```lua
print(part:IsA("Part")) --&gt; true
print(part:IsA("BasePart")) --&gt; true
print(part:IsA("Instance")) --&gt; true
```


Therefore, the following code sample will return the first `BasePart` ancestor, regardless of if it is a `WedgePart`, `MeshPart` or `Part`.

```lua
local part = object:FindFirstAncestorWhichIsA("BasePart")
```


See also, `FindFirstAncestor`.
@param className The `Instance/ClassName` to be looked for.
@returns The `Instance` found. */
	FindFirstAncestorWhichIsA<T extends keyof InstanceBases>(className: T): InstanceBases[T] | undefined;
	FindFirstAncestorWhichIsA(className: string): InstanceBases[keyof InstanceBases] | undefined;
	/** Returns the first child of the `Instance` found with the given name. If no child exists with the given name, this function returns nil. If the optional recursive argument is true, this function searches all descendants rather than only the immediate children of the `Instance`. Use this function if your code cannot guarantee the existence of an object with a given name.

## Checking the Existence of An Object
FindFirstChild is necessary if you need to verify an object something exists before continuing. Attempting to index a child by name using the dot operator throws an error if the child doesn't exist.

```lua
 -- The following line errors if Part doesn't exist in the Workspace:
workspace.Part.Transparency = .5
```


Use FindFirstChild to first check for Part, then use an if-statement to run code that needs it.
```lua
local part = workspace:FindFirstChild("Part")
if part then
	part.Transparency = .5
end
```

## Finding a Child Whose Name Matches a Property
Sometimes the `Name` of an object is the same as that of a property of its `Parent`. When using the dot operator, properties take precedence over children if they share a name.

In the following example, a `Folder` called "Color" is added to a `Part`, which also has the `Color` property. `Part.Color` refers to the `Color3`, not the Folder.

```lua
local part = Instance.new("Part")
local folder = Instance.new("Folder")
folder.Name = "Color"
folder.Parent = part
local c = part.Color --> A Color3
local c2 = part:FindFirstChild("Color") --> The Folder
```


A benefit of using FindFirstChild in this way is that the introduction of new properties does not impose a risk on your code.

**Tip:** If you only need to use the result of a FindFirstChild call once, such as getting the property of a child if it exists, you can use the following syntax with the `and` operator:

```lua
local myColor = workspace:FindFirstChild("SomePart") and workspace.SomePart.Color
```

If SomePart exists, `myColor` will contain the Color of SomePart. Otherwise, it'll be nil without throwing an error. This works due to short-circuiting: Lua ignores the right side if the left is nil/false


## Performance Note
FindFirstChild takes about 20% longer than using dot operator, and almost 8 times longer than simply storing a reference to an object. Therefore, you should avoid calling FindFirstChild in performance dependent code, such as in tight loops or functions connected to `Heartbeat`/`RenderStepped`. **Store the result in a variable,** or consider using `ChildAdded` or `WaitForChild` to detect when a child of a given name becomes available.

## Code Samples

### Instance:FindFirstChild

The below would look in Workspace for an object name "Brick". If found, it will change the name of the object to "Foo".
```lua

local found = workspace:FindFirstChild("Brick")
if found then 
  found.Name = "Foo"
end

```

@param name The `Instance/Name` to be searched for.
@param recursive Whether or not the search should be conducted recursively.
@returns The `Instance` found. */
	FindFirstChild<T extends Instance = Instance>(name: string, recursive?: boolean): T | undefined;
	/** Returns the first child of the `Instance` whose `ClassName` is equal to the given className.

If no matching child is found, this function returns nil.

Unlike `FindFirstChildWhichIsA` this function uses only returns objects whose class matches the given className, ignoring class inheritance. 

Developers looking for a child by name, should use `FindFirstChild` instead.

## Code Samples

### Instance:FindFirstChildOfClass


```lua
local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:wait()
local humanoid
while not humanoid do
    humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        character.ChildAdded:wait()
    end
end

```

@param className The `Instance/ClassName` to be looked for.
@returns The `Instance` found. */
	FindFirstChildOfClass<T extends keyof Instances>(className: T): Instances[T] | undefined;
	FindFirstChildOfClass(className: string): Instance | undefined;
	/** Returns the first child of the `Instance` for whom `IsA` returns true for the given className.

If no matching child is found, this function returns nil. If the optional recursive argument is true, this function searches all descendants rather than only the immediate children of the `Instance`.

Unlike `FindFirstChildOfClass`, this function uses `IsA` which respects class inheritance. For example:

```lua
print(part:IsA("Part")) --> true
print(part:IsA("BasePart")) --> true
print(part:IsA("Instance")) --> true
```


Therefore, the following code sample will return the first `BasePart` child, regardless of if it is a `WedgePart`, `MeshPart` or `Part`.

```lua
local part = object:FindFirstChildWhichIsA("BasePart")
```


Developers looking for a child by name, should use `FindFirstChild` instead.
@param className The `Instance/ClassName` to be searched for.
@param recursive Whether or not the search should be conducted recursively. 
@returns The `Instance` found. */
	FindFirstChildWhichIsA<T extends keyof InstanceBases>(
		className: T,
		recursive?: boolean,
	): InstanceBases[T] | undefined;
	FindFirstChildWhichIsA(className: string, recursive?: boolean): InstanceBases[keyof InstanceBases] | undefined;
	/** Returns an array (a numerically indexed table) containing all of the `Instance`'s direct children, or every `Instance` whose `Parent` is equal to the object. The array can be iterated upon using either a numeric or generic for-loop:

```lua
-- Numeric for-loop example
local children = workspace:GetChildren()
for i = 1, #children do
	local child = children[i]
	print(child.Name .. " is child number " .. i)
end
```


```lua
-- Generic for-loop example
local children = workspace:GetChildren()
for i, child in ipairs(children) do
	print(child.Name .. " is child number " .. i)
end
```


The children are sorted by the order in which their `Parent` property was set to the object.

See also the `GetDescendants` function.

## Code Samples

### Instance:GetChildren

The below would print the name of all objects currently in Workspace when ran.
```lua

local children = workspace:GetChildren()
for i = 1, #children do
    print(i, children[i].Name)
end

```

@returns An array containing the `Instance`'s children. */
	GetChildren<T extends Instance = Instance>(): Array<T>;
	/** The **GetDescendants** function of an object returns an array that contains all of the descendants of that object. Unlike `GetChildren`, which only returns the immediate children of an object, GetDescendants will find every child of the object, every child of those children, and so on and so forth.

The arrays returned by GetDescendants are arranged so that parents come earlier than their children. For example, let’s look at the following setup:

![Workspace Descendants](https://developer.roblox.com/assets/5c5622a2005d89b20bb84fee/GetDescendantsExample.png)

Here we have a `Model` in the `Workspace`. Inside this model is three parts (C, D, and E) and another model (InnerModel). Inside the inner model are two more parts (A and B). If we use GetDescendants on the first model and print out the contents of the returned array, we can see that the first level of children, InnerModel, C, D, and E, are printed out before A and B.

```lua
local descendants = game.Workspace.Model:GetDescendants()
 
-- Loop through all of the descendants of the model and
-- print out their name
for index, descendant in pairs(descendants) do
	print(descendant.Name)
end
 
-- Prints:
-- C
-- D
-- E
-- InnerModel
-- A
-- B
```

## Code Samples

### Instance:GetDescendants

GetDescendants is often used to do something to all the descendants that are a particular type of object. The code in this example uses GetDescendants and `/Instance/IsA` to find all of the parts in the workspace and turns them green.
```lua

local descendants = game.Workspace:GetDescendants()

-- Loop through all of the descendants of the Workspace. If a
-- BasePart is found, the code changes that parts color to green
for index, descendant in pairs(descendants) do
	if descendant:IsA("BasePart") then
		descendant.BrickColor = BrickColor.Green()
	end
end
```

@returns An array containing the `Instance`'s descendants. */
	GetDescendants(): Array<Instance>;
	/** Returns a string describing the `Instance`'s ancestry. The string is a concatenation of the `Name` of the object and its ancestors, separated by periods. The `DataModel` (`game`) is not considered. For example, a `Part` in the `Workspace` may return `Workspace.Part`.

When called on an `Instance` that is not a descendant of the `DataModel`, this function considers all ancestors up to and including the topmost one without a `Parent`.

This function is useful for logging and debugging. You shouldn't attempt to parse the returned string for any useful operation; this function does not escape periods (or any other symbol) in object names. In other words, although its output often appears to be a valid Lua identifier, it is not guaranteed.

## Code Samples

### Instance:GetFullName Lua Implementation

This code sample re-implements the `GetFullName` function in Lua.
```lua
local function getFullName(object)
	local result = object.Name
	object = object.Parent
	while object and object ~= game do
		-- Prepend parent name
		result = object.Name .. "." .. result
		-- Go up the hierarchy
		object = object.Parent
	end
	return result
end
print(getFullName(workspace.Camera)) --> Workspace.Camera
```

### Instance:GetFullName

This code sample demonstrates the behavior of `GetFullName`. It shows how the function behaves when called on an object not in the `DataModel` hierarchy, and it also shows how the return value does not escape special characters.
```lua
-- Create a simple hierarchy
local model = Instance.new("Model")
local part = Instance.new("Part", model)
local fire = Instance.new("Fire", part)
print(fire:GetFullName()) --> Model.Part.Fire
model.Parent = workspace
print(fire:GetFullName()) --> Workspace.Model.Part.Fire
part.Name = "Hello, world"
print(fire:GetFullName()) --> Workspace.Model.Hello, world.Fire
```

@returns The full name of the `Instance`. */
	GetFullName(): string;
	/** This method returns an event that behaves exactly like the `Changed` event, except that the event only fires when the given property changes. It's generally a good idea to use this method instead of a connection to `Changed` with a function that checks the property name. Subsequent calls to this method on the same object with the same property name return the same event.

`print(object:GetPropertyChangedSignal("Name") == object:GetPropertyChangedSignal("Name")) --&gt; always true`

`ValueBase` objects, such as `IntValue` and `StringValue`, use a modified `Changed` event that fires with the contents of the `Value` property. As such, this method provides a way to detect changes in other properties of those objects. For example, to detect changes in the `Name` property of an `IntValue`, use `IntValue:GetPropertyChangedSignal("Name"):Connect(someFunc)` since the `Changed` event of `IntValue` objects only detect changes on the `Value` property.

## Code Samples

### Old-to-New Values with Changed

This code sample demonstrates how to save a value before a changed event fires on it in order to get more information about a change.
```lua
local part = Instance.new("Part")

-- Save the current state
local currentColor = part.BrickColor

local function onBrickColorChanged()
	local newColor = part.BrickColor
	print("Color changed from " .. currentColor.Name .. " to " .. newColor.Name)
	currentColor = newColor
end 
part:GetPropertyChangedSignal("BrickColor"):Connect(onBrickColorChanged)

-- Make some changes
part.BrickColor = BrickColor.new("Really red")
part.BrickColor = BrickColor.new("Really blue")
```

### Changed and GetPropertyChangedSignal

This code sample demonstrates the equivalence of the `Changed` event and event returned by `GetPropertyChangedSignal`.
```lua
local part = Instance.new("Part")

local function onBrickColorChanged()
	print("My color is now " .. part.BrickColor.Name)
end

-- Manual detection of a property change
local function onChanged(property)
	if property == "BrickColor" then
		onBrickColorChanged()
	end
end

-- Connect both events
part:GetPropertyChangedSignal("BrickColor"):connect(onBrickColorChanged)
part.Changed:connect(onChanged)

-- Trigger some changes (because we connected twice,
-- both of these will cause two calls to onBrickColorChanged)
part.BrickColor = BrickColor.new("Really red")
part.BrickColor = BrickColor.new("Institutional white")

```
 */
	GetPropertyChangedSignal<T extends GetProperties<this>>(property: T): RBXScriptSignal;
	/** IsA returns true if the `Instance`'s class is **equivalent to** or a **subclass** of a given class. This function is similar to the **instanceof** operators in other languages, and is a form of [type introspection](https://en.wikipedia.org/wiki/Type_introspection). To ignore class inheritance, test the `ClassName` property directly instead. For checking native Lua data types (number, string, etc) use the functions `type` and `typeof`.

Most commonly, this function is used to test if an object is some kind of part, such as `Part` or `WedgePart`, which inherits from `BasePart` (an abstract class). For example, if your goal is to change all of a `Character`'s limbs to the same color, you might use `GetChildren` to iterate over the children, then use IsA to filter non-`BasePart` objects which lack the `BrickColor` property:
```lua
local function paintFigure(character, color)
	-- Iterate over the child objects of the character
	for _, child in pairs(character:GetChildren()) do
		-- Filter out non-part objects, such as Shirt, Pants and Humanoid
		-- R15 use MeshPart and R6 use Part, so we use BasePart here to detect both:
		if child:IsA("BasePart") then
			child.BrickColor = color
		end
	end
end
paintFigure(game.Players.Player.Character, BrickColor.new("Bright blue"))
```


Since all classes inherit from `Instance`, calling `object:IsA("Instance")` will always return true.

## Code Samples

### Instance:IsA

Usage of IsA to test class inheritance:
```lua

print(Workspace:IsA("Instance" )) --> true
print(Workspace:IsA("Workspace")) --> true
print(game:IsA("Workspace")) --> false
print(game:IsA("DataModel")) --> true

```

@param className The class against which the Instance's class will be checked. Case-sensitive.
@returns Describes whether the Instance's class matched or is a subclass of the given class */
	IsA<T extends keyof InstanceBases>(className: T): this is InstanceBases[T];
	IsA(className: string): boolean;
	/** Returns true if an `Instance` is an ancestor of the given descendant.

An `Instance` is considered the ancestor of an object if the object's `Parent` or one of it's parent's `Parent` is set to the `Instance`.

See also, `IsDescendantOf`.

## Code Samples

### Instance:IsAncestorOf


```lua
print(game.Workspace:IsAncestorOf(game.Workspace.Player.Torso)) --> true

```

@param descendant The descendant `Instance`.
@returns True if the `Instance` is an ancestor of the given descendant. */
	IsAncestorOf(descendant: Instance): boolean;
	/** Returns true if an `Instance` is a descendant of the given ancestor.

An `Instance` is considered the descendant of an object if the `Instance`'s parent or one of its parent's parent is set to the object.

Note, `DataModel` is a descendant of nil. This means IsDescendantOf cannot be used with a parameter of nil to check if an object has been removed. 

See also, `IsAncestorOf`.

## Code Samples

### Instance:IsDescendantOf


```lua
local part = Instance.new("Part")
print(part:IsDescendantOf(game))
--> false

part.Parent = game.Workspace
print(part:IsDescendantOf(game))
--> true

part.Parent = game
print(part:IsDescendantOf(game))
--> true

```

@param ancestor The ancestor `Instance`.
@returns True if the `Instance` is a descendant of the given ancestor. */
	IsDescendantOf(ancestor: Instance): boolean;
	/** Returns the child of the `Instance` with the given name. If the child does not exist, it will yield the current thread until it does.

If the *timeOut* parameter is specified, this function will return nil and time out after *timeOut* seconds elapsing without the child being found.

## Where should I use WaitForChild?
WaitForChild is extremely important when working on code ran by the client. Roblox does not guarantee the time or order in which objects are replicated from the server to the client. This can cause scripts to break when indexing objects that do not exist yet. 

For example, a `LocalScript` may access a `Model` in the `Workspace` called 'Ship' like so:

```lua
local ship = workspace.Ship
-- Will error if ship hasn't replicated
```


However if the model 'Ship' has not replicated to the client when this code is ran an error will be returned breaking the `LocalScript`.

Another alternative is using `FindFirstChild`. Not only is this good practice when indexing objects in the `DataModel` (as it avoids accidentally accessing properties) but it does not break if the object does not exist. For example:

```lua
local ship = workspace:FindFirstChild("Ship")
-- Won't error, but ship will be nil if the ship hasn't replicated
```


Here, if the model doesn't exist the code will not error. Instead the value ship will be equal to nil. This is better, but still not much good if we want to use the ship model.

Instead WaitForChild should be used:

```lua
local ship = workspace:WaitForChild("Ship")
-- Will wait until the ship has replicated before continuing
```


Here, the thread will be yielded until the ship model has been found. This means the ship model can be used as soon as it is ready.


## Notes
 - If a call to this function exceeds 5 seconds without returning, and no *timeOut* parameter has been specified, a warning will be printed to the output that the thread may yield indefinitely
 - This function will return immediately without yielding if the child exists when the call is made
 - WaitForChild is less efficient than `FindFirstChild` or the dot operator. Therefore it should only be used when the developer is not sure if the object has replicated to the client. Generally this is only the first time the object is accessed

## Code Samples

### Instance:WaitForChild

The following code waits for an instance named "Part" to be added to Workspace.
```lua
local part = Workspace:WaitForChild("Part")
print(part.Name .. " has been added to the Workspace")
```

@param childName The `Instance/Name` to be looked for.
@param timeOut An optional time out parameter.
@returns The `Instance` found. */
	WaitForChild<T extends Instance = Instance>(childName: string): T;
	WaitForChild<T extends Instance = Instance>(childName: string, timeOut: number): T | undefined;
	/** Fires when the `Parent` property of the object or one of its ancestors is changed.

This event includes two parameters, *child* and *parent*. *Child* refers to the `Instance` whose `Parent` was actually changed. *Parent* refers to this `Instance`'s new `Parent`.

A common use for this function is detecting when an object has been removed or destroyed (using `Destroy`). This is done by checking if the parent has been set to nil. For example:

```lua
object.AncestryChanged:Connect(function(_, parent)
	if not parent then
		print("object destroyed!")
	end
end)
```

## Code Samples

### Instance.AncestryChanged

The below example would print "Part is now a child of Model".
```lua

local p = Instance.new("Part")
p.Parent = game.Workspace
p.AncestryChanged:Connect(function(child, parent)
    print(child.Name.." is now a child of "..parent.Name)
end)
p.Parent = Workspace.Model

```
 */
	readonly AncestryChanged: RBXScriptSignal<(child: Instance, parent: Instance) => void>;
	/** If you want to detect changes of a single property only, you should use `GetPropertyChangedSignal` instead!


The Changed event fires right after most properties change on objects. It is possible to find the present value of a changed property by using `object[property]`. To get the value of a property before it changes, you must have stored the value of the property before it changed.

If you are only interested in listening to the change of a specific property, consider using the `GetPropertyChangedSignal` method instead to get an event that only fires when a given property changes.

This event does not fire for physics-related changes, like when the `CFrame`, `Velocity`, `RotVelocity`, `Position`, `Orientation` and `CFrame` properties of a `BasePart` change due to gravity. To detect changes in these properties, consider using a physics-based event like `RunService.Stepped` or `BasePart.Touched`. A while-true-do loop can also work.

For "-Value" objects, this event behaves differently: it only fires when the `Value` property changes. See individual pages for `IntValue`, `StringValue`, etc for more information. To detect other changes in these objects, you must use `GetPropertyChangedSignal` instead.

## Code Samples

### Changed Event

This sample demonstrates the subtleties of the Changed event on normal objects and "-Value" objects.
```lua
-- Demonstrate the Changed event by creating a Part
local part = Instance.new("Part")
part.Changed:Connect(print)
-- This fires Changed with "Transparency"
part.Transparency = .5
-- Similarly, this fires Changed with "Number"
part.Name = "SomePart"
-- Since changing BrickColor will also change other
-- properties at the same time, this line fires Changed
-- with "BrickColor", "Color3" and "Color3uint16".
part.BrickColor = BrickColor.Red()

-- A NumberValue holds a double-precision floating-point number 
local vNumber = Instance.new("NumberValue")
vNumber.Changed:Connect(print)
-- This fires Changed with 123.456 (not "Value")
vNumber.Value = 123.456
-- This does not fire Changed
vNumber.Name = "SomeNumber"

-- A StringValue stores one string
local vString = Instance.new("StringValue")
vString.Changed:Connect(print)
-- This fires Changed with "Hello" (not "Value")
vString.Value = "Hello"
```

### Change Detector

This code sample demonstrates the Changed event firing within a parent object.
```lua
local object = script.Parent
local function onChanged(property)
	-- Get the current value of the property
	local value = object[property]
	-- Print a message saying what changed
	print(object:GetFullName() .. "." .. property .. " (" .. typeof(value) .. ") changed to " .. tostring(value))
end
object.Changed:Connect(onChanged)
-- Trigger a simple change in the object (add an underscore to the name)
object.Name = "_" .. object.Name 

```
 */
	readonly Changed: RBXScriptSignal<(property: string) => void>;
	/** Fires when an object is parented to this `Instance`.

Note, when using this function on a client to detect objects created by the server it is necessary to use `WaitForChild` when indexing these object's descendants. This is because the object and its descendants are not guaranteed to replicate from the server to the client simultaneously. For example:

```lua
workspace.ChildAdded:Connect(function(child)
	-- need to use WaitForChild as descendants may not have replicated yet
	local head = child:WaitForChild("Head")
end)
```

Note, this function only works for immediate children of the `Instance`. For a function that captures all descendants, use `DescendantAdded`.

See also, `ChildRemoved`.

## Code Samples

### Instance.ChildAdded

This snippet prints the names of objects as they are added to the Workspace:
```lua

workspace.ChildAdded:Connect(function(instance)
    print(instance.Name .. " added to the workspace")
end)
Instance.new("Part", workspace)
--> Part added to the Workspace

```
 */
	readonly ChildAdded: RBXScriptSignal<(child: Instance) => void>;
	/** Fires when a child is removed from this `Instance`.

Removed refers to when an object's parent is changed from this `Instance` to something other than this `Instance`. Note, this event will also fire when a child is destroyed (using `Destroy`) as the destroy function sets an object's parent to nil.

This function only works for immediate children of the `Instance`. For a function that captures all descendants, use `DescendantRemoved`.

See also `ChildAdded`.

## Code Samples

### Instance.ChildRemoved

This snippet prints the names of objects as they are removed from the Workspace:
```lua

Workspace.ChildRemoved:Connect(function(instance)
    print(instance.Name .. " removed from the Workspace")
end)
local part = Instance.new("Part", Workspace)
wait(2)
part:Destroy()
```
 */
	readonly ChildRemoved: RBXScriptSignal<(child: Instance) => void>;
	/** Fires when a descendant is added to the `Instance`.

As DescendantAdded fires for every descendant, parenting an object to the `Instance` will fire the event for this object and all of its descendants individually.

Developers only concerned with the immediate children of the `Instance` should use `ChildAdded` instead.

See also `DescendantRemoving`.

## Code Samples

### Instance.DescendantAdded

This following example will print the name of any object that is added to the Workspace:
```lua

Workspace.DescendantAdded:Connect(function(descendant)
	print(descendant)
end)

```
 */
	readonly DescendantAdded: RBXScriptSignal<(descendant: Instance) => void>;
	/** DescendantRemoving fires **immediately before** the `Parent` of a descendant of the `Instance` changes such that the object is no longer a descendant of the Instance. `Destroy` and `Remove` change an object's Parent to nil, so calling these on a descendant of an object will therefore cause this event to fire.

Since this event fires before the the descendant's removal, the Parent of the descendant will be unchanged, i.e., it will still be a descendant at the time of this event firing. If the descendant is also a child of the object, It will also fire before ChildRemoved. There is no similar event called "DescendantRemoved".

If a descendant has children, this event fires with the descendant first followed by its descendants.

## Example
The example below should help clarify how DescendantRemoving fires when there are several objects involved.

![A cropped screenshot of the Explorer window. A Model contains ModelA and ModelB, which each contain a Part, PartA and PartB respectively. PartA contains a Fire object named FireA.](https://developer.roblox.com/assets/5bedf8a8a79094cd2b6a1c41/DescendantRemoving2.png)

* Calling `Remove` on **PartA** would cause DescendantRemoving to fire on both **ModelA** and **Model**, in that order.
* Setting the `Parent` of **PartA** to **ModelB** would cause DescendantRemoving to fire on **ModelA** but not **Model** (as Model would still be an ancestor of PartA).
* Calling `Destroy` on **ModelA** would cause DescendantRemoving to fire multiple times on several objects:
	1. On **Model** with **ModelA**, **PartA** then **FireA**.
	2. On **ModelA**, with **PartA** then **FireA**.
	3. On **PartA** with **FireA**.

## Warning
This event fires with the descendant object that is being removed. Attempting to set the `Parent` of the descendant being removed to something else **will fail** with the following warning: "Something unexpectedly tried to set the parent of X to Y while trying to set the parent of X. Current parent is Z", where X is the removing descendant, Y is the ignored parent setting, and Z is the original parent of X. Below is an example that demonstrates this:

```lua
workspace.DescendantRemoving:Connect(function(descendant)
	-- Don't manipulate the parent of descendant in this function!
	-- This event fires BECAUSE the parent of descendant was manipulated,
	-- and the change hasn't happened yet, i.e. this function fires before that happens.
	-- Therefore, it is problematic to change the parent like this:
	descendant.Parent = game
end)
local part = Instance.new("Part")
part.Parent = workspace
part.Parent = nil -- This triggers DescendantRemoving on Workspace:
--&gt; Something unexpectedly tried to set the parent of Part to NULL while trying to set the parent of Part. Current parent is Workspace.
```


See also `DescendantAdded`.

## Code Samples

### Instance.DescendantRemoving

The following example prints the name of any descendant as it is being removed from the Workspace:
```lua

workspace.DescendantRemoving:Connect(function(descendant)
	print(descendant.Name .. " is currently parented to " ..  tostring(descendant.Parent))
end)
local part = Instance.new("Part")
part.Parent = workspace
part.Parent = nil
--> Part is currently parented to Workspace
print(part.Parent)
--> nil

```
 */
	readonly DescendantRemoving: RBXScriptSignal<(descendant: Instance) => void>;
}
/** Instance is the base class for all classes in the Roblox class hierarchy. Every other class that the Roblox engine defines inherits all of the members of Instance.  It is not possible to directly create Instance objects.

Instance has a special function called `Instance.new` which is used to create objects via code. This function takes the name of the class as a parameter and returns the created object. Abstract classes and services cannot be created with the Instance.new function. */
type Instance = ABTestService | Accoutrement | AdService | AdvancedDragger | AnalyticsService | Animation | AnimationController | AnimationTrack | Animator | AssetService | Attachment | Backpack | BackpackItem | BadgeService | BasePlayerGui | Beam | BindableEvent | BindableFunction | BodyMover | BrowserService | CacheableContentProvider | Camera | ChangeHistoryService | CharacterAppearance | Chat | ClickDetector | ClusterPacketCache | CollectionService | Configuration | Constraint | ContentProvider | ContextActionService | Controller | ControllerService | CookiesService | CorePackages | CoreScriptSyncService | CustomEvent | CustomEventReceiver | DataModelMesh | DataStoreService | Debris | DebugSettings | DebuggerBreakpoint | DebuggerManager | DebuggerWatch | Dialog | DialogChoice | Dragger | Explosion | FaceInstance | Feature | File | Fire | FlagStandService | FlyweightService | Folder | ForceField | FriendService | FunctionalTest | GamePassService | GameSettings | GamepadService | Geometry | GlobalDataStore | GoogleAnalyticsConfiguration | GroupService | GuiBase | GuiService | GuidRegistryService | HapticService | Hopper | HttpRbxApiService | HttpRequest | HttpService | Humanoid | HumanoidDescription | InputObject | InsertService | JointInstance | JointsService | KeyboardService | Keyframe | KeyframeMarker | KeyframeSequence | KeyframeSequenceProvider | Light | Lighting | LocalStorageService | LocalizationService | LocalizationTable | LogService | LoginService | LuaSettings | LuaSourceContainer | LuaWebService | MarketplaceService | Message | MessagingService | Mouse | MouseService | NetworkMarker | NetworkPeer | NetworkReplicator | NetworkSettings | NotificationService | PVInstance | PackageLink | PackageService | Pages | PartOperationAsset | ParticleEmitter | Path | PathfindingService | PhysicsPacketCache | PhysicsService | PhysicsSettings | Player | PlayerScripts | Players | Plugin | PluginAction | PluginDragEvent | PluginGuiService | PluginManager | PluginMenu | PluginToolbar | PluginToolbarButton | PointsService | Pose | PostEffect | ReflectionMetadata | ReflectionMetadataCallbacks | ReflectionMetadataClasses | ReflectionMetadataEnums | ReflectionMetadataEvents | ReflectionMetadataFunctions | ReflectionMetadataItem | ReflectionMetadataProperties | ReflectionMetadataYieldFunctions | RemoteEvent | RemoteFunction | RenderSettings | RenderingTest | ReplicatedFirst | ReplicatedStorage | RobloxReplicatedStorage | RunService | RuntimeScriptService | ScriptContext | ScriptDebugger | ScriptService | Selection | ServerScriptService | ServerStorage | ServiceProvider | Sky | Smoke | SocialService | Sound | SoundEffect | SoundGroup | SoundService | Sparkles | SpawnerService | StarterGear | StarterPack | StarterPlayer | StarterPlayerScripts | Stats | StatsItem | StopWatchReporter | Studio | StudioService | StudioTheme | TaskScheduler | Team | Teams | TeleportService | TerrainRegion | TestService | TextFilterResult | TextService | ThirdPartyUserService | TimerService | TouchInputService | TouchTransmitter | Trail | Translator | TweenBase | TweenService | UIBase | UserGameSettings | UserInputService | VRService | ValueBase | VirtualInputManager | VirtualUser | Visit | WeldConstraint | Accessory | Hat | Hint | StarterCharacterScripts;

interface ABTestService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ABTestService";
}

interface RbxInternalDerivesFromAccoutrement extends RbxInternalInstance {
	/** Sets the offset position of the object on the Player.Sets the offset position of the object on the Player.

Tags: NotReplicated */
	AttachmentForward: Vector3;
	/** The exact CFrame of the Accoutrement. */
	AttachmentPoint: CFrame;
	/** Sets the position of the object on the Player.Sets the position of the object on the Player.

Tags: NotReplicated */
	AttachmentPos: Vector3;
	/** Sets the offset position of the object on the Player.Sets the offset position of the object on the Player.

Tags: NotReplicated */
	AttachmentRight: Vector3;
	/** Sets the offset position of the object on the Player.Sets the offset position of the object on the Player.

Tags: NotReplicated */
	AttachmentUp: Vector3;
}
/** An Accoutrement is an object that welds its child `part` called "Handle" to the Head of a player's character. The position and rotation of the Handle part can be changed with the `AttachmentPos`/`Right`/`Forward`/`Up` properties.

Parts descending from an accoutrement will be massless when attached to other parts (e.g. with a Weld) as long as they are not the root part of the assembly returned by `GetRootPart()`. `GetMass()` will return 0 for parts in this case and it will not add to the total mass or rotational inertia of the Assembly.

This will not apply to a part descending from an accoutrement when an accoutrement is not welded to another part that is ***not*** massless or one if its parts otherwise becomes root. This will not apply for the root part, it will have mass like a normal part. */
interface Accoutrement extends RbxInternalDerivesFromAccoutrement {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Accoutrement";
}


/** The Accessory class is an extension to the `Hat` class, and is also the successor to the legacy Hat system.
It's designed to be cross-compatible with both the legacy R6 character system, and the new R15 character system.

If an `Attachment` is inserted into the Accessory's Handle with the same name as an `Attachment` found in one of the character's limbs, they will connect, and the properties inherited from the `Accoutrement` class will be ignored. Otherwise, the Accessory functions identically to a `Hat`.

Note: If two matching `Attachment` are found the resulting `Weld` will be a child of the Handle of the Accessory. This differs from the legacy behavior of Hats where the Weld is always a child of the Head of the character. */
interface Accessory extends RbxInternalDerivesFromAccoutrement {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Accessory";
}

/** 

## Code Samples

### Manually Position Hats

You can use this code to manually position hats on the character:
```lua
hat.Handle.CFrame = char.Head.CFrame * CFrame.new(0, char.Head.Size.Y / 2, 0) * hat.AttachmentPoint:inverse()

```
 */
interface Hat extends RbxInternalDerivesFromAccoutrement {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Hat";
}

/** This AdService class was historically a service used to display mobile video ads as a form of game monetization. It has been decommissioned and is no longer operational.

![iPad displaying an ad](https://developer.roblox.com/assets/5c3e6293ae0aa2bf7f3a52fe/AdserviceIPad.png)


It allowed game creators to utilize a the service and display video ads to mobile players on supported iOS and Android devices. Players were able to view up to 5 ads per hour across the site.

## Best Practices
 - You couldn’t play an ad more than five times in an hour, in any mobile instance.
 - `GUIs` were extremely important in getting your ads out. They made sure players knew they were seeing an ad and that gameplay would begin once it was over. Particularly something that said, “and now a word from our sponsor,” or “gameplay sponsored by…”
 - You had to make sure players inside your game didn’t take damage or get knocked out while they were watching an ad (this could be as simple as giving them a forcefield while the ad plays).
 - It was important to always show ads when it didn’t interfere with gameplay (like between rounds, before the game starts, or after a player gets knocked out).

## Benefits
Implementing video ad impressions in mobile gameplay sessions offers a variety of positive things for Roblox developers. 

The more hits your ad got, the more ROBUX you earned (at a rate of one ROBUX per 20 impressions). So if you were trying to utilize the heavy traffic you received in your game, it was recommended to using the API to call the commercial before your game started. For those who already had a hit game, this this could have functioned as supplemental income.

Thinking of the bigger picture. You could tie the API call to, say, a button inside your game, which would only play the ad when pressed. Many Roblox players wanted to earn exclusive items for your game, but maybe couldn't afford them. Perhaps you could tie one of those items into the ad — couldn’t afford the Green Balloon? Here was another option: watch a 30 second ad. The player got the item, you got the impression, and the cycle continued that way. Maybe your game was round-based. Why not play an ad between rounds? That was easily 20 impressions just while waiting for the next level to load. And more ad impressions meant more ROBUX in your pocket. */
interface AdService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AdService";
}

/** An unfinished advanced variant of the `Dragger` class.
Internally, this object is an identical implementation of the Dragger class. */
interface AdvancedDragger extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AdvancedDragger";
}

/** An internal service intended for handling analytics on Roblox. */
interface AnalyticsService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AnalyticsService";
}

/** An object which allows animations to be applied to a player's character and make the parts that make said character up react in the way that is described within the animation file (AnimationId).

## Code Samples

### Animation Creation

This sample creates an Animation, with an AnimationId. It then creates an AnimationTrack by loading the Animation onto a character's Humanoid, before playing it.
```lua
local Players = game:GetService("Players")

local player = Players:FindFirstChild("Builderman")

local character = player.Character 
local humanoid = character:FindFirstChild("Humanoid")

local animation = Instance.new("Animation")
animation.AnimationId = "http://www.roblox.com/asset/?id=507771019" -- Roblox dance emote

local animationTrack = humanoid:LoadAnimation(animation)
animationTrack:Play()
```
 */
interface Animation extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Animation";
	/** This property is the content ID of the animation an `Animation` object is referencing. Once an animation has been created and uploaded to Roblox the content ID can be found in the uploaded animation’s URL. 

This URL is presented immediately after an animation has been uploaded to Roblox, in the Animation Editor export window. It can also be found in the Develop tab on the Roblox site, under ‘Animations’. 

It’s important to remember the URL is not the same as the content ID. It will work when pasted directly into the AnimationId property of an `Animation` in Roblox studio, as Studio will automatically correct it, however if it is being set from a `Script` then the correct content ID will need to be used, using the number from the URL. For example:

```lua
"https://www.roblox.com/catalog/507771019" -- Web URL (will not work)
"http://www.roblox.com/asset/?id=507771019" -- Content ID (will work)
"rbxassetid://507771019" -- Content ID (alternative version, will work)
```

Note, the animation will need to be loaded onto an `AnimationTrack` in order to play it.

## Code Samples

### Animation Creation

This sample creates an Animation, with an AnimationId. It then creates an AnimationTrack by loading the Animation onto a character's Humanoid, before playing it.
```lua
local Players = game:GetService("Players")

local player = Players:FindFirstChild("Builderman")

local character = player.Character 
local humanoid = character:FindFirstChild("Humanoid")

local animation = Instance.new("Animation")
animation.AnimationId = "http://www.roblox.com/asset/?id=507771019" -- Roblox dance emote

local animationTrack = humanoid:LoadAnimation(animation)
animationTrack:Play()
```
 */
	AnimationId: string;
}

/// <reference no-default-lib="true"/>
	/// <reference path="roblox.d.ts" />
	/// <reference path="generated_enums.d.ts" />
	/// <reference path="generated_classes.d.ts" />
	// GENERATED API OVERRIDES
	/** This object functions similar to an `Animation`. However, this does not require a `Humanoid` to load an `AnimationTrack`. Instead, it has a built in `LoadAnimation` method, which can load animations onto any object (Regardless if it contains a Humanoid or not). */
interface AnimationController extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AnimationController";
	/** Returns a table of all `AnimationTrack`s that are currently being played by an `AnimationController`.

A typical use for this function is stopping currently playing tracks using `Stop`.

Note this function will not return `AnimationTrack`s that have loaded but are not playing. If the developer wishes to track these they will need to index them manually. See below for one example of how this could be achieved:

```lua
local animationTracks = {}
local track = animationController:LoadTrack(animation)
table.insert(animationTracks, track)
```

## Code Samples

### Stop All Tracks

This sample contains a quick function to stop all playing AnimationTracks on an AnimationController or Humanoid.
```lua
local function stopAllTracks(animationController)
	for _, track in pairs(animationController:GetPlayingAnimationTracks()) do
		track:Stop()
	end
end

```

@returns An array of playing `AnimationTrack`s. */
	GetPlayingAnimationTracks(): Array<AnimationTrack>;
	/** This function loads an `Animation` onto an `AnimationController`, returning an `AnimationTrack` that can be used for playback.

## How to load an Animation

The following code can be used to load an `Animation` onto an `AnimationController`.

    local animationTrack = animationController:LoadAnimation(animation)
    animationTrack:Play()

## Should I load an Animation on the client or server?

In order for `AnimationTrack`s to replicate correctly, it's important to know when they should be loaded on the client (via a `LocalScript`) or on the server (via a `Script`). If an `AnimationController` is created on the server, its animations should be loaded and played on the server unless a player has been assigned network ownership of the `Model`'s root part using `SetNetworkOwner`. If an `AnimationController` is created on the client it should be animated by the client.

Although it is not recommended, if a developer wishes to play animations on a locally controlled `Model` from the server they can use the `Animator` object.

Note this differs slightly for animations playing on Player characters, for more information on this please see `LoadAnimation`.

## Code Samples

### AnimationController

This code sample demonstrates how an `AnimationController` can be used in place of a `Humanoid` for non player character objects.

A basic rig is loaded using `InsertService` and the default `Humanoid` is replaced with an `AnimationController`. An `AnimationTrack` is then created and played.
```lua
local InsertService = game:GetService("InsertService")

-- Load a model for demonstration
local npcModel = InsertService:LoadAsset(516159357):GetChildren()[1]
npcModel.Name = "NPC"
npcModel.PrimaryPart.Anchored = true
npcModel:SetPrimaryPartCFrame(CFrame.new(0, 5, 0))
npcModel.Parent = workspace
 
-- Replace the humanoid with an animationcontroller
local humanoid = npcModel:FindFirstChildOfClass("Humanoid")
humanoid:Destroy()
local animationController = Instance.new("AnimationController", npcModel)

-- Create and load an animation
local animation = Instance.new("Animation")
animation.AnimationId = "http://www.roblox.com/asset/?id=507771019" -- Roblox dance emote
local animationTrack = animationController:LoadAnimation(animation)

-- Play the animation
animationTrack:Play()
```

@param animation The `Animation` to be used.
@returns The `AnimationTrack` created. */
	LoadAnimation(animation: Animation): AnimationTrack;
	/** This event fires whenever the `AnimationController` begins playing an animation. It returns the `AnimationTrack` playing.

The `AnimationTrack` can be used to access the animation's playback functions and events. It will only fire for animations playing on the specific `AnimationController`.

See `AnimationPlayed` for the `Humanoid` variant of this function.

## Code Samples

### Listen For Animation Effects

The function in the following code sample provides an example of how the AnimationTrack.KeyframeReached event can be used to link different effects to an animation.

The function listens for any animations being played on the Humanoid (or AnimationController), and when a new animation is played listens for a keyframe named 'Effect' being reached. When a keyframe named 'Effect' is reached some basic particles will be emitted. Once the animation has stopped the connections used by the function are disconnected, in line with best practice to avoid memory leaks.

Although the particle effect in this sample is very simple, it could be substituted for a range of more complicated effects using the Sound, Beam, ParticleEffect or other objects. Additionally, in many cases the developer may only care about effects on one specific animation (rather than every animation played on a Humanoid). In this case, only the KeyframeReached portion of this sample would be needed.
```lua
local Debris = game:GetService("Debris")

local function listenForAnimationEffects(humanoid) -- would also work for an AnimationController
	-- listen for new animations being played on the Humanoid
	humanoid.AnimationPlayed:Connect(function(animationTrack)
		local keyframeConnection = nil
		-- listen for the 'Effect' keyframe being reached
		keyframeConnection = animationTrack.KeyframeReached:Connect(function(keyframeName)
			if keyframeName == "Effect" then
				-- make sure the Humanoid RootPart exists
				if humanoid.RootPart then
					-- create a basic particle effect
					local particles = Instance.new("ParticleEmitter", humanoid.RootPart)
					particles.Rate = 0
					particles:Emit(10)
					Debris:AddItem(particles, 2)
				end
			end
		end)
		local stoppedConnection = nil
		stoppedConnection = animationTrack.Stopped:Connect(function()
			-- clean up old connections to stop memory leaks
			keyframeConnection:Disconnect()
			stoppedConnection:Disconnect()
		end)
	end)
end
```
 */
	readonly AnimationPlayed: RBXScriptSignal<(animationTrack: AnimationTrack) => void>;
}

/** Controls the playback of an animation on a `Humanoid` or `AnimationController`. This object cannot be created, instead it is returned by the `LoadAnimation` method.

## Code Samples

### Animation Creation

This sample creates an Animation, with an AnimationId. It then creates an AnimationTrack by loading the Animation onto a character's Humanoid, before playing it.
```lua
local Players = game:GetService("Players")

local player = Players:FindFirstChild("Builderman")

local character = player.Character 
local humanoid = character:FindFirstChild("Humanoid")

local animation = Instance.new("Animation")
animation.AnimationId = "http://www.roblox.com/asset/?id=507771019" -- Roblox dance emote

local animationTrack = humanoid:LoadAnimation(animation)
animationTrack:Play()
```
 */
interface AnimationTrack extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AnimationTrack";
	/** The `Animation` object that was used to create this `AnimationTrack`. To create an `AnimationTrack` the developer must load an `Animation` object onto a `Humanoid` or `AnimationController` using the `LoadAnimation` method.

The Animation property is used to identify the underlying `Animation` of an `AnimationTrack`.

## Code Samples

### Listen For New Animations

The following code sample includes a function that prints the name of an animation whenever an AnimationTrack plays on a humanoid.

A connection is made listening to the Humanoid.AnimationPlayed and the name of the underlying animation is printed.

Please note that AnimationPlayed is a member of both Humanoid and AnimationController which this example would also work on.
```lua
function listenForNewAnimations(humanoid)
	humanoid.AnimationPlayed:Connect(function(animationTrack)
		local animationName = animationTrack.Animation.Name
		print("Animation playing "..animationName)
	end)
end
```
The `Animation` object that was used to create this `AnimationTrack`. To create an `AnimationTrack` the developer must load an `Animation` object onto a `Humanoid` or `AnimationController` using the `LoadAnimation` method.

The Animation property is used to identify the underlying `Animation` of an `AnimationTrack`.

## Code Samples

### Listen For New Animations

The following code sample includes a function that prints the name of an animation whenever an AnimationTrack plays on a humanoid.

A connection is made listening to the Humanoid.AnimationPlayed and the name of the underlying animation is printed.

Please note that AnimationPlayed is a member of both Humanoid and AnimationController which this example would also work on.
```lua
function listenForNewAnimations(humanoid)
	humanoid.AnimationPlayed:Connect(function(animationTrack)
		local animationName = animationTrack.Animation.Name
		print("Animation playing "..animationName)
	end)
end
```


Tags: ReadOnly, NotReplicated */
	readonly Animation?: Animation;
	/** A read only property that returns true when the `AnimationTrack` is playing.

This property can be used by developers to check if an animation is already playing before playing it (as that would cause it to restart). If a developer wishes to obtain all playing `AnimationTrack`s on a `Humanoid` or `AnimationController` they should use `GetPlayingAnimationTracks`

## Code Samples

### AnimationTrack IsPlaying

This code sample includes a simple function that will play an AnimationTrack if it is not playing, or otherwise adjust its speed and weight to match the new parameters given.
```lua
local function playOrAdjust(animationTrack, fadeTime, weight, speed)
	if not animationTrack.IsPlaying then
		animationTrack:Play(fadeTime, weight, speed)
	else
		animationTrack:AdjustSpeed(speed)
		animationTrack:AdjustWeight(weight, fadeTime)
	end
end
```
A read only property that returns true when the `AnimationTrack` is playing.

This property can be used by developers to check if an animation is already playing before playing it (as that would cause it to restart). If a developer wishes to obtain all playing `AnimationTrack`s on a `Humanoid` or `AnimationController` they should use `GetPlayingAnimationTracks`

## Code Samples

### AnimationTrack IsPlaying

This code sample includes a simple function that will play an AnimationTrack if it is not playing, or otherwise adjust its speed and weight to match the new parameters given.
```lua
local function playOrAdjust(animationTrack, fadeTime, weight, speed)
	if not animationTrack.IsPlaying then
		animationTrack:Play(fadeTime, weight, speed)
	else
		animationTrack:AdjustSpeed(speed)
		animationTrack:AdjustWeight(weight, fadeTime)
	end
end
```


Tags: ReadOnly, NotReplicated */
	readonly IsPlaying: boolean;
	/** A read only property that returns the length (in seconds) of an `AnimationTrack`. This will return 0 until the animation has fully loaded and thus may not be immediately available.

When the `Speed` of an `AnimationTrack` is equal to 1, the animation will take `Length` (in seconds) to complete.

## Code Samples

### Playing Animation for a Specific Duration

The following function will play an AnimationTrack for a specific duration. This is done by changing the speed of the animation to the length of the animation divided by the desired playback duration. This could be used in situations where a developer wants to play a standard animation for different duration (for example, recharging different abilities).
```lua
function playAnimationForDuration(animationTrack, duration)
	local speed = animationTrack.Length / duration
	animationTrack:AdjustSpeed(speed)
	animationTrack:Play()
end
```
A read only property that returns the length (in seconds) of an `AnimationTrack`. This will return 0 until the animation has fully loaded and thus may not be immediately available.

When the `Speed` of an `AnimationTrack` is equal to 1, the animation will take `Length` (in seconds) to complete.

## Code Samples

### Playing Animation for a Specific Duration

The following function will play an AnimationTrack for a specific duration. This is done by changing the speed of the animation to the length of the animation divided by the desired playback duration. This could be used in situations where a developer wants to play a standard animation for different duration (for example, recharging different abilities).
```lua
function playAnimationForDuration(animationTrack, duration)
	local speed = animationTrack.Length / duration
	animationTrack:AdjustSpeed(speed)
	animationTrack:Play()
end
```


Tags: ReadOnly, NotReplicated */
	readonly Length: number;
	/** This property sets whether the animation will repeat after finishing. If it is changed while playing the result will take effect after the animation finishes.  

The Looped property for `AnimationTrack` defaults to how it was set in the animation editor. However this property can be changed, allowing control over the `AnimationTrack` while the game is running. Looped also correctly handles animations played in reverse (negative `Speed`).  After the first keyframe is reached, it will restart at the last keyframe.  

This property allows the developer to have a looping and non looping variant of the same animation, without needing to upload two versions to Roblox.

## Code Samples

### Animation Looping

The animation in this example normally loops. After the player and the animation are loaded the animation is played in a non-looped fashion then in a looped fashion.
```lua
local Players = game:GetService("Players")
 
local localPlayer = Players.LocalPlayer
 
while not localPlayer.Character do wait() end
 
local character = localPlayer.Character
local humanoid = character:WaitForChild("Humanoid")
 
local animation = Instance.new("Animation")
animation.AnimationId = "rbxassetid://507770453"
 
local animationTrack = humanoid:LoadAnimation(animation)
animationTrack.Looped = false
wait(3) 
animationTrack:Play()
wait(4)
animationTrack.Looped = true
animationTrack:Play()
```

### Play AnimationTrack for a Number of Loops

The function in this code sample will play an AnimationTrack on a loop, for a specific number of loops, before stopping the animation.

In some cases the developer may want to stop a looped animation after a certain number of loops have completed, rather than after a certain amount of time. This is where the DidLoop event can be used.
```lua
local function playForNumberLoops(animationTrack, number)
	animationTrack.Looped = true
	animationTrack:Play()
	local numberOfLoops = 0
	local connection = nil
	connection = animationTrack.DidLoop:connect(function()
		numberOfLoops = numberOfLoops + 1
		print("loop: ", numberOfLoops)
		if numberOfLoops >= number then
			animationTrack:Stop()
			connection:Disconnect() -- it's important to disconnect connections when they are no longer needed
		end
	end)
end
```
 */
	Looped: boolean;
	/** This property sets the priority of an `AnimationTrack`. Depending on what this is set to, playing multiple animations at once will look to this property to figure out which `Keyframe` `Pose`s should be played over one another.

The Priority property for `AnimationTrack` defaults to how it was set in the editor. It uses the AnimationPriority Enum, which as four priority levels.

 1. Core (lowest priority)
 2. Idle
 3. Movement
 4. Action (highest priority)

Correctly set animation priorities, either through the editor or through this property allow multiple animations to be played without them clashing. Where two playing animations direct the target to move the same limb in different ways, the `AnimationTrack` with the highest priority will show. If both animations have the same priority, the weight of both tracks will be used to combine the animations. 

This property also allows the developer to play the same animation at different priorities, without needing to upload additional versions to Roblox. */
	Priority: Enum.AnimationPriority;
	/** The Speed of an `AnimationTrack` is a read only property that gives the current playback speed of the `AnimationTrack`. This has a default value of 1.  When speed is equal to 1, the amount of time an animation takes to complete is equal to `Length` (in seconds).

If the speed is adjusted, then the actual time it will take a track to play can be computed by dividing the length by the speed. Speed is a unitless quantity.

Speed can be used to link the length of an animation to different game events (for example recharging an ability) without having to upload different variants of the same animation. 

This property is read only and is changed using `AdjustSpeed`.

## Code Samples

### Playing Animation for a Specific Duration

The following function will play an AnimationTrack for a specific duration. This is done by changing the speed of the animation to the length of the animation divided by the desired playback duration. This could be used in situations where a developer wants to play a standard animation for different duration (for example, recharging different abilities).
```lua
function playAnimationForDuration(animationTrack, duration)
	local speed = animationTrack.Length / duration
	animationTrack:AdjustSpeed(speed)
	animationTrack:Play()
end
```

### Animation Speed

In this example a player and an animation is loaded. The Length of an AnimationTrack determines how long the track would take to play if the speed is at 1. If the speed is adjusted, then the actual time it will take a track to play can be computed by dividing the length by the speed.
```lua
local ContentProvider = game:GetService("ContentProvider")
local Players = game:GetService("Players")
 
local localPlayer = Players.LocalPlayer
while not localPlayer.Character do wait() end
local character = localPlayer.Character
local humanoid = character:WaitForChild("Humanoid")
local animation = Instance.new("Animation")
animation.AnimationId = "rbxassetid://507770453"
 
ContentProvider:PreloadAsync({animation})
 
local animationTrack = humanoid:LoadAnimation(animation)
 
local normalSpeedTime = animationTrack.Length / animationTrack.Speed
animationTrack:AdjustSpeed(3)
local fastSpeedTime = animationTrack.Length / animationTrack.Speed
 
print("At normal speed the animation will play for", normalSpeedTime, "seconds")
print("At 3x speed the animation will play for", fastSpeedTime, "seconds")
```
The Speed of an `AnimationTrack` is a read only property that gives the current playback speed of the `AnimationTrack`. This has a default value of 1.  When speed is equal to 1, the amount of time an animation takes to complete is equal to `Length` (in seconds).

If the speed is adjusted, then the actual time it will take a track to play can be computed by dividing the length by the speed. Speed is a unitless quantity.

Speed can be used to link the length of an animation to different game events (for example recharging an ability) without having to upload different variants of the same animation. 

This property is read only and is changed using `AdjustSpeed`.

## Code Samples

### Playing Animation for a Specific Duration

The following function will play an AnimationTrack for a specific duration. This is done by changing the speed of the animation to the length of the animation divided by the desired playback duration. This could be used in situations where a developer wants to play a standard animation for different duration (for example, recharging different abilities).
```lua
function playAnimationForDuration(animationTrack, duration)
	local speed = animationTrack.Length / duration
	animationTrack:AdjustSpeed(speed)
	animationTrack:Play()
end
```

### Animation Speed

In this example a player and an animation is loaded. The Length of an AnimationTrack determines how long the track would take to play if the speed is at 1. If the speed is adjusted, then the actual time it will take a track to play can be computed by dividing the length by the speed.
```lua
local ContentProvider = game:GetService("ContentProvider")
local Players = game:GetService("Players")
 
local localPlayer = Players.LocalPlayer
while not localPlayer.Character do wait() end
local character = localPlayer.Character
local humanoid = character:WaitForChild("Humanoid")
local animation = Instance.new("Animation")
animation.AnimationId = "rbxassetid://507770453"
 
ContentProvider:PreloadAsync({animation})
 
local animationTrack = humanoid:LoadAnimation(animation)
 
local normalSpeedTime = animationTrack.Length / animationTrack.Speed
animationTrack:AdjustSpeed(3)
local fastSpeedTime = animationTrack.Length / animationTrack.Speed
 
print("At normal speed the animation will play for", normalSpeedTime, "seconds")
print("At 3x speed the animation will play for", fastSpeedTime, "seconds")
```


Tags: ReadOnly, NotReplicated */
	readonly Speed: number;
	/** Returns the position in time in seconds that an `AnimationTrack` is through playing its source animation. Can be set to make the track jump to a specific moment in the animation.

TimePosition can be set to go to a specific point in the animation, but the `AnimationTrack` must be playing to do so. It can also be used in combination with `AdjustSpeed` to freeze the animation at a desired point (by setting speed to 0).

## Code Samples

### Freeze Animation at Position

The following code sample includes two functions that demonstrate how AdjustSpeed and TimePosition can be used to freeze an animation at a particular point.

The first function freezes an animation at a particular point in time (defined in seconds). The second freezes at it at a percentage (between 0 or 100) by multiplying the percentage by the track length. 

As TimePosition can not be used when an AnimationTrack is not playing, the functions check to make sure the animation is playing before proceeding.
```lua
function freezeAnimationAtTime(animationTrack, timePosition)
	-- Set the speed to 0 to freeze the animation
	animationTrack:AdjustSpeed(0)
	if not animationTrack.IsPlaying then
		-- Play the animation if it is not playing
		animationTrack:Play() 
	end
	-- Jump to the desired TimePosition
	animationTrack.TimePosition = timePosition
end

function freezeAnimationAtPercent(animationTrack, percentagePosition)
	-- Set the speed to 0 to freeze the animation
	animationTrack:AdjustSpeed(0)
	if not animationTrack.IsPlaying then
		-- Play the animation if it is not playing
		animationTrack:Play() 
	end
	-- Jump to the desired TimePosition
	animationTrack.TimePosition = (percentagePosition / 100) * animationTrack.Length
end

```
Returns the position in time in seconds that an `AnimationTrack` is through playing its source animation. Can be set to make the track jump to a specific moment in the animation.

TimePosition can be set to go to a specific point in the animation, but the `AnimationTrack` must be playing to do so. It can also be used in combination with `AdjustSpeed` to freeze the animation at a desired point (by setting speed to 0).

## Code Samples

### Freeze Animation at Position

The following code sample includes two functions that demonstrate how AdjustSpeed and TimePosition can be used to freeze an animation at a particular point.

The first function freezes an animation at a particular point in time (defined in seconds). The second freezes at it at a percentage (between 0 or 100) by multiplying the percentage by the track length. 

As TimePosition can not be used when an AnimationTrack is not playing, the functions check to make sure the animation is playing before proceeding.
```lua
function freezeAnimationAtTime(animationTrack, timePosition)
	-- Set the speed to 0 to freeze the animation
	animationTrack:AdjustSpeed(0)
	if not animationTrack.IsPlaying then
		-- Play the animation if it is not playing
		animationTrack:Play() 
	end
	-- Jump to the desired TimePosition
	animationTrack.TimePosition = timePosition
end

function freezeAnimationAtPercent(animationTrack, percentagePosition)
	-- Set the speed to 0 to freeze the animation
	animationTrack:AdjustSpeed(0)
	if not animationTrack.IsPlaying then
		-- Play the animation if it is not playing
		animationTrack:Play() 
	end
	-- Jump to the desired TimePosition
	animationTrack.TimePosition = (percentagePosition / 100) * animationTrack.Length
end

```


Tags: NotReplicated */
	TimePosition: number;
	/** When weight is set in an `AnimationTrack` it does not change instantaneously but moves from WeightCurrent to `WeightTarget`. The time it takes to do this is determined by the fadeTime parameter given when the animation is played, or the weight is adjusted. 

WeightCurrent can be checked against `WeightTarget` to see if the desired weight has been reached. Note that these values should not be checked for equality with the == operator, as both of these values are floats. To see if WeightCurrent has reached the target weight, it is recommended to see if the distance between those values is sufficiently small (see code sample below).

The animation weighting system is used to determine how `AnimationTrack`s playing at the same priority are blended together. The default weight is one, and no movement will be visible on an `AnimationTrack` with a weight of zero. The pose that is shown at any point in time is determined by the weighted average of all the `Pose`s and the WeightCurrent of each `AnimationTrack`. See below for an example of animation blending in practice.

![Animation Weight Blending](https://developer.roblox.com/assets/blt755bd460ebb6cd91/Animation_Weight_-_Copy.png)


  

In most cases blending animations is not required and using `Priority` is more suitable.

## Code Samples

### WeightCurrent and WeightTarget

This code sample loads two animations onto the local player's Humanoid and demonstrates how the fadeTime paramater in AnimationTrack.Play determines how long it takes for an AnimationTrack's WeightCurrent to reach it's WeightTarget.

As WeightCurrent and WeightTarget are floats the == operator cannot be used to compare, instead it is more appropriate to check that the difference between them is sufficiently small to assume the weight fade has completed.
```lua
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
while not localPlayer.Character do wait() end
local character = localPlayer.Character
local humanoid = character:WaitForChild("Humanoid")
 
local animation1 = Instance.new("Animation")
animation1.AnimationId = "rbxassetid://507770453"
 
local animation2 = Instance.new("Animation")
animation2.AnimationId = "rbxassetid://507771019"
 
wait(3) -- arbitrary wait time to allow the character to fall into place
 
local animationTrack1 = humanoid:LoadAnimation(animation1)
local animationTrack2 = humanoid:LoadAnimation(animation2)
animationTrack1.Priority = Enum.AnimationPriority.Movement
animationTrack2.Priority = Enum.AnimationPriority.Action
animationTrack1:Play(0.1, 5, 1)
animationTrack2:Play(10, 3, 1)
local done = false
while not done and wait(0.1) do
	if math.abs(animationTrack2.WeightCurrent - animationTrack2.WeightTarget) < 0.001 then
		print("got there")
		done = true
	end
end
```
When weight is set in an `AnimationTrack` it does not change instantaneously but moves from WeightCurrent to `WeightTarget`. The time it takes to do this is determined by the fadeTime parameter given when the animation is played, or the weight is adjusted. 

WeightCurrent can be checked against `WeightTarget` to see if the desired weight has been reached. Note that these values should not be checked for equality with the == operator, as both of these values are floats. To see if WeightCurrent has reached the target weight, it is recommended to see if the distance between those values is sufficiently small (see code sample below).

The animation weighting system is used to determine how `AnimationTrack`s playing at the same priority are blended together. The default weight is one, and no movement will be visible on an `AnimationTrack` with a weight of zero. The pose that is shown at any point in time is determined by the weighted average of all the `Pose`s and the WeightCurrent of each `AnimationTrack`. See below for an example of animation blending in practice.

![Animation Weight Blending](https://developer.roblox.com/assets/blt755bd460ebb6cd91/Animation_Weight_-_Copy.png)


  

In most cases blending animations is not required and using `Priority` is more suitable.

## Code Samples

### WeightCurrent and WeightTarget

This code sample loads two animations onto the local player's Humanoid and demonstrates how the fadeTime paramater in AnimationTrack.Play determines how long it takes for an AnimationTrack's WeightCurrent to reach it's WeightTarget.

As WeightCurrent and WeightTarget are floats the == operator cannot be used to compare, instead it is more appropriate to check that the difference between them is sufficiently small to assume the weight fade has completed.
```lua
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
while not localPlayer.Character do wait() end
local character = localPlayer.Character
local humanoid = character:WaitForChild("Humanoid")
 
local animation1 = Instance.new("Animation")
animation1.AnimationId = "rbxassetid://507770453"
 
local animation2 = Instance.new("Animation")
animation2.AnimationId = "rbxassetid://507771019"
 
wait(3) -- arbitrary wait time to allow the character to fall into place
 
local animationTrack1 = humanoid:LoadAnimation(animation1)
local animationTrack2 = humanoid:LoadAnimation(animation2)
animationTrack1.Priority = Enum.AnimationPriority.Movement
animationTrack2.Priority = Enum.AnimationPriority.Action
animationTrack1:Play(0.1, 5, 1)
animationTrack2:Play(10, 3, 1)
local done = false
while not done and wait(0.1) do
	if math.abs(animationTrack2.WeightCurrent - animationTrack2.WeightTarget) < 0.001 then
		print("got there")
		done = true
	end
end
```


Tags: ReadOnly, NotReplicated */
	readonly WeightCurrent: number;
	/** When weight is set in an `AnimationTrack` it does not change instantaneously but moves from WeightCurrent to `WeightTarget`. The time it takes to do this is determined by the fadeTime parameter given when the animation is played, or the weight is adjusted. 

WeightCurrent can be checked against `WeightTarget` to see if the desired weight has been reached. Note that these values should not be checked for equality with the == operator, as both of these values are floats. To see if WeightCurrent has reached the target weight, it is recommended to see if the distance between those values is sufficiently small (see code sample below).

The animation weighting system is used to determine how `AnimationTrack`s playing at the same priority are blended together. The default weight is one, and no movement will be visible on an `AnimationTrack` with a weight of zero. The pose that is shown at any point in time is determined by the weighted average of all the `Pose`s and the WeightCurrent of each `AnimationTrack`. See below for an example of animation blending in practice.

![Animation Weight Blending](https://developer.roblox.com/assets/blt755bd460ebb6cd91/Animation_Weight_-_Copy.png)


  

In most cases blending animations is not required and using `Priority` is more suitable.

## Code Samples

### WeightCurrent and WeightTarget

This code sample loads two animations onto the local player's Humanoid and demonstrates how the fadeTime paramater in AnimationTrack.Play determines how long it takes for an AnimationTrack's WeightCurrent to reach it's WeightTarget.

As WeightCurrent and WeightTarget are floats the == operator cannot be used to compare, instead it is more appropriate to check that the difference between them is sufficiently small to assume the weight fade has completed.
```lua
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
while not localPlayer.Character do wait() end
local character = localPlayer.Character
local humanoid = character:WaitForChild("Humanoid")
 
local animation1 = Instance.new("Animation")
animation1.AnimationId = "rbxassetid://507770453"
 
local animation2 = Instance.new("Animation")
animation2.AnimationId = "rbxassetid://507771019"
 
wait(3) -- arbitrary wait time to allow the character to fall into place
 
local animationTrack1 = humanoid:LoadAnimation(animation1)
local animationTrack2 = humanoid:LoadAnimation(animation2)
animationTrack1.Priority = Enum.AnimationPriority.Movement
animationTrack2.Priority = Enum.AnimationPriority.Action
animationTrack1:Play(0.1, 5, 1)
animationTrack2:Play(10, 3, 1)
local done = false
while not done and wait(0.1) do
	if math.abs(animationTrack2.WeightCurrent - animationTrack2.WeightTarget) < 0.001 then
		print("got there")
		done = true
	end
end
```
When weight is set in an `AnimationTrack` it does not change instantaneously but moves from WeightCurrent to `WeightTarget`. The time it takes to do this is determined by the fadeTime parameter given when the animation is played, or the weight is adjusted. 

WeightCurrent can be checked against `WeightTarget` to see if the desired weight has been reached. Note that these values should not be checked for equality with the == operator, as both of these values are floats. To see if WeightCurrent has reached the target weight, it is recommended to see if the distance between those values is sufficiently small (see code sample below).

The animation weighting system is used to determine how `AnimationTrack`s playing at the same priority are blended together. The default weight is one, and no movement will be visible on an `AnimationTrack` with a weight of zero. The pose that is shown at any point in time is determined by the weighted average of all the `Pose`s and the WeightCurrent of each `AnimationTrack`. See below for an example of animation blending in practice.

![Animation Weight Blending](https://developer.roblox.com/assets/blt755bd460ebb6cd91/Animation_Weight_-_Copy.png)


  

In most cases blending animations is not required and using `Priority` is more suitable.

## Code Samples

### WeightCurrent and WeightTarget

This code sample loads two animations onto the local player's Humanoid and demonstrates how the fadeTime paramater in AnimationTrack.Play determines how long it takes for an AnimationTrack's WeightCurrent to reach it's WeightTarget.

As WeightCurrent and WeightTarget are floats the == operator cannot be used to compare, instead it is more appropriate to check that the difference between them is sufficiently small to assume the weight fade has completed.
```lua
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
while not localPlayer.Character do wait() end
local character = localPlayer.Character
local humanoid = character:WaitForChild("Humanoid")
 
local animation1 = Instance.new("Animation")
animation1.AnimationId = "rbxassetid://507770453"
 
local animation2 = Instance.new("Animation")
animation2.AnimationId = "rbxassetid://507771019"
 
wait(3) -- arbitrary wait time to allow the character to fall into place
 
local animationTrack1 = humanoid:LoadAnimation(animation1)
local animationTrack2 = humanoid:LoadAnimation(animation2)
animationTrack1.Priority = Enum.AnimationPriority.Movement
animationTrack2.Priority = Enum.AnimationPriority.Action
animationTrack1:Play(0.1, 5, 1)
animationTrack2:Play(10, 3, 1)
local done = false
while not done and wait(0.1) do
	if math.abs(animationTrack2.WeightCurrent - animationTrack2.WeightTarget) < 0.001 then
		print("got there")
		done = true
	end
end
```


Tags: ReadOnly, NotReplicated */
	readonly WeightTarget: number;
	/** This function changes the `Speed` of an animation.  A positive value for speed plays the animation forward, a negative one plays it backwards, and 0 pauses it.

An AnimationTrack's initial speed is set as a parameter in `Play`. However a track's Speed can be changed during playback, using AdjustSpeed. When speed is equal to 1, the amount of time an animation takes to complete is equal to `Length` (in seconds).

When is adjusted, then the actual time it will take a track to play can be computed by dividing the length by the speed. Speed is a unitless quantity.

Speed can be used to link the length of an animation to different gameplay events (for example recharging an ability) without having to upload different variants of the same animation.

## Code Samples

### Playing Animation for a Specific Duration

The following function will play an AnimationTrack for a specific duration. This is done by changing the speed of the animation to the length of the animation divided by the desired playback duration. This could be used in situations where a developer wants to play a standard animation for different duration (for example, recharging different abilities).
```lua
function playAnimationForDuration(animationTrack, duration)
	local speed = animationTrack.Length / duration
	animationTrack:AdjustSpeed(speed)
	animationTrack:Play()
end
```

### Animation Speed

In this example a player and an animation is loaded. The Length of an AnimationTrack determines how long the track would take to play if the speed is at 1. If the speed is adjusted, then the actual time it will take a track to play can be computed by dividing the length by the speed.
```lua
local ContentProvider = game:GetService("ContentProvider")
local Players = game:GetService("Players")
 
local localPlayer = Players.LocalPlayer
while not localPlayer.Character do wait() end
local character = localPlayer.Character
local humanoid = character:WaitForChild("Humanoid")
local animation = Instance.new("Animation")
animation.AnimationId = "rbxassetid://507770453"
 
ContentProvider:PreloadAsync({animation})
 
local animationTrack = humanoid:LoadAnimation(animation)
 
local normalSpeedTime = animationTrack.Length / animationTrack.Speed
animationTrack:AdjustSpeed(3)
local fastSpeedTime = animationTrack.Length / animationTrack.Speed
 
print("At normal speed the animation will play for", normalSpeedTime, "seconds")
print("At 3x speed the animation will play for", fastSpeedTime, "seconds")
```

@param speed The playback speed the animation is to be changed to. */
	AdjustSpeed(speed?: number): void;
	/** Changes the weight of an animation, with the optional fadeTime parameter determining how long it takes for `WeightCurrent` to reach `WeightTarget`.

When weight is set in an `AnimationTrack` it does not change instantaneously but moves from WeightCurrent to `WeightTarget`. The time it takes to do this is determined by the fadeTime parameter given when the animation is played, or the weight is adjusted. 

WeightCurrent can be checked against `WeightTarget` to see if the desired weight has been reached. Note that these values should not be checked for equality with the == operator, as both of these values are floats. To see if WeightCurrent has reached the target weight, it is recommended to see if the distance between those values is sufficiently small (see code sample below).

The animation weighting system is used to determine how `AnimationTrack`s playing at the same priority are blended together. The default weight is one, and no movement will be visible on an `AnimationTrack` with a weight of zero. The pose that is shown at any point in time is determined by the weighted average of all the `Pose`s and the WeightCurrent of each `AnimationTrack`. See below for an example of animation blending in practice.

![Animation Weight Blending](https://developer.roblox.com/assets/blt755bd460ebb6cd91/Animation_Weight_-_Copy.png)


  

In most cases blending animations is not required and using `Priority` is more suitable.

## Code Samples

### AnimationTrack Change Weight

This code sample includes a function that changes the weight of an AnimationTrack and yields until the weight has changed to the new target weight.

The purpose of this sample is to demonstrate how the fadeTime parameter of AnimationTrack.ChangeWeight works. In most cases, if a developer wishes to yield over the fadeTime it is recommended they use wait(fadeTime).
```lua
local function changeWeight(animationTrack, weight, fadeTime)
	animationTrack:AdjustWeight(weight, fadeTime)
	local startTime = tick()
	while math.abs(animationTrack.WeightCurrent - weight) > 0.001 do
		wait()
	end
	print("Time taken to change weight "..tostring(tick() - startTime))
end
```

@param weight The weight the animation is to be changed to.
@param fadeTime The duration of time that the animation will fade between the old weight and the new weight for. */
	AdjustWeight(weight?: number, fadeTime?: number): void;
	/** This function returns an `event` similar to the `KeyframeReached` event, except it only fires when a specified `KeyframeMarker` has been hit in an `animation`. The difference allows for greater control of when the event will fire.

This event allows a developer to run code at predefined points in an animation (set by `Keyframe` names). This allows the default functionality of Roblox animations to be expanded upon by adding things such as `Sounds` or `ParticleEffects` at different points in an animation.

To learn more about using this function, see **Animation&nbsp;Events** in the `using animation Using the Animation Editor` article.

## Using the Returned Event
The RBXScriptSignal (event) returned by this can be connected to another function. The connection creates a `RBXScriptConnection` listener that executes the connected function every time the animation hits the specified KeyframeMarker until disconnected using Disconnect().

## More about Keyframes
`Keyframe` names do not need to be unique. For example, if an Animation has three keyframes named "Particles" the connected event returned by this function will fire each time one of these keyframes is reached.

`Keyframe` names can be set in the Roblox Animation Editor when creating or editing an animation. They cannot however be set by a `Script` on an existing animation prior to playing it. 

## See also
 - `AnimationTrack`, controls the playback of an animation on a `Humanoid` or `AnimationController`
 - `Keyframe`,  holds the `Poses` applied to joints in a `Model` at a given point of time in an animation
 - `AddMarker`
 - `RemoveMarker`
 - `GetMarkers`

## Code Samples

### Listening to KeyFrameMarkers

The following example plays an animation on the local `character` and prints a value whenever a `Keyframe` that has a `KeyframeMarker` named *“FootStep”* gets hit in the `animation`. 

The example listens to when the KeyFrame is hit by connecting the function *markerReached* to the event returned by `GetKeyframeReachedSignal`, which fires whenever the KeyFrameMarker named *"FootStep"* gets hit.

In order for this to work as expected, it should be placed in a `LocalScript` in `StarterGui`.
```lua
local player = game.Players:GetChildren()[1]
local character = game.Workspace:WaitForChild(player.Name)
local humanoid = character:WaitForChild("Humanoid")
 
local anim = Instance.new("Animation")
anim.AnimationId = "rbxassetid://437855404"
local animTrack = humanoid:LoadAnimation(anim)
 
animTrack:GetKeyframeReachedSignal("FootStep"):Connect(function(value)
    print(value)
end)
animTrack:Play()
```

@param name The name of the `KeyFrameMarker` the signal is being created for
@returns The signal created and fired when the animation reaches the created `KeyFrameMarker` */
	GetMarkerReachedSignal(name: string): RBXScriptSignal;
	/** Returns the time position of the first `Keyframe` of the given name in an `AnimationTrack`. If multiple `Keyframe`s share the same name, it will return the earliest one in the animation.


This function will return an error if it is uses with an invalid keyframe name (one that does not exist for example) or if the underlying `Animation` has not yet loaded. To address this make sure only correct keyframe names are used and the animation has loaded before calling this function. 

To check if the animation has loaded, verify that the `AnimationTrack`'s `Length` is greater than zero.

## Code Samples

### Jump To Keyframe

This sample includes a function that will jump to the first keyframe of a specified name in an AnimationTrack.

As AnimationTrack.TimePosition cannot be set whilst the animation is not playing the function first checks to see if the animation is playing.

This sample will only work once an Animation has loaded.
```lua
local function jumpToKeyframe(animationTrack, keyframeName)
	local timePosition = animationTrack:GetTimeOfKeyframe(keyframeName)
	if not animationTrack.IsPlaying then
		animationTrack:Play()	
	end
	animationTrack.TimePosition = timePosition
end
```

@param keyframeName The name associated with the `Keyframe` to be found.
@returns The time, in seconds, the `Keyframe` occurs at normal playback speed. */
	GetTimeOfKeyframe(keyframeName: string): number;
	/** When `Play` is called the track's animation will begin playing and the weight of the animation will increase from 0 to the specified weight (defaults to 1) over the specified fadeTime (defaults to 0.1).

The speed the `AnimationTrack` will play at is determined by the speed parameter (defaults to 1). When the speed is equal to 1 the number of seconds the track will take to complete is equal to the track's `Length` property. For example, a speed of 2 will cause the track to play twice as fast.

The weight and speed of the animation can also be changed after the animation has begun playing by using the `AdjustWeight` and `AdjustSpeed` methods.

If the developer wants to start the animation at a specific point using `TimePosition`, it is important the animation is played before this is done.

## Code Samples

### Playing Animation for a Specific Duration

The following function will play an AnimationTrack for a specific duration. This is done by changing the speed of the animation to the length of the animation divided by the desired playback duration. This could be used in situations where a developer wants to play a standard animation for different duration (for example, recharging different abilities).
```lua
function playAnimationForDuration(animationTrack, duration)
	local speed = animationTrack.Length / duration
	animationTrack:AdjustSpeed(speed)
	animationTrack:Play()
end
```

### Freeze Animation at Position

The following code sample includes two functions that demonstrate how AdjustSpeed and TimePosition can be used to freeze an animation at a particular point.

The first function freezes an animation at a particular point in time (defined in seconds). The second freezes at it at a percentage (between 0 or 100) by multiplying the percentage by the track length. 

As TimePosition can not be used when an AnimationTrack is not playing, the functions check to make sure the animation is playing before proceeding.
```lua
function freezeAnimationAtTime(animationTrack, timePosition)
	-- Set the speed to 0 to freeze the animation
	animationTrack:AdjustSpeed(0)
	if not animationTrack.IsPlaying then
		-- Play the animation if it is not playing
		animationTrack:Play() 
	end
	-- Jump to the desired TimePosition
	animationTrack.TimePosition = timePosition
end

function freezeAnimationAtPercent(animationTrack, percentagePosition)
	-- Set the speed to 0 to freeze the animation
	animationTrack:AdjustSpeed(0)
	if not animationTrack.IsPlaying then
		-- Play the animation if it is not playing
		animationTrack:Play() 
	end
	-- Jump to the desired TimePosition
	animationTrack.TimePosition = (percentagePosition / 100) * animationTrack.Length
end

```

@param fadeTime The duration of time that the animation's weight should be faded in for.
@param weight The weight the animation is to be played at.
@param speed The playback speed of the animation. */
	Play(fadeTime?: number, weight?: number, speed?: number): void;
	/** Stops the `AnimationTrack`. Once called playback of the `AnimationTrack` will stop and the weight of the animation will move towards zero over a length of time specified by the optional fadeTime parameter.

For example, if Stop is called with a fadeTime of 2 seconds it will take two seconds for the weight of the `AnimationTrack` to reach zero and its effects completely end. Please note this will be the case regardless of the initial weight of the animation.

It is not recommended to use a fadeTime of 0 seconds to try to override this effect and end the animation immediately as presently, this causes the `AnimationTrack` poses to freeze.

## Code Samples

### AnimationTrack Stop

This code sample includes a function that stops an AnimationTrack with a specific fadeTime, and yields until the fade is completed and the weight of the AnimationTrack is equal to zero.

The purpose of this sample is to demonstrate how the fadeTime parameter of AnimationTrack.Stop works. In most cases, if a developer wishes to yield over the fadeTime it is recommended they use wait(fadeTime).
```lua
local function fadeOut(animationTrack, fadeTime)
	animationTrack:Stop(fadeTime)
	local startTime = tick()
	while animationTrack.WeightCurrent > 0 do
		wait()
	end
	local timeTaken = tick() - startTime
	print("Time taken for weight to reset: "..tostring(timeTaken))
end
```

@param fadeTime The time, in seconds, for which animation weight is to be faded out over. */
	Stop(fadeTime?: number): void;
	/** This event fires whenever a looped `AnimationTrack` completes a loop, on the next update. 

Currently it may also fire at the exact end of a non looped animation track but this behavior should not be relied upon.

## Code Samples

### Play AnimationTrack for a Number of Loops

The function in this code sample will play an AnimationTrack on a loop, for a specific number of loops, before stopping the animation.

In some cases the developer may want to stop a looped animation after a certain number of loops have completed, rather than after a certain amount of time. This is where the DidLoop event can be used.
```lua
local function playForNumberLoops(animationTrack, number)
	animationTrack.Looped = true
	animationTrack:Play()
	local numberOfLoops = 0
	local connection = nil
	connection = animationTrack.DidLoop:connect(function()
		numberOfLoops = numberOfLoops + 1
		print("loop: ", numberOfLoops)
		if numberOfLoops >= number then
			animationTrack:Stop()
			connection:Disconnect() -- it's important to disconnect connections when they are no longer needed
		end
	end)
end
```
 */
	readonly DidLoop: RBXScriptSignal<() => void>;
	/** Fires every time playback of an `AnimationTrack` reaches a `Keyframe` that does not have the default name - "Keyframe".

This event allows a developer to run code at predefined points in an animation (set by `Keyframe` names). This allows the default functionality of Roblox animations to be expanded upon by adding `Sound`s or `ParticleEffect`s at different points in an animation.

`Keyframe` names do not need to be unique. For example, if an Animation has three keyframes named "Particles" the KeyframeReached event will fire each time one of these keyframes is reached.

`Keyframe` names can be set in the Roblox Animation Editor when creating or editing an animation. They cannot however be set by a `Script` on an existing animation prior to playing it.

## Code Samples

### Listen For Animation Effects

The function in the following code sample provides an example of how the AnimationTrack.KeyframeReached event can be used to link different effects to an animation.

The function listens for any animations being played on the Humanoid (or AnimationController), and when a new animation is played listens for a keyframe named 'Effect' being reached. When a keyframe named 'Effect' is reached some basic particles will be emitted. Once the animation has stopped the connections used by the function are disconnected, in line with best practice to avoid memory leaks.

Although the particle effect in this sample is very simple, it could be substituted for a range of more complicated effects using the Sound, Beam, ParticleEffect or other objects. Additionally, in many cases the developer may only care about effects on one specific animation (rather than every animation played on a Humanoid). In this case, only the KeyframeReached portion of this sample would be needed.
```lua
local Debris = game:GetService("Debris")

local function listenForAnimationEffects(humanoid) -- would also work for an AnimationController
	-- listen for new animations being played on the Humanoid
	humanoid.AnimationPlayed:Connect(function(animationTrack)
		local keyframeConnection = nil
		-- listen for the 'Effect' keyframe being reached
		keyframeConnection = animationTrack.KeyframeReached:Connect(function(keyframeName)
			if keyframeName == "Effect" then
				-- make sure the Humanoid RootPart exists
				if humanoid.RootPart then
					-- create a basic particle effect
					local particles = Instance.new("ParticleEmitter", humanoid.RootPart)
					particles.Rate = 0
					particles:Emit(10)
					Debris:AddItem(particles, 2)
				end
			end
		end)
		local stoppedConnection = nil
		stoppedConnection = animationTrack.Stopped:Connect(function()
			-- clean up old connections to stop memory leaks
			keyframeConnection:Disconnect()
			stoppedConnection:Disconnect()
		end)
	end)
end
```

### AnimationTrack KeyframeReached

Create a localscript in StarterGui and paste the following code to try out this example. 

The code in this sample will play an animation on the local character and print whenever a keyframe that is not named "Keyframe" is reached.
```lua
local player = game.Players:GetChildren()[1]
local character = game.Workspace:WaitForChild(player.Name)
local humanoid = character:WaitForChild("Humanoid")
 
local anim = Instance.new("Animation")
anim.AnimationId = "rbxassetid://437855404"
local animTrack = humanoid:LoadAnimation(anim)
 
animTrack.KeyframeReached:Connect(function(keyframeName)
	print("Keyframe reached:"..keyframeName)
end)
animTrack:Play()
```
 */
	readonly KeyframeReached: RBXScriptSignal<(keyframeName: string) => void>;
	/** Fires whenever the `AnimationTrack` finishes playing. 

This event has a number of uses. It can be used to wait until an `AnimationTrack` has stopped before continuing (for example, if chaining a series of animations to play after each other). It can also be used to clean up any `Instance`s created during the animation playback.

## Code Samples

### AnimationTrack Stopped

The function in this code sample will play an animationTrack and yield until it has stopped, before printing.
```lua
local function yieldPlayAnimation(animationTrack, fadeTime, weight, speed)
	animationTrack:Play(fadeTime, weight, speed)
	animationTrack.Stopped:wait()
	print("Animation has stopped")
end
```
 */
	readonly Stopped: RBXScriptSignal<() => void>;
}

/** The `Animator` is the main class responsible for controlling an `Animation`. It is created when `LoadAnimation` is called under a `Humanoid` or `AnimationController` for the first time.

## Code Samples

### Animator LoadAnimation

This code sample includes a function that can be used to play an animation on a locally controlled model (such as a player character) from the server.
```lua
local function playAnimationFromServer(character, animation)
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		-- need to use animation object for server access
		local animator = humanoid:FindFirstChildOfClass("Animator")
		if animator then
			local animationTrack = animator:LoadAnimation(animation)
			animationTrack:Play()
			return animationTrack
		end
	end
end
```
 */
interface Animator extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Animator";
	/** Loads an `Animation` onto an `Animator`, returning an `AnimationTrack`. Used to load animations on locally controlled models (such as player characters) from the server.

A `Model` is considered locally controlled if it has network ownership of the model, clients have network ownership of the local character model by default and other models can be assigned to a different client using `SetNetworkOwner`.

It is best practice to only animate a model from the server if the server has network ownership, and for this reason most developers will not need to use the `LoadAnimation` function as they can load animations directly from the `Humanoid` or `AnimationController`.

Note if the server has network ownership of the model, and the `AnimationController` or `Humanoid` was created on the server, then `LoadAnimation` does not need to be used as `LoadAnimation` can be used directly from the `Humanoid` or `AnimationController` on the server.

## Code Samples

### Animator LoadAnimation

This code sample includes a function that can be used to play an animation on a locally controlled model (such as a player character) from the server.
```lua
local function playAnimationFromServer(character, animation)
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		-- need to use animation object for server access
		local animator = humanoid:FindFirstChildOfClass("Animator")
		if animator then
			local animationTrack = animator:LoadAnimation(animation)
			animationTrack:Play()
			return animationTrack
		end
	end
end
```

@param animation The `Animation` to be used.
@returns The `AnimationTrack` created. */
	LoadAnimation(animation: Animation): AnimationTrack;
}

/** The AssetService is a non-replicated service that handles asset related queries to the Roblox web API. Eventually, this will house all asset related queries for Roblox objects stored in the web. One should mind the `Multi Place limitations` this API has. */
interface AssetService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AssetService";
	/** Clones a place with placeId equal to given templatePlaceId. It is placed into the inventory of the place's creator with the given name and description. This method will also return the placeId of the new place, which can be used with TeleportService. This method cannot be used to clone places that you do not own. */
	CreatePlaceAsync(placeName: string, templatePlaceID: number, description?: string): number;
	/** Clones a place which has a placeId equal to the given templatePlaceID, placing it into the inventory of the given player with the given name and description, if they accept when prompted. This method cannot be used to clone places that you do not own, or those which have disabled the use of the CreatePlace API in their place's configuration. */
	CreatePlaceInPlayerInventoryAsync(
		player: Player,
		placeName: string,
		templatePlaceID: number,
		description?: string,
	): number;
	/** Returns an array of assetIds that are contained in a specified package. */
	GetAssetIdsForPackage(packageAssetId: number): Array<number>;
	/** If the bundle Id does not exist, it throws HTTP 400 (HTTP/1.1 400 Bad Request).
If bundleId is not convertible to int, throws "Unable to cast string to int64". If param type is string, it implicitly tries to convert to int.


This function returns details of the contents of the specified bundle.

## Understanding the returned ValueTable
It returns a ValueTable object with the following key-value pairs containing details about the specified bundle
| Key Name | Value Type | Description |
| --- | --- | --- |
| Id number | int | Bundle Id (passed in as an argument) |
| Name | string | Bundle name |
| Description | string | Bundle description |
| BundleType | string | Bundle Type. eg. BodyParts or `AvatarAnimations` |
| Items | ValueArray | An array of ValueTable objects |

Each object in the Items array contains details of the item as described in the table below:

| Key Name | Value Type | Description |
| --- | --- | --- |
| Id number | int | Item's id |
| Name | string | Item name |
| Type | string | Item Type eg: "UserOutfit" or "Asset" |

## Code Samples

### Getting Bundle Details

The following code sample demonstrates how to retrieve details for the bundle with the id **13**. The **Expected Value** tab displays the key-value pairs contained within the returned ValueTable and item array for the bundle with the specified id.
```lua
local bundleId = 13
local bundleDetails = game:GetService("AssetService"):GetBundleDetailsAsync(bundleId)
```

@param bundleId The id of the specified bundle
@returns A ValueTable object with the following key-value pairs containing details about the specified bundle. See the function description for more information */
	GetBundleDetailsAsync(bundleId: number): BundleInfo;
	/** Returns a `StandardPages` object which contains the name and placeId of places within the current 'Game' (otherwise known as a 'Universe').

## Code Samples

### AssetService:GetGamePlacesAsync1

The following code goes through each page of games in the universe and prints the Name and PlaceId.
```lua
local pages = game:GetService("AssetService"):GetGamePlacesAsync()
while true do
     for _,place in pairs(pages:GetCurrentPage()) do
          print("Name: " .. place.Name)
          print("PlaceId: " .. tostring(place.PlaceId))
     end
     if pages.IsFinished then
          -- we reached the last page of results
          break
     end
     pages:AdvanceToNextPageAsync()
end
```
 */
	GetGamePlacesAsync(): StandardPages;
	/** Saves the state of the current place. This will only work for places that have been created with `CreatePlaceAsync` or `CreatePlaceInPlayerInventoryAsync`. */
	SavePlaceAsync(): void;
}

/** An Attachment is a special class used by constraint based objects. It represents an offset relative to the object it is parented to, in both its `Position` and `Orientation` properties.

The Position/Orientation properties of this object correspond with the object's CFrame property, which are then outputted in real time to the WorldPosition and WorldOrientation properties. */
interface Attachment extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Attachment";
	/** Represents the direction of the X-Axis, relative to the Attachment's `Rotation`, as a unit [Vector3](https://developer.roblox.com/api-reference/datatype/Vector3 "Vector3")
 with a length of 1. */
	Axis: Vector3;
	/** Represents the CFrame offset of the Attachment.Changes to this property will reflect onto the `Position` & `Rotation` properties of this object.

Similarly, a change to either of those properties will reflect onto this property.Represents the CFrame offset of the Attachment. */
	CFrame: CFrame;
	/** A [Vector3](https://developer.roblox.com/api-reference/datatype/Vector3 "Vector3")
 that describes the orientation of the Attachment relative to the orientation of its parent, in degrees. Rotations are applied in Z, X, Y order. */
	Orientation: Vector3;
	/** A [Vector3](https://developer.roblox.com/api-reference/datatype/Vector3 "Vector3")
 that describes the positional offset of the Attachment, relative to the position and orientation of its parent. */
	Position: Vector3;
	/** Represents the direction of the Y-Axis, relative to the Attachment's `Rotation`, as a unit [Vector3](https://developer.roblox.com/api-reference/datatype/Vector3 "Vector3")
 with a length of 1. */
	SecondaryAxis: Vector3;
	/** Toggles the visibility of the Attachment in-game. */
	Visible: boolean;
	/** Represents the direction of the `Attachment's` Attachment/Axis|X-Axis` relative to the world, as a unit `Vector3` with a length of 1. */
	WorldAxis: Vector3;
	/** WorldCFrame describes the exact `CFrame` of this attachment in the game world, independent of its `BasePart` parent.


The value of this property is equivalent to multiplying the CFrame of the `attachment's` parent by its own CFrame:

```lua
local worldCFrame = attachment.CFrame
if attachment.Parent then
    worldCFrame = attachment.Parent.CFrame * worldCFrame
end
``` */
	WorldCFrame: CFrame;
	/** Describes the orientation (in degrees) of the `attachment` relative to the world, rather than the parent of the Attachment.

Rotations are described in Z, X, Y order. */
	WorldOrientation: Vector3;
	/** Describes the position of the `attachment` relative to the world, rather than the parent of the Attachment. */
	WorldPosition: Vector3;
	/** Represents the direction of the `Y-Axis` of the `Attachment`, relative to the world, as a unit `Vector3` with a length of 1. */
	WorldSecondaryAxis: Vector3;
}

/** A container object that holds a `Player`'s inventory. Any `Tool` in a player's Backpack will be displayed in their inventory at the bottom of their screen. Selecting `Tool`s from the inventory will equip the `Tool`, moving it from the Backpack to the player's character. 

The Backpack can also store `Script`s and `LocalScript`s which will run when placed in a player's Backpack. 

When a player's character spawns, the contents of the `StarterPack` and their `StarterGear` are copied into their Backpack. Once a character dies, the Backpack is removed and a new one will be created -- populating it with the contents of `StarterPack` and `StarterGear`. 

Roblox provides an interface for a player to access their backpack and inventory by default at the bottom of the screen. If a developer wishes to disable the default Roblox backpack GUI and replace it with their own, they may do so using `SetCoreGuiEnabled`.

The Backpack can be accessed from both the client and the server.

    -- Accessing Backpack from a Server Script:
    game.Players.PlayerName.Backpack
     
    -- Accessing Backpack from a LocalScript:
    game.Players.LocalPlayer.Backpack

## Code Samples

### Backpack Give Tool

This sample includes a simple function demonstrating how a Tool can be given to a Player by parenting it to their Backpack.
```lua
local function giveTool(player, tool)
	local backpack = player:FindFirstChildOfClass("Backpack")
	if backpack then
		tool.Parent = backpack
	end
end
```
 */
interface Backpack extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Backpack";
}

interface RbxInternalBackpackItem extends RbxInternalInstance {
	/** The texture icon that is displayed for a tool in the `Player`'s backpack.

This property should be set to the content ID of an image uploaded to the Roblox website.

If this property is left blank, the `Backpack` GUI will display the name of the tool instead. */
	TextureId: string;
}
/** BackpackItem is an abstract class for backpack items such as HopperBins and Tools. */
type BackpackItem = HopperBin | Tool | Flag;

/** HopperBins are an outdated system for creating tools that can be used by a player. In place of HopperBins, please use `Tool` instead. 

Historically, only HopperBins worked without a 'Handle' `Part`, but this is no longer the case thanks to the `RequiresHandle` property of Tools.

For capturing user input (from the Mouse for example), it is no longer necessary to use HopperBins or Tools. Instead, please use these alternatives:

* `ContextActionService`
* `UserInputService`
* `GetMouse` */
interface HopperBin extends RbxInternalBackpackItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HopperBin";
	/** [LACKS DOCUMENTATION] */
	Active: boolean;
	/** [LACKS DOCUMENTATION] */
	BinType: Enum.BinType;
	/** [LACKS DOCUMENTATION] */
	readonly Deselected: RBXScriptSignal<() => void>;
	/** [LACKS DOCUMENTATION] */
	readonly Selected: RBXScriptSignal<(mouse: Instance) => void>;
}

interface RbxInternalDerivesFromTool extends RbxInternalBackpackItem {
	/** If true, when the backspace button is pressed the tool will be parented to the workspace and removed from the player's backpack. If false, when the backspace button is pressed the tool will go back to the Player's Backpack. */
	CanBeDropped: boolean;
	/** Relates to whether or not the tool can be used. */
	Enabled: boolean;
	/** Stores the Tool's Grip properties as one CFrame. */
	Grip: CFrame;
	/** One of the properties that specifies a Tool's orientation in a character's hand. This represents the R02, R12, and R22 values of the Grip CFrame's rotation matrix. */
	GripForward: Vector3;
	/** The positional offset of a Tool weld matrix. */
	GripPos: Vector3;
	/** One of the properties that specifies a Tool's orientation in a character's hand. This represents the R00, R10, and R20 values of the Grip CFrame's rotation matrix. */
	GripRight: Vector3;
	/** One of the properties that specifies a Tool's orientation in a character's hand. This represents the R01, R11, and R21 values of the Grip CFrame's rotation matrix. */
	GripUp: Vector3;
	/** When set to true, the tool will only fire `Activated` when `Activate` is called. This also suppresses the `ContextActionService`'s `BindActivate` function.

When set to false, mouse clicks (when the tool is equipped) will also fire `Activated`. */
	ManualActivationOnly: boolean;
	/** If set to false the tool will function without a handle. */
	RequiresHandle: boolean;
	/** This property controls the message that will be displayed when the player's mouse is hovering over the tool in their backpack. */
	ToolTip: string;
	/** Simulates a click on a Tool. Tool must be equipped. */
	Activate(): void;
	/** The event simulates the deactivation of a [Tool](https://developer.roblox.com/api-reference/class/Tool "Tool")
. Tools will normally trigger the `Deactivated` event when the player releases the left mouse button, while the tool is equipped.

## Code Samples

### Tool:Deactivate

The below code is intended to be inserted into a script within a Tool. The script will deactivate the tool when the user presses the x key, while the tool is equipped. The script also changes the handle's color when the tool is deactivated.
```lua
local ContextActionService = game:GetService("ContextActionService")
local tool = script.Parent
 
-- Gives Handle within Tool a random BrickColor
local function toolDeactivated()
	tool.Handle.BrickColor = BrickColor.Random()
end
 
-- Deactivates the tool when any key is pressed down
local function keyPressed(actionName, actionInputState, actionInputObject)	
	if actionInputState == Enum.UserInputState.Begin then
		tool:Deactivate()
	end
end
 
tool.Deactivated:Connect(toolDeactivated)
ContextActionService:BindAction("deactivateTool", keyPressed, true, "x")
```
 */
	Deactivate(): void;
	/** Fired when the player clicks while a tool is equipped.

## Code Samples

### Tool.Activated

The below code, when ran in a test mode with Player1 present, would create a tool in the player's backpack. It will print "Tool activated" when the player clicks while the created tool is equipped.
```lua

local tool = Instance.new("Tool")
tool.Parent = game.Players.Player1.Backpack
 
function onActivation()
    print("Tool activated")
end
 
tool.Activated:Connect(onActivation)

```
 */
	readonly Activated: RBXScriptSignal<() => void>;
	/** Fired when the left mouse button is released.

## Code Samples

### Tool.Deactivated

The below code, when ran in a test mode with Player1 present, would create a tool in the player's backpack. It will print "Tool deactivated" when the player releases the left mouse button, while the tool is equipped.
```lua

local tool = Instance.new("Tool")
tool.Parent = game.Players.Player.Backpack
 
function toolDeactivated()
    print("Tool deactivated")
end
 
tool.Deactivated:Connect(toolDeactivated)

```
 */
	readonly Deactivated: RBXScriptSignal<() => void>;
	/** Fired when the tool is equipped.

## Code Samples

### Print when a Player Equips a Tool

The example shown below will print "A tool was equipped" each time the tool is equipped by the player. Please note that the below example assumes that you've already defined what "Tool" is.
```lua
Tool.Equipped:Connect(function(mouse)
    print("A tool was equipped")
end)
```
 */
	readonly Equipped: RBXScriptSignal<(mouse: Mouse) => void>;
	/** The Unequipped event fires when a player unequips a `Tool` by putting in back in their `Backpack`. This event can be used to determine when a player stops using and puts a tool away.

The opposite of this event, `Equipped`, can be used alongside this event to determine when a player takes a tool out of their backpack to use.

The example shown below will print "A tool was unequipped" each time the tool is unequipped by the player. Please note that the below example assumes that you've already defined what "Tool" is.

```lua
Tool.Unequipped:Connect(function()
	print("The tool was unequipped")
end)
```

## Code Samples

### Player Fly Tool

The code below demonstrates the functionality of several `Tool` events, including `Activated`, `Deactivated`, and `Unequipped`.

The code, when placed in a `LocalScript` in the `StarterPlayer`.`StarterCharacterScripts` folder inserts and controls a tool in the `LocalPlayer's` `Backpack` that allows the player to fly through the sky when used.

In order to ensure that the player stops flying when the player unequips the tool, the code uses the tool's Unequipped event to turn set the `fly` boolean to true and turn stop flying until the tool is reequipped and activated again.
```lua
-- ========================================
-- GLOBAL VARIABLES
-- ========================================
local power = 30
wait() 
local tool = nil

local bpos = Instance.new("BodyPosition") 
local gyro = Instance.new("BodyGyro") 

local fly = false 

local player = game.Players.LocalPlayer 

local character = player.Character
if not character or not character.Parent then
    character = player.CharacterAdded:wait()
end

local char = character:FindFirstChild("UpperTorso")
if not char then char = character:FindFirstChild("Torso") end

local mouse = game.Players.LocalPlayer:GetMouse()
-- ========================================
-- ========================================


-- ========================================
-- SETUP FUNCTION
-- ========================================

-- Create a new tool and place it in the local player's backpack
-- Make this script a child of the tool, script controls flying
local function setupTool()
	tool = Instance.new("Tool")
	tool.Name = "Fly"
	tool.RequiresHandle = false
	tool.Parent = game.Players.LocalPlayer.Backpack
	
	gyro.maxTorque = Vector3.new(math.huge,math.huge,math.huge) 
	bpos.maxForce = Vector3.new(math.huge,math.huge,math.huge)
	
	script.Parent = tool
	
	tool.Parent = game.Players.LocalPlayer.Backpack
end

setupTool()
-- ========================================
-- ========================================


-- ========================================
-- FLY FUNCTIONS
-- ========================================

-- Start flying when player uses tool
function onSelected() 	
	bpos.Parent = char 
	bpos.position = char.Position + Vector3.new(0,10,0) 
	gyro.Parent = char 
	
	character.Humanoid.PlatformStand = true 

	for i, v in ipairs(char:GetChildren()) do 
		if v.className == "Motor" then 
			v.MaxVelocity = 0 
			v.CurrentAngle = -1 
			if v.Name == "Left Hip" then 
				v.CurrentAngle = 1 
			end 
		end 
	end
	
	fly = true 
	wait()
	while fly do
		local pos = mouse.Hit.p
		gyro.CFrame = CFrame.new(char.Position,pos) * CFrame.fromEulerAnglesXYZ(-3.14/2,0,0) 
		bpos.Position = char.Position + (pos-char.Position).unit * power 
		wait()
	end 
end 

-- Stop flying when player stops using tool
function onDeselected() 
	gyro.Parent = nil 
	fly = false 
 
	character.Humanoid.PlatformStand = false 
	
	for i, v in ipairs(char:GetChildren()) do 
		if v.className == "Motor" then 
			v.MaxVelocity = 1 
		end 
	end

	bpos.Parent = nil 
end 

tool.Unequipped:Connect(function() fly = false end)

tool.Activated:Connect(onSelected) 
tool.Deactivated:Connect(onDeselected)
-- ========================================
-- ========================================
```
 */
	readonly Unequipped: RBXScriptSignal<() => void>;
}
/** Tools are objects that a Humanoid object can equip. For players, they are stored in a Backpack object parented to a Player object. In-game, players may have multiple tools which appear as icons at the bottom of the screen. Equipping a tool moves it from the Backpack and into a player's character model in the Workspace. By default, tools are held in the right hand and have a handle in them, which is a Part named "Handle" inside (though one is not required if RequiresHandle is off). Tools that are to be provided to (re)spawning players ought to be stored in the StarterPack.

On desktop, pressing a number key (1, 2, 3...) will equip a tool. Equipped tools can be dropped into the Workspace by pressing Backspace. It's recommended that you turn CanBeDropped off so it is not possible to drop a tool, die, respawn and drop again to duplicate tools. On gamepads, LB and RB buttons will equip tools. You can disable activation via left click (or right trigger on gamepad) by setting ManualActivationOnly on. Doing so requires that you call Activate yourself through some sort of other user input.

Tools are not the only way to capture user input. You can also use ContextActionService, UserInputService or GetMouse. If you need a Tool to have multiple actions, such as pressing a key while the Tool is equipped, you should use ContextActionService's BindAction and UnbindAction in the Equipped and Unequipped events, respectively. Use a LocalScript send these actions to the server via a RemoteFunction inside the Tool.

## Code Samples

### Sword Tool Example

This code sample is for a Tool object with a Part named Handle. It detects when Humanoids other than the current holder hit the handle, and deals some damage to them. In addition, when the Tool is activated, it triggers a slash animation in the default character animation scripts. Try out this script by creating a Tool object in the StarterPack. Put a Part inside it, and name it Handle. Paste this code into a Script inside the Tool, then try slashing at another Humanoid!
```lua
    local tool = script.Parent
    
    local function onTouch(partOther)
    	-- First, try to see if the part we touched was part of a Humanoid
    	local humanOther = partOther.Parent:FindFirstChild("Humanoid")
    	-- Ignore touches by non-humanoids
    	if not humanOther then return end
    	
    	-- Ignore touches by the Humanoid carrying the sword 
    	if humanOther.Parent == tool.Parent then return end
    	
    	-- Deal some damage
    	humanOther:TakeDamage(5)
    end
    
    -- Trigger a slash animation
    local function slash()
    	-- Default character scripts will listen for a "toolanim" StringValue
    	local str = Instance.new("StringValue")
    	str.Name = "toolanim"
    	str.Value = "Slash" -- try also: Lunge
    	str.Parent = tool
    end
    
    -- Connect events
    tool.Activated:Connect(slash)
    tool.Handle.Touched:Connect(onTouch)
```
 */
interface Tool extends RbxInternalDerivesFromTool {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Tool";
}


/** The Flag is a unit spawned with a `FlagStand` object, and will respawn when captured.

When a player touches this object's Handle, which must be a child of the Flag object, which is a Part named "Handle", the flag will be added to the player's backpack and will appear in their hand. A player cannot select other weapons while carrying a flag, and can drop the flag at anytime by pressing "Backspace" on the keyboard.

If the player carrying a flag steps onto another FlagStand of a different team color, the flag will be removed from the player's backpack and a point will be added to the user's [leaderstats](https://developer.roblox.com/articles/Leaderboards)
, if provided. The flag will then regenerate at the originating flag stand.

This allows for 'Capture the Flag' to be made games very easily, which was the reason for its creation. */
interface Flag extends RbxInternalDerivesFromTool {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Flag";
	/** The `Team` this flag is for. Corresponds with the TeamColors in the `Teams` service. */
	TeamColor: BrickColor;
}

/** This is the BadgeService class that provides information on badges. Badges are used within games and across the platform to track a player's achievements and activity.

You can create and edit badges for your games directly from the website, and award them to players for in-game activities and achievements such as playtime, high scores and kill streaks, as well as more novelty badges such as for *meeting the creator*. Upon earning a badge, it is added to their inventory and displayed on their profile page.

Many of the service's functions, such as `GetBadgeInfoAsync` and `UserHasBadgeAsync` fire asynchronously - returning once they receive a response as your script continues to execute.

You can also check if a player already earned a badge using `AwardBadge`. Besides determining ownership to check if a badge needs to be awarded, you can also use badge ownership as a requirement for in-game features .

## Code Samples

### Awarding a Badge

This code sample includes a simple function for awarding a badge.
```lua
    local BadgeService = game:GetService("BadgeService")
    
    local function awardBadge(player, badgeId)
    	-- check badge can be awarded
    	if BadgeService:IsLegal(badgeId) and not BadgeService:IsDisabled(badgeId) then
    		-- award badge
    		BadgeService:AwardBadge(player.UserId, badgeId)
    	end
    end


```

### Met the Creator Badge

The following code sample gives an example of a 'met the creator' badge system. This script will award a specified badge (BADGE_ID) to anyone who is in a server at the same time as the user associated with OWNER_ID.
```lua
    local BadgeService = game:GetService("BadgeService")
    local Players = game:GetService("Players")
    
    -- change these
    local OWNER_ID = 212423 -- can use game.CreatorId for published places
    local BADGE_ID = 1
    
    local ownerInGame = false
    
    local function playerAdded(newPlayer)
    	if newPlayer.UserId == OWNER_ID then
    		-- if new player is the owner, set ownerInGame to true and give everyone the badge
    		ownerInGame = true
    		for _, player in pairs(Players:GetPlayers()) do
    			-- don't award the owner
    			if player ~= newPlayer then
    				BadgeService:AwardBadge(player.UserId, BADGE_ID)
    			end
    		end
    	elseif ownerInGame then 
    		-- if the owner is in the game, award the badge
    		BadgeService:AwardBadge(newPlayer.UserId, BADGE_ID)
    	end
    end
    
    local function playerRemoving(oldPlayer)
    	if oldPlayer.UserId == OWNER_ID then
    		-- set ownerInGame to false
    		ownerInGame = false 
    	end
    end
    
    -- listen for players joining and leaving
    Players.PlayerAdded:Connect(playerAdded)
    Players.PlayerRemoving:Connect(playerRemoving)
    
    -- fire playerAdded for existing players
    for _, player in pairs(Players:GetPlayers()) do
    	playerAdded(player)
    end


```

### Get Badge Info Asynchronously

This code sample prints information about a badge fetched using `GetBadgeInfoAsync`.
```lua
local BadgeService = game:GetService("BadgeService")

-- Fetch information (this will take a brief moment)
local info = BadgeService:GetBadgeInfoAsync(2124421311)

-- Print the information we just fetched
print("Badge: " .. info.Name)
print("Description: " .. info.Description)
print("Icon: rbxassetid://" .. info.IconImageId)
if info.IsEnabled then
	print("Badge is enabled")
else
	print("Badge is disabled")
end
```
 */
interface BadgeService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BadgeService";
	/** AwardBadge will grant a player a badge given a `Player`'s `UserId` and a badge ID. In order to successfully award a badge, the following criteria must be met:

 - The player must be presently connected to the game.
 - The player must not already have the badge.*
 - Badges must be awarded on the server, i.e. from a `Script` or `ModuleScript` eventually required by a `Script`, instead of a `LocalScript`
 - Only Roblox game servers may award badges, i.e. badges cannot be awarded in Studio.
 - The badge must be awarded in a place that is part of the game associated with the badge (checked using `IsLegal`)
 - The owner of the place must also own the badge, i.e. the owner must not have deleted the badge.
 - The owner of the badge must be subscribed to Builders Club
 - The badge must not have been disabled (checked using `IsDisabled`).

A player may delete an awarded badge from their inventory and be awarded the badge again.

## See also
 - `GetBadgeInfoAsync`
 - `AwardBadge`
 - `UserHasBadgeAsync`

## Code Samples

### Awarding a Badge

This code sample includes a simple function for awarding a badge.
```lua
    local BadgeService = game:GetService("BadgeService")
    
    local function awardBadge(player, badgeId)
    	-- check badge can be awarded
    	if BadgeService:IsLegal(badgeId) and not BadgeService:IsDisabled(badgeId) then
    		-- award badge
    		BadgeService:AwardBadge(player.UserId, badgeId)
    	end
    end


```

### Met the Creator Badge

The following code sample gives an example of a 'met the creator' badge system. This script will award a specified badge (BADGE_ID) to anyone who is in a server at the same time as the user associated with OWNER_ID.
```lua
    local BadgeService = game:GetService("BadgeService")
    local Players = game:GetService("Players")
    
    -- change these
    local OWNER_ID = 212423 -- can use game.CreatorId for published places
    local BADGE_ID = 1
    
    local ownerInGame = false
    
    local function playerAdded(newPlayer)
    	if newPlayer.UserId == OWNER_ID then
    		-- if new player is the owner, set ownerInGame to true and give everyone the badge
    		ownerInGame = true
    		for _, player in pairs(Players:GetPlayers()) do
    			-- don't award the owner
    			if player ~= newPlayer then
    				BadgeService:AwardBadge(player.UserId, BADGE_ID)
    			end
    		end
    	elseif ownerInGame then 
    		-- if the owner is in the game, award the badge
    		BadgeService:AwardBadge(newPlayer.UserId, BADGE_ID)
    	end
    end
    
    local function playerRemoving(oldPlayer)
    	if oldPlayer.UserId == OWNER_ID then
    		-- set ownerInGame to false
    		ownerInGame = false 
    	end
    end
    
    -- listen for players joining and leaving
    Players.PlayerAdded:Connect(playerAdded)
    Players.PlayerRemoving:Connect(playerRemoving)
    
    -- fire playerAdded for existing players
    for _, player in pairs(Players:GetPlayers()) do
    	playerAdded(player)
    end


```

@param userId The `Player/UserId` of the user the badge is to be awarded to
@param badgeId The ID of the badge to be awarded
@returns True if the badge was rewarded successfully.  */
	/** @rbxts server */
	AwardBadge(userId: number, badgeId: number): boolean;
	/** This function fteches information about a badge given its ID. It takes a brief moment to load the information from the Roblox website; repeated calls will cache for a short duration. It returns a dictionary with the following fields:

| Key | Type | Description |
| --- | --- | --- |
| `Name` | string | The name of the badge. |
| `Description` | string | The description of the badge. |
| `IconImageId` | int64 | The asset ID of the image for this badge. |
| `IsEnabled` | bool | Indicates whether this badge is available to be awarded. |


## See also
 - `AwardBadge`
 - `UserHasBadgeAsync`

## Code Samples

### Get Badge Info Asynchronously

This code sample prints information about a badge fetched using `GetBadgeInfoAsync`.
```lua
local BadgeService = game:GetService("BadgeService")

-- Fetch information (this will take a brief moment)
local info = BadgeService:GetBadgeInfoAsync(2124421311)

-- Print the information we just fetched
print("Badge: " .. info.Name)
print("Description: " .. info.Description)
print("Icon: rbxassetid://" .. info.IconImageId)
if info.IsEnabled then
	print("Badge is enabled")
else
	print("Badge is disabled")
end
```

@param badgeId The badgeId of the badge whose information shall be fetched.
@returns A dictionary of information about the specified badge. */
	/** @rbxts server */
	GetBadgeInfoAsync(badgeId: number): BadgeInfo;
	/** UserHasBadgeAsync checks whether a player owns a badge given the `Player`'s `UserId` and the badge's id. Such a query can only be made under the following conditions:

  - This function must be called from the server, i.e. in a `Script` or `ModuleScript` eventually required by a Script.
  - The player in question must be present in the server.

Any badge for any game can be queried, no matter who created the badge or which game it is used for. There are a number of applications of UserHasBadge:

 - A restricted door that can only be opened by players who own a badge (see code sample)
 - A basic way of determining if a player has played another game
 - Very simple progress saving. However, it is recommended developers use `DataStoreService` for saving as it is more scale-able and robust (remember - players can delete their own badges). 

## See also
 - `GetBadgeInfoAsync`
 - `AwardBadge`

## Code Samples

### Creating a Badge Restricted Door

This code sample creates a restricted door in the Workspace that can only be used by players who own the badge associated with BADGE_ID.
```lua
    local Players = game:GetService("Players")
    local BadgeService = game:GetService("BadgeService")
    
    local BADGE_ID = 1 -- change this
    
    -- create a door part
    local door = Instance.new("Part")
    door.Anchored = true 
    door.Size = Vector3.new(7, 10, 1)
    door.Position = Vector3.new(0, 5, 0)
    door.Parent = game.Workspace
    
    local debounce = false 
    
local function hit()
    	if not debounce then
    		debounce = true
    		if hit then
    			local player = Players:GetPlayerFromCharacter(hit.Parent)
    			-- if player exists and owns the badge
    			if player and BadgeService:UserHasBadgeAsync(player.UserId, BADGE_ID) then
    				-- open the door
    				door.Transparency = 0.5
    				door.CanCollide = false 
    				-- wait
    				wait(3)
    				-- close the door
    				door.Transparency = 0
    				door.CanCollide = true
    			end
    		end
    		-- cooldown
    		wait(0.5)
    		debounce = false
    	end
    end

door.Touched:Connect(hit)
```

@param userId The UserId of the Player who will be checked for ownership of the specified badge.
@param badgeId The badgeId of the badge whose ownership will be checked.
@returns A bool indicating if the specified user has the specified badge. */
	/** @rbxts server */
	UserHasBadgeAsync(userId: number, badgeId: number): boolean;
}

interface RbxInternalBasePlayerGui extends RbxInternalInstance {
	/** This function takes a screen position and returns a list of all the visible `GuiObjects` that are occupying that screen position.

The main use case is to get GUI objects under the player’s `Mouse` or touch inputs to do things like allow selection or highlighting. These effects can already be achieved using `MouseEnter` and `MouseLeave` but this requires the developer to track these events for their UI objects all the time even if they only need this functionality in specific circumstances.

Since the child classes of `BasePlayerGui` inherit this function, it can be fired by class objects such as the `PlayerGui` and `StarterGui` folders.

## Code Samples

### Selecting GUIs at a Position

All GUIs returned by GetGuiObjectsAtPosition() at ‘cloned’ by the highlighAsFrame() local function which creates a `Frame` GUI positioned on top of the specified GUI that is semi-transparent and the same `AbsoluteSize` and `AbsolutePosition`. 

These highlights are added to the HighlightsContainer `ScreenGui` in the Highlight folder of the player’s PlayerGui folder. Both are created by the code sample. All highlight GUIs are `Removed` when every time highlightGui() executes.

Note that HighlightContainer’s `DisplayOrder` is 99999, a large number, so that it is unlikely any other GUI will render on top of the higlight GUIs.
```lua
local UserInputService = game:GetService("UserInputService")

-- Get the LocalPlayer’s PlayerGui folder
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")

-- Create a Folder and ScreenGui to contain the highlight Frames
local Highlights = Instance.new("Folder")
Highlights.Name = "Highlights"
Highlights.Parent = PlayerGui
local HighlightsContainer = Instance.new("ScreenGui")
HighlightsContainer.Name = "Container"
HighlightsContainer.Parent = Highlights
HighlightsContainer.DisplayOrder = 99999

-- Deletes all GUIs in HighlightsContainer
local function deleteHighlights()
	local highlights = HighlightsContainer:GetChildren()
	
	for _, highlight in pairs (highlights) do
		highlight:Remove()
	end
end

-- Creates a semi-transparent yellow Frame on top of the gui with the same AbsoluteSize and AbsolutePosition
local function highlightAsFrame(gui)
	local highlight = Instance.new("Frame")
	highlight.Name = "Highlight"
	highlight.Parent = HighlightsContainer
	highlight.Size = UDim2.new(0, gui.AbsoluteSize.X, 0, gui.AbsoluteSize.Y)
	highlight.Position = UDim2.new(0, gui.AbsolutePosition.X, 0, gui.AbsolutePosition.Y)
	highlight.BackgroundColor3 = Color3.new(255/255, 255/255, 10/255) -- Yellow
	highlight.BackgroundTransparency = 0.75
	highlight.BorderSizePixel = 0
	highlight.LayoutOrder = gui.LayoutOrder -1
end

-- Use GetGuiObjectsAtPosition to get and highlight all GuiObjects at the input’s position
local function highlightGui(input, gameProcessed)
	local pos = input.Position
	local guisAtPosition = PlayerGui:GetGuiObjectsAtPosition(pos.X, pos.Y)
	
	deleteHighlights()
	
	for _, gui in pairs(guisAtPosition) do
		if gui:IsA("GuiButton") then
			local highlight = gui:Clone()
			highlightAsFrame(gui)
		end
	end
end

-- Fire highlightGui on InputBegan if input is of type MouseButton1 of Touch
local function InputBegan(input, gameProcessed)
	local inputType = input.UserInputType
	local touch = Enum.UserInputType.Touch
	local mouse1 = Enum.UserInputType.MouseButton1
	if inputType == touch or inputType == mouse1 then
		highlightGui(input, gameProcessed)
	end
end

UserInputService.InputBegan:Connect(InputBegan)
```

@param x The x position on the screen relative to the top left corner after the `GuiService/GuiInset|GuiInset` is applied
@param y The y position on the screen relative to the top left corner after the `GuiService/GuiInset|GuiInset` is applied
@returns A table of the visible `GuiObject|GuiObjects` that occupy the given screen space */
	GetGuiObjectsAtPosition(x: number, y: number): Array<Instance>;
}
/** The BasePlayerGui is an abstract class that all GUI drawing storage classes inherit from. */
type BasePlayerGui = CoreGui | PlayerGui | StarterGui;

/** The CoreGui is a service used to store Guis created in-game by Roblox for the core user interface found in every game (such as the game menu, the playerlist, the backpack, etc.). It can also be used by `Plugins` in Roblox Studio.

You can use the `SetCoreGuiEnabled` and `GetCoreGuiEnabled` methods in a `LocalScript` to enable and disable most elements of the CoreGui. You can also use `SetTopbarTransparency` to set the transparency of the top bar. */
interface CoreGui extends RbxInternalBasePlayerGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CoreGui";
	/** The current version of the CoreGui. Everytime the CoreGui is majorly changed, this number is increased.The current version of the CoreGui. Everytime the CoreGui is majorly changed, this number is increased.

Tags: ReadOnly, NotReplicated */
	readonly Version: number;
}

/** The PlayerGui object is a container that holds a `Player`'s user GUI. If a `ScreenGui` is a descendant of a PlayerGui, then any `GuiObject` inside of the ScreenGui will be drawn to the player's screen. Any `LocalScript` will run as soon as it is inserted into a PlayerGui.


When a player first joins a game, their PlayerGui is automatically inserted into their `Player` object. When the player's `Character` spawns for the first time all of the contents of `StarterGui` are automatically copied into the player's PlayerGui. Note that if `CharacterAutoLoads` is set to false the character will not spawn and StarterGui contents will not be copied until `LoadCharacter` is called. If `ResetPlayerGuiOnSpawn` is set to true then every time the player's character respawns all of the contents of that player's PlayerGui is cleared and replaced with the contents of StarterGui.

```lua
-- Accessing PlayerGui from a LocalScript:
game:GetService('Players').LocalPlayer:WaitForChild('PlayerGui')
``` */
interface PlayerGui extends RbxInternalBasePlayerGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PlayerGui";
	/** Describes the user's current screen orientation. */
	readonly CurrentScreenOrientation: Enum.ScreenOrientation;
	/** Sets the preferred screen orientation mode for this user, if the user is on a mobile device. */
	ScreenOrientation: Enum.ScreenOrientation;
	/** Overrides the default selection adornment (used for gamepads). For best results, this should point to a GuiObject. */
	SelectionImageObject?: GuiObject;
	/** Returns the transparency of the Topbar.

## Code Samples

### PlayerGui:GetTopbarTransparency

The following line of code prints the transparency of the topbar.
```lua
print(game:GetService('Players').LocalPlayer:WaitForChild('PlayerGui'):GetTopbarTransparency())
```
 */
	GetTopbarTransparency(): number;
	/** SetTopbarTransparency sets the transparency of the Topbar CoreGui. A value of 0 is completely opaque, and a value of 1 is completely transparent. Values outside of the range [0, 1] are clamped. The default transparency of the topbar is 0.5. The current transparency can be retrieved using the similarly-named `GetTopbarTransparency` function.

## Comparison of Values
The screenshots below show the topbar at 1.0, 0.5 and 0.0 transparency.

![The TopBar with a transparency of 1.0 (completely hidden)](https://developer.roblox.com/assets/5c2a51f2ad2d87331bc45024/Topbar_Transparency_1.0.png)
&nbsp;![The TopBar with a transparency of 0.5 (50% transparency)](https://developer.roblox.com/assets/5c2a5257ac4084cd1b196622/Topbar_Transparency_0.5.png)
&nbsp;![The TopBar with a transparency of 0.0 (completely opaque)](https://developer.roblox.com/assets/5c2a5230be5779ad1a89484d/Topbar_Transparency_0.png)


## Usage
This method is often used when re-styling the topbar to match the visual aesthetic of a game. By hiding the topbar, you can create your own custom topbar. See the code samples for an example.

## Alternative
Using the `SetCore` method with the `TopbarEnabled` option allows you to enable/disable the entire topbar and all of its features (player list, health, etc). By contrast, this method only affects how the topbar is displayed.

## Code Samples

### Custom Topbar Style

This code sample demonstrates how you can create a custom-styled topbar. Paste it into a `LocalScript` placed within `StarterPlayerScripts`. First, hide the default topbar by setting its transparency to 1 (using `SetTopbarTransparency`). Then, recreate the topbar `Frame` and parent it to a `ScreenGui`. Set the styles on the Frame to your liking, such as `BackgroundColor3` or `BackgroundTransparency`.  Below is a screenshot of what the topbar will look like after this code sample is run.

![The Topbar customized to appear dark blue](https://developer.roblox.com/assets/5c2a584cf1cdabd21bb517ed/Topbar_Custom.png)
```lua
-- Custom topbar style
local TOPBAR_COLOR = Color3.fromRGB(0, 0, 127)
local TOPBAR_TRANSPARENCY = 0

local playerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")

-- Hide the topbar
playerGui:SetTopbarTransparency(1)

-- Create a "Fake" replacement topbar with a ScreenGui and Frame
local screenGui = Instance.new("ScreenGui")
local frame = Instance.new("Frame")

-- Move (0, 0) to the actual top left corner of the screen, instead of under the topbar
screenGui.IgnoreGuiInset = true
-- The topbar is 36 pixels tall, and spans the entire width of the screen
frame.Size = UDim2.new(1, 0, 0, 36) 
-- Style the topbar
frame.BackgroundColor3 = TOPBAR_COLOR
frame.BackgroundTransparency = TOPBAR_TRANSPARENCY
frame.BorderSizePixel = 0

frame.Parent = screenGui
screenGui.Parent = playerGui
```

### PlayerGui:SetTopbarTransparency

The following line of code makes the Topbar appear fully opaque.
```lua
game:GetService('Players').LocalPlayer:WaitForChild('PlayerGui'):SetTopbarTransparency(0)
```
 */
	SetTopbarTransparency(transparency: number): void;
	/** Fires when the transparency of the Topbar CoreGui changes.

## Code Samples

### PlayerGui.TopbarTransparencyChangedSignal1

The below example prints out the value of the topbar transparency when it changes.
```lua

local playerGui = game.Players.LocalPlayer:WaitForChild('PlayerGui')
playerGui.TopbarTransparencyChangedSignal:Connect(function(topbarTransparency)
   print("The topbar transparency is now:" , topbarTransparency)
end)


```
 */
	readonly TopbarTransparencyChangedSignal: RBXScriptSignal<(transparency: number) => void>;
}

/** The StarterGui service is a container object designed to hold `GUI objects` such as `ScreenGuis`. 

## StarterGui as a container

When a `Players’` `character` respawns, the contents of their `PlayerGui` is emptied. Children of the `StarterGui` are then copied (along with their descendants) into the `StarterGui`. 

`GUI objects` such as `ScreenGuis` with their `ResetOnSpawn` property set to false will only be placed into each `Player’s` `PlayerGui` once and will not be deleted when the `Player` respawns.

## StarterGui as an interface

The StarterGui also includes a range of functions allowing you to interact with the `CoreGui`. For example `SetCoreGuiEnabled` can be used to disable elements of the `CoreGui`. `SetCore` can perform a range of functions including creating notifications and system messages. */
interface StarterGui extends RbxInternalBasePlayerGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StarterGui";
	/** This property sets the preferred orientation mode for users with mobile devices. For the different modes available, see `ScreenOrientation`.

When a `Player` joins the game, if they are using a mobile device, this property will determine the device’s starting orientation. `ScreenOrientation` will be set to this value for `Players` joining the game. For example, the following code would set the default to *‘Portrait’*:

```lua
game:GetService("StarterGui").ScreenOrientation = Enum.ScreenOrientation.Portrait
```
 

By default, this property is set to *‘LandscapeSensor’*, meaning the viewport will rotate so it is always right-side-up in landscape. 

Changing this property will not change the `ScreenOrientation` for `Players` already in the game. To change the orientation for an existing player use their `ScreenOrientation` property. 

You can also get the current screen orientation for a user’s device using `CurrentScreenOrientation`. This is useful when using the ‘sensor’ `ScreenOrientation` settings.

For more information, please see this article on `Device Orientation for Mobile Roblox device orientation`. */
	ScreenOrientation: Enum.ScreenOrientation;
	/** This property determines whether `GUI objects` descending from the `StarterGui` are visible in Studio’s edit mode.

As this property defaults to true, `ScreenGuis`, `BillboardGuis` and `SurfaceGuis` descending from the `StarterGui` are not hidden.

Setting this property to false will only affect objects not descending from the `StarterGui`. This means `BillboardGuis` and `SurfaceGuis` descending from the `Workspace` will not be hidden. 

This property has no effect outside of Roblox Studio and is intended as a tool to hide the contents of `StarterGui` whilst working in the 3d world.

## Disabling ShowDevelopmentGui by default
You can set this property to be false by default in new places by saving a `Script` with the following code into your local plugins folder.

```lua
print("StarterGui.ShowDevelopmentGui = false") -- a reminder this plugin is active
game:GetService("StarterGui").ShowDevelopmentGui = false
``` */
	ShowDevelopmentGui: boolean;
	/** This function returns whether the given `CoreGuiType` is enabled or if it has been disabled using `SetCoreGuiEnabled`.

This function should be called on the client and is used by the core scripts to help determine which core GUI elements to show.

GetCoreGuiEnabled only returns *false* if the given `CoreGuiType` has been disabled using `SetCoreGuiEnabled`. Setting *TopbarEnabled* to *false* using `SetCore` hides all `CoreGuiTypes` and does not affect the result of function.

## Code Samples

### StarterGui:GetCoreGuiEnabled

The below example would print whether or not the player list is visible to the LocalPlayer.
```lua
print(game.StarterGui:GetCoreGuiEnabled("PlayerList"))
```

@param coreGuiType The given `Enum/CoreGuiType`
@returns Whether the given `Enum/CoreGuiType` is enabled */
	GetCoreGuiEnabled(coreGuiType: CastsToEnum<Enum.CoreGuiType>): boolean;
	/** SetCore (not to be confused with `SetCoreGuiEnabled`) exposes a variety of functionality defined by Roblox's `CoreScripts`, such as sending notifications, toggling notifications for badges/points, defining a callback for the reset button or toggling the topbar. The first parameter to SetCore is a string that selects the functionality with which the call will interact: a CoreScript must have registered such a string already (if one hasn't, an error is raised). It may be necessary to make multiple calls to SetCore using `pcall` in case the respective CoreScript has yet to load (or if it has been disabled entirely).

The following table describes the strings that may be accepted as the first parameter in a call to SetCore. The parameters that should follow are dependent on the functionality that will be used and are described in sub-tables.

## ChatActive
Controls whether the chat is active

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `active` | bool | Required | Determines whether the chat should be made active |

## PointsNotificationsActive
Controls whether notifications for earned player points will appear

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `active` | bool | Required | Determines whether notifications for earned player points will appear |

## BadgeNotificationsActive
Controls whether notifications for earned badges will appear

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `active` | bool | Required | Determines whether notifications for earned badges
will appear |

## ResetButtonCallback
Determines the behavior, if any, of the reset button given a bool or a `BindableEvent` to be `fired` when a player requests to reset.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `enabled` | bool | Required | Determines whether the reset button retains its default behavior |
| OR |
| `callback` | BindableEvent | Required | A BindableEvent to be fired when the player confirms they want to reset |

## ChatMakeSystemMessage
Display a formatted message in the chat.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `configTable` | dictionary | Required | A dictionary of information describing the message (see below) |

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `Text` | string | Required | The message to display |
| `Color` | Color3 | `Color3.fromRGB(255, 255, 243)` | The TextColor3 of the message |
| `Font` | `Enum.Font` |
| `FontSize` | `Enum.FontSize` | `Size24` | The FontSize of the message |

## ChatWindowSize
Determines the `size` of the chat window.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `windowSize` | UDim2 | Required | Determines the size of the chat window |

## ChatWindowPosition
Determines the `position` of the chat window.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `windowPosition` | UDim2 | Required | Determines the position of the chat window |

## ChatBarDisabled
Determines whether the player is able to type a message into the chat.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `disabled` | bool | Required | Determines whether the chat's TextBox input is visible. |

## SendNotification
Causes a non-intrusive notification to appear at the bottom right of the screen. The notification may have up to two buttons.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `configTable` | dictionary | Required | A dictionary of information describing the notification (see below) |

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `Title` | string | Required | The title of the notification |
| `Text` | string | Required | The main text of the notification |
| `Icon` | string | Optional | The image to display with the notification |
| `Duration` | number | 5 | Duration (in seconds) the notification should stay visible |
| `Callback` | BindableFunction | Optional | A BindableFunction that should be invoked with the text of the button pressed by the player. |
| `Button1` | string | Optional | The text to display on the first button |
| `Button2` | string | Optional | The text to display on the second button |

## TopbarEnabled
Determines whether the topbar is displayed. Disabling the topbar will also disable all CoreGuis, such as the chat, inventory and player list (i.e. those set with `SetCoreGuiEnabled`).

When disabled, the region the topbar once occupied will still capture mouse events; however, `buttons` placed there will not respond to `clicks`. The origin of GUI space will still be offset 36 pixels from the top of the screen.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `enabled` | bool | Required | Determines whether the topbar should be visible |

## DeveloperConsoleVisible
Determines whether the Developer Console is visible.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `visibility` | bool | Required | Determines whether the developer console is visible |

## PromptSendFriendRequest
Prompts the current player to send a friend request to the given `Player`.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `player` | Player | Required | The player to which the friend request should be sent |

## PromptUnfriend
Prompts the current player to remove a given `Player` from their friends list.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `player` | Player | Required | The player who should be unfriended |

## PromptBlockPlayer
Prompts the current player to block the given `Player`.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `player` | Player | Required | The player who should be blocked |

## PromptUnblockPlayer
Prompts the current player to unblock the given `Player`.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `player` | Player | Required | The player who should be unblocked |

## AvatarContextMenuEnabled
Determines whether the `Avatar Context Menu#visual-Avatar Context Menu` is enabled.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `enabled` | bool | Required | Determines whether the Avatar Context Menu is enabled |

## AddAvatarContextMenuOption
Adds an option to the `Avatar Context Menu#visual-Avatar Context Menu`.

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `option` | `Enum.AvatarContextMenuOption` | Required | `Friend` (send friend request), `Chat` (start private chat), or `Emote` (wave) |
| OR |
| `option` | table | Required | A two-element table, where the first is the name of the custom action, and the second is a BindableEvent which will be fired with a player was selected when the option was activated. |

## RemoveAvatarContextMenuOption
Removes an option to the `Avatar Context Menu#visual-Avatar Context Menu`. The `option` argument must be the same as what was used with **AddAvatarContextMenuOption** (see above).

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| `option` | Variant | Required | The same value provided to **AddAvatarContextMenuOption** |


## AvatarContextMenuTheme
Configures the customizable Avatar Context Menu (ACM) which is an opt-in feature that allows easy player-to-player social interaction via custom actions, such as initiating trades, battles, and more.

For more info on the ACM including how to customize its theme and use it in your game, see the `Avatar Context Menu#visual-Avatar Context Menu` article.

## CoreGuiChatConnections
Sets up a bindable gateway connection between the CoreGui topbar's chat button and the Lua Chat System. The second parameter must be a table of `BindableEvents` and `BindableFunctions`. See the example below for more clarification.

```lua
-- Create the Bindable objects
local ChatConnections = {}
 
local function AddObjects(bindableClass,targetName,...)
	local target = ChatConnections[targetName]
	if not target then
		target = {}
		ChatConnections[targetName] = target
	end
	local names = {...}
	for _,name in pairs(names) do
		local signal = Instance.new(bindableClass)
		signal.Name = targetName .. "_" .. name
		signal.Parent = script
		target[name] = signal
	end
end
 
AddObjects("BindableEvent","ChatWindow",
	---------------------------
	-- Fired from the CoreGui
	---------------------------
	"ToggleVisibility", -- Fired when the CoreGui chat button is pressed.
	"SetVisible", -- Fired when the CoreGui wants to directly change the visiblity state of the chat window.
	"FocusChatBar", -- Fired when the CoreGui wants to capture the Chatbar's Focus.
	"TopbarEnabledChanged", -- Fired when the visibility of the Topbar is changed.
	"SpecialKeyPressed", -- Fired when the reserved ChatHotkey is pressed.
	"CoreGuiEnabled", -- Fired when a user changes the SetCoreGuiEnabled state of the Chat Gui.
 
	---------------------------
	-- Fired to the CoreGui
	---------------------------
	"ChatBarFocusChanged",
		-- ^ Fire this with 'true' when you want to assure the CoreGui that the ChatBar is being focused on.
 
	"VisibilityStateChanged", 
		-- ^ Fire this with 'true' when the user shows or hides the chat.
 
	"MessagesChanged",
		-- ^ Fire this with a number to change the number of messages that have been recorded by the chat window.
		--   If the CoreGui thinks the chat window isn't visible, it will display the recorded difference between
		--   the number of messages that was displayed when it was visible, and the number you supply.
 
	"MessagePosted" 
		-- ^ Fire this to make the player directly chat under Roblox's C++ API. 
		--	 This will fire the LocalPlayer's Chatted event.
		--   Please only fire this on the player's behalf. If you attempt to spoof a player's chat
		--   to get them in trouble, you could face serious moderation action.
)
 
AddObjects("BindableFunction","ChatWindow",
	"IsFocused" -- This will be invoked by the CoreGui when it wants to check if the chat window is active.
)
 
-- The following events are fired if the user calls StarterGui:SetCore(string name, Variant data)
-- Note that you can only hook onto these ones specifically.
AddObjects("BindableEvent","SetCore",
	"ChatMakeSystemMessage",
	"ChatWindowPosition",
	"ChatWindowSize",
	"ChatBarDisabled"
)
 
-- The following functions are invoked if the user calls StarterGui:GetCore(string name)
-- Note that you can only hook onto these ones specifically.
AddObjects("BindableFunction","GetCore",
	"ChatWindowPosition", -- Should return a UDim2 representing the position of the chat window.
	"ChatWindowSize", -- Should return a UDim2 representing the size of the chat window.
	"ChatBarDisabled" -- Should return true if the chat bar is currently disabled.
)
 
-- Connect ChatConnections to the CoreGui.
local StarterGui = game:GetService("StarterGui")
local tries = 0
local maxAttempts = 10
 
while (tries < maxAttempts) do
 local success,result = pcall(function ()
 StarterGui:SetCore("CoreGuiChatConnections",ChatConnections)
 end)
 if success then
 break
 else
 tries = tries + 1
 if tries == maxAttempts then
 error("Error calling SetCore CoreGuiChatConnections: " .. result)
 else
 wait()
 end
 end
end

while wait(0.2) do
 local isVisible = (math.random() >
 0.5)
	ChatConnections.ChatWindow.VisibilityStateChanged:Fire(isVisible)
	if not isVisible then
		local messageCount = math.random(1,120)
		ChatConnections.ChatWindow.MessagesChanged:Fire(messageCount)
	end
end
```

## Code Samples

### StarterGui Setting Core GUI


```lua
local StarterGui = game:GetService("StarterGui")

StarterGui:SetCore("AvatarContextMenuTheme", { 
	BackgroundImage = "", 
	BackgroundTransparency = 0.5, 
	BackgroundColor = Color3.fromRGB(111, 145, 242),
	NameTagColor = Color3.fromRGB(0, 0, 200),
	NameUnderlineColor = Color3.fromRGB(213, 233, 255),
	ButtonFrameColor = Color3.fromRGB(15, 24, 65), 
	ButtonFrameTransparency = 0.2, 
	ButtonUnderlineColor = Color3.fromRGB(213, 233, 255), 
	Font = Enum.Font.SciFi
})
```

@param parameterName Selects the functionality with which the call will interact: a CoreScript must have registered such a string already (if one hasn't, an error is raised)
@param value A table of `BindableEvent|BindableEvents` and `BindableFunction|BindableFunctions`
@returns No return */
	SetCore(parameterName: "ChatActive", active: boolean): void;
	SetCore(parameterName: "PointsNotificationsActive", active: boolean): void;
	SetCore(parameterName: "BadgeNotificationsActive", active: boolean): void;
	SetCore(parameterName: "ResetButtonCallback", enabled: boolean): void;
	SetCore(parameterName: "ResetButtonCallback", callback: BindableEvent): void;
	SetCore(parameterName: "ChatMakeSystemMessage", configTable: MakeSystemMessageConfig): void;
	SetCore(parameterName: "ChatWindowSize", windowSize: UDim2): void;
	SetCore(parameterName: "ChatWindowPosition", windowPosition: UDim2): void;
	SetCore(parameterName: "ChatBarDisabled", disabled: boolean): void;
	SetCore(parameterName: "SendNotification", configTable: boolean): void;
	SetCore(parameterName: "TopbarEnabled", enabled: boolean): void;
	SetCore(parameterName: "DeveloperConsoleVisible", visibility: boolean): void;
	SetCore(parameterName: "PromptSendFriendRequest", player: Player): void;
	SetCore(parameterName: "PromptUnfriend", player: Player): void;
	SetCore(parameterName: "PromptBlockPlayer", player: Player): void;
	SetCore(parameterName: "PromptUnblockPlayer", player: Player): void;
	SetCore(parameterName: "SetAvatarContextMenuEnabled", enabled: boolean): void;
	SetCore(parameterName: "AddAvatarContextMenuOption", option: CastsToEnum<Enum.AvatarContextMenuOption>): void;
	SetCore(parameterName: "AddAvatarContextMenuOption", option: [string, BindableFunction]): void;
	SetCore(parameterName: "RemoveAvatarContextMenuOption", option: CastsToEnum<Enum.AvatarContextMenuOption>): void;
	SetCore(parameterName: "RemoveAvatarContextMenuOption", option: [string, BindableFunction]): void;
	SetCore(
		parameterName: "CoreGuiChatConnections",
		connections: { [name: string]: BindableEvent | BindableFunction },
	): void;
	/** This function sets whether the `CoreGui` element associated with the given `CoreGuiType` is enabled or disabled.

The top bar can not be disabled using this function. To disable the top bar, set *TopbarEnabled* to *false* using `SetCore`. This will also disable the element associated with all `CoreGuiTypes`.

For more information on how to use this function, see the article on `Disabling Parts of Game disabling the game interface`.

## Code Samples

### StarterGui:SetCoreGuiEnabled

The following line of code would be used to *disable* all optional elements of the `/CoreGui` for the LocalPlayer.
```lua
game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
```

@param coreGuiType The given `Enum/CoreGuiType`
@param enabled Whether to enable or disable the given `Enum/CoreGuiType` */
	SetCoreGuiEnabled(coreGuiType: CastsToEnum<Enum.CoreGuiType>, enabled: boolean): void;
	/** GetCore returns data set or made available by Roblox's `CoreScripts`. The first and only parameter is a string that selects the information to be fetched. The following sections describe the strings and the data they return by this function.

Each of these is registered by a CoreScript and calling this function may yield. Many of these also register an equivalent `SetCore` function (these are marked with an asterisk).

## PointsNotificationsActive*
Returns true if player point notifications are enabled.

## BadgesNotificationsActive*
Returns true if badge notifications are enabled.

## AvatarContextMenuEnabled*
Returns true if the Avatar Context Menu is enabled.

## ChatActive*
Returns whether the chat is active or not. This is indicated by the selection state of the top bar's chat icon.

## ChatWindowSize*
Returns the size of the chat window as a UDim2.

## ChatWindowPosition*
Returns the size of the chat window as a UDim2.

## ChatBarDisabled*
Returns true if the chat bar is disabled.

## GetBlockedUserIds
Returns a list of `UserId`s associated with users that have been blocked by the local player.

## PlayerBlockedEvent
Returns a BindableEvent that is fired whenever a player is blocked by the local player.

## PlayerUnblockedEvent
Returns a BindableEvent that is fired whenever a player is unblocked by the local player.

## PlayerMutedEvent
Returns a BindableEvent that is fired whenever a player is muted by the local player.

## PlayerUnmutedEvent
Returns a BindableEvent that is fired whenever a player is unmuted by the local player.

## PlayerFriendedEvent
Returns a BindableEvent that is fired whenever a player is friended by the local player.

## PlayerUnfriendedEvent
Returns a BindableEvent that is fired whenever a player is unfriended by the local player.

## DeveloperConsoleVisible*
Returns true if the developer console is visible.

## VRRotationIntensity
Returns a string describing the camera rotation sensitivity in VR: `Low`, `High` and `Smooth`. *This will not be available unless `VREnabled` is true.*

## Code Samples

### Using GetCore to Check ChatActive

The following code would check if chat is currently active:
```lua
local StarterGui = game:GetService("StarterGui")

if StarterGui:GetCore("ChatActive") then
	print("Chat is active")
else
	print("Chat is not active")
end
```
 */
	GetCore(parameterName: "PointsNotificationsActive"): boolean;
	GetCore(parameterName: "BadgesNotificationsActive"): boolean;
	GetCore(parameterName: "ChatActive"): boolean;
	GetCore(parameterName: "ChatWindowSize"): UDim2;
	GetCore(parameterName: "ChatWindowPosition"): UDim2;
	GetCore(parameterName: "ChatBarDisabled"): boolean;
	GetCore(parameterName: "GetBlockedUserIds"): Array<number>;
	GetCore(parameterName: "PlayerBlockedEvent"): BindableEvent;
	GetCore(parameterName: "PlayerUnblockedEvent"): BindableEvent;
	GetCore(parameterName: "PlayerMutedEvent"): BindableEvent;
	GetCore(parameterName: "PlayerUnmutedEvent"): BindableEvent;
	GetCore(parameterName: "PlayerFriendedEvent"): BindableEvent;
	GetCore(parameterName: "PlayerUnfriendedEvent"): BindableEvent;
	GetCore(parameterName: "DeveloperConsoleVisible"): boolean;
	GetCore(parameterName: "VRRotationIntensity"): "Low" | "High" | "Smooth";
}

/** A Beam object connects two `Attachment`s by drawing a texture between them.

## Setting up a Beam

To display, beams must be a descendant of the `Workspace` with their `Attachment0` and `Attachment1` properties set to `Attachment`s also descending from the `Workspace`.

The beam's appearance can be customised using the range of properties available. 

## Beam Curvature

Beams are configured to use a cubic [Bézier curve][1]. This means they are not constrained to straight lines, and the curve of the beam can be modified by changing `CurveSize0`, `CurveSize1` and the orientation of the beam's `Attachment`s.

Cubic Bézier curves are formed of four control points. They are determined as follows:

 - **P0**: The start of the beam, the position of `Attachment0`
 - **P1**: `CurveSize0` studs away from `Attachment0`, in `Attachment0`'s positive X direction.
 - **P2**: `CurveSize1` studs away from `Attachment1`, in `Attachment1`'s negative X direction.
 - **P3**: The end of the beam, the position of `Attachment1`

The beam starts at P0, goes towards P1, and arrives at P3, from the direction of P2. The beam will not necessarily pass through P1 and P2.

 See the image below for a visual demonstration.

![Beam Curve](https://developer.roblox.com/assets/5b440a3b46591e820b82a430/BeamCurve1.png)

  [1]: https://en.wikipedia.org/wiki/B%C3%A9zier_curve

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```

### Create a chain of beams between parts

This code sample includes a function that will connect the given `BasePart`s together with `Beam`s.
```lua
local function connectParts(...)
	-- build an array of parts given
	local parts = {...}
	-- make sure there is more than one part
	if #parts > 1 then
		-- create a template beam
		local beam = Instance.new("Beam")
		-- can change beam properties here		
		-- create an initial attachment in the first part	
		local lastAttachment = Instance.new("Attachment", parts[1])
		-- iterate through parts from the second part
		for i = 2, #parts do
			local part = parts[i]
			-- create an attachment in the part
			local nextAttachment = Instance.new("Attachment", part)
			-- hook the beam up
			local newBeam = beam:Clone()
			newBeam.Attachment0 = lastAttachment
			newBeam.Attachment1 = nextAttachment
			newBeam.Parent = lastAttachment
			-- set the last attachment
			lastAttachment = nextAttachment
		end
	end
end
```
 */
interface Beam extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Beam";
	/** The `Attachment` the `Beam` originates from.

A `Beam`'s Attachment0 is the first control point on the `Beam`'s [cubic Bézier curve][1]. The orientation of Attachment0, alongside the `Beam`'s `CurveSize0`, property determine the position of the second control point.

For the `Attachment` where the `Beam` ends see `Attachment1`.

For more information how a `Beam` curves, see `CurveSize0`.

  [1]: https://en.wikipedia.org/wiki/B%C3%A9zier_curve

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	Attachment0?: Attachment;
	/** The `Attachment` the `Beam` ends at.

A `Beam`'s Attachment1 is the fourth and final control point on the `Beam`'s [cubic Bézier curve][1]. The orientation of Attachment1, alongside the `Beam`'s `CurveSize1` property, determine the position of the third control point.

For the `Attachment` where the `Beam` starts see `Attachment0`.

For more information how a `Beam` curves, see `CurveSize1`.

  [1]: https://en.wikipedia.org/wiki/B%C3%A9zier_curve

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	Attachment1?: Attachment;
	/** Determines the color of the `Beam`.

If the `Beam`'s `Texture` is set, this color will be applied to the `Beam`'s texture. If no `Texture` has been set then the `Beam` will appear as a solid bar colored in accordance with this property.

## Beams and ColorSequences
This property is a `ColorSequence`, allowing the color to be configured to vary across the length of the `Beam`. Take for example the following `ColorSequence`.

```lua
local colorSequence = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)), -- red
	ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 0)), -- green
	ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 255)), -- blue
	}
)
```


Applying this `ColorSequence` to a `Beam` would yield the following result:

![enter image description here](https://developer.roblox.com/assets/blt44487f7a1e259ab2/BeamColor.png)

Note the `Beam`'s coloration also depends on the number of `Segments` the `Beam` has. Each segment of the beam can only show a transition between two colors. Therefore a `Beam` will need to have at least n-1 segments in order for the color to display correctly, where n is the number of `ColorSequenceKeypoint`s in the `ColorSequence`

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	Color: ColorSequence;
	/** Determines, along with `Attachment0` the position of the first control point in the Beam's Bézier curve.

The position of this point can be determined by the following equation:

```lua
local controlPoint1 = Beam.Attachment0.WorldPosition + (Beam.Attachment0.CFrame.rightVector * Beam.CurveSize0)
```


## Beam Curvature

Beams are configured to use a cubic [Bézier curve][1]. This means they are not constrained to straight lines, and the curve of the beam can be modified by changing CurveSize0, `CurveSize1` and the orientation of the beam's `Attachment`s.

Cubic Bézier curves are formed of four control points. They are determined as follows:

 - **P0**: The start of the beam, the position of `Attachment0`
 - **P1**: CurveSize0 studs away from `Attachment0`, in `Attachment0`'s positive X direction.
 - **P2**: `CurveSize1` studs away from `Attachment1`, in `Attachment1`'s negative X direction.
 - **P3**: The end of the beam, the position of `Attachment1`

The beam starts at P0, goes towards P1, and arrives at P3, from the direction of P2. The beam will not necessarily pass through P1 and P2.

 See the images below for a visual demonstration.

![BeamCurve1](https://developer.roblox.com/assets/5b440a3b46591e820b82a430/BeamCurve1.png)
![BeamCurve2](https://developer.roblox.com/assets/5b4faa21f80cc8770b8530bb/BeamCurve2.png)


  [1]: https://en.wikipedia.org/wiki/B%C3%A9zier_curve

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	CurveSize0: number;
	/** Determines, along with `Attachment0` the position of the first control point in the Beam's Bézier curve.

The position of this point can be determined by the following equation:

```lua
local controlPoint2 = Beam.Attachment1.WorldPosition - (Beam.Attachment1.CFrame.rightVector * Beam.CurveSize1)
```


## Beam Curvature

Beams are configured to use a cubic [Bézier curve][1]. This means they are not constrained to straight lines, and the curve of the beam can be modified by changing `CurveSize0`, CurveSize1 and the orientation of the beam's `Attachment`s.

Cubic Bézier curves are formed of four control points. They are determined as follows:

 - **P0**: The start of the beam, the position of `Attachment0`
 - **P1**: `CurveSize0` studs away from `Attachment0`, in `Attachment0`'s positive X direction.
 - **P2**: CurveSize1 studs away from `Attachment1`, in `Attachment1`'s negative X direction.
 - **P3**: The end of the beam, the position of `Attachment1`

The beam starts at P0, goes towards P1, and arrives at P3, from the direction of P2. The beam will not necessarily pass through P1 and P2.

 See the images below for a visual demonstration.

![enter image description here](https://developer.roblox.com/assets/5b440a3b46591e820b82a430/BeamCurve1.png)
![enter image description here](https://developer.roblox.com/assets/5b4faa21f80cc8770b8530bb/BeamCurve2.png)


  [1]: https://en.wikipedia.org/wiki/B%C3%A9zier_curve

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	CurveSize1: number;
	/** Determines whether the `Beam` is visible or not.

When this property is set to false, the `Beam`'s `Segments` will not be displayed.

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	Enabled: boolean;
	/** Determines whether the `Segments` of the `Beam` will always face the `CurrentCamera` regardless of its orientation.

A `Beam` has no depth, and is hence a two dimensional projection existing in three dimensional space. This means that, by default, a `Beam` is not visible from every angle.

When FaceCamera is set to true, the `Beam` will always be orientated towards the `CurrentCamera`.

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	FaceCamera: boolean;
	/** Determines to what degree the colors of the `Beam` are blended with the colors behind it.

The LightEmission property determines the blending of the `Beam` with the colors behind it. It should be set in the range [0, 1]. A value of 0 uses normal blending modes, and a value of 1 will use additive blending. The value of the additive blending is determined by this property. 

Pictured below are two sets of overlapping `Beam`s. The right one has its LightEmission set to 1, so the texture appears brighter due to the additive blending on the overlaps.

![enter image description here](https://developer.roblox.com/assets/blta7d562b91fdd7f61/BeamLightEmission.png)

This property should not be confused with `LightInfluence`, which determines how particles are affected by environment light. This property does not cause the `Beam` to light the environment. To do that, consider using a `SurfaceLight`.

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	LightEmission: number;
	/** Determines the degree to which the `Beam` is influenced by the environment's lighting.

LightInfluence is clamped between 0 and 1. When LightInfluence is 0, the `Beam` will be unaffected by the environment's lighting. When LightInfluence is 1 however, it will be fully affected by lighting (as a `BasePart` would be).

For an example of this, and a demonstration of how this property interacts with `LightEmission`, please see the images below.

![enter image description here](https://developer.roblox.com/assets/blt58bbd58122916e57/BeamLight1.png)

![enter image description here](https://developer.roblox.com/assets/blt1d1d4b30144114c3/BeamLight2.png)

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	LightInfluence: number;
	/** Sets how many straight segments the `Beam` is made up of.

This value can be any integer greater than 0. The default value is 10.

## Beam Segments and curvature
Rather than being a perfect curve, a beam is made up of straight segments. The more segments, the higher the resoloution of the curve. See the image below for a demonstration of this:

![enter image description here](https://developer.roblox.com/assets/5b4e0a69d0af7f6e0ba4ae67/BeamSegments.gif)

For more information on how a `Beam` is configured to curve, see the page for `CurveSize0`.

## Beam Segments with Color and Transparency

The `Color` and `Transparency` properties require a certain number of segments to display correctly. This is because each segment can only show a transition between two colors or transparencies. Therefore a `Beam` requires at least n-1 segments to display correctly, where n is the number of keypoint associated with the `Beam`'s `Color` and `Transparency`.

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	Segments: number;
	/** The content ID of the texture to be displayed on the `Beam`.

If the Texture property of the beam is not set the beam will be displayed as a solid line. This also occurs when the texture is set to an invalid content ID or the image associated with the texture has not yet loaded.

The appearance of the texture can be further modified by other `Beam` properties including `Color` and `Transparency`.

The scaling of the texture is determined by the `TextureMode`, `TextureLength`, `Width0` and `Width1` properties.

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	Texture: string;
	/** Sets the length of the `Beam`s texture if `TextureMode` is 'Wrap' or 'Static'. If `TextureMode` is 'Stretch' then it determines the size of the texture relative to the `Beam`'s length.

## Beam texture behavior 

How a `Beam's` texture scales or repeats is dependent on the `TextureMode` property.

When `TextureMode` is 'Wrap' the size of the repeating texture is equal to TextureLength in studs. For an example of this see the image below:

![beamTexture1](https://developer.roblox.com/assets/blt92742bad209f4935/beamTexture.gif)

Note, the 'Static' `TextureMode` type is not used for `Beam`s and therefore behaves identically to 'Wrap'.

When `TextureMode` is set to 'Stretch' however the texture will be stretched relative to the beam's length. The size of the texture relative to the `Beam`'s length will be one over the TextureLength. In practice, this means the texture will repeat TextureLength times. For an example of this see the image below:

![beamTexture2](https://developer.roblox.com/assets/blt034506939f5674b3/beamTexture2.gif)

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	TextureLength: number;
	/** Determines the manner in which the `Texture` scales and repeats.

## Beam texture behavior 

How a `Beam`'s texture scales or repeats is dependent on the TextureMode property.

When TextureMode is 'Wrap' the size of the repeating texture corresponds to `TextureLength` in studs. For an example of this see the image below:

![enter image description here](https://developer.roblox.com/assets/blt92742bad209f4935/beamTexture.gif)

Note, the 'Static' `TextureMode` type is not used for `Beam`s and therefore behaves identically to 'Wrap'.

When `TextureMode` is set to 'Stretch' however the texture will be stretched relative to the beam's length. The size of the texture relative to the `Beam`'s length will be one over the `TextureLength`. In practice, this means the texture will repeat `TextureLength` times. For an example of this see the image below:

![enter image description here](https://developer.roblox.com/assets/blt034506939f5674b3/beamTexture2.gif)

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	TextureMode: Enum.TextureMode;
	/** Determines the speed at which the `Texture` image moves along the `Beam`.

When TextureSpeed is positive, the beam's texture will move from `Attachment0` to `Attachment1`. This direction can be inverted by setting TextureSpeed to a negative number.

Note the speed at which the texture moves is relative to the length of the texture. Meaning the more stretched the beam's `Texture` is, the faster it will move at the same TextureSpeed.

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	TextureSpeed: number;
	/** Determines the transparency of the `Beam` across its segments.

## Beams and Transparency

This property is a `NumberSequence`, allowing the transparency to be configured to vary across the length of the `Beam`. Take for example the following `NumberSequence`.

```lua
local numberSequence = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1), -- transparent
	NumberSequenceKeypoint.new(0.5, 0), -- opaque
	NumberSequenceKeypoint.new(1, 1), -- transparent
	}
)
```


Applying this `NumberSequence` to a `Beam` would yield the following result:

![enter image description here](https://developer.roblox.com/assets/bltb919bbb4d83c7ba8/BeamTransparency.png)

Note the `Beam's` transparency also depends on the number of `Segments` the `Beam` has. Each segment of the beam can only show a transition between two transparencies. Therefore a `Beam` will need to have at least n-1 segments in order to display correctly, where n is the number of `NumberSequenceKeypoint`s in the `NumberSequence`

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```
 */
	Transparency: NumberSequence;
	/** The width in studs of the `Beam` at its base.

The beam will be Width0 studs wide at `Attachment0` and the width will change linearly to `Width1` studs at `Attachment1`. For a visual demonstration of this, see the image below.

![Width](https://developer.roblox.com/assets/bltaa8ac3288251010b/Width.png)

The width properties should not be confused with `CurveSize0` and `CurveSize1` which control the curvature of the beam.

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```

### Layering Beams

This code sample uses the `ZOffset` property to layer multiple `Beam`s between the same `Attachment`s.
```lua
-- create beams
local beam1 = Instance.new("Beam")
beam1.Color = ColorSequence.new(Color3.new(1, 0, 0))
beam1.FaceCamera = true
beam1.Width0 = 3
beam1.Width1 = 3

local beam2 = Instance.new("Beam")
beam2.Color = ColorSequence.new(Color3.new(0, 1, 0))
beam2.FaceCamera = true
beam2.Width0 = 2
beam2.Width1 = 2

local beam3 = Instance.new("Beam")
beam3.Color = ColorSequence.new(Color3.new(0, 0, 1))
beam3.FaceCamera = true
beam3.Width0 = 1 
beam3.Width1 = 1

-- layer beams
beam1.ZOffset = 0
beam2.ZOffset = 0.01
beam3.ZOffset = 0.02

-- create attachments
local attachment0 = Instance.new("Attachment", workspace.Terrain)
attachment0.Position = Vector3.new(0, 5, 0)
local attachment1 = Instance.new("Attachment", workspace.Terrain)
attachment1.Position = Vector3.new(0, 15, 0)

-- connect beams
beam1.Attachment0 = attachment0
beam1.Attachment1 = attachment1
beam2.Attachment0 = attachment0
beam2.Attachment1 = attachment1
beam3.Attachment0 = attachment0
beam3.Attachment1 = attachment1

-- parent beams
beam1.Parent = workspace
beam2.Parent = workspace
beam3.Parent = workspace 



```
 */
	Width0: number;
	/** The width in studs of the `Beam` at its end.

The beam will be `Width0` studs wide at `Attachment0` and the width will change linearly to Width1 studs at `Attachment1`. For a visual demonstration of this, see the image below.

![Width](https://developer.roblox.com/assets/bltaa8ac3288251010b/Width.png)

The width properties should not be confused with `CurveSize0` and `CurveSize1` which control the curvature of the beam.

## Code Samples

### Creating a Beam From Scratch

​This code sample demonstrates how a `Beam` effect can be created from scratch by creating a `Beam`, setting all of its properties and configuring it's `Attachment`s. See below for an image of the final result:

![enter image description here](https://developer.roblox.com/assets/bltbdd703fd3670062e/ModelBeam.gif)
```lua
-- create attachments
local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")

-- parent to terrain (can be part instead)
att0.Parent = workspace.Terrain
att1.Parent = workspace.Terrain

-- position attachments
att0.Position = Vector3.new(0, 10, 0)
att1.Position = Vector3.new(0, 10, 10)

-- create beam
local beam = Instance.new("Beam")
beam.Attachment0 = att0
beam.Attachment1 = att1 

-- appearance properties
beam.Color = ColorSequence.new({ -- a color sequence shifting from white to blue
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 255))
	}
)
beam.LightEmission = 1 -- use additive blending
beam.LightInfluence = 0 -- beam not influenced by light
beam.Texture = "rbxasset://textures/particles/sparkles_main.dds" -- a built in sparkle texture
beam.TextureMode = Enum.TextureMode.Wrap -- wrap so length can be set by TextureLength
beam.TextureLength = 1 -- repeating texture is 1 stud long 
beam.TextureSpeed = 1 -- slow texture speed
beam.Transparency = NumberSequence.new({ -- beam fades out at the end
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0),
		NumberSequenceKeypoint.new(1, 1)
	}
)
beam.ZOffset = 0 -- render at the position of the beam without offset 

-- shape properties
beam.CurveSize0 = 2 -- create a curved beam
beam.CurveSize1 = -2 -- create a curved beam
beam.FaceCamera = true -- beam is visible from every angle 
beam.Segments = 10 -- default curve resolution  
beam.Width0 = 0.2 -- starts small
beam.Width1 = 2 -- ends big

-- parent beam
beam.Enabled = true
beam.Parent = att0
```

### Layering Beams

This code sample uses the `ZOffset` property to layer multiple `Beam`s between the same `Attachment`s.
```lua
-- create beams
local beam1 = Instance.new("Beam")
beam1.Color = ColorSequence.new(Color3.new(1, 0, 0))
beam1.FaceCamera = true
beam1.Width0 = 3
beam1.Width1 = 3

local beam2 = Instance.new("Beam")
beam2.Color = ColorSequence.new(Color3.new(0, 1, 0))
beam2.FaceCamera = true
beam2.Width0 = 2
beam2.Width1 = 2

local beam3 = Instance.new("Beam")
beam3.Color = ColorSequence.new(Color3.new(0, 0, 1))
beam3.FaceCamera = true
beam3.Width0 = 1 
beam3.Width1 = 1

-- layer beams
beam1.ZOffset = 0
beam2.ZOffset = 0.01
beam3.ZOffset = 0.02

-- create attachments
local attachment0 = Instance.new("Attachment", workspace.Terrain)
attachment0.Position = Vector3.new(0, 5, 0)
local attachment1 = Instance.new("Attachment", workspace.Terrain)
attachment1.Position = Vector3.new(0, 15, 0)

-- connect beams
beam1.Attachment0 = attachment0
beam1.Attachment1 = attachment1
beam2.Attachment0 = attachment0
beam2.Attachment1 = attachment1
beam3.Attachment0 = attachment0
beam3.Attachment1 = attachment1

-- parent beams
beam1.Parent = workspace
beam2.Parent = workspace
beam3.Parent = workspace 



```
 */
	Width1: number;
	/** The distance, in studs, the `Beam`s display is offset by relative to the `CurrentCamera`.

When ZOffset is 0, the `Beam` will be displayed in its standard position between `Attachment0` and `Attachment1`. ZOffset can be both positive and negative.

This property can be particularly useful when using multiple `Beams` between the same `Attachment`s. Here, ZOffset can be used to layer the `Beam`s and avoid [Z-fighting][1]. For example:


See the image below for a visual demonstration of ZOffset:

![ZOffset](https://developer.roblox.com/assets/blta08e9828cbe14d33/ZOffset.gif)


  [1]: https://en.wikipedia.org/wiki/Z-fighting

## Code Samples

### Layering Beams

This code sample uses the `ZOffset` property to layer multiple `Beam`s between the same `Attachment`s.
```lua
-- create beams
local beam1 = Instance.new("Beam")
beam1.Color = ColorSequence.new(Color3.new(1, 0, 0))
beam1.FaceCamera = true
beam1.Width0 = 3
beam1.Width1 = 3

local beam2 = Instance.new("Beam")
beam2.Color = ColorSequence.new(Color3.new(0, 1, 0))
beam2.FaceCamera = true
beam2.Width0 = 2
beam2.Width1 = 2

local beam3 = Instance.new("Beam")
beam3.Color = ColorSequence.new(Color3.new(0, 0, 1))
beam3.FaceCamera = true
beam3.Width0 = 1 
beam3.Width1 = 1

-- layer beams
beam1.ZOffset = 0
beam2.ZOffset = 0.01
beam3.ZOffset = 0.02

-- create attachments
local attachment0 = Instance.new("Attachment", workspace.Terrain)
attachment0.Position = Vector3.new(0, 5, 0)
local attachment1 = Instance.new("Attachment", workspace.Terrain)
attachment1.Position = Vector3.new(0, 15, 0)

-- connect beams
beam1.Attachment0 = attachment0
beam1.Attachment1 = attachment1
beam2.Attachment0 = attachment0
beam2.Attachment1 = attachment1
beam3.Attachment0 = attachment0
beam3.Attachment1 = attachment1

-- parent beams
beam1.Parent = workspace
beam2.Parent = workspace
beam3.Parent = workspace 



```
 */
	ZOffset: number;
	/** Sets the current offset of the `Beam`'s texture cycle.

The offset of a `Beam`s texture cycle represents the progress of the `Beam`s texture animation. Hence, a `Beam`'s texture cycle can be reset as follows:

```lua
beam:SetTextureOffset(0)
```


Where manual control is not required over the `Beam`'s texture cycle, `TextureSpeed` can be used instead to animate the `Beam`. Although, for illustrative purposes, a similar function can be achieved with SetTextureOffset.

```lua
local RunService = game:GetService("RunService")
while true do
	for i = 1, 0, -0.01 do
		RunService.RenderStepped:Wait()
		beam:SetTextureOffset(i)
	end	
end
```


## Notes

 - The given offset parameter is expected to be a value between 0 and 1, but greater values can still be used
 - The texture cycle wraps at 0 and 1, meaning the texture is in the same position when the offset is 0 or at 1
 - If the `Texture` property is not set, this function will do nothing
 - Increasing the offset will act in the inverse direction to the `TextureSpeed` property. Meaning, it will move the texture in the opposite direction to the direction the texture animates when `TextureSpeed` is more than 0
@param offset The desired offset of the texture cycle. */
	SetTextureOffset(offset?: number): void;
}

/** **Note:**
 If a Table is passed as an argument to a BindableEvent it must be an array without missing entries or have string keys, not a mixture, or else the string keys will be lost. Allows events defined in one script to be subscribed to by another script. However, please note that BindableEvents do not allow for communication between the server and client. If you are looking for this functionality use `RemoteEvent`.

## Code Samples

### BindableEvent Hello World

This code sample defines and connects a simple function to a BindableEvent. It then fires the BindableEvent, which in turn calls the connected function. It prints "Hello, world". Test this script by pasting it into a BindableEvent within the Workspace or ServerScriptService.
```lua
local be = script.Parent

-- Define a simple function to connect
-- to the custom event
local function onEvent(...)
	print(...)
end
be.Event:Connect(onEvent)

-- Fire the event
be:Fire("Hello, world")
```

### BindableEvent Theading Behavior

This code sample demonstrates how BindableEvents, like all Events, create threads of each connected function. Even if one errors, like `ohNo` does, the others continue. In addition, this sample shows how functions connected to the event can yield without blocking the thread that fired the event.

Test this code by pasting it into a Script within a BindableEvent parented to the Workspace or ServerScriptService. When running it, you'll notice the error by `ohNo` does not stop the script from continuing ("Let's-a-go!") or any other connected function from being called. `count` and `alphabet` both do their tasks at the same time.
```lua
local be = script.Parent

-- Print numbers 1 through `n`
local function count(n)
	for i = 1, n do
		wait(.25)
		print(i)
	end
end

-- Print the first `n` letters of the alphabet
local function alphabet(n)
	for i = 0, n-1 do
		wait(.333)
		print(string.char(65+i))
	end
end

-- This function errors! But it doesn't stop
-- the others from being called
local function ohNo(n)
	if n > 10 then
		error("Oh no!")
	end
end

be.Event:Connect(count)
be.Event:Connect(alphabet)
be.Event:Connect(ohNo)
be:Fire(26)
print("Let's-a-go!")

```

### BindableEvent Valid Values

This code sample shows the kinds of values that can be sent when firing BindableEvents using Fire. Test this code by placing a Script within a BindableEvent inside the Workspace or ServerScriptService. It will raise errors on the values that cannot be fired.
```lua
local be = script.Parent

-- Define a simple function to connect
-- to the custom event
local function onEvent(...)
	print(...)
end
be.Event:Connect(onEvent)

-- These values CAN be sent when firing BindableEvents
be:Fire()           -- nil
be:Fire(25)         -- numbers
be:Fire("hello")    -- strings
be:Fire(true)       -- booleans
be:Fire("buy", 25)  -- multiple values are OK
be:Fire{1, 2, 3}    -- tables as arrays with no gaps
                      -- note the curly braces
be:Fire{            -- tables with string keys only
	hello = "world";
	goodbye = "world";
}
be:Fire{            -- tables with string keys
	point = {1, 2};   -- whose values are also valid
	point2 = {3, 4};
}
be:Fire{            -- tables as arrays
	{1, 2, 3};        -- whose values also are valid
	{hello = "world";};
}

-- These are some values you CANNOT send to/from BindableFunctions
be:Fire{1, nil, 3}  -- tables as arrays cannot have nil gaps
be:Fire{
	[{}] = "hello";   -- table keys can only be numbers OR strings
}
be:Fire{            -- tables keys cannot be BOTH numbers AND strings  
	[1] = "apple";
	hello = "world";
}
```
 */
interface BindableEvent extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BindableEvent";
	/** Calling this method will fire the "Event" event. This function does not yield, even no script has connected to the "Event" event and even if a connected function yields. There are limitations on the values that can be sent as arguments; see the code samples

## Code Samples

### BindableEvent Theading Behavior

This code sample demonstrates how BindableEvents, like all Events, create threads of each connected function. Even if one errors, like `ohNo` does, the others continue. In addition, this sample shows how functions connected to the event can yield without blocking the thread that fired the event.

Test this code by pasting it into a Script within a BindableEvent parented to the Workspace or ServerScriptService. When running it, you'll notice the error by `ohNo` does not stop the script from continuing ("Let's-a-go!") or any other connected function from being called. `count` and `alphabet` both do their tasks at the same time.
```lua
local be = script.Parent

-- Print numbers 1 through `n`
local function count(n)
	for i = 1, n do
		wait(.25)
		print(i)
	end
end

-- Print the first `n` letters of the alphabet
local function alphabet(n)
	for i = 0, n-1 do
		wait(.333)
		print(string.char(65+i))
	end
end

-- This function errors! But it doesn't stop
-- the others from being called
local function ohNo(n)
	if n > 10 then
		error("Oh no!")
	end
end

be.Event:Connect(count)
be.Event:Connect(alphabet)
be.Event:Connect(ohNo)
be:Fire(26)
print("Let's-a-go!")

```

### BindableEvent Valid Values

This code sample shows the kinds of values that can be sent when firing BindableEvents using Fire. Test this code by placing a Script within a BindableEvent inside the Workspace or ServerScriptService. It will raise errors on the values that cannot be fired.
```lua
local be = script.Parent

-- Define a simple function to connect
-- to the custom event
local function onEvent(...)
	print(...)
end
be.Event:Connect(onEvent)

-- These values CAN be sent when firing BindableEvents
be:Fire()           -- nil
be:Fire(25)         -- numbers
be:Fire("hello")    -- strings
be:Fire(true)       -- booleans
be:Fire("buy", 25)  -- multiple values are OK
be:Fire{1, 2, 3}    -- tables as arrays with no gaps
                      -- note the curly braces
be:Fire{            -- tables with string keys only
	hello = "world";
	goodbye = "world";
}
be:Fire{            -- tables with string keys
	point = {1, 2};   -- whose values are also valid
	point2 = {3, 4};
}
be:Fire{            -- tables as arrays
	{1, 2, 3};        -- whose values also are valid
	{hello = "world";};
}

-- These are some values you CANNOT send to/from BindableFunctions
be:Fire{1, nil, 3}  -- tables as arrays cannot have nil gaps
be:Fire{
	[{}] = "hello";   -- table keys can only be numbers OR strings
}
be:Fire{            -- tables keys cannot be BOTH numbers AND strings  
	[1] = "apple";
	hello = "world";
}
```
 */
	Fire(...arguments: Array<unknown>): void;
	/** This event is fired when any script calls the Fire method of the BindableEvent.

## Code Samples

### BindableEvent Hello World

This code sample defines and connects a simple function to a BindableEvent. It then fires the BindableEvent, which in turn calls the connected function. It prints "Hello, world". Test this script by pasting it into a BindableEvent within the Workspace or ServerScriptService.
```lua
local be = script.Parent

-- Define a simple function to connect
-- to the custom event
local function onEvent(...)
	print(...)
end
be.Event:Connect(onEvent)

-- Fire the event
be:Fire("Hello, world")
```
 */
	readonly Event: RBXScriptSignal<(...arguments: Array<unknown>) => void, true>;
}

/** A BindableFunction is a Roblox object that allows you to give access to functions to external scripts. Functions put in BindableFunctions will not be replicated, therefore making it impossible to use these objects to pass functions between scripts. Functions are invoked through `Invoke`, which calls `OnInvoke`.

## Code Samples

### BindableFunction Valid Values

This code sample shows the kinds of values that can be sent to and from BindableFunctions via Invoke/OnInvoke. Test this code by placing a Script within a BindableFunction inside the Workspace or ServerScriptService. It will raise errors on the values that cannot be sent.
```lua
local bf = script.Parent

-- Dummy function
bf.OnInvoke = function (...) return ... end

-- These values CAN be sent to/from BindableFunctions
bf:Invoke()           -- nil
bf:Invoke(25)         -- numbers
bf:Invoke("hello")    -- strings
bf:Invoke(true)       -- booleans
bf:Invoke("buy", 25)  -- multiple values are OK
bf:Invoke{1, 2, 3}    -- tables as arrays with no gaps
                      -- note the curly braces
bf:Invoke{            -- tables with string keys only
	hello = "world";
	goodbye = "world";
}
bf:Invoke{            -- tables with string keys
	point = {1, 2};   -- whose values are also valid
	point2 = {3, 4};
}
bf:Invoke{            -- tables as arrays
	{1, 2, 3};        -- whose values also are valid
	{hello = "world";};
}

-- These are some values you CANNOT send to/from BindableFunctions
bf:Invoke{1, nil, 3}  -- tables as arrays cannot have nil gaps
bf:Invoke{
	[{}] = "hello";   -- table keys can only be numbers OR strings
}
bf:Invoke{            -- tables keys cannot be BOTH numbers AND strings  
	[1] = "apple";
	hello = "world";
}
```

### BindableFunction Addition

This code sample sets the OnInvoke callback of the parent BindableFunction to a function that returns the sum of two numbers. Test this code sample by pasting this code inside a Script within a BindableFunction. You'll then be able to use Invoke on the BindableFunction from other scripts.
```lua
local bf = script.Parent

-- Define a function for use with the BindableFunction
local function AddTwoNumbers(a, b)
	return a + b
end

-- Set the OnInvoke callback to be our function
bf.OnInvoke = AddTwoNumbers

-- Invoke the BindableFunction
print(bf:Invoke(25, 44))
```
 */
interface BindableFunction extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BindableFunction";
	/** Invoke will call the OnInvoke callback and return any values that were returned by the callback (if any). If the OnInvoke callback is not set, this method will yield until one is set. If OnInvoke yields, this method will also yield. There are limitations on the values that can be sent as arguments; see the code samples.

## Code Samples

### BindableFunction Valid Values

This code sample shows the kinds of values that can be sent to and from BindableFunctions via Invoke/OnInvoke. Test this code by placing a Script within a BindableFunction inside the Workspace or ServerScriptService. It will raise errors on the values that cannot be sent.
```lua
local bf = script.Parent

-- Dummy function
bf.OnInvoke = function (...) return ... end

-- These values CAN be sent to/from BindableFunctions
bf:Invoke()           -- nil
bf:Invoke(25)         -- numbers
bf:Invoke("hello")    -- strings
bf:Invoke(true)       -- booleans
bf:Invoke("buy", 25)  -- multiple values are OK
bf:Invoke{1, 2, 3}    -- tables as arrays with no gaps
                      -- note the curly braces
bf:Invoke{            -- tables with string keys only
	hello = "world";
	goodbye = "world";
}
bf:Invoke{            -- tables with string keys
	point = {1, 2};   -- whose values are also valid
	point2 = {3, 4};
}
bf:Invoke{            -- tables as arrays
	{1, 2, 3};        -- whose values also are valid
	{hello = "world";};
}

-- These are some values you CANNOT send to/from BindableFunctions
bf:Invoke{1, nil, 3}  -- tables as arrays cannot have nil gaps
bf:Invoke{
	[{}] = "hello";   -- table keys can only be numbers OR strings
}
bf:Invoke{            -- tables keys cannot be BOTH numbers AND strings  
	[1] = "apple";
	hello = "world";
}
```

### BindableFunction Addition

This code sample sets the OnInvoke callback of the parent BindableFunction to a function that returns the sum of two numbers. Test this code sample by pasting this code inside a Script within a BindableFunction. You'll then be able to use Invoke on the BindableFunction from other scripts.
```lua
local bf = script.Parent

-- Define a function for use with the BindableFunction
local function AddTwoNumbers(a, b)
	return a + b
end

-- Set the OnInvoke callback to be our function
bf.OnInvoke = AddTwoNumbers

-- Invoke the BindableFunction
print(bf:Invoke(25, 44))
```
 */
	Invoke(...arguments: Array<unknown>): Array<unknown>;
	/** This callback can be set multiple times, but cannot be called directly. It is called when the `Invoke` method is called, using the same arguments as parameters.

There are limitations on the valid parameters this callback can return (see the code samples to learn more).

## Code Samples

### Temporary DataStore

This code sample demonstrates one possible usage of `BindableFunctions`, temporary datastores, in combination with `ClickDetectors`.  It also demonstrates why BindableFunctions are important, since they allow multiple server `Scripts` to communicate with each other.

Note that this can also be achieved through the use of a `ModuleScript`. 

This example creates a datastore using a table in a `Script`. Since it does not utilize Roblox’s `DataStores`, it is temporary and player data is erased when the player leaves or the server shuts down. For persistent DataStores, take a look at [this][1] article.

The code below contains two parts:

###TempDataStore Script
The script containing the `OnInvoke` callback. Since this is a callback, the Invoke() function will wait for and receive the results of the invoked function. This is the `TempDataStore` script in the code below. 

This script maintains a table called `PlayerData` that tracks players’ data while they are in the game. When a player enters the game, they are added to the table with a balance of 0 using their `UserId` as the table key. When a player exits the game, their key is removed from the table. The script creates two BindableFunctions to interact with the `ActivateButton` script named GetData and SetData.

When GetData’s OnInvoke event fires, the script returns the player’s balance in `PlayerData`.

When SetData’s OnInvoke event fires, the script set’s the player’s balance in `PlayerData` to the value passed as an argument and returns the updated value.

###ActivateButton Script
The script containing the `Invoke` function. This is the `ActivateButton` script in the code below.

It creates a `ClickDetector` that allows the player to retrieve and increment their balance in the temporary datastore in `TempDataStore`. When the player left mouse clicks on the parent part the `SetData` BindableFunction is Invoked, which increases the player’s balance by 1. When the player right mouse clicks on the part the `GetData` BindableFunction is invoked, which retrieves and prints the player’s balance.


  [1]: https://www.robloxdev.com/articles/Data-store
```lua
-- TempDataStore (Script 1)
local GetData = Instance.new("BindableFunction", game.ServerStorage)
GetData.Name = "GetData"

local SetData = Instance.new("BindableFunction", game.ServerStorage)
SetData.Name = "SetData"

local PlayerData = {}

local function getData(player)
	return PlayerData[player.UserId]
end

local function setData(player, value)
	PlayerData[player.UserId] = value
	return PlayerData[player.UserId]
end

local function addPlayerData(player)
	table.insert(PlayerData, player.UserId, 0)
end

local function removePlayerData(player)
	table.remove(PlayerData, player.UserId)
end

GetData.OnInvoke = getData
SetData.OnInvoke = setData

game.Players.PlayerAdded:Connect(addPlayerData)
game.Players.PlayerRemoving:Connect(removePlayerData)




-- ActivateButton (Script 2)
local GetData = game.ServerStorage:WaitForChild("GetData")
local SetData = game.ServerStorage:WaitForChild("SetData")

local ClickDetector = Instance.new("ClickDetector", script.Parent)

local function getData(player)
	print(player.Name.."'s Current Balance: "..GetData:Invoke(player))
end

local function setData(player)
	local value = 100
	print("Set "..player.Name.."'s Balance to: "..SetData:Invoke())
end

local function incrementData(player)
	local balance = GetData:Invoke(player)
	print("Set "..player.Name.."'s Balance to: "..SetData:Invoke(player, balance+1))
end

ClickDetector.MouseClick:Connect(incrementData)
ClickDetector.RightMouseClick:Connect(getData)
```

### BindableFunction Valid Values

This code sample shows the kinds of values that can be sent to and from BindableFunctions via Invoke/OnInvoke. Test this code by placing a Script within a BindableFunction inside the Workspace or ServerScriptService. It will raise errors on the values that cannot be sent.
```lua
local bf = script.Parent

-- Dummy function
bf.OnInvoke = function (...) return ... end

-- These values CAN be sent to/from BindableFunctions
bf:Invoke()           -- nil
bf:Invoke(25)         -- numbers
bf:Invoke("hello")    -- strings
bf:Invoke(true)       -- booleans
bf:Invoke("buy", 25)  -- multiple values are OK
bf:Invoke{1, 2, 3}    -- tables as arrays with no gaps
                      -- note the curly braces
bf:Invoke{            -- tables with string keys only
	hello = "world";
	goodbye = "world";
}
bf:Invoke{            -- tables with string keys
	point = {1, 2};   -- whose values are also valid
	point2 = {3, 4};
}
bf:Invoke{            -- tables as arrays
	{1, 2, 3};        -- whose values also are valid
	{hello = "world";};
}

-- These are some values you CANNOT send to/from BindableFunctions
bf:Invoke{1, nil, 3}  -- tables as arrays cannot have nil gaps
bf:Invoke{
	[{}] = "hello";   -- table keys can only be numbers OR strings
}
bf:Invoke{            -- tables keys cannot be BOTH numbers AND strings  
	[1] = "apple";
	hello = "world";
}
```

### BindableFunction Addition

This code sample sets the OnInvoke callback of the parent BindableFunction to a function that returns the sum of two numbers. Test this code sample by pasting this code inside a Script within a BindableFunction. You'll then be able to use Invoke on the BindableFunction from other scripts.
```lua
local bf = script.Parent

-- Define a function for use with the BindableFunction
local function AddTwoNumbers(a, b)
	return a + b
end

-- Set the OnInvoke callback to be our function
bf.OnInvoke = AddTwoNumbers

-- Invoke the BindableFunction
print(bf:Invoke(25, 44))
```
 */
	OnInvoke: (...arguments: Array<unknown>) => any;
}

interface RbxInternalBodyMover extends RbxInternalInstance {}
/** BodyMover is the abstract base class for the set of legacy objects that exert forces to `BasePart`s in different ways. In general, the subclasses of BodyMover can be placed into one of two categories based on the type of force(s) they exert:

## Translational Force
 -  `BodyForce`: Exert a force relative to world coordinates
 -  `BodyPosition`: Exert force to maintain a certain world position
 -  `BodyVelocity`: Exert force to maintain a certain velocity

## Rotational Force (Torque)
 -  `BodyThrust`: Exert a force relative to object coordinates, which applies torque if positioned in a certain way
 -  `BodyGyro`: Exert torque to maintain a certain orientation
 -  `BodyAngularVelocity`: Exert torque to maintain a certain angular velocity

An exception is the `RocketPropulsion` class, which exerts **both** translational and rotational forces to cause a part to track down another part. */
type BodyMover = BodyAngularVelocity | BodyForce | BodyGyro | BodyPosition | BodyThrust | BodyVelocity | RocketPropulsion;

/** The BodyAngularVelocity object applies a [torque][1] (or **rotational force**) on a `BasePart` such that it maintains a constant [angular velocity][3] as determined by its `AngularVelocity` property. This allows for the creation of parts that continually rotate. It is the rotational counterpart to a `BodyVelocity`. If you would like to maintain a constant [angular displacement][2], use a `BodyGyro` instead.

![An animation of a Part with a BodyAngularVelocity applied; there is a superimposed green line visualizing the AngularVelocity property](/assets/5b42688e811ef5800bf7c42f/BodyAngularVelocity.gif)

The `AngularVelocity` property (visualized above as a green line) controls the goal angular velocity of the applied torque: the direction of the `Vector3` is the axis which the part rotates around, and the magnitude is the speed in **radians/s**. The `MaxTorque` property controls the maximum amount of torque that can be applied to the object, while the `P` property controls the amount of [power][4] used in applying the torque.

**Tip:** Regarding the `AngularVelocity` property, you can multiply a `Vector3` by `math.rad(360)`, or **2π**, in order to convert [angular frequency][5] (rotations per second) into the desired [angular velocity][3] (radians per second). For example: Setting `AngularVelocity` to `Vector3.new(0, 1, 0) * math.rad(360)` ≈ `Vector3.new(0, 6.283, 0)` will cause a part to spin around the Y axis once per second.

![Diagram of each axes and the torque applied](/assets/5b2db3612d96e4e55d6238e0/AngularvelocitydiagramV2.png)

  [1]: https://en.wikipedia.org/wiki/Torque
  [2]: https://en.wikipedia.org/wiki/Angular_displacement
  [3]: https://en.wikipedia.org/wiki/Angular_velocity
  [4]: https://en.wikipedia.org/wiki/Power_(physics)
  [5]: https://en.wikipedia.org/wiki/Angular_frequency */
interface BodyAngularVelocity extends RbxInternalBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyAngularVelocity";
	/** The AngularVelocity property is a `Vector3` which determines the goal angular velocity a `BodyAngularVelocity` should maintain through the exertion of torque. For this property, the direction of the vector is the axis of rotation. The magnitude is the angular velocity in **radians per second**. By default, this property is `(0, 2, 0)`.

**Tip:** You can multiply a `Vector3` by `math.rad(360)`, or **2π**, in order to convert [angular frequency][5] (rotations per second) into the desired [angular velocity][3] (radians per second). For example: Setting `AngularVelocity` to `Vector3.new(0, 1, 0) * math.rad(360)` ≈ `Vector3.new(0, 6.283, 0)` will cause a part to spin around the Y axis once per second.

To better understand how the axis of rotation is determined from this property, imagine that there is an axle running between the part's position and the part's position plus this property as a global offset. This axle determines in what orientation the object will spin. The length of the axle determines the angular speed in radians per second. In the animation below, the `Part` contains a `BodyAngularVelocity` and is floating in the air (using a `BodyPosition`). The `BodyAngularVelocity` has the default AngularVelocity of `(0, 2, 0)`, and this vector is visualized with a superimposed green line. It represents the axis of rotation. If we were to make the axle longer, like `(0, 4, 0)`, the part would spin faster.

![A floating part with a BodyAngularVelocity whose AngularVelocity is set to the default (0, 2, 0), with a superimposed green line visualizing the AngularVelocity vector](https://developer.roblox.com/assets/5b42688e811ef5800bf7c42f/BodyAngularVelocity.gif)

As for the direction of rotation (counterclockwise or clockwise), use a **right-hand rule**: make a thumbs up with your right hand, and point **your thumb** it in the direction of the vector. The direction in which your fingers curl is the direction of the goal angular velocity.

  
  [2]: https://en.wikipedia.org/wiki/Angular_displacement
  [3]: https://en.wikipedia.org/wiki/Angular_velocity
  [4]: https://en.wikipedia.org/wiki/Power_(physics)
  [5]: https://en.wikipedia.org/wiki/Angular_frequency */
	AngularVelocity: Vector3;
	/** The MaxTorque property determines the limit of the torque that may be exerted on each world axis. If a part isn't moving, consider raising this value (and also check that it is not `Anchored` or attached to another anchored part). See also `P` (power). */
	MaxTorque: Vector3;
	/** The P property determines how much [power](https://en.wikipedia.org/wiki/Power_(physics)) is used while applying torque in order to reach the goal `AngularVelocity`. The higher this value, the more power will be used and the faster it will be used. */
	P: number;
}

/** The BodyForce object applies (or exerts) a force on the part to which it is parented. If the magnitude of such a force is great enough, parts can begin to accelerate. See [Newton's First Law of Motion](https://www.grc.nasa.gov/www/K-12/airplane/newton.html). The force is determined by the `Force` property, and is defined on the three world axes.

A BodyForce alone cannot apply a torque (it cannot cause the parent to rotate on its own). To apply a force at a specific point (e.g. to apply torque for angular acceleration) or apply forces relative to the orientation of the part, use a `BodyThrust` instead.

## Forces Relative to Parent
Using the `CFrame:vectorToWorldSpace(Vector3)` method, it is possible to translate a force vector that is relative to the part into the world vector necessary for `Force`. For example, to apply a force to the left an object (no matter which way it's facing), try:
```lua
magnitude = 100
left = Vector3.new(-1, 0, 0) * magnitude -- You could also use Vector3.FromNormalId(Enum.NormalId.Left)
bodyForce.Force = bodyForce.Parent.CFrame:vectorToWorldSpace(left)
```

You can also use a `BodyThrust` with a `Location` of `(0, 0, 0)`, then set the `Force` for the same effect.

## Anti-gravity
BodyForce is commonly used to counteract the effects of `Gravity` on a per-part basis by simply applying a force in the +Y direction. See the code samples for more information.

## Code Samples

### Lunar Gravity

This code sample demonstrates how a BodyForce can be used to counteract the force of gravity by providing a force in the opposite direction (upward).
```lua
-- The factor by which gravity will be counteracted
local MOON_GRAVITY = 0.5

local function setGravity(part, g)
	local antiGravity = part:FindFirstChild("AntiGravity")
	if g == 1 then
		-- Standard gravity; destroy any gravity-changing force
		if antiGravity then
			antiGravity:Destroy()
		end 
	else
		-- Non-standard gravity: create and change gravity-changing force
		if not antiGravity then
			antiGravity = Instance.new("BodyForce")
			antiGravity.Name = "AntiGravity"
			antiGravity.Archivable = false
			antiGravity.Parent = part
		end
		antiGravity.Force = Vector3.new(0, part:GetMass() * workspace.Gravity * (1 - g), 0)
	end
end

local function moonGravity(part)
	setGravity(part, MOON_GRAVITY)
end

local function recursiveMoonGravity(object)
	if object:IsA("BasePart") then
		moonGravity(object)
	end
	for _, child in pairs(object:GetChildren()) do
		recursiveMoonGravity(child)
	end
end

local function onDescendantAdded(object)
	if object:IsA("BasePart") then
		moonGravity(object)
	end
end

recursiveMoonGravity(workspace)
workspace.DescendantAdded:Connect(onDescendantAdded)
```
 */
interface BodyForce extends RbxInternalBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyForce";
	/** The Force property determines the magnitude of force exerted on each axis, relative to the world. */
	Force: Vector3;
}

/** The **BodyGyro** object applies a torque (rotational&nbsp;force) on a `BasePart` such that it maintains a constant angular displacement, or orientation. This allows for the creation of parts that point in a certain direction, as if a real gyroscope were acting upon it. Essentially, it's the rotational counterpart to a `BodyPosition`.

If you would like to maintain a constant angular velocity, use a `BodyAngularVelocity` instead.

The `CFrame` property controls the goal orientation. Only the angular components of the `CFrame` are used; position will make no difference. `MaxTorque` limits the amount of angular force that may be applied, `P` controls the power used in achieving the goal orientation, and `D` controls dampening behavior.

## Setting the Orientation

Like all `CFrame` properties, the `CFrame` property isn't editable in the **Properties** window of Studio. Since there's no physical component to a **BodyGyro**, you should use scripting to set the `CFrame`.

A common technique for setting the goal orientation is to set the `CFrame` to a part's `CFrame`. For example:

```lua
workspace.Part.BodyGyro.CFrame = workspace.Part.CFrame
```


You can also use a `CFrame` **constructor** which initializes rotation such as `CFrame.fromAxisAngle`, `CFrame.fromEulerAnglesXYZ`, or `CFrame.fromEulerAnglesYXZ`. Alternatively, you can use the following structure to make the body gyro "look&nbsp;at" a `targetPosition`.

```lua
CFrame.new(BodyGyro.Parent.Position, targetPosition)
```


## Troubleshooting

* If the assembly isn't moving at all, it most likely has mass larger than what the **BodyGyro** can move. Try raising the `MaxTorque` and/or `P` (power) properties. You should also check that no `Anchored` parts are within the assembly or in the way of the assembly.
* If the assembly isn't moving on all axes, double check the axis in question has sufficient `MaxTorque`. Alternatively, if the part allows movement on an axis and shouldn't, be sure the `MaxTorque` is non-zero on that axis and refine the manner in which you are setting the **BodyGyro** `CFrame`.
* If the assembly is moving too quickly, consider raising the `D` (dampening) property.
* If the assembly is moving too slowly, consider lowering the `D` (dampening) property. Also consider raising the `MaxTorque` and/or `P` (power) properties.
* Any assembly containing a part that contains a **BodyGyro** or `BodyPosition` will not be simulated when interacting with a player unless that player is the `/articles/Network Ownership|network owner`
 of the assembly.

## Code Samples

### BodyGyro

Point one part back at another using BodyGyro:
```lua
local part1 = game.Workspace.Part1 -- The part that will turn to face Part2
local part2 = game.Workspace.Part2

part1.BodyGyro.cframe = CFrame.new(part1.Position, part2.Position)
```
 */
interface BodyGyro extends RbxInternalBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyGyro";
	/** The CFrame property (not to be confused with `CFrame`) determines the target orientation towards which torque will be exerted. Since `BodyGyro` does not apply translational force, the translational/positional component of the `CFrame`, `CFrame.p`, is ignored. Consider using one of the following CFrame constructors in setting this property: `CFrame.fromAxisAngle`, `CFrame.fromEulerAnglesXYZ` or `CFrame.fromEulerAnglesYXZ`. Beware of [gimbal lock](https://en.wikipedia.org/wiki/Gimbal_lock) as you choose which of these methods and what angles (in radians). Additionally, you could use `CFrame.new(gyro.Parent.Position, targetPosition)` in order to have the BodyGyro "look at" a targetPosition (`Vector3`). */
	CFrame: CFrame;
	/** The D property is how much **dampening** will be applied to the torque used to reach the goal `CFrame`. When the part approaches the goal orientation it needs to decelerate, otherwise it will rotate past the goal and have to stop and re-accelerate back toward the goal. This is often creates undesirable **rubber-banding** effect, so applying dampening using this property is how that effect is avoided. The higher this value is set, the greater the dampening curve becomes, or the slower the part will approach the goal orientation. */
	D: number;
	/** The MaxTorque property determines the limit on the amount of torque that may be applied on each axis in reaching the goal orientation (`CFrame`). If a part isn't moving, consider increasing this value (also check that it is not `Anchored` or attached to any anchored parts). */
	MaxTorque: Vector3;
	/** The P property determines how much [power](https://en.wikipedia.org/wiki/Power_(physics)) is used while applying torque in order to reach the goal `CFrame`. The higher this value, the more power will be used and the faster it will be used. */
	P: number;
}

/** The **BodyPosition** object applies a force on a `BasePart` such that it will maintain a constant position in the world. The `Position` property, not to be confused with `Position`, controls the target world position. This is the translational counterpart to a `BodyGyro`. If you need further control on a force applied to an object, consider using a `BodyForce` or `BodyThrust` instead.

The strength of the force applied by this object is controlled by several factors, namely the distance to the goal position: the force is stronger when farther away from the goal. This is amplified by `P` (power). The present velocity will also dampen the force applied by this object, and this is amplified by `D` (dampening). The resulting force is then capped by `MaxForce`. Note the force applied on the part to achieve the goal position may vary on a per-axis basis.

## Troubleshooting

* If the assembly isn't moving, it's likely the `MaxForce` is too low. Also check for any `Anchored` parts within the assembly or in the way of the assembly.
* If the assembly is moving horizontally but not vertically, it's likely the `MaxForce` is strong enough to overcome friction but not gravity. Consider raising the **Y** component of `MaxForce` in order to get the object off the ground.
* If the assembly is **overshooting** the goal position and springing back, it's likely the `D` (dampening) is too low. Alternatively, the `MaxForce` and/or `P` may be too high.
* Any assembly containing a part that contains a **BodyPosition** or a `BodyGyro` will not be simulated when interacting with a player unless that player is the `/articles/Network Ownership|network owner`
 of the assembly.

## Code Samples

### BodyPosition

This code will make a brick fly and hover in the center of the map, a little bit off the ground.
```lua
script.Parent.BodyPosition.position = Vector3.new(0, 20, 0)

```
 */
interface BodyPosition extends RbxInternalBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyPosition";
	/** The D property determines how much **dampening** will be applied to the force used toward reaching the goal `Position`. When the part approaches the goal position it needs to decelerate, otherwise it will move past the goal and have to stop and re-accelerate back toward the goal. This is often creates undesirable **rubber-banding** effect, so applying dampening using this property is how that effect is avoided. The higher this value is set, the greater the dampening curve becomes, or the slower the part will approach the goal position. */
	D: number;
	/** The MaxForce property determines the limit on the amount of force that may be applied on each axis in reaching the goal `Position`. If a part isn't moving, consider increasing this value (also check that it is not `Anchored` or attached to any anchored parts). */
	MaxForce: Vector3;
	/** The P property determines how much [power](https://en.wikipedia.org/wiki/Power_(physics)) is used while applying force in order to reach the goal `Position`. The higher this value, the more power will be used and the faster it will be used.
The force the `BodyPosition` exerts increases as the difference between the part's current position and the goal position increases. This property is multiplied to this force to either amplify or diminish it. */
	P: number;
	/** The Position property determines the goal position towards which the `BodyPosition` will apply force. */
	Position: Vector3;
	/** This function returns the last force in the object. */
	GetLastForce(): Vector3;
	/** Fired when the Parent of the BodyPosition reaches the desired `Position` (within .1 studs). Once this event fires it will not fire again until `Position` is updated. */
	readonly ReachedTarget: RBXScriptSignal<() => void>;
}

/** The BodyThrust object applies (or exerts) a force relative to the part to which it is parented at a specific location. It behaves similar to a `BodyForce`, except that this object's force applies at a specific point (`Location`), allowing you to exert a [torque][1] (rotational force). To apply a force dynamically so that a part maintains a constant angular velocity, use a `BodyAngularVelocity` instead. To apply a force dynamically so that a part maintains a constant orientation (angular position), use a `BodyGyro`.

   [1]: https://en.wikipedia.org/wiki/Torque */
interface BodyThrust extends RbxInternalBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyThrust";
	/** The Force property determines the amount of force exerted on each axis relative to the part. Unlike `Force`, this property is relative to the part and not the world. The force is exerted at the `Location`, which is also relative to the part. */
	Force: Vector3;
	/** The Location property determines the relative offset from the center part at which the `Force` is exerted. This is the primary means for turning force into torque. */
	Location: Vector3;
}

/** The BodyVelocity object applies a [force][1] on a `BasePart` such that it will maintain a constant velocity. The `Velocity` property, not to be confused wtih `Velocity`, controls the goal velocity. This is the translational counterpart to a `BodyAngularVelocity`. If you need the part to move toward a goal position, use a `BodyPosition` instead. If you need further control on a force applied to an object, consider using a `BodyForce` or `BodyThrust` instead.

The strength of the force applied by this object is controlled by several factors, namely the difference between the part's current velocity and the goal velocity. This is multiplied by `P` (power) to either amplify or diminish it. The resulting force is then capped by `MaxForce`. By setting `Velocity` to `(0, 0, 0)` it is possible to simulate `Anchored` behavior with less strictness.

   [1]: https://en.wikipedia.org/wiki/Force */
interface BodyVelocity extends RbxInternalBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyVelocity";
	/** The MaxForce property determines the limit on the amount of force that may be applied on each axis in reaching the goal `Velocity`. If a part isn't moving, consider increasing this value (also check that it is not `Anchored` or attached to any anchored parts). */
	MaxForce: Vector3;
	/** **Note**: This property is ignored if PGS is enabled via Workspace.PGSPhysicsSolverEnabled, which is enabled by default.


The P property determines how much [power](https://en.wikipedia.org/wiki/Power_(physics)) is used while applying force in order to reach the goal `Velocity`. The higher this value, the more power will be used and the faster it will be used.
The force the `BodyVelocity` exerts increases as the difference between the part's current velocity and the goal velocity increases. This property is multiplied to this force to either amplify or diminish it. */
	P: number;
	/** The Velocity property (not to be confused with `Velocity`) determines the target velocity towards which force will be exerted. It is specified relative to the world, not the part. */
	Velocity: Vector3;
	/** Returns the last force in the object.
@returns Dummy */
	GetLastForce(): Vector3;
	/** Returns the last force in the object. */
	lastForce(): Vector3;
}

/** The RocketPropulsion object applies a force on a part so that it both **follows** and **faces** a target part. It acts like a hybrid of `BodyPosition` and `BodyGyro`. Unlike other `BodyMover`s, a RocketPropulsion must be instructed to begin applying a force: call `Fire` to start, or call `Abort` to stop.

Below is an animation of a blue `Part` with a RocketPropulsion. The `Target` is set to a tall red `Part` that is being dragged around in a circle in Studio. Notice how the blue part homes in to the target:
![A blue Part with a RocketPropulsion following a tall red Part that is being dragged around in Studio](https://developer.roblox.com/assets/5b426347b496a3810b47f2d4/RocketPropulsion.gif)

You can detect when the part reaches its target using the `ReachedTarget` event, which fires once the part is within the `TargetRadius` of the `Target`.

RocketPropulsion has the most physics-related properties out of all the BodyMovers. It is helpful to separate the properties out into categories based on what they control:
 -  **Goal:** `Target`, `TargetOffset` and `TargetRadius`
 -  **Position (Thrust):** `MaxSpeed`, `MaxThrust`, `ThrustD` and `ThrustP`
 -  **Rotation (Turn):**  -  `CartoonFactor`, `MaxTorque`, `TurnD` and `TurnP`

Remember, you don't need to use both the translational and rotational force features of a RocketPropulsion: by setting `MaxThrust` to 0, you can make a part just face the target **without** having it follow the target around (consider also using a `BodyPosition` in addition). Similarly, by setting `MaxTorque` to `(0, 0, 0)`, you can have a part simply follow another object without facing it (use a `BodyGyro` if you want the object to maintain a specific orientation). */
interface RocketPropulsion extends RbxInternalBodyMover {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RocketPropulsion";
	/** The CartoonFactor property determines the tendency of the part to face the `Target`. By default, this property is set to `0.7`. If set to `0`, the part will make no effort to face the target. */
	CartoonFactor: number;
	/** The MaxSpeed property determines the upper limit of the velocity at which the part will move toward the `Target`. A `RocketPropulsion` will apply a force to decelerate a part if it exceeds this speed limit. */
	MaxSpeed: number;
	/** The MaxThrust property determines the upper limit of the thrust that may be exerted to move the part. Parts or assemblies that have high `mass` will require more thrust in order to to remain airborne, and thus track the `Target`. */
	MaxThrust: number;
	/** The MaxTorque property determines the upper limit on the amount of torque that may be exerted in order to rotate the part towards the `Target`. It functions similarly to `MaxTorque`. */
	MaxTorque: Vector3;
	/** The Target property determines the object towards which the `RocketPropulsion` will exert force/torque. If set to `nil`, the the `TargetOffset` will be used instead. */
	Target?: BasePart;
	/** The TargetOffset property determines the world offset from the `Target`. Basically, it makes the `RocketPropulsion` behave as if the target were really offset by this property. It is especially useful when Target is set to nil, since this property then acts as the target position. */
	TargetOffset: Vector3;
	/** The TargetRadius property determines the maximum distance from the `Target` the part must be in order for the `ReachedTarget` event to be fired. It does not affect the exerted forces in any way. */
	TargetRadius: number;
	/** The D property is used to dampen the velocity of the part in order to prevent it from overshooting the `Target` and causing a **rubber-banding** effect. It behaves similarly to `D`. */
	ThrustD: number;
	/** The P property determines how much [power](https://en.wikipedia.org/wiki/Power_(physics)) is used while applying force in order to reach the `Target` position. The higher this value, the more power will be used and the faster it will be used.
This property works similarly to `P`. */
	ThrustP: number;
	/** The D property is how much **dampening** will be applied to the torque used to face the `Target`. When the part approaches the goal orientation it needs to decelerate, otherwise it will rotate past the goal and have to stop and re-accelerate back toward the goal. This is often creates undesirable **rubber-banding** effect, so applying dampening using this property is how that effect is avoided. The higher this value is set, the greater the dampening curve becomes, or the slower the part will approach the goal orientation. */
	TurnD: number;
	/** The P property determines how much [power](https://en.wikipedia.org/wiki/Power_(physics)) is used while applying torque in order to face the `Target`. The higher this value, the more power will be used and the faster it will be used. */
	TurnP: number;
	/** Causes the Rocket to stop moving towards its target, making it fall. */
	Abort(): void;
	/** Causes the rocket to fly towards Target. */
	Fire(): void;
	/** Fired when the Rocket comes within TargetRadius of the Target. This is used to make the rocket work, such as make an explosion when it flies near the Target. */
	readonly ReachedTarget: RBXScriptSignal<() => void>;
}

interface BrowserService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BrowserService";
}

interface RbxInternalCacheableContentProvider extends RbxInternalInstance {}
/** A variant of the `ContentProvider` that caches assets that have already been received. This service is not used directly, but it is used by the services that inherit from it. */
type CacheableContentProvider = MeshContentProvider | SolidModelContentProvider;

/** A service that is internally responsible for fetching, parsing, and caching meshes. */
interface MeshContentProvider extends RbxInternalCacheableContentProvider {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "MeshContentProvider";
}

/** An internal `ContentProvider` for preloading solid models. */
interface SolidModelContentProvider extends RbxInternalCacheableContentProvider {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SolidModelContentProvider";
}

/** The Camera object defines a view of the 3D game world. 

## Where the Camera object is found
In an instance of the game, each client has its own Camera object associated with it. Camera objects exist only upon the viewer's client, residing in that user's local Workspace, and therefore cannot be edited directly from the server. 

Each client's particular Camera object can be accessed through the `CurrentCamera` property of the `Workspace` on that client.

Note, `CurrentCamera` can also be used to find the Camera object in Roblox Studio.

## How the Camera object works

The Camera's properties define the current view of the 3D game world. The most important of these being:

 - The `CFrame` property represents the position and orientation of the camera.
 - The `Focus` property represents the point the camera is looking at. It is important this property is set as it also represents where the game thinks you are in the world. Certain visuals will be more detailed and will update more frequently, depending on how close they are to the Focus. Roblox's default [camera scripts][1] take care of this.
 - The `CameraType` property is read by the game's [camera scripts][1] and determines how the Camera should update each frame.
 - The `CameraSubject` property is read by the game's [camera scripts][1] and determines what object the Camera should follow.
 - The `FieldOfView` property represents the extent of the observable world visible.
 - An internal roll amount, set by `SetRoll`, determines the angle the camera is rotated by on the longitudinal axis (the roll).

## How to work with the Camera

Roblox's [camera scripts][1] update the Camera's properties every frame dependent on the current `CameraType`. This means developers looking to control the Camera themselves have two options.

 1. Setting the `CameraType` property to *'Scriptable'*. When the Camera is in *'Scriptable'* mode the default [camera scripts][1] will not update the camera. In most cases this is the easiest option.
 2. Replacing or modifying the default [camera scripts][1] in `StarterPlayer.StarterPlayerScripts`. This is only recommended for advanced developers.

  [1]: http://robloxdev.com/articles/Movement-and-camera-controls */
interface Camera extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Camera";
	/** This property is the `CFrame` of the `Camera` and definies its position and orientation in the 3D world.

Some transformations, such as the rotation of the head when using VR devices are not reflected in this property. For this reason, developers should use `GetRenderCFrame` to obtain the ‘true’ `CFrame` of the `Camera`.

## How to set the Camera's CFrame

You can move the  `Camera` by setting the CFrame property. However, the default [camera scripts][1] also set the CFrame property. When manually setting the CFrame property, it may be overwritten by the [camera scripts][1] which update every frame. There are two options to address this:

 1. Set the `Camera` `CameraType` to *'Scriptable'*. When the `Camera` is *'Scriptable'* the default scripts will not update the CFrame. This method is simplest and recommended in most cases

 2. Replace the default [camera scripts][1] with an alternative that doesn't interfere with the developer's desired implementation. This is only recommended when developers do not need any default `Camera` functionality

## How the Camera CFrame works

Like all `CFrame` data, the `Camera` CFrame represents a position and an orientation. 

The most intuitive way to position and orientate the `Camera` is by using the *new* `CFrame` constructor with the *pos* and *lookAt* parameters, for example:

```lua
local pos = Vector3.new(0, 10, 0)
local lookAt = Vector3.new(10, 0, 0)
local cameraCFrame = CFrame.new(pos, lookAt)
workspace.CurrentCamera.CFrame = cameraCFrame
```

In the above example the `Camera` is positioned at *0, 10, 0* and oriented to be looking towards *10, 0, 0*.  

## Animating the Camera CFrame

Although the `Camera` can be placed in the manner demonstrated above, you may want to animate the Camera to smoothly move from one `CFrame` to another. For this, there are a number of options:

 1. Creating a `Tween` using `TweenService` that animates the CFrame property of the `Camera`. See the code sample below for an example of this
2. Setting the `Camera` CFrame every frame with `BindToRenderStep` and the *lerp* `CFrame` method

  [1]: http://robloxdev.com/articles/Movement-and-camera-controls

## Code Samples

### Basic Camera Cutscene

In this code sample a simple `Camera` animation is played after the `LocalPlayer` spawns using `TweenService`. The `CameraType` of the `Camera` is set to *'Scriptable'* so the default camera scripts do not interfere.
```lua
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

function playCutscene(character)
	local primaryPart = character.PrimaryPart

	camera.CameraType = Enum.CameraType.Scriptable 
	

	local baseCFrame = primaryPart.CFrame * CFrame.new(0, 0, -100) * CFrame.Angles(0, math.pi, 0)
	local targetCFrame = primaryPart.CFrame * CFrame.new(0, 0, -10) * CFrame.Angles(0, math.pi, 0)

	camera.CFrame = baseCFrame 

	local tween = TweenService:Create(
		camera,
		TweenInfo.new(2),
		{CFrame = targetCFrame}
	)

	tween:Play()
	tween.Completed:Wait()
	camera.CameraType = Enum.CameraType.Custom
end

localPlayer.CharacterAdded:Connect(function(character)
	wait(3)
	playCutscene(game.Players.LocalPlayer.Character)
end)


```
 */
	CFrame: CFrame;
	/** When using the default [camera scripts][1], the CameraSubject property has two roles:

 - Defining the object the `Camera` is to follow, in the case of the *'Follow'*, *'Attach'*, *'Track'*, *'Watch'* and *'Custom'* `CameraTypes`
 - For all `CameraTypes` but *'Scriptable'*, the object whose position the `Camera's` `Focus` will be set to

CameraSubject accepts a variety of `Instances`. The default [camera scripts][1] respond differently to different CameraSubject types:

 - `Humanoid`: By default the CameraSubject is set to the `LocalPlayer's` `Humanoid`. The camera scripts will follow the `Humanoid` factoring in the `Humanoid's` current state and `CameraOffset`
 - `BasePart`: The camera scripts will follow the position of any `BasePart`, with a vertical offset in the case of `VehicleSeats`

You can configure the `Camera` to follow a `Model` by setting the CameraSubject to the model’s `PrimaryPart`.

The CameraSubject cannot be set to *nil*. If it is, it will revert to its previous value.

To restore the CameraSubject to its default value, set it to the `LocalPlayer's` `Humanoid` like so:

```lua
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer

local function resetCameraSubject()
	if workspace.CurrentCamera and localPlayer.Character then
		local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			workspace.CurrentCamera.CameraSubject = humanoid
		end
	end
end
```


  [1]: http://robloxdev.com/articles/Movement-and-camera-controls */
	CameraSubject: Humanoid | BasePart | undefined;
	/** The default Roblox [camera scripts][1] have several built in behaviors. Setting the CameraType of a player's `Camera` will toggle between these behaviors. Note some CameraType's require a valid `CameraSubject` to work correctly.

 - Fixed: `Camera` is stationary
 - Follow: `Camera` moves with the `CameraSubject` and rotates to keep the subject in the center of view
 - Attach: `Camera` moves with the `CameraSubject` at a fixed offset and will rotate as the subject rotates
 - Track: `Camera` moves with the `CameraSubject` but does not rotate automatically
 - Watch: `Camera` is stationary but will rotate to keep the `CameraSubject` in the center of view
 - Custom: Default
 - Scriptable: No default behavior. Used by developers to script custom behavior 

The above only applies when you use the default Roblox [camera scripts][1]. If you write your own camera scripts, you can choose to listen to CameraType and implement your own behaviors or ignore the property entirely.

## Manually controlling the Camera

In some cases you may wish to manually control the `Camera` (for example during a cut-scene). The best way to do this is by setting the CameraType to *'Scriptable'*. The default [camera scripts][1] will not move or update the `Camera` on its own if CameraType is set to *’Scriptable’*. This means you can freely modify the `Camera` using its properties and functions. For more information on positioning and orientating the `Camera` manually see the `Camera.CFrame` page.

If you want complete control over the camera at all times, you may replace the default [camera scripts][1] with your own.

  [1]: http://robloxdev.com/articles/Movement-and-camera-controls

## Code Samples

### Basic Camera Cutscene

In this code sample a simple `Camera` animation is played after the `LocalPlayer` spawns using `TweenService`. The `CameraType` of the `Camera` is set to *'Scriptable'* so the default camera scripts do not interfere.
```lua
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

function playCutscene(character)
	local primaryPart = character.PrimaryPart

	camera.CameraType = Enum.CameraType.Scriptable 
	

	local baseCFrame = primaryPart.CFrame * CFrame.new(0, 0, -100) * CFrame.Angles(0, math.pi, 0)
	local targetCFrame = primaryPart.CFrame * CFrame.new(0, 0, -10) * CFrame.Angles(0, math.pi, 0)

	camera.CFrame = baseCFrame 

	local tween = TweenService:Create(
		camera,
		TweenInfo.new(2),
		{CFrame = targetCFrame}
	)

	tween:Play()
	tween.Completed:Wait()
	camera.CameraType = Enum.CameraType.Custom
end

localPlayer.CharacterAdded:Connect(function(character)
	wait(3)
	playCutscene(game.Players.LocalPlayer.Character)
end)


```
 */
	CameraType: Enum.CameraType;
	/** Field of view, often shortened to FOV, is the extent of the observable game world that can be seen on screen at a given moment. The FieldOfView property is clamped between 1 and 120 degrees and defaults at 70. Very low or very high fields of view are not recommended as they can be disorientating to players.

The FieldOfView property sets how many degrees in the vertical direction (y-axis) the camera can view. Uniform scaling is enforced meaning the vertical and horizontal field of view are always related by the [aspect ratio][1] of the screen. This means the FieldOfView property also determines the horizontal field of view.

See the images below for an example of how different FieldOfView settings can impact the extent of the perceptive game world. At a FOV of 70, a considerable portion of the game world is visible:

![A demonstration of the default FOV of 70](https://developer.roblox.com/assets/5b676631f9cd894d3d8ace1f/Fov70.png)

However when the FOV is reduced to 30, although the `Camera's` `CFrame` has not changed, a much smaller portion of the game world is rendered:

![A demonstration of a reduced FOV of 30](https://developer.roblox.com/assets/5b67662a74c0756340c86bfa/Fov30.png)

## Suggested uses for FieldOfView

Changing FOV can produce a variety of effects, such as:

 - Reducing FOV to give the impression of magnification (for example when using binoculars)
 - Increasing FOV when the player is 'sprinting' to give the impression of a lack of control

  [1]: https://en.wikipedia.org/wiki/Aspect_ratio_(image) */
	FieldOfView: number;
	/** The `Camera` Focus is a `CFrame` that determines the area in 3D space the graphics engine will prioritize. 

Certain graphical operations Roblox performs, such as updating lighting, can take a lot of time or computational effort to complete. Focus tells Roblox the area in 3D space to prioritize when performing such operations. For example dynamic lighting from objects such as `PointLights` may not render at distances far from the Focus.

The default Roblox [camera scripts][1] automatically set the Focus to follow the `CameraSubject` (usually a `Humanoid`). However, Focus will not be automatically updated in the following cases:

 - When the `CameraType` is set to *'Scriptable'*
 - When the default [camera scripts][1] are not being used

In these cases, you should update Focus every frame, using `BindToRenderStep` function at the *'Camera'* `RenderPriority`.

Focus has no bearing on the positioning or orientation of the `Camera` (see `Camera.CFrame` for this).

  [1]: http://robloxdev.com/articles/Movement-and-camera-controls

## Code Samples

### Following Camera

When the following code is placed inside a `LocalScript` named *'CameraScript'* parented to `StarterPlayer.StarterPlayerScripts` the default Roblox camera scripts are overwritten and replaced with a custom following camera.
```lua
-- Make variables for Roblox services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
 
-- Make variable for the camera offset
local OFFSET = Vector3.new(20,20,20)
 
-- Make variables for the player and camera
local player = Players.LocalPlayer
local camera = game.Workspace.CurrentCamera
 
-- Detatch the character's rotation from the camera
UserSettings().GameSettings.RotationType = Enum.RotationType.MovementRelative

-- Function to call on the render step
local function onRenderStep()
	-- Check if the player's character exists and if that character'script
	-- HumanoidRootPart exists
	local character = player.Character
	if character then
		local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
		if humanoidRootPart then
			-- Update the position of the camera
			local playerPosition = humanoidRootPart.Position
			local cameraPosition = playerPosition + OFFSET
			camera.CoordinateFrame = CFrame.new(cameraPosition, playerPosition)
 
			-- Update the focus of the camera to follow the character
			camera.Focus = humanoidRootPart.CFrame
		end
	end
end
 
-- Binds function to render step at camera priority
RunService:BindToRenderStep("Camera", Enum.RenderPriority.Camera.Value, onRenderStep)
```
 */
	Focus: CFrame;
	/** Un-linking the camera from a VR user's head motions can cause motion sickness. This property should only be set to false after extensive testing.


Toggles whether the `Camera` will automatically track the head motion of a player using a VR device.

When HeadLocked is *true*, the engine will combine the `Camera` `CFrame` with the `CFrame` of the user's head to render the position and orientation of the `Camera` correctly. The camera will be rendered at the following `CFrame`:

```lua
local UserInputService = game:GetService("UserInputService")
local headCFrame = UserInputService:GetUserCFrame(Enum.UserCFrame.Head)
renderCFrame = workspace.CurrentCamera.CFrame * headCFrame
```


## Disabling HeadLocked
You are recommended not to disable HeadLocked for the following reasons:

 - Players may experience motion sickness if an equivalent head tracking solution is not added 
 - The Roblox engine performs latency optimizations when HeadLocked is true

However in some circumstances you may wish to develop your own head tracking systems. For example, you may want custom camera transformations that restrict or augment the `CFrame` of the head. 

## See also

 - `UserInputService's` `GetUserCFrame` function, which can be used to obtain the `CFrame` of the head
 - `UserInputService's` `RecenterUserHeadCFrame` which is used to recenter the head to the current position and orientation of the VR device
 - The `GetRenderCFrame` function which returns the `Camera` `CFrame` combined with the `CFrame` of the user's head */
	HeadLocked: boolean;
	/** HeadScale is the scale of the user’s head when using VR.

The unit scale of Roblox, from the user's perspective in VR, is defined as follows:

*unitScale = HeadScale (in studs) / Feet ^ 2*

This means the larger the HeadScale value, the smaller the world will look from the user's perspective when using VR devices. 

When not using VR, this property has no effect.

This property should not be confused with `Humanoid` HeadScale, which is a `NumberValue` parented to a `Humanoid` to control its scaling.

## See also
The following are also useful when developing for VR:

 - `HeadLocked`
 - `GetRenderCFrame` */
	HeadScale: number;
	/** The NearPlaneZ property describes how far away the Camera’s near clipping plane is in studs. The near clipping plane is a geometric plane that sits in-front of the `Camera's` `CFrame`. Anything between this plane and the camera will not render. This creates a cutaway view when viewing objects at very short distances. See the images below for a visual example of this:

![A demonstration of how the near clipping plane resides in front of the camera's view](https://developer.roblox.com/assets/5b65d852858e507e4016d57d/NearPlaneZ1.jpg)
![A demonstration of how anything falling behind the clipping plane is not rendered](https://developer.roblox.com/assets/5b65d85c858e507e4016d583/NearPlaneZ2.jpg)

The value of NearPlaneZ varies across different platforms, but is currently always between *-0.1* and *-0.5*.

 - Most windows systems, all Xbox systems and most iOS systems support the more precise value of *-0.1*
 - Currently Mac and Android systems only support a NearPlaneZ of *-0.5*, although this may change in the future */
	readonly NearPlaneZ: number;
	/** ViewportSize describes the dimensions, in pixels, of the client's viewport.

![A visual demonstration of the ViewportSize](https://developer.roblox.com/assets/5b65d49954f6677d407bbad6/ViewportSize.png)

 - This property ignores the GUI inset applied by the top bar, meaning the center of the screen can be found at precisely at 50% of the ViewportSize in both directions
 - You can find the position of a `Vector3` in the world on the viewport using `WorldToViewportPoint` */
	readonly ViewportSize: Vector2;
	/** This function is used by *‘PopperCam’* in the default [camera scripts][1] to ensure obstructions do not come between the `Camera` and the `Camera’s` subject.

This function will check all `BaseParts` and `Terrain` in the `Workspace` with the following exceptions:

 - Any `Instance` specified in the *ignoreList* (including its descendants) will be ignored
 - `BaseParts` with `CanCollide` set to false are ignored
 - `BaseParts` with a `Transparency` greater than 0.95 will be ignored
Water `Terrain` is ignored 

Note, as this function requires an *ignoreList* to run, you should pass an empty table when none is required. 

  [1]: http://robloxdev.com/articles/Movement-and-camera-controls
@param ignoreList An array of `Instance|Instances` to ignore. Descendants of these instances will also be ignored.
@returns The distance, in studs, that the `Camera` needs to be pushed towards its `Camera/Focus` to ensure there are no obstructions between the `Camera/Focus` and `Camera/CFrame` of the `Camera` */
	GetLargestCutoffDistance(ignoreList: Array<Instance>): number;
	/** This function is broken and should not be used


This function returns the current ‘pan’ speed of the `Camera`.

The ‘pan’ speed of the `Camera` describes the speed at which the `Camera` is rotating around its `Focus` around the Y axis.

 - `GetTiltSpeed` for the speed at which the `Camera` is rotating around its `Focus` on the `Camera’s` X axis
 - `PanUnits` to ‘pan’ the camera
 - `TiltUnits` to ‘tilt’ the camera
@returns The speed at which the `Camera` is rotating around its `Camera/Focus` on the Y axis */
	GetPanSpeed(): number;
	/** This function returns an array of `BaseParts` that are obscuring the lines of sight between `Camera’s` `CFrame` and the *castPoints*.

GetPartsObscuringTarget is used by the ‘Invisicam’ in in the default [camera scripts][1] to hide parts between the `Camera’s` `CFrame` and `Focus`.

Any `Instances` included in the *ignoreList* array will, along with their descendants, be ignored. 

See below for a visual example of this function. The `Camera` is represented by the grey camera model and the cast points are represented by the colored dots. The `Parts` highlighted in red are the ones that would be returned.

![A visual demonstration of the function](https://developer.roblox.com/assets/5b842528a3326f570bb88a6b/GetPartsObscuringTarget.png)

The castPoints parameter is given as an array of `Vector3s`, for example:

```lua
local castPoints = {Vector3.new(0, 10, 0), Vector3.new(0, 15, 0)}
local ignoreList = {}
workspace.CurrentCamera:GetPartsObscuringTarget(castPoints, ignoreList)
```


The array of `BaseParts` returned is in an arbitrary order, and no additional raycast data is provided (for example hit position, hit material and surface normal). If this information is required, you should a `Workspace` raycast function such as `FindPartOnRayWithIgnoreList`.

If `Terrain` obscures a cast point, `BaseParts` obscuring the cast point between the obscuring `Terrain` and the cast point will not be returned.

Note, this function benefits from internal optimisations that make it more performant than casting a ray for each cast point individually.

  [1]: http://robloxdev.com/articles/Movement-and-camera-controls

## Code Samples

### X-Ray Function

This function will make any `BaseParts`, `Decals` or `Textures` coming between the `CurrentCamera` and the given cast points translucent.
```lua
local function XRay(castPoints, ignoreList)
	ignoreList = ignoreList or {}
	local parts = workspace.CurrentCamera:GetPartsObscuringTarget(castPoints, ignoreList)

	for _, part in pairs(parts) do
		part.LocalTransparencyModifier = 0.75
		for _, child in pairs(part:GetChildren()) do
			if child:IsA("Decal") or child:IsA("Texture") then
				child.LocalTransparencyModifier = 0.75
			end
		end
	end
end

```

@param castPoints An array of `DataType/Vector3` positions of cast points

@param ignoreList An array of `Instance|Instances` that, along with their descendants, are to be ignored
@returns An array of `BasePart|BaseParts` that obscure the lines of sight between the `Camera|Camera’s` `Camera/CFrame` and the *castPoints* */
	GetPartsObscuringTarget(castPoints: Array<Vector3>, ignoreList: Array<Instance>): Array<Instance>;
	/** This function returns the actual `CFrame` of the `Camera` as it is rendered. This includes any roll applied using `SetRoll` and the impact of VR.

VR head transformations, along with roll applied using `SetRoll` is not applied to the `CFrame` property. For this reason, it is best practice to use `GetRenderCFrame` to obtain the ‘true’ `CFrame` of the `Camera`.

For example, when using VR the `Camera` is actually rendered at the following `CFrame`:

```lua
local UserInputService = game:GetService("UserInputService")

local headCFrame = UserInputService:GetUserCFrame(Enum.UserCFrame.Head)
renderCFrame = workspace.CurrentCamera.CFrame * headCFrame
```


The `Camera’s` render `CFrame` will only be changed to account for the head when the `HeadLocked` property is true.
@returns The `DataType/CFrame` the `Camera` is being rendered at */
	GetRenderCFrame(): CFrame;
	/** This function returns, in radians, the current roll applied to the `Camera` using `SetRoll`. Roll is defined as rotation around the `Camera’s` Z-axis.

This function only returns roll applied using the `SetRoll` function. Roll manually applied to the `Camera’s` `CFrame` is not accounted for. To obtain the actual roll of the `Camera`, including roll manually applied, you can use the following snippet:

```lua
local function getActualRoll()
	local camera = workspace.CurrentCamera

	local trueUp = Vector3.new(0, 1, 0)
	local cameraUp = camera:GetRenderCFrame().upVector

	return math.acos(trueUp:Dot(cameraUp))
end
```

## Code Samples

### Camera:GetRoll

This example, when used in a `/LocalScript`, will retrieve the current roll of the camera in degrees. Then, if the camera roll angle is not 20 degrees, the camera roll angle is set to 20 degrees.
```lua
local currentRoll = math.deg(game.Workspace.CurrentCamera:GetRoll()) -- Gets the current roll of the camera in degrees.

if currentRoll ~= 20 then
	game.Workspace.CurrentCamera:SetRoll(math.rad(20)) -- If the camera isn't at 20 degrees roll, the roll is set to 20 degrees.
end
```

@returns The current roll applied by `Camera/SetRoll`, in radians */
	GetRoll(): number;
	/** This function is broken and should not be used


This function returns the current ‘tilt’ speed of the `Camera`.

The 'tilt’ speed of the `Camera` describes the speed at which the `Camera` is rotating around its `Focus` around the `Camera’s` X axis.

See also:
`GetPanSpeed` for the speed the `Camera` is rotating around the `Focus` around the Y axis
`PanUnits` to ‘pan’ the camera
`TiltUnits` to ‘tilt’ the camera
@returns The speed at which the `Camera` is rotating around its `Camera/Focus` around the `Camera|Camera’s` X axis */
	GetTiltSpeed(): number;
	/** This function tweens the `Camera` in a linear fashion towards a new `CFrame` and `Focus` over a given duration, for example:

```lua
local camera = workspace.CurrentCamera
camera.CameraType = Enum.CameraType.Scriptable

camera:Interpolate(
	CFrame.new(0, 10, 100),
	CFrame.new(0, 0, 100),
	5
)
```


Throughout the tween, the `Camera’s` `CFrame` will be orientated towards the `Camera’s` `Focus`.

When the tween has completed, the `Camera’s` `InterpolationFinished` event will fire.

If this function is called while the `Camera` is already tweening the older tween will be stopped (without firing `InterpolationFinished`) and overridden by the new tween.

Interpolate can only be used if the current `CameraType` is *’Scriptable’*, regardless of whether the default [camera scripts][1] are being used. If it is used with any other `CameraType` an error will be thrown.

You are advised to use `TweenService` to tween the `Camera` instead as it is more reliable and offers a variety of easing styles. See below for an example:

```lua
local TweenService = game:GetService("TweenService")

local camera = workspace.CurrentCamera
camera.CameraType = Enum.CameraType.Scriptable

local tween = TweenService:Create(
	camera,
	TweenInfo.new(5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
	{
		CFrame = CFrame.new(0, 10, 100),
		Focus = CFrame.new(0, 0, 100)
	}
)

tween:Play()
```



  [1]: http://robloxdev.com/articles/Movement-and-camera-controls
@param endPos The `DataType/CFrame` for the `Camera` to tween to
@param endFocus The `DataType/CFrame`  for the `Camera|Camera’s` `Camera/Focus` to tween to
@param duration The duration, in seconds, of the tween
@returns No return */
	Interpolate(endPos: CFrame, endFocus: CFrame, duration: number): void;
	/** This function pans the `Camera` around the `Focus` in 45 degree increments around the Y axis.

The rotation is applied to the `Camera’s` `CFrame` property.

This function pans the `Camera` in 45 degree increments, for example:

```lua
workspace.CurrentCamera:PanUnits(1) -- 45 degrees
workspace.CurrentCamera:PanUnits(-2) -- -90 degrees
```

PanUnits does not require the `CameraType` to be *’Scriptable’*.
@param units The number of 45 degree increments by which to pan the `Camera`
@returns No return */
	PanUnits(units: number): void;
	/** This function creates a unit `Ray` from a 2D position on the screen (defined in pixels). This position accounts for the GUI inset. The `Ray` originates from the `Vector3` equivalent of the 2D position in the world at the given depth (in studs) away from the `Camera`.

As this function accounts for the GUI inset, the offset applied to GUI elements (such as from the top bar) is accounted for. This means the screen position specified will start in the top left corner below the top bar. For an otherwise identical function that does not account for the GUI offset, use `ViewportPointToRay`.

As the `Ray` created is a unit ray it is only one stud long. To create a longer ray, you can do the following:

```lua
local camera = workspace.CurrentCamera
local length = 500
local unitRay = camera:ScreenPointToRay(100, 100)
local ray = Ray.new(unitRay.Origin, unitRay.Direction * length)
```

## Code Samples

### Camera:ScreenPointToRay


```lua
local Camera = workspace.CurrentCamera
local Player = game:GetService("Players").LocalPlayer
local Mouse = Player:GetMouse()
 
--This will create a cube facing centered at the origin of the [[Ray]] returned and facing in the same direction. The center of the cube will be one stud in front of the camera.
Mouse.Button1Down:Connect(function()
	local ray = Camera:ScreenPointToRay(Mouse.X, Mouse.Y, 1)
    local cube = Instance.new("Part", workspace)
    cube.Size = Vector3.new(1, 1, 1)
    cube.CFrame = CFrame.new(ray.Origin, ray.Origin + ray.Direction)
    cube.Anchored = true
end)
```

@param x The position on the X axis, in pixels, of the screen point at which to originate the `DataType/Ray`. This position accounts for the GUI inset
@param y The position on the Y axis, in pixels, of the screen point at which to originate the `DataType/Ray`. This position accounts for the GUI inset
@param depth The depth from the `Camera`, in studs, from which to offset the origin of the `DataType/Ray`
@returns A unit `DataType/Ray`, originating from the equivalent `DataType/Vector3` world position of the given screen coordinates at the given depth away from the `Camera`. This ray is orientated in the direction of the `Camera` */
	ScreenPointToRay(x: number, y: number, depth?: number): Ray;
	/** This function sets the `CameraPanMode` to be used by the `Camera` on mobile devices.

When the *‘EdgeBump’ `CameraPanMode` is used, swipe to pan is disabled and the edge bump camera controls are enabled.

SetCameraPan mode has no effect on PC / Mac users.
@param mode The `Enum/CameraPanMode` to set the `Camera` to
@returns No return */
	SetCameraPanMode(mode?: CastsToEnum<Enum.CameraPanMode>): void;
	/** This function is outdated and no longer considered best practice.


This function sets the current roll, in radians, of the `Camera`. The roll is applied after the `CFrame` and represents the rotation around the `Camera’s` Z-axis.

For example, the following would invert the `Camera`:

```lua
workspace.CurrentCamera:SetRoll(math.pi) -- math.pi radians = 180 degrees
```


SetRoll has no effect on any roll applied using the `CFrame` property. Roll applied using SetRoll is not reflected in the `CFrame` property but is reflected in in the `CFrame` returned by`GetRenderCFrame`.

This function can only be used when the `CameraType` is set to *‘Scriptable’*, regardless of whether the default [camera scripts][1] are being used. If it is used with any other `CameraType` a warning is given in the output. 

Any roll applied using this function will be lost when the `CameraType` is changed from *’Scriptable’*.

To obtain the roll set using this function use `GetRoll`.

As this function is outdated, you are advised to instead apply roll to the `Camera` using the `CFrame` property. For example:

```lua
local currentCFrame = workspace.CurrentCamera.CFrame
local rollCFrame = CFrame.Angles(0, 0, roll)
workspace.CurrentCamera.CFrame = currentCFrame * rollCFrame
```


  [1]: http://robloxdev.com/articles/Movement-and-camera-controls
@param rollAngle The roll angle, in radians, to be applied to the `Camera`
@returns No return */
	SetRoll(rollAngle: number): void;
	/** This function ‘tilts’ the `Camera` by rotating it around the `Focus` around the `Camera’s` X axis by a given multiple of 10 degrees.

The rotation is applied to the `Camera’s` `CFrame` property and is constrained between *-81.05* and *81.05* degrees.

This function tilts the `Camera` in 10 degree increments, for example:

```lua
workspace.CurrentCamera:TiltUnits(2) -- 20 degrees
workspace.CurrentCamera:TiltUnits(-5) -- -50 degrees
```


TiltUnits does not require the `CameraType` to be *’Scriptable’*.

## See also
 - `PanUnits`
@param units The number of 10 degree units by which to to tilt the `Camera`
@returns Whether the `Camera` tilt applied was constrained */
	TiltUnits(units: number): boolean;
	/** This function creates a unit `Ray` from a 2D position on the viewport (defined in pixels). This position does not account for the GUI inset. The `Ray` originates from the `Vector3` equivalent of the 2D position in the world at the given depth (in studs) away from the `Camera`.

As this function does not account for the GUI inset, the viewport position given is not equivalent to the screen position used by GUI elements. If you are not using `IgnoreGuiInset` and need an otherwise identical function that accounts for the GUI offset, use `ScreenPointToRay`.

This function can be used in conjunction with the `ViewportSize` property to create a ray from the centre of the screen, for example:


```lua
local camera = workspace.CurrentCamera
local viewportPoint = camera.ViewportSize / 2
local unitRay = camera:ViewportPointToRay(viewportPoint.X, viewportPoint.Y, 0)
```


As the `Ray` created is a unit ray it is only one stud long. To create a longer ray, you can do the following:

```lua
local camera = workspace.CurrentCamera
local length = 500
local unitRay = camera:ScreenPointToRay(100, 100)
local ray = Ray.new(unitRay.Origin, unitRay.Direction * length)
```
@param x The position on the X axis, in pixels, of the viewport point at which to originate the `DataType/Ray`. This position does not account for the GUI inset
@param y The position on the Y axis, in pixels, of the viewport point at which to originate the `DataType/Ray`. This position does not account for the GUI inset
@param depth The depth from the `Camera`, in studs, from which to offset the origin of the `DataType/Ray`
@returns A unit `DataType/Ray`, originating from the equivalent `DataType/Vector3` world position of the given viewport coordinates at the given depth away from the `Camera`. This ray is orientated in the direction of the `Camera` */
	ViewportPointToRay(x: number, y: number, depth?: number): Ray;
	/** This function returns the screen location and depth of a `Vector3` *worldPoint* and whether this point is visible on the screen or not.

This function takes in account the current GUI inset (such as the space occupied by the top bar). This means the 2D position returned is in the same term as GUI positions and can be used to place GUI elements. For an otherwise identical function that ignores the GUI inset, see `WorldToViewportPoint`. 

For example:

```lua
local camera = workspace.CurrentCamera
Local worldPoint = Vector3.new(0, 10, 0)
local vector, onScreen = camera:WorldToScreenPoint(worldPoint)

local screenPoint = Vector2.new(vector.X, vector.Y)
local depth = vector.Z
```


Note this function does not perform any raycasting, meaning the visible bool will be true regardless if the *worldPoint* is obscured by `BaseParts` or `Terrain`.
@param worldPoint The `DataType/Vector3` world position
@returns A tuple containing, in order:

A `DataType/Vector3` whose X and Y components represent the offset of the *worldPoint* from the top left corner of the screen, in pixels. The `DataType/Vector3|Vector3’s` Z component represents the depth of the *worldPoint* from the screen (in studs).

A bool indicating if the *worldPoint* is within the bounds of the screen
 */
	WorldToScreenPoint(worldPoint: Vector3): LuaTuple<[Vector3, boolean]>;
	/** This function returns the screen location and depth of a `Vector3` *worldPoint* and whether this point is visible on the screen or not.

This function does not take in account the current GUI inset (such as the space occupied by the top bar). This means the 2D position returned is taken from the top left corner of the viewport. This means, unless you are using `IgnoreGuiInset` this position is not appropriate for placing GUI elements. For an otherwise identical function that accounts for the GUI inset, see `WorldToScreenPoint`. 

For example:

```lua
local camera = workspace.CurrentCamera
local worldPoint = Vector3.new(0, 10, 0)
local vector, inViewport = camera:WorldToViewportPoint(worldPoint)

local viewportPoint = Vector2.new(vector.X, vector.Y)
local depth = vector.Z
```


Note this function does not perform any raycasting, meaning the visible bool will be true regardless if the *worldPoint* is obscured by `BaseParts` or `Terrain`.

## Code Samples

### Check if a point is visible

The following function returns true if a `Vector3` is visible on screen and unobscured by `BaseParts` and `Terrain`.
```lua
local function isPointVisible(worldPoint)
    local camera = workspace.CurrentCamera
    local vector, onScreen = camera:WorldToViewportPoint(worldPoint)
    
    if onScreen then
        local origin = camera.CFrame.p
        local ray = Ray.new(origin, worldPoint - origin)
        local hit = workspace:FindPartOnRay(ray)
        if hit then
            return false
        end
    else
        return false
    end
    return true
end

```

@param worldPoint The `DataType/Vector3` world position
@returns A tuple containing, in order:

 A `DataType/Vector3` whose X and Y components represent the offset of the *worldPoint* from the top left corner of the viewport, in pixels. The `DataType/Vector3|Vector3’s` Z component represents the depth of the *worldPoint* from the screen (in studs).

A bool indicating if the *worldPoint* is within the bounds of the viewport.
 */
	WorldToViewportPoint(worldPoint: Vector3): LuaTuple<[Vector3, boolean]>;
	/** This event fires when the `Camera` has finished interpolating using the `Interpolate` function.

This event will not fire if a tween is interrupted due to `Interpolate` being called again.

You are advised to use `TweenService` to animate the `Camera` instead, as it is more reliable and provides more options for easing styles. */
	readonly InterpolationFinished: RBXScriptSignal<() => void>;
}

/** The ChangeHistoryService provides a way for plugins to undo and redo changes and to create waypoints when changes are made to the place. */
interface ChangeHistoryService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ChangeHistoryService";
}

interface RbxInternalCharacterAppearance extends RbxInternalInstance {}
/** Base class for objects that change a character's appearance. */
type CharacterAppearance = BodyColors | CharacterMesh | Clothing | ShirtGraphic | Skin;

/** BodyColors is a utility object used by Roblox to load avatar body colors from the website.

Avatars that are loaded from the website will automatically have a BodyColors object corresponding to said avatar's body color configuration.

When parented inside of a character with a `Humanoid`, it will apply the colors to each specified limb. */
interface BodyColors extends RbxInternalCharacterAppearance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BodyColors";
	/** Sets the color of this limb, as a [BrickColor](https://developer.roblox.com/api-reference/datatype/BrickColor "API:BrickColor")
. */
	HeadColor: BrickColor;
	/** Sets the color of this limb, as a [Color3](https://developer.roblox.com/api-reference/datatype/Color3 "API:Color3")
. */
	HeadColor3: Color3;
	/** Sets the color of this limb, as a [BrickColor](https://developer.roblox.com/api-reference/datatype/BrickColor "API:BrickColor")
. */
	LeftArmColor: BrickColor;
	/** Sets the color of this limb, as a [Color3](https://developer.roblox.com/api-reference/datatype/Color3 "API:Color3")
. */
	LeftArmColor3: Color3;
	/** Sets the color of this limb, as a [BrickColor](https://developer.roblox.com/api-reference/datatype/BrickColor "API:BrickColor")
. */
	LeftLegColor: BrickColor;
	/** Sets the color of this limb, as a [Color3](https://developer.roblox.com/api-reference/datatype/Color3 "API:Color3")
. */
	LeftLegColor3: Color3;
	/** Sets the color of this limb, as a [BrickColor](https://developer.roblox.com/api-reference/datatype/BrickColor "API:BrickColor")
. */
	RightArmColor: BrickColor;
	/** Sets the color of this limb, as a [Color3](https://developer.roblox.com/api-reference/datatype/Color3 "API:Color3")
. */
	RightArmColor3: Color3;
	/** Sets the color of this limb, as a [BrickColor](https://developer.roblox.com/api-reference/datatype/BrickColor "API:BrickColor")
. */
	RightLegColor: BrickColor;
	/** Sets the color of this limb, as a [Color3](https://developer.roblox.com/api-reference/datatype/Color3 "API:Color3")
. */
	RightLegColor3: Color3;
	/** Sets the color of this limb, as a [BrickColor](https://developer.roblox.com/api-reference/datatype/BrickColor "API:BrickColor")
. */
	TorsoColor: BrickColor;
	/** Sets the color of this limb, as a [Color3](https://developer.roblox.com/api-reference/datatype/Color3 "API:Color3")
. */
	TorsoColor3: Color3;
}

/** Modifies the appearance of an R6 body part.
This object has no effect in R15 characters. */
interface CharacterMesh extends RbxInternalCharacterAppearance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CharacterMesh";
	/** The texture of a CharacterMesh. It can be overridden by Shirts, Pants, T-Shirts, and the `OverlayTextureId` property. */
	BaseTextureId: number;
	/** The part of the Character's body that is affected. */
	BodyPart: Enum.BodyPart;
	/** Used to load a mesh file, and apply it to the given BodyPart. */
	MeshId: number;
	/** The assetId of the overlay texture. The overlay covers Shirts, Pants, T-Shirts, and the `BaseTextureId`. */
	OverlayTextureId: number;
}

interface RbxInternalClothing extends RbxInternalCharacterAppearance {
	/** [LACKS DOCUMENTATION] */
	Color3: Color3;
}
/** The base class for clothing objects. */
type Clothing = Pants | Shirt;

/** The Pants object displays shirts on a character model. Pants are items of clothing that cover the legs and torso of the character based on a predefined texture uploaded to Roblox.

## How do Pants work?

Pants only have one property, `PantsTemplate`. This is a content ID pointing to the pant's texture on the Roblox website.

A Pants object parented to a model will display the pants on the model provided a `Humanoid` is present and the limbs required for the pants corresponding with the humanoid's `RigType` exist. 

Note if multiple Pants objects are present in a model only one will be shown. However both a `Shirt` and Pants object will be shown together with the shirt drawn on top (as pants also cover the torso).

Pants automatically load onto new characters spawning based on the `CharacterAppearance` property.

## How do I make Pants?

In order to make a pants a texture (image) determining what will be displayed on what limbs needs to be uploaded to the Roblox website. For more information, please see [this tutorial][1].

  [1]: /articles/How-to-Make-Shirts-and-Pants-for-Roblox-Characters

## Code Samples

### Change Shirt / Pants

This sample includes a simple function to change the texture of the `Shirt` and `Pants` worn by a player's character. If shirt and pants don't exist then they are created. Note, this should be run every time the character spawns. If a developer is looking to permanently change a character's appearance to a preset it is recommended they use `CharacterAppearance`.
```lua
    local function replaceClothes(player)
    	local character = player.Character
    	if character then 
    		-- look for shirts / pants
    		local shirt = character:FindFirstChildOfClass("Shirt")
    		local pants = character:FindFirstChildOfClass("Pants")
    		-- create shirts / pants if they don't exist
    		if not shirt then 
    			shirt = Instance.new("Shirt", character)
    		end 
    		if not pants then 
    			pants = Instance.new("Pants", character)
     		end
    		-- reset shirt / pants content ids
    		shirt.ShirtTemplate = "http://www.roblox.com/asset/?id=83326831"
    		pants.PantsTemplate = "http://www.roblox.com/asset/?id=10045638"
    	end
    end
```
 */
interface Pants extends RbxInternalClothing {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Pants";
	/** Determines the texture of the `Pants`. The content ID link pointing to the pants template hosted on the Roblox website.

## How do I find the PantsTemplate?

This content ID is different to the website URL of the pants. The content ID can be found by pasting the website URL of the pants into the PantsTemplate property in Roblox Studio, as studio will correct it. Alternatively `LoadAsset` can be used to insert the pants into the workspace, for example:

    local webURL = "https://www.roblox.com/catalog/1804739/Jeans"
    local assetId = tonumber(string.match(webURL, "%d+") or 0) -- extract the number
    local success, model = pcall(function() 
    	return game:GetService("InsertService"):LoadAsset(assetId) 
    end)
    if success then 
    	model.Parent = workspace
    end

For a `Shirt` object's template, see `ShirtTemplate`.

## Code Samples

### Change Shirt / Pants

This sample includes a simple function to change the texture of the `Shirt` and `Pants` worn by a player's character. If shirt and pants don't exist then they are created. Note, this should be run every time the character spawns. If a developer is looking to permanently change a character's appearance to a preset it is recommended they use `CharacterAppearance`.
```lua
    local function replaceClothes(player)
    	local character = player.Character
    	if character then 
    		-- look for shirts / pants
    		local shirt = character:FindFirstChildOfClass("Shirt")
    		local pants = character:FindFirstChildOfClass("Pants")
    		-- create shirts / pants if they don't exist
    		if not shirt then 
    			shirt = Instance.new("Shirt", character)
    		end 
    		if not pants then 
    			pants = Instance.new("Pants", character)
     		end
    		-- reset shirt / pants content ids
    		shirt.ShirtTemplate = "http://www.roblox.com/asset/?id=83326831"
    		pants.PantsTemplate = "http://www.roblox.com/asset/?id=10045638"
    	end
    end
```
 */
	PantsTemplate: string;
}

/** The Shirt object is what displays Shirts on a character. The arms and torso are covered by this object.

## Code Samples

### Change Shirt / Pants

This sample includes a simple function to change the texture of the `Shirt` and `Pants` worn by a player's character. If shirt and pants don't exist then they are created. Note, this should be run every time the character spawns. If a developer is looking to permanently change a character's appearance to a preset it is recommended they use `CharacterAppearance`.
```lua
    local function replaceClothes(player)
    	local character = player.Character
    	if character then 
    		-- look for shirts / pants
    		local shirt = character:FindFirstChildOfClass("Shirt")
    		local pants = character:FindFirstChildOfClass("Pants")
    		-- create shirts / pants if they don't exist
    		if not shirt then 
    			shirt = Instance.new("Shirt", character)
    		end 
    		if not pants then 
    			pants = Instance.new("Pants", character)
     		end
    		-- reset shirt / pants content ids
    		shirt.ShirtTemplate = "http://www.roblox.com/asset/?id=83326831"
    		pants.PantsTemplate = "http://www.roblox.com/asset/?id=10045638"
    	end
    end
```
 */
interface Shirt extends RbxInternalClothing {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Shirt";
	/** The content ID link pointing to the shirt template hosted on the Roblox website. Determines the texture of the `Shirt`.

## How do I find the ShirtTemplate?

This content ID is different to the website URL of the shirt. The content ID can be found by pasting the website URL of the shirt into the ShirtTemplate property in Roblox Studio, as studio will correct it. Alternatively `LoadAsset` can be used to insert the shirt into the workspace, for example:

    local webURL = "https://www.roblox.com/catalog/1804747/White-Shirt"
    local assetId = tonumber(string.match(webURL, "%d+") or 0) -- extract the number
    local success, model = pcall(function() 
    	return game:GetService("InsertService"):LoadAsset(assetId) 
    end)
    if success then 
    	model.Parent = workspace
    end

See also `Graphic` for the image applied to T-shirts.

## Code Samples

### Change Shirt / Pants

This sample includes a simple function to change the texture of the `Shirt` and `Pants` worn by a player's character. If shirt and pants don't exist then they are created. Note, this should be run every time the character spawns. If a developer is looking to permanently change a character's appearance to a preset it is recommended they use `CharacterAppearance`.
```lua
    local function replaceClothes(player)
    	local character = player.Character
    	if character then 
    		-- look for shirts / pants
    		local shirt = character:FindFirstChildOfClass("Shirt")
    		local pants = character:FindFirstChildOfClass("Pants")
    		-- create shirts / pants if they don't exist
    		if not shirt then 
    			shirt = Instance.new("Shirt", character)
    		end 
    		if not pants then 
    			pants = Instance.new("Pants", character)
     		end
    		-- reset shirt / pants content ids
    		shirt.ShirtTemplate = "http://www.roblox.com/asset/?id=83326831"
    		pants.PantsTemplate = "http://www.roblox.com/asset/?id=10045638"
    	end
    end
```
 */
	ShirtTemplate: string;
}

/** The ShirtGraphic object applies a texture to the front surface of a character's Torso. It is the object used to display T-shirts. */
interface ShirtGraphic extends RbxInternalCharacterAppearance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ShirtGraphic";
	/** [LACKS DOCUMENTATION] */
	Color3: Color3;
	/** The content ID link pointing to the T-shirt texture hosted on the Roblox website. This property sets the texture associated with a `ShirtGraphic`, or T-shirt, object.

## How do I find the T-Shirt Graphic?

This content ID is different to the website URL of the T-shirt. The content ID can be found by pasting the website URL of the T-shirt into the Graphic property in Roblox Studio, as studio will correct it. Alternatively `LoadAsset` can be used to insert the T-shirt into the workspace, for example:

    local webURL = "https://www.roblox.com/catalog/2591161/Sword-Fight-on-the-Heights-Ring-of-Fire-T-Shirt"
    local assetId = tonumber(string.match(webURL, "%d+") or 0) -- extract the number
    local success, model = pcall(function() 
    	return game:GetService("InsertService"):LoadAsset(assetId) 
    end)
    if success then 
    	model.Parent = workspace
    end */
	Graphic: string;
}

/** The Skin object, when placed into a humanoid model, will change the colors all body parts of the torso, head, etc, to value of the `SkinColor` property.


Superceded by the `BodyColors` class. */
interface Skin extends RbxInternalCharacterAppearance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Skin";
	/** [LACKS DOCUMENTATION] */
	SkinColor: BrickColor;
}

/** The Chat service is a special service that houses the Lua code responsible for running the [Lua Chat System](/articles/Lua-Chat-System). Similar to `StarterPlayerScripts`, default objects (`Script`s, `ModuleScript`s and other objects) are inserted into the Chat service. Individual objects may be overridden by providing objects with the same name as those inserted. The following objects are guaranteed to exist inside of the Chat service, and can be overridden:

![The contents of the Chat service which are loaded when the game runs.](https://developer.roblox.com/assets/5b2d98148fbd570b783cb0d2/Chat.png)

## Text Filtering
In addition to housing the Lua Chat System, the Chat service also exposes functions used to filter text - `FilterStringAsync` and `FilterStringForBroadcast`. Chat filtering is built into the Lua Chat System already, but **games that implement custom chat systems must use these functions to filter chat properly.** For more information, see [Text and Chat Filtering](/articles/Text-and-Chat-Filtering). */
interface Chat extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Chat";

	BubbleChatEnabled: boolean;
	/** Toggles whether the default chat framework should be automatically loaded when the game runs. */
	readonly LoadDefaultChat: boolean;
	/** The Chat function fires the `Chatted` event with the parameters specified in this method.

By default, there is a `LocalScript` inside of each player's `PlayerScripts` object named *BubbleChat*, which causes a dialog-like billboard to appear above the *partOrCharacter* when the chatted event is fired.

*Note:* Since dialogs are controlled by a LocalScript, you will not be able to see any dialogs created from this method unless you are running in *Play Solo* mode.

## Code Samples

### Chat:Chat

The below example would create a part in Workspace and cause it to exclaim "Blame John!"
```lua
local ChatService = game:GetService("Chat")

local part = Instance.new("Part")
part.Anchored = true
part.Parent = workspace

ChatService:Chat(part, "Blame John!", "Red") 
```

@param partOrCharacter An instance that is the part or character which the *BubbleChat* dialog should appear above.
@param message The message string being chatted.
@param color An `Enum/ChatColor` specifying the color of the chatted message.
@returns No return */
	Chat(partOrCharacter: BasePart | Model, message: string, color?: CastsToEnum<Enum.ChatColor>): void;

	InvokeChatCallback(callbackType: CastsToEnum<Enum.ChatCallbackType>, callbackArguments: Array<any>): unknown;
	/** RegisterChatCallback binds a function to some chat system event in order to affect the behavior of the Lua chat system. The first argument determines the event (using the `ChatCallbackType` enum) to which the second argument, the function, shall be bound. The default Lua chat system uses `InvokeChatCallback` to invoke registered functions. Attempting to register a server- or client- only callback on a peer that isn't a server or client respectively will raise an error. The following sections describe in what ways registered functions will be used.

## OnCreatingChatWindow
Client-only. Invoked before the client constructs the chat window. Must return a table of settings to be merged into the information returned by the ChatSettings module.

## OnClientFormattingMessage
Client-only. Invoked before the client displays a message (whether it is a player chat message, system message, or /me command). This function is invoked with the message object and may (or may not) return a table to be merged into `message.ExtraData`.

## OnClientSendingMessage
Not invoked at this time.

## OnServerReceivingMessage
Server-only. Invoked when the server receives a message from a speaker (note that speakers may not necessarily be a `Player` chatting). This callback is called with the Message object. The function can make changes to the Message object to change the manner in which the message is processed. **The Message object must be returned for this callback to do anything.** Setting this callback can allow the server to, for example:

* Set `message.ShouldDeliver` to false in order to cancel delivery of the message to players (useful for implementing a chat blacklist)
* Get/set the speaker's name color (`message.ExtraData.NameColor`, a Color3) on a message-by-message basis
@param callbackType The callback to which the function shall be registered (this determines in what way the function is called)
@param callbackFunction The function to call when the callback is invoked using Chat:InvokeChatCallback */
	RegisterChatCallback(callbackType: CastsToEnum<Enum.ChatCallbackType>, callbackFunction: Function): void;
	/** Will return false if the player with the specified `UserId` is not allowed to chat because of their account settings. */
	CanUserChatAsync(userId: number): boolean;
	/** Will return false if the two users cannot communicate because their account settings do not allow it. */
	CanUsersChatAsync(userIdFrom: number, userIdTo: number): boolean;
	/** Filters a [string](https://developer.roblox.com/articles/String "String")
 being sent to _playerTo_ from _playerFrom_
 with filtering that is appropriate to the given player's account settings. This function should be used any time a user can enter custom text in any context. Some examples of text that should be filtered:
* Custom chat messages
* Entering a custom character name
* Entering a name for a shop in a tycoon

If the filtered string is being used for a persistent message (such as the name of a shop, writing on a plaque, etc) then the function should be called with the writing player as both the sender and receiver.

Calling FilterString from LocalScripts is deprecated and will be disabled in the future. Text filtering should be done from server-side Scripts using `FilterStringAsync`.
A game not using this filter function for custom chat or other user generated text may be subjected to moderation action. */
	FilterStringAsync(stringToFilter: string, playerFrom: Player, playerTo: Player): string;
	/** Filters a string sent from *playerFrom* for broadcast to no particular target. The filtered message has more restrictions than `FilterStringAsync`.

Some examples of where this method could be used:

 - -Message walls
 - -Cross-server shouts
 - -User-created signs

Calling FilterString from `LocalScript`s is deprecated and will be disabled in the future. Text filtering should be done from server-side `Script`s using FilterStringAsync.

*Note:* A game not using this filter function for custom chat or other user generated text may be subjected to moderation action.

## Code Samples

### Chat:FilterStringForBroadcast

The following example shows a simple way to use the FilterStringForBroadcast function. The example uses the message variable as the *stringToFilter* argument and the local player as the *playerFrom* argument.

The example then prints the result of the filtering function, *FilteredString*.
```lua
local playerFrom = game.Players.LocalPlayer	-- Local player (player sending message)
local message = "Hello world!"	-- Message to be filtered

-- Filter the string and store the result in the 'FilteredString' variable
FilteredString = game:GetService("Chat"):FilterStringForBroadcast(message, playerFrom)

-- Print the filtered string
print(FilteredString)
```

@param stringToFilter Message string being filtered
@param playerFrom Instance of the player sending the message
@returns Filtered message string */
	FilterStringForBroadcast(stringToFilter: string, playerFrom: Player): string;
	/** Fires when `Chat` is called. */
	readonly Chatted: RBXScriptSignal<(part: BasePart, message: string, color: Enum.ChatColor) => void>;
}

/** ClickDetector allows both `Scripts` and `LocalScripts` to receive user input. They are placed inside `Models`, `Folders`, and `BaseParts`. They mirror user input to the server through FilteringEnabled. They can detect basic mouse events: enter, leave, left click and right click.

If an action bound with `/ContextActionService` uses the same input as a ClickDetector, the bound action will take priority and the ClickDetector events will not fire.

With gamepad input, the right trigger button will fire the MouseClick event and center dot will trigger MouseHoverEnter/MouseHoverLeave.

LocalScripts can connect to ClickDetector events and they will fire on the client. Since LocalScripts only run if they are descendants of a `/Player` or Player's Character, it's not a good idea to put LocalScripts inside ClickDetectors. If you need a LocalScript to detect ClickDetector events, `/StarterPlayerScripts` may be a better place instead.

If multiple ClickDetectors would detect a user input, only the deepest ClickDetector will fire events. If two ClickDetectors are siblings, the first ClickDetector takes priority. Due to the nature of user input, you ought not depend on all MouseHoverEnter events to fire a matching MouseHoverLeave event.

## Code Samples

### ClickDetector Example

Place this code inside a `Script` inside a `ClickDetector`. The code sample first creates a reference to the `ClickDetector` parent and defines a function to show a message that greets a player. Finally, it connects the `MouseClick` event of the `ClickDetector` to the defined function.
```lua
local clickDetector = script.Parent

local function onClicked(player)
	-- Show a message to the player
	local msg = Instance.new("Message")
	msg.Parent = player:FindFirstChild("PlayerGui")
	msg.Text = "Hello, " .. player.Name
	wait(2.5)
	msg:Destroy()
end
-- Connect the function to the MouseClick event
clickDetector.MouseClick:Connect(onClicked)
```

### Part Anchored Toggle

This code sample will allow a part to be clicked to toggle its anchored property. When toggled, the visual appearance of the part is updated (red means anchored, yellow means free).
```lua
local part = script.Parent

-- Create a ClickDetector so we can tell when the part is clicked 
local cd = Instance.new("ClickDetector", part)

-- This function updates how the part looks based on its Anchored state
local function updateVisuals()
	if part.Anchored then
		-- When the part is anchored...
		part.BrickColor = BrickColor.new("Bright red")
		part.Material = Enum.Material.DiamondPlate
	else
		-- When the part is unanchored...
		part.BrickColor = BrickColor.new("Bright yellow")
		part.Material = Enum.Material.Wood
	end
end

local function onToggle()
	-- Toggle the anchored property
	part.Anchored = not part.Anchored
	
	-- Update visual state of the brick
	updateVisuals()
end

-- Update, then start listening for clicks
updateVisuals()
cd.MouseClick:connect(onToggle)

```
 */
interface ClickDetector extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ClickDetector";
	/** Sets the mouse icon that will be displayed when the mouse is hovered over this ClickDetector. */
	CursorIcon: string;
	/** The MaxActivationDistance property controls the maximum distance, in studs, between a `Character` and the `ClickDetector` for the character to be able to click it. This is used to limit from how far a player can interact with a ClickDetector.

For instance, a character within `10` studs of a ClickDetector with a MaxActivationDistance of `5` would not be able to click the ClickDetector because they are out of range. If, however, the MaxActivationDistance was `15`, the character would be able to click it.

## Code Samples

### Creating a ClickDetector Door

The code sample below demonstrates the functionality of a `ClickDetector` and its properties and events. 

First the code creates a ClickDetector and set's its `parent` to the `door`. It also sets the `maximum distance` players can interact with the ClickDetector to 10 studs and set's the ClickDetector's `CursorImage` to:

![Custom cursor image](https://developer.roblox.com/assets/5b874ff0fcd8df450b22f391/InterestCursorIcon.png)

Then, the code connects the ClickDetector to several events, including changing the door's `Transparency` when the player's mouse hovers `on` and `off` off the door. The player opens the door by `left clicking` their mouse while over the ClickDetector and closes the door by `right clicking` their mouse while over the ClickDetector.

This code works in a `Script` and a `LocalScript` as long as the script's parent is the door `Part`.
```lua
-- The door 'BasePart'
local door = script.Parent

-- Asset ID of the image you want the to set the cursor to
local CursorId = "2287179355"

-- Create a ClickDetector
local ClickDetector = Instance.new("ClickDetector")
ClickDetector.Parent = door
ClickDetector.MaxActivationDistance = 10
ClickDetector.CursorIcon = "rbxassetid://"..CursorId

-- Make door slightly transparent when mouse hovers over it
ClickDetector.MouseHoverEnter:Connect(function()
	door.Transparency = 0.1
end)

-- Door is not transparent when mouse is not hovering over it
ClickDetector.MouseHoverLeave:Connect(function()
	door.Transparency = 0
end)

-- Open door on left mouse click
ClickDetector.MouseClick:Connect(function()
	door.Transparency = 0.8
	door.CanCollide = false
end)

-- Close door on right mouse click
ClickDetector.RightMouseClick:Connect(function()
	door.Transparency = 0.1
	door.CanCollide = true
end)
```
 */
	MaxActivationDistance: number;
	/** The MouseClick event fires when a player presses and releases the left mouse button while the cursor is hovering over a `BasePart` or `Model` with a `ClickDetector`. Additionally, the Player's `Character` must be within the `MaxActivationDistance` of the clicked object. This event fires when using either a `Script` or `LocalScript`.

## Platform Support
* On `TouchEnabled` platforms, this event fires when the user taps on the same model.
* On `GamepadEnabled` platforms, this event fires when the center dot is over the same model and the A button is pressed and released.

## Related Events
* If you want to check when a player right clicks on the ClickDetector, you can use the `RightMouseClick` event.
* If you want a function to fire when a player hovers on or off of the ClickDetector without mouse clicking it you can use the `MouseHoverEnter` and `MouseHoverLeave` events.

## Code Samples

### Creating a ClickDetector Door

The code sample below demonstrates the functionality of a `ClickDetector` and its properties and events. 

First the code creates a ClickDetector and set's its `parent` to the `door`. It also sets the `maximum distance` players can interact with the ClickDetector to 10 studs and set's the ClickDetector's `CursorImage` to:

![Custom cursor image](https://developer.roblox.com/assets/5b874ff0fcd8df450b22f391/InterestCursorIcon.png)

Then, the code connects the ClickDetector to several events, including changing the door's `Transparency` when the player's mouse hovers `on` and `off` off the door. The player opens the door by `left clicking` their mouse while over the ClickDetector and closes the door by `right clicking` their mouse while over the ClickDetector.

This code works in a `Script` and a `LocalScript` as long as the script's parent is the door `Part`.
```lua
-- The door 'BasePart'
local door = script.Parent

-- Asset ID of the image you want the to set the cursor to
local CursorId = "2287179355"

-- Create a ClickDetector
local ClickDetector = Instance.new("ClickDetector")
ClickDetector.Parent = door
ClickDetector.MaxActivationDistance = 10
ClickDetector.CursorIcon = "rbxassetid://"..CursorId

-- Make door slightly transparent when mouse hovers over it
ClickDetector.MouseHoverEnter:Connect(function()
	door.Transparency = 0.1
end)

-- Door is not transparent when mouse is not hovering over it
ClickDetector.MouseHoverLeave:Connect(function()
	door.Transparency = 0
end)

-- Open door on left mouse click
ClickDetector.MouseClick:Connect(function()
	door.Transparency = 0.8
	door.CanCollide = false
end)

-- Close door on right mouse click
ClickDetector.RightMouseClick:Connect(function()
	door.Transparency = 0.1
	door.CanCollide = true
end)
```

### Temporary DataStore

This code sample demonstrates one possible usage of `BindableFunctions`, temporary datastores, in combination with `ClickDetectors`.  It also demonstrates why BindableFunctions are important, since they allow multiple server `Scripts` to communicate with each other.

Note that this can also be achieved through the use of a `ModuleScript`. 

This example creates a datastore using a table in a `Script`. Since it does not utilize Roblox’s `DataStores`, it is temporary and player data is erased when the player leaves or the server shuts down. For persistent DataStores, take a look at [this][1] article.

The code below contains two parts:

###TempDataStore Script
The script containing the `OnInvoke` callback. Since this is a callback, the Invoke() function will wait for and receive the results of the invoked function. This is the `TempDataStore` script in the code below. 

This script maintains a table called `PlayerData` that tracks players’ data while they are in the game. When a player enters the game, they are added to the table with a balance of 0 using their `UserId` as the table key. When a player exits the game, their key is removed from the table. The script creates two BindableFunctions to interact with the `ActivateButton` script named GetData and SetData.

When GetData’s OnInvoke event fires, the script returns the player’s balance in `PlayerData`.

When SetData’s OnInvoke event fires, the script set’s the player’s balance in `PlayerData` to the value passed as an argument and returns the updated value.

###ActivateButton Script
The script containing the `Invoke` function. This is the `ActivateButton` script in the code below.

It creates a `ClickDetector` that allows the player to retrieve and increment their balance in the temporary datastore in `TempDataStore`. When the player left mouse clicks on the parent part the `SetData` BindableFunction is Invoked, which increases the player’s balance by 1. When the player right mouse clicks on the part the `GetData` BindableFunction is invoked, which retrieves and prints the player’s balance.


  [1]: https://www.robloxdev.com/articles/Data-store
```lua
-- TempDataStore (Script 1)
local GetData = Instance.new("BindableFunction", game.ServerStorage)
GetData.Name = "GetData"

local SetData = Instance.new("BindableFunction", game.ServerStorage)
SetData.Name = "SetData"

local PlayerData = {}

local function getData(player)
	return PlayerData[player.UserId]
end

local function setData(player, value)
	PlayerData[player.UserId] = value
	return PlayerData[player.UserId]
end

local function addPlayerData(player)
	table.insert(PlayerData, player.UserId, 0)
end

local function removePlayerData(player)
	table.remove(PlayerData, player.UserId)
end

GetData.OnInvoke = getData
SetData.OnInvoke = setData

game.Players.PlayerAdded:Connect(addPlayerData)
game.Players.PlayerRemoving:Connect(removePlayerData)




-- ActivateButton (Script 2)
local GetData = game.ServerStorage:WaitForChild("GetData")
local SetData = game.ServerStorage:WaitForChild("SetData")

local ClickDetector = Instance.new("ClickDetector", script.Parent)

local function getData(player)
	print(player.Name.."'s Current Balance: "..GetData:Invoke(player))
end

local function setData(player)
	local value = 100
	print("Set "..player.Name.."'s Balance to: "..SetData:Invoke())
end

local function incrementData(player)
	local balance = GetData:Invoke(player)
	print("Set "..player.Name.."'s Balance to: "..SetData:Invoke(player, balance+1))
end

ClickDetector.MouseClick:Connect(incrementData)
ClickDetector.RightMouseClick:Connect(getData)
```
 */
	readonly MouseClick: RBXScriptSignal<(playerWhoClicked: Player) => void>;
	/** The MouseHoverEnter event fires when the player's `mouse` begins hovering over the `ClickDetector`'s parent. This event fires when using either a `Script` or `LocalScript`.

Due to the nature of user input, you ought not depend on all MouseHoverEnter events to fire a matching `MouseHoverLeave` event.

The player does not have to click the ClickDetector for this event to fire. If you want an event to execute when the player clicks, you can use `MouseClick` and `RightMouseClick` events.

## Code Samples

### Mouse Hovering On and Off of a ClickDetector

The below code will print "Oh my... PlayerName left the confines of my parent" when a player's mouse is moved off of the `ClickDetector's` parent, replacing "PlayerName" with the player's name. 

It will also print "Oh my... PlayerName hovered over my parent" when a player's mouse hovers over the ClickDetector's parent, replacing "PlayerName" with the player's name.

In order for this example to work as expected, it must be placed in a `Script` or `LocalScript` whose parent is the ClickDetector.
```lua
script.Parent.ClickDetector.MouseHoverLeave:Connect(function(Player)
   print("Oh my... " .. Player.Name .. " left the confines of my parent")
end)

script.Parent.ClickDetector.MouseHoverEnter:Connect(function(Player)
   print("Oh my... " .. Player.Name .. " hovered over my parent")
end)
```

### Creating a ClickDetector Door

The code sample below demonstrates the functionality of a `ClickDetector` and its properties and events. 

First the code creates a ClickDetector and set's its `parent` to the `door`. It also sets the `maximum distance` players can interact with the ClickDetector to 10 studs and set's the ClickDetector's `CursorImage` to:

![Custom cursor image](https://developer.roblox.com/assets/5b874ff0fcd8df450b22f391/InterestCursorIcon.png)

Then, the code connects the ClickDetector to several events, including changing the door's `Transparency` when the player's mouse hovers `on` and `off` off the door. The player opens the door by `left clicking` their mouse while over the ClickDetector and closes the door by `right clicking` their mouse while over the ClickDetector.

This code works in a `Script` and a `LocalScript` as long as the script's parent is the door `Part`.
```lua
-- The door 'BasePart'
local door = script.Parent

-- Asset ID of the image you want the to set the cursor to
local CursorId = "2287179355"

-- Create a ClickDetector
local ClickDetector = Instance.new("ClickDetector")
ClickDetector.Parent = door
ClickDetector.MaxActivationDistance = 10
ClickDetector.CursorIcon = "rbxassetid://"..CursorId

-- Make door slightly transparent when mouse hovers over it
ClickDetector.MouseHoverEnter:Connect(function()
	door.Transparency = 0.1
end)

-- Door is not transparent when mouse is not hovering over it
ClickDetector.MouseHoverLeave:Connect(function()
	door.Transparency = 0
end)

-- Open door on left mouse click
ClickDetector.MouseClick:Connect(function()
	door.Transparency = 0.8
	door.CanCollide = false
end)

-- Close door on right mouse click
ClickDetector.RightMouseClick:Connect(function()
	door.Transparency = 0.1
	door.CanCollide = true
end)
```
 */
	readonly MouseHoverEnter: RBXScriptSignal<(playerWhoHovered: Player) => void>;
	/** The MouseHoverLeave event fires when a player's `mouse` moves off of the `ClickDetector`'s parent. This event fires when using either a `Script` or `LocalScript`.

Due to the nature of user input, you ought not depend on all `MouseHoverEnter` events to fire a matching MouseHoverLeave event.

The player does not have to click the ClickDetector for this event to fire. If you want an function to run when the player clicks, you can use `MouseClick` and `RightMouseClick` events.

## Code Samples

### Mouse Hovering On and Off of a ClickDetector

The below code will print "Oh my... PlayerName left the confines of my parent" when a player's mouse is moved off of the `ClickDetector's` parent, replacing "PlayerName" with the player's name. 

It will also print "Oh my... PlayerName hovered over my parent" when a player's mouse hovers over the ClickDetector's parent, replacing "PlayerName" with the player's name.

In order for this example to work as expected, it must be placed in a `Script` or `LocalScript` whose parent is the ClickDetector.
```lua
script.Parent.ClickDetector.MouseHoverLeave:Connect(function(Player)
   print("Oh my... " .. Player.Name .. " left the confines of my parent")
end)

script.Parent.ClickDetector.MouseHoverEnter:Connect(function(Player)
   print("Oh my... " .. Player.Name .. " hovered over my parent")
end)
```

### Creating a ClickDetector Door

The code sample below demonstrates the functionality of a `ClickDetector` and its properties and events. 

First the code creates a ClickDetector and set's its `parent` to the `door`. It also sets the `maximum distance` players can interact with the ClickDetector to 10 studs and set's the ClickDetector's `CursorImage` to:

![Custom cursor image](https://developer.roblox.com/assets/5b874ff0fcd8df450b22f391/InterestCursorIcon.png)

Then, the code connects the ClickDetector to several events, including changing the door's `Transparency` when the player's mouse hovers `on` and `off` off the door. The player opens the door by `left clicking` their mouse while over the ClickDetector and closes the door by `right clicking` their mouse while over the ClickDetector.

This code works in a `Script` and a `LocalScript` as long as the script's parent is the door `Part`.
```lua
-- The door 'BasePart'
local door = script.Parent

-- Asset ID of the image you want the to set the cursor to
local CursorId = "2287179355"

-- Create a ClickDetector
local ClickDetector = Instance.new("ClickDetector")
ClickDetector.Parent = door
ClickDetector.MaxActivationDistance = 10
ClickDetector.CursorIcon = "rbxassetid://"..CursorId

-- Make door slightly transparent when mouse hovers over it
ClickDetector.MouseHoverEnter:Connect(function()
	door.Transparency = 0.1
end)

-- Door is not transparent when mouse is not hovering over it
ClickDetector.MouseHoverLeave:Connect(function()
	door.Transparency = 0
end)

-- Open door on left mouse click
ClickDetector.MouseClick:Connect(function()
	door.Transparency = 0.8
	door.CanCollide = false
end)

-- Close door on right mouse click
ClickDetector.RightMouseClick:Connect(function()
	door.Transparency = 0.1
	door.CanCollide = true
end)
```
 */
	readonly MouseHoverLeave: RBXScriptSignal<(playerWhoHovered: Player) => void>;
	/** The RightMouseClick event fires when a player presses and releases the right mouse button while the cursor is hovering over a `BasePart` or `Model` with a `ClickDetector`. Additionally, the Player's `Character` must be within the `MaxActivationDistance` of the clicked object. This event fires when using either a `Script` or `LocalScript`.

## Related Events
* If you want to check when a player left clicks on the ClickDetector, you can use the `MouseClick` event.
* If you want a function to fire when a player hovers on or off of the ClickDetector without clicking it you can use the `MouseHoverEnter` and `MouseHoverLeave` events.

## Code Samples

### Creating a ClickDetector Door

The code sample below demonstrates the functionality of a `ClickDetector` and its properties and events. 

First the code creates a ClickDetector and set's its `parent` to the `door`. It also sets the `maximum distance` players can interact with the ClickDetector to 10 studs and set's the ClickDetector's `CursorImage` to:

![Custom cursor image](https://developer.roblox.com/assets/5b874ff0fcd8df450b22f391/InterestCursorIcon.png)

Then, the code connects the ClickDetector to several events, including changing the door's `Transparency` when the player's mouse hovers `on` and `off` off the door. The player opens the door by `left clicking` their mouse while over the ClickDetector and closes the door by `right clicking` their mouse while over the ClickDetector.

This code works in a `Script` and a `LocalScript` as long as the script's parent is the door `Part`.
```lua
-- The door 'BasePart'
local door = script.Parent

-- Asset ID of the image you want the to set the cursor to
local CursorId = "2287179355"

-- Create a ClickDetector
local ClickDetector = Instance.new("ClickDetector")
ClickDetector.Parent = door
ClickDetector.MaxActivationDistance = 10
ClickDetector.CursorIcon = "rbxassetid://"..CursorId

-- Make door slightly transparent when mouse hovers over it
ClickDetector.MouseHoverEnter:Connect(function()
	door.Transparency = 0.1
end)

-- Door is not transparent when mouse is not hovering over it
ClickDetector.MouseHoverLeave:Connect(function()
	door.Transparency = 0
end)

-- Open door on left mouse click
ClickDetector.MouseClick:Connect(function()
	door.Transparency = 0.8
	door.CanCollide = false
end)

-- Close door on right mouse click
ClickDetector.RightMouseClick:Connect(function()
	door.Transparency = 0.1
	door.CanCollide = true
end)
```
 */
	readonly RightMouseClick: RBXScriptSignal<(playerWhoClicked: Player) => void>;
}

/** An internal service meant to cache cluster packets. 
This service will only be present if a `NetworkServer` is present. */
interface ClusterPacketCache extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ClusterPacketCache";
}

/** The `CollectionService` manages groups (collections) of instances with tags. Tags are sets of strings applied to objects that replicate from the server to the client and in Team Create. They are also serialized when places are saved. At the moment, tags are not visible within Roblox Studio except with the use of a tag-editing plugin.

The primary use of `CollectionService` is to add flags and/or behaviors to Roblox objects. If you find yourself adding the same script to many different objects, perhaps a script that uses CollectionService would be better. Here are a couple examples:

* In an obstacle course with many bricks that kill players, don't paste the same script in all your kill bricks! Instead, tag them with "KIllBrick". Then, have any brick tagged as such kill the player.
* Payers with a VIP game pass could have their `Humanoid` tagged "VIP", and be allowed through doors that only allow VIPs.
* When creating a freeze-tag game, you could tag frozen players' `Humanoid` objects with a "Frozen" tag. Then, use a `LocalScript` to listen for the "Frozen" tag and create client-side visual effects to reduce the number of objects replicated from server to client.

When working with collections and tags, it's a good idea to use an [object-oriented programming style][1]. In almost all situations, tagged objects have their own identity, state and behavior. The pattern goes like this: when a tag is found (`GetTagged` and `GetInstanceAddedSignal`), create a Lua object with the Roblox instance. When it is removed (`GetInstanceRemovedSignal`), call a cleanup/destroy method within the Lua object. See the code samples for a better idea of how this can be done.

When tags replicate, **all tags on an object replicate at the same time**. Therefore, if you set a tag on an object from the client then add/remove a **different** tag on the same object from the server, the client's local tags on the object are overwritten.

[1]: https://www.lua.org/pil/16.html

## Code Samples

### CollectionService Door

This code sample uses an object-oriented programming style to create a Door class, then uses the Door class and CollectionService to listen for "Door" tags.
```lua
local CollectionService = game:GetService("CollectionService")

------------------------------------------------------------------------------ 
-- In this section of the script, we define a Door class. This could be placed in
-- its own independent ModuleScript.

-- For more information on this class pattern, check out
-- the object-oriented programming chapter in Programming in Lua:  
-- https://www.lua.org/pil/16.html

local Door = {}
Door.__index = Door
Door.TAG_NAME = "Door"
Door.OPEN_TIME = 2

function Door.new(door)
	-- Create a table which will act as our new door object.
	local self = {}
	-- Setting the metatable allows the table to access
	-- the SetOpen, OnTouch and Cleanup methods even if we did not
	-- add all of the functions ourself - this is because the
	-- __index metamethod is set in the Door metatable.
	setmetatable(self, Door)
	
	-- Keep track of some door properties of our own
	self.door = door
	self.debounce = false
	
	-- Initialize a Touched event to call a method of the door
	self.touchConn = door.Touched:connect(function (...)
		self:OnTouch(...)
	end)
	
	-- Initialize the state of the door
	self:SetOpen(false)
	
	-- Print a message so we know when doors are initialized
	print("Initialized door: " .. door:GetFullName())
	
	return self
end

function Door:SetOpen(isOpen)
	if isOpen then
		self.door.Transparency = .75
		self.door.CanCollide = false
	else
		self.door.Transparency = 0
		self.door.CanCollide = true
	end
end

function Door:OnTouch(part)
	if self.debounce then return end
	local human = part.Parent:FindFirstChild("Humanoid")
	if not human then return end
	self.debounce = true
	self:SetOpen(true)
	wait(Door.OPEN_TIME)
	self:SetOpen(false)
	self.debounce = false
end

function Door:Cleanup()
	self.touchConn:disconnect()
	self.touchConn = nil
end

------------------------------------------------------------------------------ 
-- In this section of the script, we want to listen for objects with the door
-- tag. When we find one, create a new Door and keep track of it. When the door
-- tag is removed, we'll find the Door we created and destroy it.

local doors = {}

local doorAddedSignal = CollectionService:GetInstanceAddedSignal(Door.TAG_NAME)
local doorRemovedSignal = CollectionService:GetInstanceRemovedSignal(Door.TAG_NAME)

local function onDoorAdded(door)
	if door:IsA("BasePart") then
		-- Create a new Door object and save it
		-- The door class will take over from here!
		doors[door] = Door.new(door)
	end
end

local function onDoorRemoved(door)
	if doors[door] then
		-- Clean up an already-existing door
		doors[door]:Cleanup()
		doors[door] = nil
	end
end

-- Listen for existing tags, tag additions and tag removals for the door tag 
for _,inst in pairs(CollectionService:GetTagged(Door.TAG_NAME)) do
	onDoorAdded(inst)
end
doorAddedSignal:Connect(onDoorAdded)
doorRemovedSignal:Connect(onDoorRemoved)

```
 */
interface CollectionService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CollectionService";
	/** AddTag will apply a tag to an object. This method will not throw an error if the object already had the tag. Successfully adding a tag will fire a signal created by `GetInstanceAddedSignal` with the given tag.

**Warning:** When tagging an object, it is common that some resources are used to give the tag its functionality, e.g. event connections or tables. To prevent memory leaks, it is a good idea to clean these up (disconnect, set to nil, etc) when no longer needed for a tag. Do this when calling `RemoveTag`, calling `Destroy` or in a function connected to a signal returned by `GetInstanceRemovedSignal`. */
	AddTag(instance: Instance, tag: string): void;
	/** GetInstanceAdded is given a tag (a string) and returns a signal which fires under two conditions:

   - The tag is assigned to an object within the `DataModel` (game) using `AddTag`
   - An object with the given tag is added as a descendant of the `DataModel`, e.g. by setting `Parent` or similar

Subsequent calls to this method with the same tag return the same signal object. Consider also calling `GetTagged` to get a list of objects that already have a tag (and thus won't fire the event if they already are in the `DataModel`).

See also `GetInstanceRemovedSignal`, which returns an event that fires under similar conditions.

## Code Samples

### Deadly Bricks using CollectionService

This code sample causes any `BasePart` with the tag "Deadly" to kill any `Humanoid` that touches it. It does this using a common pattern with `CollectionService`: listen for all parts with the tag, and make a connection. When the tag is removed, disconnect. Instead of copying the same kill script into many bricks, use this pattern instead!
```lua
local CollectionService = game:GetService("CollectionService")
local tag = "Deadly"

local function onDeadlyPartTouched(otherPart)
	if not otherPart.Parent then return end
	local human = otherPart.Parent:FindFirstChildOfClass("Humanoid")
	if human then
		human.Health = 0
	end
end

-- Save the connections so they can be disconnected when the tag is removed
-- This table maps BaseParts with the tag to their Touched connections
local connections = {}

local function onInstanceAdded(object)
	-- Remember that any tag can be applied to any object, so there's no
	-- guarantee that the object with this tag is a BasePart.
	if object:IsA("BasePart") then
		connections[object] = object.Touched:Connect(onDeadlyPartTouched)
	end
end

local function onInstanceRemoved(object)
	-- If we made a connection on this object, disconnect it (prevent memory leaks)
	if connections[object] then
		connections[object]:disconnect()
		connections[object] = nil
	end
end

-- Listen for this tag being applied to objects
CollectionService:GetInstanceAddedSignal(tag):Connect(onInstanceAdded)

-- Also detect any objects that already have the tag
for _, object in pairs(CollectionService:GetTagged(tag)) do
	onInstanceAdded(object)
end
```
 */
	GetInstanceAddedSignal(tag: string): RBXScriptSignal<(instance: Instance) => void>;
	/** GetInstanceRemoved is given a tag (a string) and returns a signal which fires under two conditions:

   - The tag is removed from an object within the `DataModel` (game) using `RemoveTag`
   - An object with the given tag is removed as a descendant of the `DataModel`, e.g. by un-setting `Parent` or similar

Subsequent calls to this method with the same tag return the same signal object. The signal is useful for cleaning up resources used by objects that once had tags, such as disconnecting connections.

See also `GetInstanceAddedSignal`, which returns an event that fires under similar conditions.

## Code Samples

### Deadly Bricks using CollectionService

This code sample causes any `BasePart` with the tag "Deadly" to kill any `Humanoid` that touches it. It does this using a common pattern with `CollectionService`: listen for all parts with the tag, and make a connection. When the tag is removed, disconnect. Instead of copying the same kill script into many bricks, use this pattern instead!
```lua
local CollectionService = game:GetService("CollectionService")
local tag = "Deadly"

local function onDeadlyPartTouched(otherPart)
	if not otherPart.Parent then return end
	local human = otherPart.Parent:FindFirstChildOfClass("Humanoid")
	if human then
		human.Health = 0
	end
end

-- Save the connections so they can be disconnected when the tag is removed
-- This table maps BaseParts with the tag to their Touched connections
local connections = {}

local function onInstanceAdded(object)
	-- Remember that any tag can be applied to any object, so there's no
	-- guarantee that the object with this tag is a BasePart.
	if object:IsA("BasePart") then
		connections[object] = object.Touched:Connect(onDeadlyPartTouched)
	end
end

local function onInstanceRemoved(object)
	-- If we made a connection on this object, disconnect it (prevent memory leaks)
	if connections[object] then
		connections[object]:disconnect()
		connections[object] = nil
	end
end

-- Listen for this tag being applied to objects
CollectionService:GetInstanceAddedSignal(tag):Connect(onInstanceAdded)

-- Also detect any objects that already have the tag
for _, object in pairs(CollectionService:GetTagged(tag)) do
	onInstanceAdded(object)
end
```
 */
	GetInstanceRemovedSignal(tag: string): RBXScriptSignal<(instance: Instance) => void>;
	/** GetTagged returns a table of objects with a given tag which are descendants of the `DataModel` (`game`). Such tags have been added using `AddTag`, and removing a tag using `RemoveTag` will ensure this method does not return them. Although the name of this method is past-tense, this method only returns objects **presently** tagged with the given tag. It will not return objects that once had a tag but no longer have it.

If you want to detect all objects with a tag, both present and future, use this method to iterate over objects while also making a connection to a signal returned by `GetinstanceAddedSignal`.

This method does not guarantee any ordering of the returned objects. Additionally, it is possible that objects can have the given tag assigned to them, but not be a descendant of the `DataModel`, i.e. its parent is nil. This method will not return such objects.

## Code Samples

### Deadly Bricks using CollectionService

This code sample causes any `BasePart` with the tag "Deadly" to kill any `Humanoid` that touches it. It does this using a common pattern with `CollectionService`: listen for all parts with the tag, and make a connection. When the tag is removed, disconnect. Instead of copying the same kill script into many bricks, use this pattern instead!
```lua
local CollectionService = game:GetService("CollectionService")
local tag = "Deadly"

local function onDeadlyPartTouched(otherPart)
	if not otherPart.Parent then return end
	local human = otherPart.Parent:FindFirstChildOfClass("Humanoid")
	if human then
		human.Health = 0
	end
end

-- Save the connections so they can be disconnected when the tag is removed
-- This table maps BaseParts with the tag to their Touched connections
local connections = {}

local function onInstanceAdded(object)
	-- Remember that any tag can be applied to any object, so there's no
	-- guarantee that the object with this tag is a BasePart.
	if object:IsA("BasePart") then
		connections[object] = object.Touched:Connect(onDeadlyPartTouched)
	end
end

local function onInstanceRemoved(object)
	-- If we made a connection on this object, disconnect it (prevent memory leaks)
	if connections[object] then
		connections[object]:disconnect()
		connections[object] = nil
	end
end

-- Listen for this tag being applied to objects
CollectionService:GetInstanceAddedSignal(tag):Connect(onInstanceAdded)

-- Also detect any objects that already have the tag
for _, object in pairs(CollectionService:GetTagged(tag)) do
	onInstanceAdded(object)
end
```
 */
	GetTagged<T extends Instance = Instance>(tag: string): Array<T>;
	/** GetTags is given an object and returns a table of strings, which are the tags applied to the given object.

```lua
local CollectionService = game:GetService("CollectionService")
local object = workspace.Model
local tags = CollectionService:GetTags(object)
print("The object " .. object:GetFullName() .. " has tags: " .. table.concat(tags, ", "))
```


This method is useful when you want to do something with multiple tags at once on an object. However, it would be inefficient to use this method to check for the existence of a single tag. For this, use `HasTag` to check for a single tag.

## Code Samples

### Using Tags and CollectionService

This code sample demonstrates adding, removing and querying a tag from an object using `CollectionService`. Be sure to add a `Part` to the `Workspace` before running this code.
```lua
local CollectionService = game:GetService("CollectionService")
local object = workspace.Part

-- Add a tag
CollectionService:AddTag(object, "Deadly")

-- Query for a tag
if CollectionService:HasTag(object, "Deadly") then
	print(object:GetFullName() .. " is deadly")
end

-- List tags on an object
local tags = CollectionService:GetTags(object)
print("The object " .. object:GetFullName() .. " has tags: " .. table.concat(tags, ", "))

-- Remove a tag
CollectionService:RemoveTag(object, "Deadly")
```

@param instance The object whose tags should be returned
@returns A table of strings which are the tags applied to the given object */
	GetTags(instance: Instance): Array<string>;
	/** HasTag returns whether a given object has a tag

   - Using `AddTag` to add the tag will cause this method to return true.
   - Using `RemoveTag` to remove the tag will cause this method to return false.

By extension, any tags returned by a call to `GetTags` on an object will return true when used with this method.

## Code Samples

### Using Tags and CollectionService

This code sample demonstrates adding, removing and querying a tag from an object using `CollectionService`. Be sure to add a `Part` to the `Workspace` before running this code.
```lua
local CollectionService = game:GetService("CollectionService")
local object = workspace.Part

-- Add a tag
CollectionService:AddTag(object, "Deadly")

-- Query for a tag
if CollectionService:HasTag(object, "Deadly") then
	print(object:GetFullName() .. " is deadly")
end

-- List tags on an object
local tags = CollectionService:GetTags(object)
print("The object " .. object:GetFullName() .. " has tags: " .. table.concat(tags, ", "))

-- Remove a tag
CollectionService:RemoveTag(object, "Deadly")
```
 */
	HasTag(instance: Instance, tag: string): boolean;
	/** RemoveTag will remove some tag from some object. This method will not throw an error if the object did not have the tag in the first place. Successfully removing a tag will fire a signal created by `GetInstanceRemovedSignal` with the given tag.

When removing a tag, it is common that some resources are used to give the tag its functionality, e.g. event connections or tables. To prevent memory leaks, it is a good idea to clean these up (disconnect, set to nil, etc) when no longer needed for a tag.

## Code Samples

### Using Tags and CollectionService

This code sample demonstrates adding, removing and querying a tag from an object using `CollectionService`. Be sure to add a `Part` to the `Workspace` before running this code.
```lua
local CollectionService = game:GetService("CollectionService")
local object = workspace.Part

-- Add a tag
CollectionService:AddTag(object, "Deadly")

-- Query for a tag
if CollectionService:HasTag(object, "Deadly") then
	print(object:GetFullName() .. " is deadly")
end

-- List tags on an object
local tags = CollectionService:GetTags(object)
print("The object " .. object:GetFullName() .. " has tags: " .. table.concat(tags, ", "))

-- Remove a tag
CollectionService:RemoveTag(object, "Deadly")
```
 */
	RemoveTag(instance: Instance, tag: string): void;
}

/** The Configuration object is a container object that is designed to hold value objects to make values used in `Tool`s or any model using `Script`s more accessible.

## How does the Configuration object work?
The Configuration object is just a container, and does not automatically offer any additional functionality to a `Folder`.

Configurations should hold value objects (`BrickColorValue`, `NumberValue`, `IntValue`, `ObjectValue` etc). These value objects should be read by the `Script` or `LocalScript` associated with the configuration to determine constants such as damage, speed or color.

For example, 
```lua
local damage = 10
```

Becomes:
```lua
local configuration = tool:FindFirstChildWhichIsA("Configuration", true)
damage = configuration:FindFirstChild("Damage").Value -- A NumberValue
```

The Configuration object is intended to be placed inside a `BasePart` in a `Model` or `Tool`. It was originally intended to be used with a tool that provided a GUI interface to edit these properties. However it is more common now for developers to edit these values directly in the Roblox Studio properties window.

## Why should I use the Configuration object?

Use of Configurations is optional, but a number of developers chose to use them for the following reasons.

 - Variables held in a Configuration can be found quickly and are in a single place
 - When sharing your work, others can make changes without needing to modify your code
 - Provides a single location for variables read by multiple scripts in more complex games */
interface Configuration extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Configuration";
}

interface RbxInternalConstraint extends RbxInternalInstance {
	/** True if the constraint is currently active in the world.

True if the constraint and both of its parts are in the `Workspace` and the constraint's `Enabled` property is true.True if the constraint is currently active in the world.

True if the constraint and both of its parts are in the `Workspace` and the constraint's `Enabled` property is true.

Tags: ReadOnly, NotReplicated */
	readonly Active: boolean;
	/** The `Attachment` that is connected to `Attachment1` */
	Attachment0?: Attachment;
	/** The `Attachment` that is connected to `Attachment0` */
	Attachment1?: Attachment;
	/** The color of the constraint. */
	Color: BrickColor;
	/** Toggles whether or not this Constraint is enabled. */
	Enabled: boolean;
	/** Toggles the visibility of this Constraint. */
	Visible: boolean;
}
/** The base class for Constraint-based objects. */
type Constraint = AlignOrientation | AlignPosition | AngularVelocity | BallSocketConstraint | HingeConstraint | LineForce | RodConstraint | RopeConstraint | SlidingBallConstraint | SpringConstraint | Torque | VectorForce;

/** **AlignOrientation** is a constraint that applies a torque to make its attachments align. Like other constraints, this has two `Attachments`. In this case, the two attachments are constrained to be **oriented** in the same direction but not necessarily the same position.

By default, this constraint only applies torque on the parent of `Attachment0`, although it can be configured to apply torque on both attachments. This torque can be limited to a max amount via `MaxTorque`.

Note that any torque created by **AlignOrientation** will be applied about the center of mass of the parent of the attachments (or the center of mass of parts rigidly connected to the parents). Also note that if this constraint attaches one part (**A**) to another part (**B**) that is anchored or connected to an anchored part (**Z**), part **A**
 will not be locally simulated when interacting with a player.

## Code Samples

### Creating an AlignOrientation

This example demos the functionality of AlignOrientation. 

In order to do this, we must first create two `BasePart`s, one with the AlignOrientation, and the other being that part that will move according to the torque applied by the AlignOrientation in the first part. Note that the part that we apply torque on, named *part2*, cannot be anchored or it will not move when the torque is applied.

Then, we create two attachments, *attachment0* and *attachment1*. The first of these attachments, *attachment0* will apply torque to its parent part, *part1* to allign with *attachment1*, which is parented to *part2*.

For these attachments to work as described, we create a new AlignOrientation and parent it to *part1*. We then connect *attachment0* to `Attachment0` and *attachment1* to `Attachment1`. In this example, we set `RigidityEnabled` to *true* because it helps to smooth the alignment - but this is optional.

Finally, to demo the alignment the example relies on `RunService`'s `RenderStepped` to slowly rotate *part1*. Due to the AlignmentOrientation, *part2* also rotates as *attachment0* aligns itself with *attachment1*.
```lua
-- Create a new part1
local part1 = Instance.new("Part")
part1.Name = "Part1"
part1.Parent = game.Workspace
part1.Anchored = true
part1.Position = Vector3.new(-7, 2, 3)

-- Create a new part2
local part2 = Instance.new("Part")
part2.Name = "Part2"
part2.Parent = game.Workspace
part2.Anchored = false
part2.Position = Vector3.new(-7, 2, 8)

-- Create 2 attachments
local attachment0 = Instance.new("Attachment")
attachment0.Parent = part2

local attachment1 = Instance.new("Attachment")
attachment1.Parent = part1

-- Create AlignOrientation
local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = part1
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true

-- Rotate Part1
local RunService = game:GetService("RunService")
RunService.RenderStepped:Connect(function()
	part1.CFrame = part1.CFrame*CFrame.Angles(0,.05, 0)
end)
```
 */
interface AlignOrientation extends RbxInternalConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AlignOrientation";
	/** [LACKS DOCUMENTATION] */
	AlignType: Enum.AlignType;
	/** The maximum angular velocity the constraint can use to reach its goal. */
	MaxAngularVelocity: number;
	/** The maximum torque the constraint can use to reach its goal. */
	MaxTorque: number;
	/** If set to true, then the AlignOrientation will only apply torque if the primary axis of its Attachment0 becomes unaligned with Attachment1. This means that any rotation about the Attachment0’s primary axis will not create a torque. */
	PrimaryAxisOnly: boolean;
	/** When true the constraint will apply torque on both Attachments to achieve the goal. */
	ReactionTorqueEnabled: boolean;
	/** Used to control how quickly the constraint will reach its goal. Higher values will cause the attachment to align quicker. Value can be between 5 and 200. */
	Responsiveness: number;
	/** When set to true, the solver will react as quickly as possible to align the attachments. When false, the torque is dependent on `MaxTorque`, `MaxAngularVelocity`, and `Responsiveness`. */
	RigidityEnabled: boolean;
}

/** **AlignPosition** is used to apply a force towards a location. Like other constraints, this has two `Attachments`. In this case, the two attachments are constrained to be in the same **position**, although not necessarily in the same orientation.

By default, this constraint only applies force on the parent of `Attachment0`, although it can be configured to apply force on both attachments.

Note that if this constraint attaches one part (**A**) to another part (**B**) that is anchored or connected to an anchored part (**Z**), part **A**
 will not be locally simulated when interacting with a player. */
interface AlignPosition extends RbxInternalConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AlignPosition";
	/** When true, applies force at center of mass of Attachment0’s parent Part. When false, applied at Attachment0. */
	ApplyAtCenterOfMass: boolean;
	/** Maximum force the constraint can apply to achieve its goal. Only used if RigidityEnabled is false. */
	MaxForce: number;
	/** Maximum speed the Attachment can move when converging. Only used if RigidityEnabled is false. */
	MaxVelocity: number;
	/** When true the constraint will apply force on both Attachments to achieve the goal. */
	ReactionForceEnabled: boolean;
	/** Used to control how quickly the constraint will reach its goal. Higher values will cause the attachments to move together quicker. Value can be between 5 and 200. */
	Responsiveness: number;
	/** When set to true, the solver will react as quickly as possible to move the attachments together. When false, the torque is dependent on `MaxForce`, `MaxVelocity`, and `Responsiveness`. */
	RigidityEnabled: boolean;
}

interface AngularVelocity extends RbxInternalConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AngularVelocity";
	/** A `Vector3` force applied to achieve and maintain an angular velocity for the body. This vector is applied in the `CFrame` expressed by the `RelativeTo` property. Defaults to **(0, 0, 0)**. */
	AngularVelocity: Vector3;
	/** Magnitude of the maximum torque the constraint can apply. Defaults to **0**. */
	MaxTorque: number;
	/** The `CFrame` in which the `AngularVelocity` force is specified. If set to **`World`**, the angular velocity vector is used as is. If set to **Attachment1**, the angular velocity is transformed by the CFrame of the assigned attachment.

`RelativeTo` can also be set to **Attachment0**, but it makes no physical sense and will lead to unpredictable behaviors. There will be a warning in Studio but the API will not prevent setting this value. */
	RelativeTo: Enum.ActuatorRelativeTo;
}

/** A **BallSocketConstraint** constrains its `Attachments` so that they occupy the same position. By default it allows both attachments to freely rotate about all of their axes, but if `LimitsEnabled` is `true`, the attachments can only rotate in a limited cone.

Note that if this constraint attaches one part (**A**) to another part (**B**) that is anchored or connected to an anchored part (**Z**), part **A**
 will not be locally simulated when interacting with a player. */
interface BallSocketConstraint extends RbxInternalConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BallSocketConstraint";
	/** Sets whether the `BallSocketConstraint` has a limit on rotation based on `UpperAngle`. 
When a BallSocketConstraint has LimitsEnabled set to true, it enforces that its `Attachment1` isn’t rotated more than a set distance from its `Attachment0`.

The angle that is used is the angle between the x-axes of the attachments:

![BallSocketConstraint Limits](https://developer.roblox.com/assets/5b60fef9858e507e4016cc1e/BallSocketConstraintLimits.png) */
	LimitsEnabled: boolean;
	/** The visualized radius of the BallSocketConstraint. */
	Radius: number;
	/** How elastic `Attachment` connected by a `BallSocketConstraint` will be when they reach the end of the range specified by `UpperAngle` when `LimitsEnabled` is true. Constrained between 0 and 1. */
	Restitution: number;
	/** Sets whether the `BallSocketConstraint` sets a limit on twist rotation based on `TwistUpperAngle` and `TwistLowerAngle`. 


When a BallSocketConstraint has TwistLimitsEnabled set to true, it enforces that its `Attachment1` isn't twisted more than a set distance from its `Attachment0`. The angle that is used is the angle between the x-axes of the attachments:Sets whether the BallSocketConstraint sets a limit on twist rotation based on `TwistUpperAngle` and `TwistLowerAngle`. */
	TwistLimitsEnabled: boolean;
	/** Sets the lower twist rotation limit of the BallSocketConstraint, as long as `TwistLimitsEnabled` is `true`
. */
	TwistLowerAngle: number;
	/** Sets the upper twist rotation limit of the BallSocketConstraint, as long as `TwistLimitsEnabled` is `true`
. */
	TwistUpperAngle: number;
	/** Sets the upper rotation limit of the BallSocketConstraint, as long as `LimitsEnabled` is `true`
. */
	UpperAngle: number;
}

/** A **HingeConstraint** allows two `Attachments` to rotate about one axis, constraining the two attachments so that they both occupy the same position and that their **X** axes point in the same direction.

Hinges can also be configured to actuate rotation, as follows:

* If `ActuatorType` is set to `Motor`, the hinge will attempt to rotate the attachments with the goal of reaching `AngularVelocity`. This rotation is limited by both `MotorMaxAcceleration` and `MotorMaxTorque`.
* If `ActuatorType` is set to `Servo`, the hinge will attempt to rotate to an angle specified by `TargetAngle`. This rotation is limited by both `AngularSpeed` and `ServoMaxTorque`.

Note that both actuated and free spinning rotation can be limited by setting `LimitsEnabled` to `true`. Also note that if this constraint attaches one part (**A**) to another part (**B**) that is anchored or connected to an anchored part (**Z**), part **A**
 will not be locally simulated when interacting with a player. */
interface HingeConstraint extends RbxInternalConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HingeConstraint";
	/** Sets whether the rotation of the HingeConstraint is actuated and, if so, what kind of actuation.

When ActuatorType is set to `None` then the hinge can swing freely:

![None](https://developer.roblox.com/assets/5b61fa9274c0756340c86538/HingeConstraintNone.gif)

When ActuatorType is set to `Motor` then the HingeConstraint will attempt to rotate at a constant velocity specified by `AngularVelocity`. The HingeConstraint will apply a torque up to `MotorMaxTorque` to achieve the desired velocity but will be limited by `MotorMaxAcceleration`.

![Motor](https://developer.roblox.com/assets/5b61faca74c0756340c8653e/HingeConstraintMotor.gif)

When ActuatorType is set to `Servo` then the HingeConstraint will attempt to rotate to an angle specified by `TargetAngle`. The HingeConstraint will attempt to rotate towards that goal at a target speed set by `AngularSpeed`. The maximum torque the HingeConstraint is allowed to use to meet these goals is set by `ServoMaxTorque`.

![Servo](https://developer.roblox.com/assets/5b61fafccf5f5e183db66827/HingeConstraintServo.gif) */
	ActuatorType: Enum.ActuatorType;
	/** The desired angular speed a `HingeConstraint` with `ActuatorType` set to `Servo` will attempt to maintain while rotating towards its `TargetAngle`. Measured in radians/second. */
	AngularSpeed: number;
	/** The angular velocity a `HingeConstraint` with `ActuatorType` set to `Motor` will attempt to achieve. Measured in radians/second. */
	AngularVelocity: number;
	/** The current angle of the `HingeConstraint`. This angle is calculated by measuring the angle separation of the y-axes of the HingeConstraint’s `Attachment`.

![CurrentAngle](https://developer.roblox.com/assets/5b61fbe602a4ed4c3dc9f6c9/HingeConstraintCurrentAngle.png)

Note that in the above picture the x-axis of the Attachment in PartA is pointed away from the camera.The current angle of the `HingeConstraint`. This angle is calculated by measuring the angle separation of the y-axes of the HingeConstraint’s `Attachment`.

![CurrentAngle](https://developer.roblox.com/assets/5b61fbe602a4ed4c3dc9f6c9/HingeConstraintCurrentAngle.png)

Note that in the above picture the x-axis of the Attachment in PartA is pointed away from the camera.

Tags: ReadOnly, NotReplicated */
	readonly CurrentAngle: number;
	/** Sets whether the `HingeConstraint` will limit the range of rotation. If enabled, the constraint will only allow the `CurrentAngle` to be between `LowerAngle` and `UpperAngle`. If the `Attachment` reach the end of the limited range of rotation then they will stop rotating. If `Restitution` is greater than 0 then the attachments will bounce when they hit the ends of the limited range.

For example, here is the result if LowerAngle is set to -90 and UpperAngle is set to 45. Note that the x-axis of the Attachment in PartA is pointed away from the camera:

![LimitsEnabled](https://developer.roblox.com/assets/5b61fc4f4bf5bf624023e747/HingeConstraintLimitsEnabled.gif) */
	LimitsEnabled: boolean;
	/** The minimum rotation angle the `HingeConstraint` will allow if `LimitsEnabled` is true. */
	LowerAngle: number;
	/** The maximum angular acceleration a `HingeConstraint` with `ActuatorType` set to `Motor` can apply to achieve its `AngularVelocity`. Measured in radians/(second squared). */
	MotorMaxAcceleration: number;
	/** The maximum torque a `HingeConstraint` with `ActuatorType` set to `Motor` can apply when trying to reach its desired `AngularVelocity`. */
	MotorMaxTorque: number;
	/** The visualized radius of the HingeConstraint. */
	Radius: number;
	/** How elastic `Attachment` connected by a `HingeConstraint` will be when they reach the end of the range  when `LimitsEnabled` is true. Constrained between 0 and 1. */
	Restitution: number;
	/** The maximum torque a `HingeConstraint` with `ActuatorType` set to `Servo` can apply when trying to reach its desired `AngularSpeed`. */
	ServoMaxTorque: number;
	/** The target angle a `HingeConstraint` will attempt to rotate to if its `ActuatorType` is set to `Servo`. Measured in degrees. */
	TargetAngle: number;
	/** The maximum rotation angle the `HingeConstraint` will allow if `LimitsEnabled` is true. */
	UpperAngle: number;
}

/** A LineForce is used to apply a force along a line between two points. As the end points of the line move, the direction of the force will change accordingly. */
interface LineForce extends RbxInternalConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LineForce";
	/** When set to false, the force will be applied to the part at the Attachment0’s location. This means that if the attachment is not at the center of the part, it can create a torque on the part. */
	ApplyAtCenterOfMass: boolean;
	/** When true, the force magnitude is multiplied by the inverse square of the distance. */
	InverseSquareLaw: boolean;
	/** The magnitude of the force. */
	Magnitude: number;
	/** The maximum absolute force that can be applied. This property is enabled only when InverseSquareLaw is also enabled. This property is mainly used to address the issue that the force of the body mover becomes infinite the closer the two attachments are, causing explosions that can't be prevented by scripts. This property bounds the force's absolute value. */
	MaxForce: number;
	/** Enables a reaction force (equal an opposite) to be applied to the parent of Attachment1. By default line force only applies a force on the parent of Attachment0 and uses Attachment1 as the target direction without any dynamic relationship. */
	ReactionForceEnabled: boolean;
}

/** A **RodConstraint** constrains two `Attachments` to remain separated by the value specified by `Length`. While the attachments remain at a set distance from one another, they can both rotate freely.

Note that if this constraint attaches one part (**A**) to another part (**B**) that is anchored or connected to an anchored part (**Z**), part **A**
 will not be locally simulated when interacting with a player. */
interface RodConstraint extends RbxInternalConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RodConstraint";
	/** The current distance between the `RodConstraint`'s two `Attachment`.The current distance between the `RodConstraint`'s two `Attachment`.

Tags: ReadOnly, NotReplicated */
	readonly CurrentDistance: number;
	/** The distance apart the `RodConstraint` attempts to keep its `Attachment` at. Measured in studs. */
	Length: number;
	/** The visualized thickness of the RodConstraint. */
	Thickness: number;
}

/** A RopeConstraint constrains two `Attachment` to separate no further than the length specified by `Length`. The attachments can move closer together than this length and can both freely rotate. */
interface RopeConstraint extends RbxInternalConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RopeConstraint";
	/** The current distance between the RopeConstraint's two `Attachment`.The current distance between the RopeConstraint's two `Attachment`.

Tags: ReadOnly, NotReplicated */
	readonly CurrentDistance: number;
	/** The maximum distance two `Attachment` can be when connected with a `RopeConstraint`. Measured in studs. */
	Length: number;
	/** Restitution controls how *elastic* an `Attachment` connected by a `RopeConstraint` will be when reaching the end of the rope `Length`. The value of this property is constrained between 0 and 1.

A RopeConstraint with a Restitution of 0 will not bounce when its Attachments reach their maximum separation.

![Restitution of 0](https://developer.roblox.com/assets/5b61fd89858e507e4016cec1/RopeConstraintRestitution0.gif)

A RopeConstraint with a Restitution of 1 will be almost completely elastic when its Attachments reach their maximum separation.

![Restitution of 1](https://developer.roblox.com/assets/5b61fda6858e507e4016cec7/RopeConstraintRestitution1.gif) */
	Restitution: number;
	/** The visualized thickness of the RopeConstraint. */
	Thickness: number;
}

interface RbxInternalSlidingBallConstraint extends RbxInternalConstraint {
	/** Sets whether the translation of the `PrismaticConstraint` is actuated and, if so, what kind of actuation.

If ActuatorType is set to **None**, then the joint can slide freely:

![None](https://developer.roblox.com/assets/5b61fe15b0a0fd683d298842/SlidingBallConstraintNone.gif)

If ActuatorType is set to **Motor**, then the PrismaticConstraint will attempt to move its `Attachment` at a constant velocity specified by `Velocity`. The PrismaticConstraint will apply a force up to `MotorMaxForce` to achieve the desired velocity but will be limited by `MotorMaxAcceleration`.


If ActuatorType is set to **Servo**, then the PrismaticConstraint will attempt to move its Attachments to an offset specified by `TargetPosition`. The PrismaticConstraint will attempt to translate towards that goal at a target speed set by `Speed`. The maximum force the PrismaticConstraint is allowed to use to meet these goals is set by `ServoMaxForce`. */
	ActuatorType: Enum.ActuatorType;
	/** The current offset between the `SlidingBallConstraint`’s `Attachment`.

![CurrentPosition](https://developer.roblox.com/assets/5b61fe4154f6677d407bb3a0/SlidingBallConstraintCurrentPosition.png)The current offset between the `SlidingBallConstraint`’s `Attachment`.

![CurrentPosition](https://developer.roblox.com/assets/5b61fe4154f6677d407bb3a0/SlidingBallConstraintCurrentPosition.png)

Tags: ReadOnly, NotReplicated */
	readonly CurrentPosition: number;
	/** Sets whether the `SlidingBallConstraint` will limit the range of translation. If enabled, the `CurrentPosition` of the SlidingBallConstraint will only be able to be between the values of `LowerLimit` and `UpperLimit`.

Here is a case where the UpperLimit is 2 and the LowerLimit is 1:

![Constraint Limits 1](https://developer.roblox.com/assets/5b61fe15ba048a343db86452/SlidingBallConstraintLimits0.png)

Here is a case where the UpperLimit is 4 and the LowerLimit is 2. Note that in this case the attachments will never be allowed to overlap; they will always be offset:

![Constraint Limits 2](https://developer.roblox.com/assets/5b61fe15cf5f5e183db66841/SlidingBallConstraintLimits1.png) */
	LimitsEnabled: boolean;
	/** The lower position limit along the x-axis of `Attachment0` for a `SlidingBallConstraint` if `LimitsEnabled` is true. */
	LowerLimit: number;
	/** The maximum acceleration a `SlidingBallConstraint` with `ActuatorType` set to `ActuatorType` can apply when trying to reach its desired `Velocity`. */
	MotorMaxAcceleration: number;
	/** The maximum force a `SlidingBallConstraint` with `ActuatorType` set to `ActuatorType` can apply when trying to reach its desired `Velocity`. */
	MotorMaxForce: number;
	/** How elastic `Attachment` connected by a SlidingBallConstraint will be when they reach the end of the range specified by `UpperLimit` and `LowerLimit` when `LimitsEnabled` is set to true. Constrained between 0 and 1.

***


Restitution of 0
-

![Restitution of 0](https://developer.roblox.com/assets/5b5b63434bf5bf624023dc3c/SlidingBallConstraintRestitution0.gif)

Restitution of 0.5
-

![Restitution of 0.5](https://developer.roblox.com/assets/5b5b6370f9cd894d3d8abc96/SlidingBallConstraintRestitution.5.gif)

Restitution of 1
-

![Restitution of 1](https://developer.roblox.com/assets/5b5b64587eac3e673d5e5720/SlidingBallConstraintRestitution1.gif) */
	Restitution: number;
	/** The maximum force a `SlidingBallConstraint` with `ActuatorType` set to `ActuatorType` can apply when trying to reach its desired `Speed`. */
	ServoMaxForce: number;
	/** The visualized size of the SlidingBallConstraint. */
	Size: number;
	/** The desired speed a `SlidingBallConstraint` with `ActuatorType` set to `ActuatorType` will attempt to maintain while translating towards its `TargetPosition`. Measured in studs/second. */
	Speed: number;
	/** The target position a `SlidingBallConstraint` will attempt to translate to if its `ActuatorType` is set to `ActuatorType`. Measured in studs. */
	TargetPosition: number;
	/** The upper position limit along the x-axis of `Attachment0` for a `SlidingBallConstraint` if `LimitsEnabled` is true. */
	UpperLimit: number;
	/** The velocity a `SlidingBallConstraint` with `ActuatorType` set to `ActuatorType` will attempt to achieve. Measured in studs/second. */
	Velocity: number;
}
/** The base class for constraints that allow their attachments to slide along an axis. */
type SlidingBallConstraint = CylindricalConstraint | PrismaticConstraint;

/** A **CylindricalConstraint** allows its attachments to slide along one axis and rotate about another axis. It can be thought of like a combination of a `PrismaticConstraint` and a `HingeConstraint`. The sliding axis is determined by the **X** axis of the constraint's `Attachment0`. The rotation axis is centered at the constraint's `Attachment1` and is angled off of the sliding constraint by the constraint's `InclinationAngle`.

This constraint, along with a `SpringConstraint`, is ideal for building vehicle suspension as demonstrated in `/articles/building carkit 1|Building a Basic Car`
.

Note that if this constraint attaches one part (**A**) to another part (**B**) that is anchored or connected to an anchored part (**Z**), part **A**
 will not be locally simulated when interacting with a player. */
interface CylindricalConstraint extends RbxInternalSlidingBallConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CylindricalConstraint";
	/** Type of angular actuator: None, Motor, or Servo. */
	AngularActuatorType: Enum.ActuatorType;
	/** Enables the angular limits around the rotation axis. */
	AngularLimitsEnabled: boolean;
	/** Restitution of the two limits, or how elastic they are. Value in [0, 1]. */
	AngularRestitution: number;
	/** Target angular speed. This value is unsigned as the servo will always move toward its target. In radians per second. Value in [0, inf). */
	AngularSpeed: number;
	/** The target angular velocity of the motor in radians per second around the rotation axis. Value in [0, inf). */
	AngularVelocity: number;
	/** Signed angle (in degrees) between the reference axis and the secondary axis of Attachment1 around the rotation axis. Value in [-180, 180].Signed angle (in degrees) between the reference axis and the secondary axis of Attachment1 around the rotation axis. Value in [-180, 180].

Tags: ReadOnly, NotReplicated */
	readonly CurrentAngle: number;
	/** Direction of the rotation axis as an angle from the x-axis in the xy-plane of Attachment0. Value in [-180, 180]. */
	InclinationAngle: number;
	/** Lower limit for the angle (in degrees) between the reference axis and the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	LowerAngle: number;
	/** The maximum angular acceleration of the motor in radians per second squared. Value in [0, inf). */
	MotorMaxAngularAcceleration: number;
	/** The maximum torque the motor can apply to achieve the target angular velocity. The units are mass * studs^2 / second^2. Value in [0, inf). */
	MotorMaxTorque: number;
	/** Enable the visibility of the rotation axis. */
	RotationAxisVisible: boolean;
	/** Maximum torque the servo motor can apply. The units are mass * studs^2 / second^2. Value in [0, inf). */
	ServoMaxTorque: number;
	/** Target angle (in degrees) between the reference axis and the secondary axis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	TargetAngle: number;
	/** Upper limit for the angle (in degrees) between the reference axis and the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	UpperAngle: number;
	/** The unit vector direction of the rotation axis in world coordinates.The unit vector direction of the rotation axis in world coordinates.

Tags: ReadOnly, NotReplicated */
	readonly WorldRotationAxis: Vector3;
}

/** A **PrismaticConstraint** creates a rigid joint between two `Attachments`, allowing them to slide along one axis but not rotate. This constrains the attachments so that their **X** axes are collinear but pointing in opposite directions. It also constrains the attachments so that their **Y** axes are parallel.

This constraint inherits properties from `SlidingBallConstraint` and can be configured to actuate translation, as follows:

* If `ActuatorType` is set to `Motor`, it will attempt to translate the attachments with the goal of reaching `Velocity`. This translation is limited by both `MotorMaxAcceleration` and `MotorMaxForce`.
* If `ActuatorType` is set to `Servo`, it will attempt to translate the attachments to a set separation specified by `TargetPosition`.

Note that both actuated and free translation can be limited by setting `LimitsEnabled` to `true`. Also note that if this constraint attaches one part (**A**) to another part (**B**) that is anchored or connected to an anchored part (**Z**), part **A**
 will not be locally simulated when interacting with a player. */
interface PrismaticConstraint extends RbxInternalSlidingBallConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PrismaticConstraint";
}

/** A **SpringConstraint** applies a force to its `Attachments` based on spring and damper behavior. Assuming the constraint has `Stiffness`, it will apply forces based on how far apart the attachments are. If the attachments are further apart than the constraint's `FreeLength`, the attachments will be forced together. If they are closer than the `FreeLength`, the attachments will be forced apart. In addition, if `Damping` is set, there will be a damping component to the applied force that scales with the velocity of the attachments.

This constraint, along with a `CylindricalConstraint`, is ideal for building vehicle suspension as demonstrated in `/articles/building carkit 1|Building a Basic Car`
.

Note that if this constraint attaches one part (**A**) to another part (**B**) that is anchored or connected to an anchored part (**Z**), part **A**
 will not be locally simulated when interacting with a player.

## Calculating SpringConstraint Force

The following helper function exhibits how the force of a `SpringConstraint` is calculated based on various properties of the constraint and its attachments.

```lua
local function getSpringForce(spring)
	if not spring:IsA("SpringConstraint") then
		warn(spring .. " is not a spring constraint!")
		return
	end

	local currentLength = spring.CurrentLength
	local freeLength = spring.FreeLength
	if (spring.LimitsEnabled) then
		currentLength = math.clamp(currentLength, spring.MinLength, spring.MaxLength)
		freeLength = math.clamp(freeLength, spring.MinLength, spring.MaxLength)
	end
	local springLength = currentLength - freeLength

	local axis = spring.Attachment0.WorldPosition - spring.Attachment1.WorldPosition
	if axis.Magnitude > 0 then
		axis = axis.Unit
	end
	local effectiveVelocity = spring.Attachment0.Parent.Velocity - spring.Attachment1.Parent.Velocity

	-- https://en.wikipedia.org/wiki/Harmonic_oscillator
	-- f = -k * x - c * dx/dt + fext
	-- Gravity may not be all of the external forces; friction may affect this, but it's harder to account for
	local forceExternal = Vector3.new(0, -workspace.Gravity, 0)
	local force = -spring.Stiffness * springLength - spring.Damping * axis:Dot(effectiveVelocity) + axis:Dot(forceExternal)

	force = math.clamp(force, -spring.MaxForce, spring.MaxForce)
	return force
end
```

## Code Samples

### Calculating SpringConstraint Force

The following helper function exhibits how the force of a `SpringConstraint` is calculated based on various properties of the constraint and its attachments.
```lua
local function getSpringForce(spring)
	if not spring:IsA("SpringConstraint") then
		warn(spring .. " is not a spring constraint!")
		return
	end

	local currentLength = spring.CurrentLength
	local freeLength = spring.FreeLength
	if (spring.LimitsEnabled) then
		currentLength = math.clamp(currentLength, spring.MinLength, spring.MaxLength)
		freeLength = math.clamp(freeLength, spring.MinLength, spring.MaxLength)
	end
	local springLength = currentLength - freeLength

	local axis = spring.Attachment0.WorldPosition - spring.Attachment1.WorldPosition
	if axis.Magnitude > 0 then
		axis = axis.Unit
	end
	local effectiveVelocity = spring.Attachment0.Parent.Velocity - spring.Attachment1.Parent.Velocity

	-- https://en.wikipedia.org/wiki/Harmonic_oscillator
	-- f = k * x - c * dx/dt + fext
	-- Gravity may not be all of the external forces; friction may affect this, but it's harder to account for
	local forceExternal = Vector3.new(0, -workspace.Gravity, 0)
	local force = spring.Stiffness * springLength - spring.Damping * axis:Dot(effectiveVelocity) + axis:Dot(forceExternal)

	force = math.clamp(force, -spring.MaxForce, spring.MaxForce)
	return force
end
```
 */
interface SpringConstraint extends RbxInternalConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SpringConstraint";
	/** The number of coils visualized on the SpringConstraint. This can only be set between 0 and 8. */
	Coils: number;
	/** The current distance between the `SpringConstraint`’s `Attachment`.The current distance between the `SpringConstraint`’s `Attachment`.

Tags: ReadOnly, NotReplicated */
	readonly CurrentLength: number;
	/** Damping constant for the `SpringConstraint`. Multiplied to the velocity of the constraint’s `Attachment` to reduce the spring force applied. */
	Damping: number;
	/** Natural resting length of the spring. */
	FreeLength: number;
	/** Sets whether the `SpringConstraint` enforces a minimum and maximum length. If the `SpringConstraint`’s `Attachment` reach these limits, they will simply stop moving apart from one another without restitution. If you need restitution or elasticity at the ends of the range of motion, you can combine a `SpringConstraint` with another constraint that allows restitution at the end of its range, such as a `PrismaticConstraint` or `RopeConstraint`. */
	LimitsEnabled: boolean;
	/** The maximum force the `SpringConstraint` can apply on its `Attachment`.
Some spring systems can give rise to forces that grow fast leading to instability. In such cases it is recommended to set MaxForce to a reasonable value.The maximum force the SpringConstraint can apply on its `Attachment`. */
	MaxForce: number;
	/** The maximum separation the `SpringConstraint` will allow if `LimitsEnabled` is true. */
	MaxLength: number;
	/** The minimum separation the `SpringConstraint` will allow if `LimitsEnabled` is true. */
	MinLength: number;
	/** The visualized radius of the spring's coils. */
	Radius: number;
	/** The strength of the spring. The higher this value the more force will be applied when the attachments are separated a different length than the `FreeLength`. */
	Stiffness: number;
	/** The visualized thickness of the spring's coils. */
	Thickness: number;
}

/** A Torque, as it's name suggests, is used to apply a rotational force to a part or assembly. When active, this object will find the center of mass of the part or assembly connected to its Attachment0 and will apply a torque, spinning the part or parts. */
interface Torque extends RbxInternalConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Torque";
	/** The [CFrame](https://developer.roblox.com/api-reference/datatype/CFrame "CFrame")
 in which the Torque is expressed. */
	RelativeTo: Enum.ActuatorRelativeTo;
	/** The strength and direction of the torque. */
	Torque: Vector3;
}

/** A VectorForce is used to apply a force to a part or assembly of parts. The direction and strength of the force is determined by a Vector3 and can be relative to an attachment on the part, another attachment, or the world coordinate system. */
interface VectorForce extends RbxInternalConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VectorForce";
	/** When true, applies force at center of mass of Attachment0’s parent Part. When false, applied at Attachment0. */
	ApplyAtCenterOfMass: boolean;
	/** The strength and direction of the force. */
	Force: Vector3;
	/** The [CFrame](https://developer.roblox.com/api-reference/datatype/CFrame "CFrame")
 in which the force is expressed. */
	RelativeTo: Enum.ActuatorRelativeTo;
}

/** The ContentProvider is a service that is used to load content, or assets, into a game.

The service's main use is to preload assets into a game. When a new asset, such as a `Decal` or `Sound` is used in a game, Roblox will load the content associated with it from Roblox servers. In some cases this can be undesirable for developers as it can lead to a delay before the content loads into the game.

With ContentProvider, developers can preload assets using the `PreloadAsync` function. Another useful property is `RequestQueueSize`, which can be used to measure what proportion of assets in the request queue have been downloaded.

## Code Samples

### ContentProvider

In this example a Decal and Sound are preloaded into a game. Once they have finished loading the script will print a message to the output.
```lua
local ContentProvider = game:GetService("ContentProvider")
 
local logoId = "rbxassetid://658743164"
local pageTurnId = "rbxassetid://12222076"
 
local decal = Instance.new("Decal")
decal.Texture = logoId
 
local sound = Instance.new("Sound")
sound.SoundId = pageTurnId
 
local assets = { decal, sound }
 
ContentProvider:PreloadAsync(assets)
 
print("All assets loaded.")
```
 */
interface ContentProvider extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ContentProvider";
	/** The base URL that is used by the `ContentProvider` for downloading assets from the Roblox website. This url will point to a Roblox hosted website where asserts are to be downloaded from. 

This URL is pulled from the AppSettings.xml file which is located in the version-hash folder.

It is possible to overwrite this property using the `SetBaseUrl` function in the command bar. However this is not recommended and may cause issues with assets loading. */
	readonly BaseUrl: string;
	/** RequestQueueSize gives the number of items in `ContentProvider`'s request queue that are waiting to be downloaded.

Items are added to the client's request queue when an asset is used for the first time or `PreloadAsync` is called.

Developers are advised not to use RequestQueueSize to create loading bars. This is because the queue size can both increase and decrease over time as new assets are added and downloaded. Developers looking to display loading progress should load assets one at a time (see example below).

## Code Samples

### ContentProvider Loading Bar

This code sample demonstrates how `PreloadAsync` can be used to create a simple loading bar in a game, by loading the assets one at a time.
```lua
local ContentProvider = game:GetService("ContentProvider")
local Players = game:GetService("Players")

-- create a screenGui
local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")
local screenGui = Instance.new("ScreenGui", playerGui)

-- create a basic loading bar
local frame = Instance.new("Frame", screenGui)
frame.Size = UDim2.new(0.5, 0, 0.1, 0)
frame.Position = UDim2.new(0.5, 0, 0.5, 0)
frame.AnchorPoint = Vector2.new(0.5, 0.5)

local bar = Instance.new("Frame", frame)
bar.Size = UDim2.new(0, 0, 1, 0)
bar.Position = UDim2.new(0, 0, 0, 0)
bar.BackgroundColor3 = Color3.new(0, 0, 1)

-- create some sample assets
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://301964312"
local sound2 = Instance.new("Sound")
sound2.SoundId = "rbxassetid://301964312"

-- create a table of assets to be loaded
local assets = {
	sound,
	sound2
}

wait(3)

for i = 1, #assets do
	local asset = assets[i]
	ContentProvider:PreloadAsync({asset}) -- 1 at a time, yields
	local progress = i / #assets
	bar.Size = UDim2.new(progress, 0, 1, 0)
end

print("loading done")
```
 */
	readonly RequestQueueSize: number;
	/** This function takes an array of `Instances` as a parameter and yields until all of assets associated with those instances have loaded. This can be used to pause a script and not use content until it is certain that the content has been loaded into the game.

When the function is called, the engine will go through all of the instances in the passed in array (and all of the descendants of the passed in instances). If any of the instances have a property that defines a link to content, such as a `Decal` or a `Sound`, then the function will attempt to load the asset from the Roblox website. If any of the assets fail to load, an error message will appear in the places output, but the PreloadAsync function itself will not error and will continue executing until it has processed each passed in instance.

## Code Samples

### Preloading Assets

In this example a Decal and Sound are preloaded into a game. Once they have finished loading the script will print a message to the output.
```lua
local ContentProvider = game:GetService("ContentProvider")

local logoId = "rbxassetid://658743164"
local pageTurnId = "rbxassetid://12222076"

local decal = Instance.new("Decal")
decal.Texture = logoId

local sound = Instance.new("Sound")
sound.SoundId = pageTurnId

local assets = { decal, sound }

ContentProvider:PreloadAsync(assets)

print("All assets loaded.")
```

@param contentIdList An array of `Instance`s to be preloaded. */
	PreloadAsync(contentIdList: Array<Instance>): void;
}

/** @client */
	/** The ContextActionService is a game service that allows a game to bind user input to contextual actions, or actions that are only enabled under some condition or period of time. For example, allowing a player to open a door only while close by. In code, an action is simply a string (the name of the action) used by the service to differentiate between unique actions. The string is provided to BindAction and UnbindAction, among other member functions. If two actions are bound to the same input, the most recent takes priority. When the most recent action is unbound, the one bound before that takes control again.

You can inspect the currently bound actions in the developer console under the "Action Bindings" tab. You'll also see bindings from the Roblox engine too. This is useful in checking if your actions are binding/unbinding at the correct times, or if some other action is stealing input from your actions. For exmaple, if you are attempting to bind WASD, it may be the case that character movement scripts is binding over those same keys.

ContextActionService is especially useful for supporting keyboard-less players, in which on-screen touch buttons can be used in place of key presses. The buttons will display only when the action is bound, and the position, text and/or images of these buttons can be configured through this service.

It's better to use ContextActionService's BindAction than UserInputService's InputBegan for most cases. For example, if you want to use the `R` key to reload a weapon while it is equipped, the player might type "roblox is fun" in chat or otherwise use the `R` key for something else. The weapon could reload when the player didn't mean to! If you instead use BindAction and UnbindAction when the weapon is equipped/unequipped, ContextActionService will make sure that `R` key presses trigger the reload action only when it is the most recently bound action. */
interface ContextActionService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ContextActionService";
	/** BindAction will bind an action to user input given an action handling function. The action handler function will be called when some input matches the provided user input enums.

The method behaves like a stack: if two actions are bound to the same user input, only the most recent action handler will be called.  When UnbindAction is called, the action handler is removed from the stack. If an action handler returns `Enum.ContextActionResult.Pass`, an input will call to the next most recently bound action handler.

## Code Samples

### Stacked Action Handlers

This code sample demonstrates how BindAction acts like a stack. It binds two actions, FirstAction (`Z`, `X`, and `C` keys) and SecondAction (`Z` and `X` keys) to two action handling functions. The second one will pass on a certain input (the `X` key).

Both actions use the `Z` and `X` keys, however the second handler will pass input only if `X` is pressed. So, when `X` is pressed, the second handler is called and then the first. The first action is also bound to the `C` key, and can be triggered even though the other two inputs are "covered" by the second action.

Test this code out by pasting it into a LocalScript within StarterPlayerScripts, then pressing `Z`, `X` and `C`. Observe which action handlers are called with what actions.
```lua
local ContextActionService = game:GetService("ContextActionService")
 
-- Define an action handler for FirstAction
local function actionHandlerOne(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin then
		print("Action Handler One: " .. actionName)
	end
	-- This action handler returns nil, so it is assumed that
	-- it properly handles the action.
end

-- Binding the action FirstAction (it's on the bottom of the stack)
ContextActionService:BindAction("FirstAction", actionHandlerOne, false, Enum.KeyCode.Z, Enum.KeyCode.X, Enum.KeyCode.C)

-- Define an action handler for SecondAction 
local function actionHandlerTwo(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin then 
		print("Action Handler Two: " .. actionName)
	end
	
	if inputObj.KeyCode == Enum.KeyCode.X then
		return Enum.ContextActionResult.Pass
	else
		-- Returning nil implicitly Sinks inputs
		return Enum.ContextActionResult.Sink
	end
end

-- Binding SecondAction over the first action (since it bound more recently, it is on the top of the stack)
-- Note that SecondAction uses the same keys as 
ContextActionService:BindAction("SecondAction", actionHandlerTwo, false, Enum.KeyCode.Z, Enum.KeyCode.X)
```

### General Action Handler

This code sample uses ContextActionService to bind an action named "BoundAction" to a general action handler function on the `F` key. Place this in a LocalScript inside StarterPlayerScripts and press `F` to see the message "Handling action: BoundAction".
```lua
local ContextActionService = game:GetService("ContextActionService")

-- Setting up the action handling function
local function handleAction(actionName, inputState, inputObj)
    if inputState == Enum.UserInputState.Begin then
        print("Handling action: " .. actionName)
    end

	-- Since this function does not return anything, this handler will
	-- "sink" the input and no other action handlers will be called after
	-- this one.
end

-- Bind the action to the handler
ContextActionService:BindAction("BoundAction", handleAction, false, Enum.KeyCode.F)
```
 */
	/** @rbxts client */
	BindAction(
		/** The name of the action being bound */
		actionName: string,
		/** The function to call when the corresponding event fires */
		functionToBind: (actionName: string, state: Enum.UserInputState, inputObject: InputObject) => void,
		/** Whether or not a TouchButton will be created for this action on mobile */
		createTouchButton: boolean,
		/** The event to which the functionToBind will be bound. */
	...inputTypes: Array<Enum.KeyCode | Enum.PlayerActions | Enum.UserInputType>
	): void;
	/** Binds function to fire when specified inputTypes occur. Allows the priority of the bound action to be specified.
If there are multiple actions bound to one of the _inputTypes_, the priority of this action will determine if it will be passed first.Binds function to fire when specified inputTypes occur. Allows the priority of the bound action to be specified. */
	/** @rbxts client */
	BindActionAtPriority(
		/** The name of the action being bound */
		actionName: string,
		/** The function to call when the corresponding event fires */
		functionToBind: (actionName: string, state: Enum.UserInputState, inputObject: InputObject) => void,
		/** Whether or not a TouchButton will be created for this action on mobile */
		createTouchButton: boolean,
		/** The priority level.  */
		priorityLevel: number,
		/** The event to which the functionToBind will be bound. */
	...inputTypes: Array<Enum.KeyCode | Enum.PlayerActions | Enum.UserInputType>
	): void;
	/** Specifies the `KeyCode` that can be used with a `UserInputType` to activate a [Tool](https://wiki.roblox.com/index.php?title=Tool "Tool"), or a [HopperBin](https://wiki.roblox.com/index.php?title=HopperBin "HopperBin") .

When the KeyCode is used, it will fire the [Button1Down](https://wiki.roblox.com/index.php?title=Button1Down "Button1Down") event under the [Mouse](https://wiki.roblox.com/index.php?title=Mouse "Mouse") returned by `Equipped` or `Selected`, and it will fire the [Tool](https://wiki.roblox.com/index.php?title=Tool "Tool")'s `Activated` event.Specifies the `KeyCode` that can be used with a `UserInputType` to activate a [Tool](https://wiki.roblox.com/index.php?title=Tool "Tool"), or a [HopperBin](https://wiki.roblox.com/index.php?title=HopperBin "HopperBin").

## Notes

* You should only use the following `UserInputType` with the _userInputTypeForActivation_ parameter, as the others will not do anything:
  - _Keyboard_
  - _Gamepad1_ through _Gamepad8_

* If a [Tool](https://wiki.roblox.com/index.php?title=Tool "Tool")
's `ManualActivationOnly` property is set to true, you will be unable to activate the tool using this. */
	BindActivate(userInputTypeForActivation: CastsToEnum<Enum.UserInputType>, keyCodeForActivation?: CastsToEnum<Enum.KeyCode>): void;
	/** Returns a table with all bound action info. Each entry is a key with _actionName_
 and value being the same table you would get from `GetBoundActionInfo`. */
	GetAllBoundActionInfo(): Map<string, BoundActionInfo>;
	/** Returns a table with info regarding the function bound with _actionName_ . Table has the keys _title_ (current title that was set with `SetTitle`) _image_ (image set with `SetImage`) _description_ (description set with `SetDescription`) _inputTypes_ (tuple containing all input bound for this _actionName_) _createTouchButton_ (whether or not we created a touch button for this _actionName_
). */
	GetBoundActionInfo(actionName: string): BoundActionInfo;
	/** Returns the `TextureId` of a [tool](https://wiki.roblox.com/index.php?title=Tool "Tool") currently equipped by the [Player](https://wiki.roblox.com/index.php?title=Player "Player")
, if one is equipped. */
	GetCurrentLocalToolIcon(): string;
	/** If _actionName_ key contains a bound action, then _description_
 is set as the description of the bound action. This description will appear for users in a listing of current actions available. */
	SetDescription(actionName: string, description: string): void;
	/** If _actionName_ key contains a bound action, then _image_
 is set as the image of the touch button. Does nothing if a touch button was not created. No guarantees are made whether image will be set when button is manipulated. */
	SetImage(actionName: string, image: string): void;
	/** If _actionName_ key contains a bound action, then _position_
 is set as the position of the touch button. Does nothing if a touch button was not created. No guarantees are made whether position will be set when button is manipulated. */
	SetPosition(actionName: string, position: UDim2): void;
	/** If _actionName_ key contains a bound action, then _title_
 is set as the title of the touch button. Does nothing if a touch button was not created. No guarantees are made whether title will be set when button is manipulated. */
	SetTitle(actionName: string, title: string): void;
	/** UnbindAction will unbind an action by name from user inputs. Use this function when the context for some action is no longer applicable. For instance, if a gun Tool is unequipped, you might use UnbindAction on a Reload action since a gun can only be reloaded if it is equipped. */
	UnbindAction(actionName: string): void;
	/** Undos the specification of a `KeyCode` that can be used with a `UserInputType` to activate a [Tool](https://wiki.roblox.com/index.php?title=Tool "Tool"), or a [HopperBin](https://wiki.roblox.com/index.php?title=HopperBin "HopperBin")
, if it was set earlier using `BindActivate`. */
	UnbindActivate(userInputTypeForActivation: CastsToEnum<Enum.UserInputType>, keyCodeForActivation?: CastsToEnum<Enum.KeyCode>): void;
	/** Removes all functions bound. No actionNames will remain. All touch buttons will be removed. If a button was manipulated manually there is no guarantee it will be cleaned up. */
	UnbindAllActions(): void;
	/** If _actionName_
 key contains a bound action, then this will return the touch button (if was created). Returns nil if a touch button was not created. No guarantees are made whether button will be retrievable when button is manipulated. */
	/** @rbxts client */
	GetButton(actionName: string): ImageButton | undefined;
	/** Fires when the current player equips a [Tool](https://developer.roblox.com/api-reference/class/Tool "Tool")
. */
	/** @rbxts client */
	readonly LocalToolEquipped: RBXScriptSignal<(toolEquipped: Tool | Flag) => void>;
	/** Fires when the current player unequips a [Tool](https://developer.roblox.com/api-reference/class/Tool "Tool")
. */
	/** @rbxts client */
	readonly LocalToolUnequipped: RBXScriptSignal<(toolUnequipped: Tool | Flag) => void>;
}

interface RbxInternalController extends RbxInternalInstance {
	/** Activates an overriding bind on the specified button.

## Code Samples

### Controller:BindButton1

The example below when placed inside a `/LocalScript`, would result in a GUI saying "Press Backspace to win!".
```lua
local ControllerService = game:GetService("ControllerService")
local humanoidController = ControllerService:FindFirstChildOfClass("HumanoidController")
humanoidController:BindButton(Enum.Button.Dismount, "win!")
```
 */
	BindButton(button: CastsToEnum<Enum.Button>, caption: string): void;
	/** Returns whether or not Button is being pressed. */
	GetButton(button: CastsToEnum<Enum.Button>): boolean;
	/** Removes the bind on button. */
	UnbindButton(button: CastsToEnum<Enum.Button>): void;
	/** Fired when the pressed state of a bound button is changed. This event can be used in conjunction with `GetButton` to see whether a bound button is being pressed down or not. */
	readonly ButtonChanged: RBXScriptSignal<(button: Enum.Button) => void>;
}
/** The base class for controller objects, such as the `HumanoidController` object. */
type Controller = HumanoidController | SkateboardController | VehicleController;

/** A HumanoidController is an internal object responsible for translating PlayerAciton movements to the user's character (specifically, their `Humanoid`).

This object can be found inside of the `ControllerService`, via:
```lua
local ControllerService = game:GetService("ControllerService")
local HumanoidController = ControllerService:FindFirstChildOfClass("HumanoidController")
``` */
interface HumanoidController extends RbxInternalController {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HumanoidController";
}

/** A SkateboardController is an object  responsible for translating PlayerActions to movements with a  `SkateboardPlatform`. */
interface SkateboardController extends RbxInternalController {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SkateboardController";
	/** The direction of movement, tied to the keys A and D. Must be 1 (right), 0 (straight), or -1 (left). Will refresh back to 0 unless constantly set.The direction of movement, tied to the keys A and D. Must be 1 (right), 0 (straight), or -1 (left). Will refresh back to 0 unless constantly set.

Tags: ReadOnly, NotReplicated */
	readonly Steer: number;
	/** The direction of movement, tied to the keys W and S. Must be an integer 1 (forward), 0 (null), or -1 (reverse). Will refresh back to 0 unless constantly set.The direction of movement, tied to the keys W and S. Must be an integer 1 (forward), 0 (null), or -1 (reverse). Will refresh back to 0 unless constantly set.

Tags: ReadOnly, NotReplicated */
	readonly Throttle: number;
	/** Fired when any input state of the skateboard controller is updated.
The _axis_ is fired with either ["Throttle"](https://developer.roblox.com/articles/String "String") if the throttle state of the skateboard was updated or ["Steer"](https://developer.roblox.com/articles/String "String") if the steering state of the skateboard was updated.Fired when any input state of the skateboard controller is updated. */
	readonly AxisChanged: RBXScriptSignal<(axis: string) => void>;
}

/** A VehicleController is an object responsible for translating [PlayerActions](https://developer.roblox.com/api-reference/enum/PlayerActions "PlayerActions")
 to movements with a  `VehicleSeat`. */
interface VehicleController extends RbxInternalController {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VehicleController";
}

/** Container class for the `HumanoidController` among other classes. */
interface ControllerService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ControllerService";
}

/** Used by Roblox to control HTTP cookies for analytical purposes.

Can only be used by Roblox's backend servers, and therefore is not available to developers in any shape or form. */
interface CookiesService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CookiesService";
}

/** An internal service which stores `ModuleScript`s used by Roblox's `CoreScript`s. */
interface CorePackages extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CorePackages";
}

interface CoreScriptSyncService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CoreScriptSyncService";
}

interface CustomEvent extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CustomEvent";
	/** This function returns the `CustomEventReceivers` that are connected to the `CustomEvent`. */
	GetAttachedReceivers(): Array<Instance>;
	/** This function sets the value of the `CustomEvent` and fires the `SourceValueChanged` event for all connected `recievers`. */
	SetValue(newValue: number): void;
	/** This event fires when a receiver is connected to the `CustomEvent` */
	readonly ReceiverConnected: RBXScriptSignal<(receiver: Instance) => void>;
	/** This event fires when a receiver is disconnected from the `CustomEvent`. */
	readonly ReceiverDisconnected: RBXScriptSignal<(receiver: Instance) => void>;
}

interface CustomEventReceiver extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CustomEventReceiver";
	/** This property attaches the `CustomEventReceiver` object to a `CustomEvent`. */
	Source?: Instance;
	/** This function returns the current value of the reciever's `Source` property. */
	GetCurrentValue(): number;
	/** This event fires when the receiver is attached to a different `CustomEvent`, when the `Source` property is changed. */
	readonly EventConnected: RBXScriptSignal<(event: Instance) => void>;
	/** This event fires when the receiver is attached to a different `CustomEvent`, when the `Source` property is changed. */
	readonly EventDisconnected: RBXScriptSignal<(event: Instance) => void>;
	/** Fires when the value of the CustomEvent's source is changed, passing the CustomEvent's new value. */
	readonly SourceValueChanged: RBXScriptSignal<(newValue: number) => void>;
}

interface RbxInternalDataModelMesh extends RbxInternalInstance {
	/** The Offset of a mesh determines the distance from the `Position` of a `BasePart` that the mesh will be displayed.

## How to use mesh offset

The Offset property changes the relative position the mesh will be rendered at. For example, an offset of 0, 5, 0 will cause the mesh to be displayed 5 studs above the position of the `BasePart`.

The position of the `BasePart` remains unchanged, meaning the physics collision box of the part will remain in the same location. This is demonstrated in the image below where the green outline (a `SelectionBox`) shows the extents of the `BasePart`.


![enter image description here](https://developer.roblox.com/assets/bltd3942dca6b981850/OffsetAnim.gif)

## Other uses for mesh offset

There are a number of interesting uses for the mesh offset property.

 - Offset and `Scale` can be animated using `TweenService` relatively inexpensively as the engine does not need to make any physics/collision calculations as the `BasePart` is not moved.
 - Changing the relationship between the mesh and its collision extents (determined by the `BasePart`)

## Code Samples

### Mesh Offset and Scale

In this code sample a `BasePart` is instanced with a `SpecialMesh`. The `Scale` and `Offset` properties of the `SpecialMesh` are then animated using `TweenService`.
```lua
local TweenService = game:GetService("TweenService")

-- instance a part and a mesh
local part = Instance.new("Part")
part.Size = Vector3.new(4, 8, 4)
part.Position = Vector3.new(0, 4, 0)
part.Anchored = true
part.CanCollide = false 

local mesh = Instance.new("SpecialMesh", part)
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "rbxassetid://1086413449"
mesh.TextureId = "rbxassetid://1461576423"
mesh.Offset = Vector3.new(0, 0, 0)
mesh.Scale = Vector3.new(4, 4, 4)

-- selection box to show part extents
local box = Instance.new("SelectionBox", part)
box.Adornee = part

-- parent part to workspace
part.Parent = workspace

-- animate offset and scale with a tween
local tween = TweenService:Create(
  mesh,
  TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, -1, true, 0),
  {Scale = Vector3.new(1, 1, 1), Offset = Vector3.new(0, 3, 0)}
)

tween:Play()
```
 */
	Offset: Vector3;
	/** The Scale of a mesh determines the size of the mesh relative to its original dimensions.

## How to use mesh scale

The scale property works slightly differently depending on the type of mesh being used. Note the size of the `BasePart` remains unchanged, meaning the physics collision box of the part will remain the same. 

 - `SpecialMesh` objects with `FileType` set to 'FileMesh' scale relative to the original dimensions of the mesh when it was uploaded to Roblox
 - `BlockMesh` objects or `SpecialMesh` objects with `FileType` set to 'Brick', 'Wedge' or 'Sphere' scale uniformly relative to the `Size` of their parent
 - `CylinderMesh` objects or `SpecialMesh` objects with `FileType` set to 'Cylinder' scale relative to the `Size` of their parent. Uniformly for the cylinders height axis and maintaining a 1:1 ratio for the length and width of the cylinder, using the lowest value.
 - `SpecialMesh` objects with `FileType` set to 'Head' currently scale in a non standard manner. Developers should not rely on this as their are plans to change this behavior
 - `SpecialMesh` objects with `FileType` set to 'Torso' scale in a non standard manner. Developers should not rely on this as their are plans to deprecate this mesh type.

## Mesh scale demonstration
The above behavior can be seen in the following demonstration images.

Linear scaling relative to part size for 'Brick', 'Wedge' and 'Sphere' meshes.
![enter image description here](https://developer.roblox.com/assets/bltd4a34d2e19dc865c/Scale1.gif)

Linear scaling relative to original uploaded mesh for 'FileMesh' meshes
![enter image description here](https://developer.roblox.com/assets/blt3eff78f21fd4de1d/Scale2.gif)

Non-uniform constrained scaling for 'Cylinder' meshes
![enter image description here](https://developer.roblox.com/assets/blt543d8e7d5ba8c404/Scale3.gif)

## Other uses for mesh scale
There are a number of interesting uses for the mesh offset property.

 - `Offset` and Scale can be animated using `TweenService` relatively inexpensively as the engine does not need to make any physics/collision calculations as the `BasePart` is not changed.
 - Changing the relationship between the mesh and its collision extents (determined by the `BasePart`)

## Code Samples

### Mesh Offset and Scale

In this code sample a `BasePart` is instanced with a `SpecialMesh`. The `Scale` and `Offset` properties of the `SpecialMesh` are then animated using `TweenService`.
```lua
local TweenService = game:GetService("TweenService")

-- instance a part and a mesh
local part = Instance.new("Part")
part.Size = Vector3.new(4, 8, 4)
part.Position = Vector3.new(0, 4, 0)
part.Anchored = true
part.CanCollide = false 

local mesh = Instance.new("SpecialMesh", part)
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "rbxassetid://1086413449"
mesh.TextureId = "rbxassetid://1461576423"
mesh.Offset = Vector3.new(0, 0, 0)
mesh.Scale = Vector3.new(4, 4, 4)

-- selection box to show part extents
local box = Instance.new("SelectionBox", part)
box.Adornee = part

-- parent part to workspace
part.Parent = workspace

-- animate offset and scale with a tween
local tween = TweenService:Create(
  mesh,
  TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, -1, true, 0),
  {Scale = Vector3.new(1, 1, 1), Offset = Vector3.new(0, 3, 0)}
)

tween:Play()
```
 */
	Scale: Vector3;
	/** Changes the hue of the mesh's texture.

Note this property is only functional when a texture has been applied to the mesh. For this reason it only works with the `SpecialMesh` object as it includes the `TextureId` property.

## How to use VertexColor

See below for a visual example of the impact of VertexColor on a mesh's texture.

![enter image description here](https://developer.roblox.com/assets/blt554914f560c80848/VertexColor_-_Copy.gif)

Note this property uses the `Vector3` rather than the `Color3` data type. Therefore developers will generally need to convert the `Color3` rgb components to the `Vector3 xyz components. See below for a brief example.

    local yellow = BrickColor.new("Bright yellow")
    local yColor = yellow.Color
    local yVector = Vector3.new(yColor.r,yColor.g,yColor.b)
    workspace.Baseplate.Mesh.VertexColor = yVector

## Alternative to VertexColor

Although VertexColor can be used to make changes to the appearance of a Mesh's texture much more flexibility is offered by uploading a new texture for the mesh. For more information on textures, see the page for `MeshPart`s.

## Code Samples

### Mesh VertexColor

In this code sample a `BasePart` is instanced with a `SpecialMesh`. The `VertexColor` property of the `SpecialMesh` is then animated using `TweenService`.
```lua
local TweenService = game:GetService("TweenService")

-- instance a part and a mesh
local part = Instance.new("Part")
part.Size = Vector3.new(4, 8, 4)
part.Position = Vector3.new(0, 4, 0)
part.Anchored = true
part.CanCollide = false 

local mesh = Instance.new("SpecialMesh", part)
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "rbxassetid://1086413449"
mesh.TextureId = "rbxassetid://1461576423"
mesh.Offset = Vector3.new(0, 0, 0)
mesh.Scale = Vector3.new(4, 4, 4)
mesh.VertexColor = Vector3.new(1, 1, 1)

-- parent part to workspace
part.Parent = workspace

-- create tweens
local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local blackTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 0, 0)})
local redTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(1, 0, 0)})
local greenTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 1, 0)})
local blueTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 0, 1)})
local resetTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(1, 1, 1)})

-- animate 
while true do 
	blackTween:Play()
	blackTween.Completed:Wait()
	redTween:Play()
	redTween.Completed:Wait()
	greenTween:Play()
	greenTween.Completed:Wait()
	blueTween:Play()
	blueTween.Completed:Wait()
	resetTween:Play()
	resetTween.Completed:Wait()
	wait()
end
```
 */
	VertexColor: Vector3;
}
/** The DataModelMesh is an abstract class from which mesh classes descend.

Mesh classes are objects that, when parented to `BasePart`s alter the appearance of the part to that of a predefined mesh. Note, they only alter the appearance of the part and not the physics/collision boundaries of the part. Developers looking to apply a mesh to a part that alters the part's collision should use `MeshPart`s.

Note the `MeshPart` and `CharacterMesh` classes do not descend from DataModelMesh. */
type DataModelMesh = BevelMesh | FileMesh | SpecialMesh;

interface RbxInternalBevelMesh extends RbxInternalDataModelMesh {}
/** This is an abstract class that `BlockMesh` and `CylinderMesh` inherit from. */
type BevelMesh = BlockMesh | CylinderMesh;

/** The BlockMesh object applies a 'brick' mesh to the `BasePart` it is parented to. It behaves identically to a `SpecialMesh` with `MeshType` set to 'brick'.

## What does a BlockMesh do?

A BlockMesh gives the `BasePart` it was applied to a brick shaped mesh. It is identical in appearance to a standard Roblox `Part`.

The dimensions of the mesh will scale linearly in all directions with `Size`, this means a part containing a BlockMesh can be resized the same way as any other part.

The additional functionality a BlockMesh brings however, is the ability to set the `Scale` and `Offset` properties. These allow the position and dimensions of the mesh that is displayed to be changed without changing the `Position` or `Size` of the `BasePart` the mesh is parented to.

Note as the `BlockMesh` object does not include a texture the `VertexColor` property does not do anything.

## Code Samples

### BlockMesh Instantiation

A simple demonstration of how a `BlockMesh` can be created and how the `Scale` and `Offset` properties can be used.
```lua
    -- instance a part with a blockmesh
    local part = Instance.new("Part")
    part.Position = Vector3.new(0, 2, 0)
    part.Size = Vector3.new(5, 2, 5)
    part.Anchored = true 
    local mesh = Instance.new("BlockMesh", part)
    
    -- set the scale and offset of the mesh
    mesh.Scale = Vector3.new(0.5, 0.5, 0.5)
    mesh.Offset = Vector3.new(0, 2, 0)
    
    -- add a selectionbox to highlight part
    local adornment = Instance.new("SelectionBox", part)
    adornment.Adornee = part
    
    -- parent to workspace
    part.Parent = workspace
```
 */
interface BlockMesh extends RbxInternalBevelMesh {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BlockMesh";
}

/** The CylinderMesh object applies a 'cylinder' mesh to the `BasePart` it is parented to. 

What does a CylinderMesh do?
----------------------------

A CylinderMesh gives the `BasePart` it was applied to a cylinder shaped mesh. 

The mesh applied gives the same appearance as that due to the `MeshType` of a `SpecialMesh` being set to 'Cylinder' or `Shape` being set to 'Cylinder'. However, unlike those two cases, it is orientated so that the height of the cylinder is along the `BasePart`'s Y axis.

The dimensions of the mesh scale relative to the `Size` of the `BasePart`. This scale is uniformly along the `BasePart`'s Y axis and maintaining a 1:1 ratio for the part’s X and Z axis, using the lowest value. This means the `BasePart` can be resized normally, but the cross section of the cylinder will always remain a circle and cannot be stretched or compressed. 

Note as the CylinderMesh object does not include a texture the `VertexColor` property does not do anything.

## Why use a CylinderMesh?

The advantage of using a mesh over setting the `Shape` property of a part to 'Cylinder' is that the `Scale` and `Offset` properties are exposed. These allow the position and dimensions of the mesh that is displayed to be changed without changing the `Position` or `Size` of the `Part` the mesh is parented to.

The key difference between a CylinderMesh or a `SpecialMesh` with `MeshType` set to 'Cylinder' is the orientation of the cylinder mesh. With a CylinderMesh, the height of the cylinder is aligned with the height (Y axis) of the part. With a `SpecialMesh` (or `Part` with `Shape` set to 'Cylinder'), the height of the cylinder is aligned with the X axis.

## Code Samples

### CylinderMesh Instantiation

This code sample includes a demonstration of how a `CylinderMesh` can be used, and how it scales so as to maintain a constant ratio of length to width.
```lua
    -- instance a part with a cylindermesh
    local part = Instance.new("Part")
    part.Position = Vector3.new(0, 2, 0)
    part.Size = Vector3.new(10, 2, 5) -- 10 x 5 to demonstrate resizing
    part.Anchored = true 
    local mesh = Instance.new("CylinderMesh", part)
    
    -- set the scale and offset of the mesh
    mesh.Scale = Vector3.new(1, 1, 1)
    mesh.Offset = Vector3.new(0, 0, 0)
    
    -- add a selectionbox to highlight part
    local adornment = Instance.new("SelectionBox", part)
    adornment.Adornee = part
    
    -- parent to workspace
    part.Parent = workspace
```
 */
interface CylinderMesh extends RbxInternalBevelMesh {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CylinderMesh";
}

interface RbxInternalDerivesFromFileMesh extends RbxInternalDataModelMesh {
	/** The MeshId is the content ID of the mesh that is to be displayed.

The content ID for a mesh is generated when a developer uploads a mesh to the Roblox website. 

## How do I create a mesh?

Meshes can currently only be be uploaded using `MeshPart`s or the game explorer. Once uploaded however, the content ID for the mesh can be used for the MeshId property. For more information on how to do this please see `Mesh this tutorial`.


  [1]: /articles/Mesh-Parts

## Code Samples

### Mesh VertexColor

In this code sample a `BasePart` is instanced with a `SpecialMesh`. The `VertexColor` property of the `SpecialMesh` is then animated using `TweenService`.
```lua
local TweenService = game:GetService("TweenService")

-- instance a part and a mesh
local part = Instance.new("Part")
part.Size = Vector3.new(4, 8, 4)
part.Position = Vector3.new(0, 4, 0)
part.Anchored = true
part.CanCollide = false 

local mesh = Instance.new("SpecialMesh", part)
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "rbxassetid://1086413449"
mesh.TextureId = "rbxassetid://1461576423"
mesh.Offset = Vector3.new(0, 0, 0)
mesh.Scale = Vector3.new(4, 4, 4)
mesh.VertexColor = Vector3.new(1, 1, 1)

-- parent part to workspace
part.Parent = workspace

-- create tweens
local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local blackTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 0, 0)})
local redTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(1, 0, 0)})
local greenTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 1, 0)})
local blueTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 0, 1)})
local resetTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(1, 1, 1)})

-- animate 
while true do 
	blackTween:Play()
	blackTween.Completed:Wait()
	redTween:Play()
	redTween.Completed:Wait()
	greenTween:Play()
	greenTween.Completed:Wait()
	blueTween:Play()
	blueTween.Completed:Wait()
	resetTween:Play()
	resetTween.Completed:Wait()
	wait()
end
```
 */
	MeshId: string;
	/** The TextureId is the content ID of the image that is to be applied to used for the meshes texture. When the TextureId property is set to an empty string, no texture will be applied to the mesh.

## How can I change the texture of a mesh?

Using the TextureId property, the texture of a mesh can be changed without having to reupload the mesh. To do this, a new image will need to be uploaded to Roblox with the desired texture. The original texture image file can be obtained by exporting the mesh using the 'Export Selection' option in Roblox Studio. The image file will be saved alongside the exported .obj file.

The new texture can then be re-uploaded to Roblox as a Decal and its content ID can be applied to the mesh using the TextureId property.

## How can I make a textured mesh?

A mesh can only be textured if the mesh has been UV mapped. UV mapping refers to the practice of projecting a texture map onto a mesh. This cannot be done using Roblox Studio and has to be done using an external 3D modelling application such as [Blender][1].


  [1]: https://www.blender.org/

## Code Samples

### Mesh VertexColor

In this code sample a `BasePart` is instanced with a `SpecialMesh`. The `VertexColor` property of the `SpecialMesh` is then animated using `TweenService`.
```lua
local TweenService = game:GetService("TweenService")

-- instance a part and a mesh
local part = Instance.new("Part")
part.Size = Vector3.new(4, 8, 4)
part.Position = Vector3.new(0, 4, 0)
part.Anchored = true
part.CanCollide = false 

local mesh = Instance.new("SpecialMesh", part)
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "rbxassetid://1086413449"
mesh.TextureId = "rbxassetid://1461576423"
mesh.Offset = Vector3.new(0, 0, 0)
mesh.Scale = Vector3.new(4, 4, 4)
mesh.VertexColor = Vector3.new(1, 1, 1)

-- parent part to workspace
part.Parent = workspace

-- create tweens
local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local blackTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 0, 0)})
local redTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(1, 0, 0)})
local greenTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 1, 0)})
local blueTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 0, 1)})
local resetTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(1, 1, 1)})

-- animate 
while true do 
	blackTween:Play()
	blackTween.Completed:Wait()
	redTween:Play()
	redTween.Completed:Wait()
	greenTween:Play()
	greenTween.Completed:Wait()
	blueTween:Play()
	blueTween.Completed:Wait()
	resetTween:Play()
	resetTween.Completed:Wait()
	wait()
end
```
 */
	TextureId: string;
}
/** The FileMesh object applies a textured mesh to a `BasePart` when parented to it.  Its properties are inherited by the `SpecialMesh` object.

## What is a FileMesh?

FileMeshes allow user uploaded meshes to be applied to a `BasePart`. The mesh that is applied is dependent on the `MeshId` property. A texture can also be applied to this mesh using `TextureId`.

Although it is not an abstract class, and can be used by developers, all `FileMesh` properties are inherited by the `SpecialMesh` object. A `SpecialMesh` behaves identically to the FileMesh object when its `MeshType` is set to 'FileMesh'. Although both objects are functional, the `SpecialMesh` object is the official supported class.

For more information on using meshes, please see the `SpecialMesh` page.

## Code Samples

### FileMesh Offset and Scale

In this code sample a `BasePart` is instanced with a `FileMesh`. The `Scale` and `Offset` properties of the `FileMesh` are then animated using `TweenService`.
```lua
local TweenService = game:GetService("TweenService")

-- instance a part and a mesh
local part = Instance.new("Part")
part.Size = Vector3.new(4, 8, 4)
part.Position = Vector3.new(0, 4, 0)
part.Anchored = true
part.CanCollide = false 

local mesh = Instance.new("FileMesh", part) -- advised to use SpecialMesh instead
mesh.MeshId = "rbxassetid://1086413449"
mesh.TextureId = "rbxassetid://1461576423"
mesh.Offset = Vector3.new(0, 0, 0)
mesh.Scale = Vector3.new(4, 4, 4)

-- selection box to show part extents
local box = Instance.new("SelectionBox", part)
box.Adornee = part

-- parent part to workspace
part.Parent = workspace

-- animate offset and scale with a tween
local tween = TweenService:Create(
	mesh,
	TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, -1, true, 0),
	{Scale = Vector3.new(1, 1, 1), Offset = Vector3.new(0, 3, 0)}
)

tween:Play()


```
 */
interface FileMesh extends RbxInternalDerivesFromFileMesh {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FileMesh";
}


/** The SpecialMesh is an object that allows developers to provide a standard template or user uploaded mesh to a `BasePart`.

## What does a SpecialMesh do?

The SpecialMesh object applies a mesh to a `BasePart` depending on the the `MeshType` property. A number of options are available.

 - **Brick** - A block shape, equivalent to a `BlockMesh`
 - **Cylinder** - A cylinder, identical to a `Part` with a `Shape` of 'Cylinder'
 - **FileMesh** - A user uploaded Mesh, equivalent to `FileMesh` that a texture can be applied to using the `TextureId` property
 - **Head** - A character head shape
 - **Sphere** - A sphere shape, similar to a `Part` with a `Shape` of 'Ball' but can be freely resized on all axis
 - **Wedge** - A wedge shape, identical to a `WedgePart`
 - **Torso** - A block with sloped sides, due to be deprecated 

Note, each `MeshType` will scale differently when using `Scale`, for more information on this please see the page on `Scale`. The SpecialMesh object also exposes the `Offset` property.

It is important to remember that when using a SpecialMesh, only the appearance of a part changes. The collision model of the part remains the same. For example, a character will not be able to walk correctly over a mesh as the mesh geometry is not taken into account.
 
## SpecialMesh or MeshPart?

There are currently two ways of using a developer created mesh. They are using a SpecialMesh with the `FileType` set to 'FileMesh', or by using a `MeshPart`. Although, on the whole, the `MeshPart` object has superseded the SpecialMesh there are some differences developers should be aware of.

 - `Material` displays correctly on the mesh when using a `MeshPart` and not when using a SpecialMesh
 - `MeshPart`s include the `CollisionFidelity` property, meaning the collision model of a `MeshPart` can be set to resemble the geometry of the mesh. The SpecialMesh object by contrast, uses the parent `BasePart`s collision model
 - The mesh of a `MeshPart` scales on all axis depending on the `Size` property of the `MeshPart`, the mesh of a SpecialMesh does not
 - The SpecialMesh object includes the `Offset` and `Scale` properties whereas `MeshPart`s do not
 - The `MeshId` property of a `SpecialMesh` can be changed by a `Script` or `LocalScript` during runtime. The `MeshId` property of a `MeshPart` can not.

In most, but not all cases, using a `MeshPart` is more suitable. As `MeshPart`s are a relatively new feature however, developers should expect some of the above behaviour to change.

## Uploading a custom mesh

Although a developer uploaded mesh can be used on a `SpecialMesh`, meshes can currently only be be uploaded using `MeshPart`s or the game explorer. For more information on how to do this please see `Mesh this tutorial`.


  [1]: /articles/Mesh-Parts

## Code Samples

### Mesh Offset and Scale

In this code sample a `BasePart` is instanced with a `SpecialMesh`. The `Scale` and `Offset` properties of the `SpecialMesh` are then animated using `TweenService`.
```lua
local TweenService = game:GetService("TweenService")

-- instance a part and a mesh
local part = Instance.new("Part")
part.Size = Vector3.new(4, 8, 4)
part.Position = Vector3.new(0, 4, 0)
part.Anchored = true
part.CanCollide = false 

local mesh = Instance.new("SpecialMesh", part)
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "rbxassetid://1086413449"
mesh.TextureId = "rbxassetid://1461576423"
mesh.Offset = Vector3.new(0, 0, 0)
mesh.Scale = Vector3.new(4, 4, 4)

-- selection box to show part extents
local box = Instance.new("SelectionBox", part)
box.Adornee = part

-- parent part to workspace
part.Parent = workspace

-- animate offset and scale with a tween
local tween = TweenService:Create(
  mesh,
  TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, -1, true, 0),
  {Scale = Vector3.new(1, 1, 1), Offset = Vector3.new(0, 3, 0)}
)

tween:Play()
```

### Mesh VertexColor

In this code sample a `BasePart` is instanced with a `SpecialMesh`. The `VertexColor` property of the `SpecialMesh` is then animated using `TweenService`.
```lua
local TweenService = game:GetService("TweenService")

-- instance a part and a mesh
local part = Instance.new("Part")
part.Size = Vector3.new(4, 8, 4)
part.Position = Vector3.new(0, 4, 0)
part.Anchored = true
part.CanCollide = false 

local mesh = Instance.new("SpecialMesh", part)
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "rbxassetid://1086413449"
mesh.TextureId = "rbxassetid://1461576423"
mesh.Offset = Vector3.new(0, 0, 0)
mesh.Scale = Vector3.new(4, 4, 4)
mesh.VertexColor = Vector3.new(1, 1, 1)

-- parent part to workspace
part.Parent = workspace

-- create tweens
local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local blackTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 0, 0)})
local redTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(1, 0, 0)})
local greenTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 1, 0)})
local blueTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 0, 1)})
local resetTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(1, 1, 1)})

-- animate 
while true do 
	blackTween:Play()
	blackTween.Completed:Wait()
	redTween:Play()
	redTween.Completed:Wait()
	greenTween:Play()
	greenTween.Completed:Wait()
	blueTween:Play()
	blueTween.Completed:Wait()
	resetTween:Play()
	resetTween.Completed:Wait()
	wait()
end
```
 */
interface SpecialMesh extends RbxInternalDerivesFromFileMesh {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SpecialMesh";
	/** The mesh that the  `SpecialMesh`object applies to the `BasePart` depends on the MeshType property. A number of options are available.

 - **Brick** - A block shape, equivalent to a `BlockMesh`
 - **Cylinder** - A cylinder, identical to a `Part` with a `Shape` of 'Cylinder'
 - **FileMesh** - A user uploaded Mesh, equivalent to `FileMesh` that a texture can be applied to using the `TextureId` property
 - **Head** - A character head shape
 - **Sphere** - A sphere shape, similar to a `Part` with a `Shape` of 'Ball' but can be freely resized on all axis
 - **Wedge** - A wedge shape, identical to a `WedgePart`
 - **Torso** - A block with sloped sides, due to be deprecated 

Note, each MeshType will scale differently when using `Scale`, for more information on this please see the page on `Scale`.

## Code Samples

### Mesh VertexColor

In this code sample a `BasePart` is instanced with a `SpecialMesh`. The `VertexColor` property of the `SpecialMesh` is then animated using `TweenService`.
```lua
local TweenService = game:GetService("TweenService")

-- instance a part and a mesh
local part = Instance.new("Part")
part.Size = Vector3.new(4, 8, 4)
part.Position = Vector3.new(0, 4, 0)
part.Anchored = true
part.CanCollide = false 

local mesh = Instance.new("SpecialMesh", part)
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "rbxassetid://1086413449"
mesh.TextureId = "rbxassetid://1461576423"
mesh.Offset = Vector3.new(0, 0, 0)
mesh.Scale = Vector3.new(4, 4, 4)
mesh.VertexColor = Vector3.new(1, 1, 1)

-- parent part to workspace
part.Parent = workspace

-- create tweens
local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local blackTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 0, 0)})
local redTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(1, 0, 0)})
local greenTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 1, 0)})
local blueTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(0, 0, 1)})
local resetTween = TweenService:Create(mesh, tweenInfo, {VertexColor = Vector3.new(1, 1, 1)})

-- animate 
while true do 
	blackTween:Play()
	blackTween.Completed:Wait()
	redTween:Play()
	redTween.Completed:Wait()
	greenTween:Play()
	greenTween.Completed:Wait()
	blueTween:Play()
	blueTween.Completed:Wait()
	resetTween:Play()
	resetTween.Completed:Wait()
	wait()
end
```
 */
	MeshType: Enum.MeshType;
}

/** @server */
	/** **DataStoreService** exposes methods for getting `GlobalDataStore` and `OrderedDataStore` objects. Data stores can only be accessed by game servers, so you can only use **DataStoreService** within a `Script` or a `ModuleScript` that is used by a `Script`.

## Using Data Stores in Studio

**DataStoreService** cannot be used in Studio if a game is not configured to allow access to API services. See the `Data Data Stores`
 article for instructions.

## Request Limits

There are limits applied to the data store model. Please see `Datastore Data Store Errors and Limits` for details.

## Code Samples

### DataStore Budget

This code sample prints the request budget for all data store request types.
```lua
local DataStoreService = game:GetService("DataStoreService")

for _, enumItem in pairs(Enum.DataStoreRequestType:GetEnumItems()) do
	print(enumItem.Name, DataStoreService:GetRequestBudgetForRequestType(enumItem))
end
```
 */
interface DataStoreService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DataStoreService";
	/** This method returns a `GlobalDataStore` by name/scope. Subsequent calls to this method with the same name/scope will return the same object.

## Code Samples

### Data Store Game Config

This code sample uses data stores to read/write/listen to a global configuration value. It uses a defensive coding style so potential data store errors will not cause issues.
```lua
local DATA_STORE_NAME = "Config"
local DATA_STORE_SCOPE = "MyGameName"
local KEY_NEW_FEATURE = "NewFeatureEnabled"

local DataStoreService = game:GetService("DataStoreService")

local dsConfig = DataStoreService:GetDataStore(DATA_STORE_NAME, DATA_STORE_SCOPE)

local function checkFeature()
	local isFeatureEnabled
	local success, err = pcall(function()
		isFeatureEnabled = dsConfig:GetAsync(KEY_NEW_FEATURE)
	end)
	if success then
		print(KEY_NEW_FEATURE .. ": " .. tostring(isFeatureEnabled))
		if isFeatureEnabled == true then
			print("Feature is enabled!")
		elseif isFeatureEnabled == false then
			print("Feature is disabled!")
		elseif isFeatureEnabled == nil then
			print("Feature is not set!")
		else
			-- Some other value was found in this key
		end
	else
		print("Failed to load feature! Error: " .. tostring(err))
	end
	return success
end

local function onFeatureChanged(isFeatureEnabled)
	print("Feature toggled: " .. tostring(isFeatureEnabled))
end

-- Listen for changes
dsConfig:OnUpdate(KEY_NEW_FEATURE, onFeatureChanged)

local function setFeatureEnabled(isFeatureEnabled)
	local success, err = pcall(function()
		dsConfig:SetAsync(KEY_NEW_FEATURE, isFeatureEnabled)
	end) 
	return success
end

setFeatureEnabled(true)
checkFeature()
```

### Individual Player Data Stores

This code sample features a simple way to work with per-player data stores called "Stats" and "Resources."
```lua
local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")

local function onPlayerAdded(player)
	local scope = "Player_" .. player.UserId
	local playerStats = DataStoreService:GetDataStore("Stats", scope)
	local playerResources = DataStoreService:GetDataStore("Resources", scope)
	-- GetAsync()/UpdateAsync() can now be called on the 'Stats' and 'Resources' data stores
end

Players.PlayerAdded:Connect(onPlayerAdded)
```
 */
	GetDataStore(name: string, scope?: string): GlobalDataStore;
	/** This function returns the default `GlobalDataStore`. If you want to access a specific **named** data store instead, you should use the `GetDataStore()` function.

## Code Samples

### Get GlobalDataStore Instance

The following example retrieves a default data store instance which behaves like a regular `Instance`. Since a `GlobalDataStore` is an `Instance`, functions such as `GlobalDataStore:GetChildren()` will execute without error.
```lua
local DataStoreService = game:GetService("DataStoreService")

local GlobalDataStore = DataStoreService:GetGlobalDataStore()
print(GlobalDataStore.Name)
```

@returns Default `GlobalDataStore` instance */
	GetGlobalDataStore(): GlobalDataStore;
	/** This method returns an `OrderedDataStore`, similar to the way `GetDataStore()` does with `GlobalDataStores`. Subsequent calls to this method with the same name/scope will return the same object.

## Code Samples

### OrderedDataStore Basics

This code sample demonstrates usage of an `OrderedDataStore` and pages.
```lua
local DataStoreService = game:GetService("DataStoreService")
local PointsODS = DataStoreService:GetOrderedDataStore("Points") 

local function printTopTenPlayers()
	local isAscending = false
	local pageSize = 10
	local pages = PointsODS:GetSortedAsync(isAscending, pageSize)
	local topTen = pages:GetCurrentPage()

	-- The data in 'topTen' is stored with the index being the index on the page
	-- For each item, 'data.key' is the key in the OrderedDataStore and 'data.value' is the value
	for rank, data in ipairs(topTen) do
		local name = data.key
		local points = data.value
		print(data.key .. " is ranked #" .. rank .. " with " .. data.value .. "points")
	end

	-- Potentially load the next page...
	--pages:AdvanceToNextPageAsync()
end

-- Create some data
PointsODS:SetAsync("Alex", 55)
PointsODS:SetAsync("Charley", 32)
PointsODS:SetAsync("Sydney", 68)

-- Display the top ten players
printTopTenPlayers()
```
 */
	GetOrderedDataStore(name: string, scope?: string): OrderedDataStore;
	/** This function returns the number of data store requests that the current place can make based on the given `DataStoreRequestType`. Any requests made that exceed this budget are subject to `Datastore throttling`. Monitoring and adjusting the frequency of data store requests using this function is recommended.

## Code Samples

### Print Request Budget


```lua
local DataStoreService = game:GetService("DataStoreService")
local globalStore = DataStoreService:GetGlobalDataStore()

local function printBudget()
	local budget = DataStoreService:GetRequestBudgetForRequestType(Enum.DataStoreRequestType.SetIncrementAsync)
	print("Current set/increment budget:", budget)
end

for i = 1, 5 do
	local key = "key" .. i
	local success, err = pcall(function()
		globalStore:SetAsync(key, true)
	end)
	if success then
		printBudget()
	else
		print(err)
	end
end
```
 */
	GetRequestBudgetForRequestType(requestType: CastsToEnum<Enum.DataStoreRequestType>): number;
}

/** The Debris service allows the developer to schedule the removal of the object without yielding any code, through the usage of the `AddItem` method.

After the lifetime argument has elapsed (in seconds) the object is removed in the same manner as `Destroy`.

As Debris is a service it must be created using the `GetService` method.

**Why use Debris?**

Beyond creating a bit of a mess, objects that are no longer required can use up system memory and cause the game to run slower over time. For this reason it is always advised to run the `Destroy` function on objects you no longer need. However in many cases an object may have a specific period of utility after which it needs to be destroyed. 

Take the example of projectile that has just been thrown. On first thought, it could be cleaned up using:

    wait(3)
    projectile:Destroy()

However there are a number of issues with this approach. Firstly, it requires yielding the code with a wait, which is not always desirable. Secondly, before the 3 seconds have elapsed the object may have already been destroyed (for example, if it reached `FallenPartsDestroyHeight`). In this case, the code would error as it tries to destroy an item that has already been destroyed. One answer may be:

    delay(3, function()
    	if projectile and projectile.Parent then
    		projectile:Destroy()
    	end
    end)

This solves the above issues, as it spawns a new thread to prevent the current one from yielding and checks to see if it can be destroyed. However at this point a simple command has already become quite complicated and an unnecessary thread is being created. 

This is where Debris comes in, and the following code addresses all of the above issues.

    Debris:AddItem(projectile, 3)

Debris does not yield the current thread, does not require a new thread and will not error if the object is already destroyed. For this reason it is the recommended method for cleaning up objects with a fixed lifetime.

## Code Samples

### Debris AddItem

Creates parts on a loop and parents them to the Workspace, then uses Debris.AddItem to clean them up.
```lua
local Debris = game:GetService("Debris")

local ball = Instance.new("Part")
ball.Anchored = false
ball.Shape = Enum.PartType.Ball
ball.TopSurface = Enum.SurfaceType.Smooth
ball.BottomSurface = Enum.SurfaceType.Smooth
ball.Size = Vector3.new(1, 1, 1)

while true do
	newBall = ball:Clone()
	newBall.BrickColor = BrickColor.Random()
	newBall.CFrame = CFrame.new(0, 30, 0)
	newBall.Velocity = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10))
	newBall.Parent = game.Workspace
	Debris:AddItem(newBall, 2)
	wait(0.1)
end
```
 */
interface Debris extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Debris";
	/** The AddItem method allows the developer to schedule the removal of the object without yielding any code.

Registers a given `Instance` to the `Debris` service for removal after the specified delay. The first argument is the object being removed, and the second argument is the amount of time in seconds the `Debris` service will wait before removing the object. The delay argument is optional, if it is not specified, it defaults to 10 seconds. The delay argument is a number, so it accepts decimal points, such as '1.5', or '0.25'.

**Why use Debris?**

Beyond creating a bit of a mess, objects that are no longer required can use up system memory and cause the game to run slower over time. For this reason it is always advised to run the `Destroy` function on objects you no longer need. However in many cases an object may have a specific period of utility after which it needs to be destroyed. 

Take the example of projectile that has just been thrown. On first thought, it could be cleaned up using:

    wait(3)
    projectile:Destroy()

However there are a number of issues with this approach. Firstly, it requires yielding the code with a wait, which is not always desirable. Secondly, before the 3 seconds have elapsed the object may have already been destroyed (for example, if it reached `FallenPartsDestroyHeight`). In this case, the code would error as it tries to destroy an item that has already been destroyed. One answer may be:

    delay(3, function()
    	if projectile and projectile.Parent then
    		projectile:Destroy()
    	end
    end)

This solves the above issues, as it spawns a new thread to prevent the current one from yielding and checks to see if it can be destroyed. However at this point a simple command has already become quite complicated and an unnecessary thread is being created. 

This is where Debris comes in, and the following code addresses all of the above issues.

    Debris:AddItem(projectile, 3)

Debris does not yield the current thread, does not require a new thread and will not error if the object is already destroyed. For this reason it is the recommended method for cleaning up objects with a fixed lifetime.

## Code Samples

### Debris AddItem

Creates parts on a loop and parents them to the Workspace, then uses Debris.AddItem to clean them up.
```lua
local Debris = game:GetService("Debris")

local ball = Instance.new("Part")
ball.Anchored = false
ball.Shape = Enum.PartType.Ball
ball.TopSurface = Enum.SurfaceType.Smooth
ball.BottomSurface = Enum.SurfaceType.Smooth
ball.Size = Vector3.new(1, 1, 1)

while true do
	newBall = ball:Clone()
	newBall.BrickColor = BrickColor.Random()
	newBall.CFrame = CFrame.new(0, 30, 0)
	newBall.Velocity = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10))
	newBall.Parent = game.Workspace
	Debris:AddItem(newBall, 2)
	wait(0.1)
end
```

@param item The `Instance` to be added to `Debris`.
@param lifetime The number of seconds before the `Instance` should be destroyed. */
	AddItem(item: Instance, lifetime?: number): void;
}

/** The DebugSettings allows you to view diagnostics information regarding Roblox. It is labeled as **Diagnostics**
 in the Roblox Studio Settings menu. */
interface DebugSettings extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DebugSettings";
	/** Describes whether a `DataModel` is actively in memory, as an integer (where 1 = true, and 0 = false).Describes whether a `DataModel` is actively in memory, as an integer (where 1 = true, and 0 = false).

Tags: ReadOnly, NotReplicated */
	readonly DataModel: number;
	/** The action Roblox should take when reporting an error. */
	ErrorReporting: Enum.ErrorReporting;
	/** The GfxCard currently installed into your machine.The GfxCard currently installed into your machine.

Tags: ReadOnly, NotReplicated */
	readonly GfxCard: string;
	/** The number of instances active in the simulation.The number of instances active in the simulation.

Tags: ReadOnly, NotReplicated */
	readonly InstanceCount: number;
	/** Toggles whether or not profiling of the Fmod library (which is responsible for sounds) is enabled. */
	IsFmodProfilingEnabled: boolean;
	/** Whether or not a stacktrace is displayed in the output for an error. */
	IsScriptStackTracingEnabled: boolean;
	/** Returns the number of internal DataModel jobs actively being processed.Returns the number of internal DataModel jobs actively being processed.

Tags: ReadOnly, NotReplicated */
	readonly JobCount: number;
	/** Sets a RAM limit in bytes for Lua if greater than 0. */
	LuaRamLimit: number;
	/** Whether your OS is a 64 bit OS or a 32 bit one.Whether your OS is a 64 bit OS or a 32 bit one.

Tags: ReadOnly, NotReplicated */
	readonly OsIs64Bit: boolean;
	/** A string representing the type of Operating System Platform your machine is on.A string representing the type of Operating System Platform your machine is on.

Tags: ReadOnly, NotReplicated */
	readonly OsPlatform: string;
	/** The PlatformId of your Operating System.The PlatformId of your Operating System.

Tags: ReadOnly, NotReplicated */
	readonly OsPlatformId: number;
	/** The current version of your Operating System.The current version of your Operating System.

Tags: ReadOnly, NotReplicated */
	readonly OsVer: string;
	/** The number of players currently in the active game-instance.The number of players currently in the active game-instance.

Tags: ReadOnly, NotReplicated */
	readonly PlayerCount: number;
	/** Whether or not sound warnings should be reported. */
	ReportSoundWarnings: boolean;
	/** The purpose of this property is unknown.
Its value is always ["?"](https://developer.roblox.com/articles/String "String")
.The purpose of this property is unknown.
Its value is always ["?"](https://developer.roblox.com/articles/String "String")
.

Tags: ReadOnly, NotReplicated */
	readonly RobloxProductName: string;
	/** The current client version of Roblox. Can also be retrieved by using the version() function.The current client version of Roblox. Can also be retrieved by using the version() function.

Tags: ReadOnly, NotReplicated */
	readonly RobloxVersion: string;
	/** The type of SIMD instruction set used by your machine.The type of SIMD instruction set used by your machine.

Tags: ReadOnly, NotReplicated */
	readonly SIMD: string;
	/** The name of your System's Model.The name of your System's Model.

Tags: ReadOnly, NotReplicated */
	readonly SystemProductName: string;
	/** Sets the internal sampling method used to measure elapsed time with consistency across platforms. */
	TickCountPreciseOverride: Enum.TickCountSampleMethod;
	/** The total amount of video memory on your machine, in bytes as a negative integer.The total amount of video memory on your machine, in bytes as a negative integer.

Tags: ReadOnly, NotReplicated */
	readonly VideoMemory: number;
}

/** Represents a breakpoint in Roblox's Lua Debugger.
This object cannot be created, but it can be retrieved from the `ScriptDebugger` class. */
interface DebuggerBreakpoint extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DebuggerBreakpoint";
	/** The condition of the debugger breakpoint. */
	Condition: string;
	/** Whether or not the breakpoint is enabled. */
	IsEnabled: boolean;
	/** The line that the breakpoint has been placed on.The line that the breakpoint has been placed on.

Tags: ReadOnly, NotReplicated */
	readonly Line: number;
}

/** The DebuggerManager is a special singleton class responsible for managing Roblox's Lua Debugger feature.
It can be retrieved via the `DebuggerManager()` function, but only from plugins or the command bar. */
interface DebuggerManager extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DebuggerManager";
	/** Whether the debugger is enabled or disabled.Whether the debugger is enabled or disabled.

Tags: ReadOnly, NotReplicated */
	readonly DebuggingEnabled: boolean;
	/** Registers a script to be used in the Lua Debugger. Returns a `ScriptDebugger` for the script. */
	AddDebugger(script: Instance): Instance | undefined;
	/** Returns a list of `ScriptDebugger` present in the game. */
	GetDebuggers(): Array<Instance>;
	/** Resumes the Lua Debugger if it paused. */
	Resume(): void;
	/** Performs a [step into](https://developer.roblox.com/articles/Lua-debugger "Lua Debugger")
 operation on the Lua Debugger. */
	StepIn(): void;
	/** Performs a [step out](https://developer.roblox.com/articles/Lua-debugger "Lua Debugger")
 operation on the Lua Debugger. */
	StepOut(): void;
	/** Performs a [step over](https://developer.roblox.com/articles/Lua-debugger "Lua Debugger")
 operation on the Lua Debugger. */
	StepOver(): void;
	/** Fired when a new [ScriptDebugger](https://developer.roblox.com/api-reference/class/ScriptDebugger "ScriptDebugger") is created through the [AddDebugger](https://developer.roblox.com/api-reference/function/DebuggerManager/AddDebugger "AddDebugger")
 method. */
	readonly DebuggerAdded: RBXScriptSignal<(debug: Instance) => void>;
	/** Fired when a registered [ScriptDebugger](https://developer.roblox.com/api-reference/class/ScriptDebugger "ScriptDebugger")
 has been discontinued. */
	readonly DebuggerRemoved: RBXScriptSignal<(debug: Instance) => void>;
}

/** Represents a watch in Roblox's Lua Debugger.
This object cannot be created, but it can be retrieved from the `ScriptDebugger` class. */
interface DebuggerWatch extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DebuggerWatch";
	/** The expression set for the DebuggerWatch. */
	Expression: string;
	/** Checks the syntax of the DebuggerWatch. */
	CheckSyntax(): void;
}

/** The Dialog object allows users to create non-player characters (NPCs) that players can talk to using a list of choices. The Dialog object can be inserted into a part such as a Humanoid's head, and then a player will see a speech bubble above the part that they can click on to start a conversation. The creator of a place can choose what choices the player can say by inserting `DialogChoice` objects into the dialog.

**See Also:**

* [How to use Dialogs][1]


  [1]: /articles/Usage-of-dialogs */
interface Dialog extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Dialog";
	/** The BehaviorType of a Dialog determines whether multiple players can interact with a dialog at once. The default value for this property is SinglePlayer.
## SinglePlayer

When a Dialog is configured to SinglePlayer, only one player can interact with it at a time. As soon as a player engages with a dialog, other players will not be able to initiate the dialog until the first player is finished.



While a player is engaged with a dialog, the other players will see the dialog choices of the player who started the dialog, along with the responses.

## MultiplePlayers

When a Dialog is setto MultiplePlayers, any player can initiate a dialog at any time, even if another player has already initiated the dialog. Unlike SinglePlayer however, Dialogs set to MultiplePlayers will not show the dialog choices and responses to anyone but the player in the conversation.Sets whether the Dialog can be used by multiple players at once.

## Example

```lua
local singlePlayerDialog = Instance.new("Dialog")
local singlePlayerPart = game.Workspace.SinglePlayerPart
singlePlayerDialog.BehaviorType = Enum.DialogBehaviorType.SinglePlayer
singlePlayerDialog.InitialPrompt = "Only one person can interact with me at once."
singlePlayerDialog.Parent = singlePlayerPart

local multiplePlayersDialog = Instance.new("Dialog")
local multiplePlayersPart = game.Workspace.MultiplePlayersPart
multiplePlayersDialog.BehaviorType = Enum.DialogBehaviorType.MultiplePlayers
multiplePlayersDialog.InitialPrompt = "Any number of players can interact with me at once."
multiplePlayersDialog.Parent = multiplePlayersPart
``` */
	BehaviorType: Enum.DialogBehaviorType;
	/** The furthest distance that I player can be from the Dialog's parent to start a conversation. */
	ConversationDistance: number;
	/** Toggles whether the goodbye option will be displayed. If true, the dialog will display the content of `GoodbyeDialog` as the last option after other dialog choices. Clicking on the goodbye option will exit the dialog.

## GoodbyeChoiceActive = true
![Active](https://developer.roblox.com/assets/5b6101077eac3e673d5e5e19/GoodbyeChoiceActive.png)

## GoodbyeChoiceActive = false
![Inactive](https://developer.roblox.com/assets/5b610107858e507e4016cc26/GoodbyeChoiceInactive.png) */
	GoodbyeChoiceActive: boolean;
	/** Sets the sentence that the dialog will show to the player when the chat ends */
	GoodbyeDialog: string;
	/** If true, this dialog is being used by at least one player. */
	InUse: boolean;
	/** Sets the first sentence that the dialog will show to the player, once a chat is commenced. */
	InitialPrompt: string;
	/** Sets the icon that the initial dialog displays. */
	Purpose: Enum.DialogPurpose;
	/** Sets the color of the NPC's speech bubble. */
	Tone: Enum.DialogTone;
	/** Sets the maximum distance that a dialog can be triggered from. */
	TriggerDistance: number;
	/** Sets the offset of the dialog relative to the dialog's parent. */
	TriggerOffset: Vector3;
	/** The GetCurrentPlayers function of a Dialog will return a list of `Player` currently using the Dialog. If there are no players using the dialog then the returned list will be empty.

## Code Samples

### Dialog:GetCurrentPlayers


```lua
local dialog = script.Parent

local function onChoiceSelected(player, choice)
	local currentPlayers = dialog:GetCurrentPlayers()
	print("The current players in the dialog:")
	for _, player in ipairs(currentPlayers) do
		print(player)
	end
end

dialog.DialogChoiceSelected:Connect(onChoiceSelected)
```
 */
	GetCurrentPlayers(): Array<Player>;
	/** Fired when a player chooses something to say, through a `Dialog` instance.

This event is client-side only and will not fire on the server. It should be connected to in either a `LocalScript` or a `ModuleScript` required by a `LocalScript`. */
	readonly DialogChoiceSelected: RBXScriptSignal<(player: Player, dialogChoice: Dialog) => void>;
}

/** Used to craft the further choices available to players who have started a dialog conversation with an NPC. */
interface DialogChoice extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DialogChoice";
	/** Toggles whether the goodbye option will be displayed. If true, the dialog will display the content of `GoodbyeDialog` as the last option after other dialog choices. Clicking on the goodbye option will exit the dialog.

## GoodbyeChoiceActive = true
![Active](https://developer.roblox.com/assets/5b6101077eac3e673d5e5e19/GoodbyeChoiceActive.png)

## GoodbyeChoiceActive = false
![Inactive](https://developer.roblox.com/assets/5b610107858e507e4016cc26/GoodbyeChoiceInactive.png) */
	GoodbyeChoiceActive: boolean;
	/** Sets the sentence that the dialog will show to the player when the chat ends */
	GoodbyeDialog: string;
	/** Sets what the NPC will say when the player chooses this DialogChoice. */
	ResponseDialog: string;
	/** Sets what the player will say when they choose this DialogChoice. */
	UserDialog: string;
}

/** The **Dragger**
 object is a helper object used to create tools that can drag parts. It is expected (but not required) to be used with `Mouse` events.

Its implementation is primarily used in the `RbxStamper` library. */
interface Dragger extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Dragger";
	/** Rotates the currently dragged part(s) by 90 degrees on the given axis. */
	AxisRotate(axis?: CastsToEnum<Enum.Axis>): void;
	/** Initializes a dragging action, specifying which parts to use when dragging. */
	MouseDown(mousePart: BasePart, pointOnMousePart: Vector3, parts: Array<BasePart>): void;
	/** Tries to move the currently dragged part to the point where MouseRay hits another part. */
	MouseMove(mouseRay: Ray): void;
	/** Stops the current dragging action (made by [MouseDown](https://developer.roblox.com/api-reference/function/Dragger/MouseDown "MouseDown")
) */
	MouseUp(): void;
}

/** An Explosion applies force to `BaseParts` within the explosion's `BlastRadius`. This force breaks joints between parts and kills `Humanoid` characters not protected by a `ForceField`.

If an explosion is instanced whilst the game is running, it will destroy itself shortly afterwards meaning they do not need to be cleaned up using the `Debris` service.

**Explosion effects**

`Humanoids` are killed by explosions as they break the character `Model`'s neck joint. Parenting a `ForceField` to a model will protect all of its children from Explosions. This means that their joints will not be broken and thus `Humanoid`s will not be killed.

If a developer doesn't want joints between `BaseParts` to be broken or wants to implement their own formula for damaging `Humanoid`s it is recommended they set `DestroyJointRadiusPercent` to 0 and use the `Hit` event to handle the result of the explosion.

Explosions can also be configured to damage `Terrain`, creating craters, this behavior is controlled by the `ExplosionType ` property.

The effect of an Explosion is not disrupted by obstacles, this means parts shielded behind other parts will still be effected, even if the `BasePart` they are shielded behind is not anchored.

## Code Samples

### Explosion Instantiation

This code sample includes a brief snippet that creates a large explosion in the game at 0, 10, 0.
```lua
local explosion = Instance.new("Explosion")
explosion.BlastRadius = 60
explosion.ExplosionType = Enum.ExplosionType.Craters -- damages terrain
explosion.Position = Vector3.new(0, 10, 0)
explosion.Parent = game.Workspace
```
 */
interface Explosion extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Explosion";
	/** Used to determine the amount of force applied to `BasePart`s caught in the `BlastRadius`.

Currently this level of force applied does not vary based on distance from `Position`. Unanchored `BaseParts` will accelerate equally away from the origin regardless of distance provided they are within the blast radius.

The blast pressure determines the acceleration of parts due to an explosion. It does not determine the degree to which joints are broken. When `DestroyJointRadiusPercent` is equal to 1 all joints between parts in the `BlastRadius` will be destroyed provided BlastPressure is greater than 0.

The BlastPressure also does not determine the amount of damage given to `Terrain`. Provided BlastPressure is greater than 0 and `ExplosionType` isn't set to Enum.ExplosionType.NoCraters the size of the crater created is determined exclusively by the `BlastRadius`.

Setting BlastPressure to 0 eliminates the effect of the explosion and is useful when developers want to program their own custom behavior for explosions using the `Hit` event.

## Code Samples

### Custom Explosion

This sample contains a simple function that creates a custom explosion. The custom explosion will not break joints as Explosion.DestroyJointRadiusPercent is equal to 0. This means Humanoids will not be instantly killed as their neck joints are broken. In this example explosion.BlastPressure is equal to zero so as not to apply force or damage terrain but this can be changed.

The Explosion.Hit event is used to listen for contact. Once contact has been made the code will look for the parent model of the BasePart hit by the explosion. If that model exists, hasn't already been damaged and has a Humanoid in it damage will be applied based on distance from the explosion's origin.
```lua
local function customExplosion(position, radius, maxDamage)
	local explosion = Instance.new("Explosion")
	explosion.BlastPressure = 0 -- this could be set higher to still apply velocity to parts
	explosion.DestroyJointRadiusPercent = 0 -- joints are safe
	explosion.BlastRadius = radius
	explosion.Position = position
	
	-- set up a table to track the models hit
	local modelsHit = {}

	-- listen for contact
	explosion.Hit:Connect(function(part, distance)
		local parentModel = part.Parent
		if parentModel then 
			-- check to see if this model has already been hit 
			if modelsHit[parentModel] then
				return
			end
			-- log this model as hit
			modelsHit[parentModel] = true

			-- look for a humanoid
			local humanoid = parentModel:FindFirstChild("Humanoid")
			if humanoid then
				local distanceFactor = distance / explosion.BlastRadius -- get the distance as a value between 0 and 1
				distanceFactor = 1 - distanceFactor -- flip the amount, so that lower == closer == more damage
				humanoid:TakeDamage(maxDamage * distanceFactor) -- TakeDamage to respect ForceFields
			end	
		end
	end)

	explosion.Parent = game.Workspace
end
```
 */
	BlastPressure: number;
	/** This property determines the radius of the `Explosion`, in studs. This property accepts any value between 0 and 100.

This radius determines the area of effect of the Explosion, not the size of the Explosion's visuals. The size of the Explosion's visual effect is the same regardless of BlastRadius (even if BlastRadius is 0).

`BasePart`s within the BlastRadius will be affected by the explosion. Meaning, if `BlastPressure` is greater than 0, force will be applied to parts. The degree to which joints are broken within the BlastRadius depends on `DestroyJointRadiusPercent`. `Hit` will fire for any every `BasePart` within the radius.

`BasePart`s are considered within an `Explosion`'s BlastRadius even if they are only partially in range.

## Code Samples

### Explosion Instantiation

This code sample includes a brief snippet that creates a large explosion in the game at 0, 10, 0.
```lua
local explosion = Instance.new("Explosion")
explosion.BlastRadius = 60
explosion.ExplosionType = Enum.ExplosionType.Craters -- damages terrain
explosion.Position = Vector3.new(0, 10, 0)
explosion.Parent = game.Workspace
```
 */
	BlastRadius: number;
	/** Used to set the proportion of the `BlastRadius`, between 0 and 1, within which all joints will be destroyed. Anything outside of this range will only have the `Explosion` force applied to it.

For example, if `BlastRadius` is set to 100 and DestroyJointRadiusPercent is set to 0.5, any joints within a radius of 50 studs would be broken. Any joints between the ranges of 50 and 100 studs wouldn't be destroyed, but the `Explosion`'s force would still be applied to the `BasePart`s.

This property allows developers to make `Explosion`s 'non-lethal' to `Humanoid`s by setting DestroyJointRadiusPercent to 0. This means the neck joint will not be broken when characters come into contact with the `Explosion`.

## Code Samples

### Non lethal explosions

This sample includes an example of how Explosions can be made non lethal to player characters.
```lua
-- listen for new Explosion's being added to the workspace
workspace.DescendantAdded:Connect(function(instance)
	if instance:IsA("Explosion") then
		local explosion = instance
		-- set DestroyJointRadiusPercent to 0
		explosion.DestroyJointRadiusPercent = 0
		-- implement our own DestroyJointRadiusPercent
		local destroyJointRadiusPercent = 1
		explosion.Hit:Connect(function(part, distance)
			-- check the part is in range to break joints
			if distance <= destroyJointRadiusPercent * explosion.BlastRadius then
				-- make sure the part does not belong to a character
				if not game.Players:GetPlayerFromCharacter(part.Parent) then
					-- break joints
					part:BreakJoints()
				end
			end
		end)
	end
end)
```

### Custom Explosion

This sample contains a simple function that creates a custom explosion. The custom explosion will not break joints as Explosion.DestroyJointRadiusPercent is equal to 0. This means Humanoids will not be instantly killed as their neck joints are broken. In this example explosion.BlastPressure is equal to zero so as not to apply force or damage terrain but this can be changed.

The Explosion.Hit event is used to listen for contact. Once contact has been made the code will look for the parent model of the BasePart hit by the explosion. If that model exists, hasn't already been damaged and has a Humanoid in it damage will be applied based on distance from the explosion's origin.
```lua
local function customExplosion(position, radius, maxDamage)
	local explosion = Instance.new("Explosion")
	explosion.BlastPressure = 0 -- this could be set higher to still apply velocity to parts
	explosion.DestroyJointRadiusPercent = 0 -- joints are safe
	explosion.BlastRadius = radius
	explosion.Position = position
	
	-- set up a table to track the models hit
	local modelsHit = {}

	-- listen for contact
	explosion.Hit:Connect(function(part, distance)
		local parentModel = part.Parent
		if parentModel then 
			-- check to see if this model has already been hit 
			if modelsHit[parentModel] then
				return
			end
			-- log this model as hit
			modelsHit[parentModel] = true

			-- look for a humanoid
			local humanoid = parentModel:FindFirstChild("Humanoid")
			if humanoid then
				local distanceFactor = distance / explosion.BlastRadius -- get the distance as a value between 0 and 1
				distanceFactor = 1 - distanceFactor -- flip the amount, so that lower == closer == more damage
				humanoid:TakeDamage(maxDamage * distanceFactor) -- TakeDamage to respect ForceFields
			end	
		end
	end)

	explosion.Parent = game.Workspace
end
```
 */
	DestroyJointRadiusPercent: number;
	/** This property determines how the `Explosion` will interact with `Terrain`. It is an Enum.ExplosionType value and can be set to one of three options.

 - **NoCraters** - Explosions will not damage Terrain
 - **Craters** - Explosions will create craters in Terrain 
 - **CratersAndDebris** - Redundant, behaves the same as Craters

If ExplosionType is set to create craters in `Terrain`, the radius of the crater will be roughly equal to the `BlastRadius`. Craters are created in all `Terrain` materials other than water. The size of the crater is not influenced by the material, although some materials create rougher edges than others.

## Code Samples

### Stop Explosions from Damaging Terrain

This code sample includes an example of how the Explosion.ExplosionType property can be used to stop Explosions from damaging terrain. It is recommended to set the ExplosionType to NoCraters at the point of Explosion instantiation, but if that is not practical the code below will work.
```lua
game.Workspace.DescendantAdded:Connect(function(descendant)
	if descendant:IsA("Explosion") then
		descendant.ExplosionType = Enum.ExplosionType.NoCraters
		descendant:GetPropertyChangedSignal("ExplosionType"):Connect(function()
			descendant.ExplosionType = Enum.ExplosionType.NoCraters
		end)
	end
end)
```
 */
	ExplosionType: Enum.ExplosionType;
	/** This property is the position of the center of the `Explosion`. It is defined in world-space and not influenced by the `Explosion`'s parent.

`BasePart`s will be influenced by the `Explosion` if they are within `BlastRadius` studs of the explosion's position. 

The effect of an explosion is instantaneous. This means that although the position of an explosion can be changed after it has been set it cannot affect two different areas. Once an explosion has been 'detonated', shortly after parenting it to a descendant of the `Workspace`, it will not do so again. In some cases the visual effect of the explosion will move but it will have no effect.

For this reason a new Explosion should be created if the developer wants an explosion to appear at a different position.

## Code Samples

### Explosion Instantiation

This code sample includes a brief snippet that creates a large explosion in the game at 0, 10, 0.
```lua
local explosion = Instance.new("Explosion")
explosion.BlastRadius = 60
explosion.ExplosionType = Enum.ExplosionType.Craters -- damages terrain
explosion.Position = Vector3.new(0, 10, 0)
explosion.Parent = game.Workspace
```
 */
	Position: Vector3;
	/** This property determines whether or not the visual effect of an `Explosion` is shown or not.

When Visible is set to false, the explosion will still affect `BasePart`s in its `BlastRadius`, the only difference is it will not be seen.

One use for this property would be for a developer to make their own custom explosion effects using a `ParticleEmitter`, whilst retaining the default `Explosion` functionality.

## Code Samples

### Explosion Custom Visuals

This sample includes a function that will create an Explosion but replace the default Explosion visuals but those of a ParticleEmitter.
```lua
local Debris = game:GetService("Debris")

local function customExplosion(position)
	local explosion = Instance.new("Explosion")
	explosion.Position = position
	explosion.Visible = false 
	
	local attachment = Instance.new("Attachment", workspace.Terrain)
	attachment.Position = position
	
	local particleEmitter = Instance.new("ParticleEmitter")
	particleEmitter.Enabled = false 
	particleEmitter.Parent = attachment 
	particleEmitter.Speed = NumberRange.new(5, 30)
	particleEmitter.SpreadAngle = Vector2.new(-90, 90)

	explosion.Parent = workspace 
	particleEmitter:Emit(20)

	Debris:AddItem(attachment, 5) -- clean up attachment
end
```
 */
	Visible: boolean;
	/** Fires when the `Explosion` hits a `BasePart` within its `BlastRadius`. Returns the part hit along with the distance of the part from `Position`.

Note that the effect of an `Explosion` is not disrupted by obstacles, this means parts shielded behind other parts will still be hit, even if the `BasePart` they are shielded behind is anchored.

This event will also fire when `BlastPressure` is equal to zero. This means developers can program their own custom behavior for explosions by eliminating the explosion's influence on `BasePart`s and `Terrain`.

Note that this event will fire for every `BasePart` hit. This means it can fire multiple times for the same player character (as the character `Model` is made up of multiple parts). For this reason when dealing custom damage using the `Explosion.Hit` event it's recommended to implement a check to see if the character has already been hit by the `Explosion`.

## Code Samples

### Custom Explosion

This sample contains a simple function that creates a custom explosion. The custom explosion will not break joints as Explosion.DestroyJointRadiusPercent is equal to 0. This means Humanoids will not be instantly killed as their neck joints are broken. In this example explosion.BlastPressure is equal to zero so as not to apply force or damage terrain but this can be changed.

The Explosion.Hit event is used to listen for contact. Once contact has been made the code will look for the parent model of the BasePart hit by the explosion. If that model exists, hasn't already been damaged and has a Humanoid in it damage will be applied based on distance from the explosion's origin.
```lua
local function customExplosion(position, radius, maxDamage)
	local explosion = Instance.new("Explosion")
	explosion.BlastPressure = 0 -- this could be set higher to still apply velocity to parts
	explosion.DestroyJointRadiusPercent = 0 -- joints are safe
	explosion.BlastRadius = radius
	explosion.Position = position
	
	-- set up a table to track the models hit
	local modelsHit = {}

	-- listen for contact
	explosion.Hit:Connect(function(part, distance)
		local parentModel = part.Parent
		if parentModel then 
			-- check to see if this model has already been hit 
			if modelsHit[parentModel] then
				return
			end
			-- log this model as hit
			modelsHit[parentModel] = true

			-- look for a humanoid
			local humanoid = parentModel:FindFirstChild("Humanoid")
			if humanoid then
				local distanceFactor = distance / explosion.BlastRadius -- get the distance as a value between 0 and 1
				distanceFactor = 1 - distanceFactor -- flip the amount, so that lower == closer == more damage
				humanoid:TakeDamage(maxDamage * distanceFactor) -- TakeDamage to respect ForceFields
			end	
		end
	end)

	explosion.Parent = game.Workspace
end
```
 */
	readonly Hit: RBXScriptSignal<(part: BasePart, distance: number) => void>;
}

interface RbxInternalFaceInstance extends RbxInternalInstance {
	/** Sets what face of the brick the object appears on. */
	Face: Enum.NormalId;
}
/** The FaceInstance class is an abstract class from which the `Decal` class inherits. */
type FaceInstance = Decal | Texture;

interface RbxInternalDerivesFromDecal extends RbxInternalFaceInstance {
	/** The `Color3` tint of the `Decal`.

Developers should note that this property only sets the tint of the decal, rather than the color. This means, unless the image associated with the `Decal` was originally white (RGB = 1,1,1) then the color cannot be freely changed using this property.

By reducing the RGB properties of `Color3` in union, developers can make a decal darker.

## Code Samples

### Decal Color3

This code sample creates a `Decal` in the workspace and changes its `Color3` property on a loop using `TweenService`.
```lua
local TweenService = game:GetService("TweenService")

-- create part 1
local part = Instance.new("Part")
part.Size = Vector3.new(10, 10, 1)
part.Position = Vector3.new(0, 5, 0)
part.Anchored = true
part.Transparency = 1

-- create decal
local decal = Instance.new("Decal", part)
decal.Face = Enum.NormalId.Front
decal.Texture = "http://www.roblox.com/asset/?id=1145367640" -- white circle

-- add to workspace
part.Parent = workspace

-- create tweens
local redTween = TweenService:Create(decal, 
	TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
	{Color3 = Color3.new(1, 0, 0)}
)
local greenTween = TweenService:Create(decal, 
	TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
	{Color3 = Color3.new(0, 1, 0)}
)
local blueTween = TweenService:Create(decal, 
	TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
	{Color3 = Color3.new(0, 0, 1)}
)

-- play tweens
while true do
	redTween:Play()
	redTween.Completed:Wait()
	greenTween:Play()
	greenTween.Completed:Wait()
	blueTween:Play()
	blueTween.Completed:Wait()
end
```
 */
	Color3: Color3;
	/** Acts as a multiplier for the `Decal`'s `Transparency` property. The effects are only visible to the `LocalPlayer`.

This property should be used in situations where `Transparency` is being set by a different script. The benefit of LocalTransparencyModifier is that it can be changed without concern for the original `Transparency` of the `Decal`

When LocalTransparencyModifier is set to 1, the `Decal` will be completely invisible regardless of its original transparency. When it is set to 0, the `Decal`s rendered transparency will match the `Transparency` value. The formula for this is:
```lua
Displayed Transparency = Transparency + ((1 - Transparency) * LocalTransparencyModifier)
```


Note, this property should be used on the client only and will not replicate to the server.

For a variant of this property for `BasePart`s, see `LocalTransparencyModifier`.Acts as a multiplier for the `Decal`'s `Transparency` property. The effects are only visible to the `LocalPlayer`.

This property should be used in situations where `Transparency` is being set by a different script. The benefit of LocalTransparencyModifier is that it can be changed without concern for the original `Transparency` of the `Decal`

When LocalTransparencyModifier is set to 1, the `Decal` will be completely invisible regardless of its original transparency. When it is set to 0, the `Decal`s rendered transparency will match the `Transparency` value. The formula for this is:
```lua
Displayed Transparency = Transparency + ((1 - Transparency) * LocalTransparencyModifier)
```


Note, this property should be used on the client only and will not replicate to the server.

For a variant of this property for `BasePart`s, see `LocalTransparencyModifier`.

Tags: Hidden, NotReplicated */
	LocalTransparencyModifier: number;
	/** The Content ID of the image to be applied by the `Decal`.

## How can I upload a Decal?
Images can be uploaded to Roblox provided they adhere to the community guidelines. Information on how to upload images can be found `How to upload a here`.

## How to find do I find a Decal's Content ID?
Unlike with `Sound` and `Animation` objects, the Content ID of a Decal is not the same as the number in the URL. There are two main ways of finding the Content ID of a Decal:

 - Paste the URL into the Texture property in Roblox Studio. Roblox will automatically update the property to the correct Content ID. Note this only works in Roblox Studio and cannot be done from Scripts or whilst the game is running.
 - Insert the Decal into the game, this is generally done through the Toolbox under 'My Decals'. The Content ID can be found in the decal that is inserted. Note, `LoadAsset` can also be used if developers wish to automate this method.

  [1]: /articles/How-to-upload-a-Decal

## Code Samples

### Changing Decal Texture

The following code will create a `Part` on the ground with a `Decal` applied to its top face. When something hits the part, such as when a player walks over it, the texture applied to the decal will change and a sound will play.
```lua
-- create part 
local part = Instance.new("Part")
part.Size = Vector3.new(5, 1, 5)
part.Position = Vector3.new(0, 0.5, 0)
part.Anchored = true
part.TopSurface = Enum.SurfaceType.Smooth
part.BrickColor = BrickColor.new("Toothpaste")

-- create decal
local decal = Instance.new("Decal", part)
decal.Face = Enum.NormalId.Top

-- create sound
local sound = Instance.new("Sound", part)
sound.SoundId = "rbxasset://sounds/uuhhh.mp3" --ooff

-- define faces
local happyFace = "http://www.roblox.com/asset/?id=26424652"
local sadFace = "http://www.roblox.com/asset/?id=147144198"

decal.Texture = happyFace

-- touched event 
local cooldown = false
part.Touched:Connect(function(hit)
	if not cooldown then
		if hit and hit.Parent then
			cooldown = true
			sound:Play()
			decal.Texture = sadFace
			wait(1)
			decal.Texture = happyFace
			wait(0.2)
			cooldown = false
		end
	end
end)

-- add to workspace
part.Parent = workspace


```
 */
	Texture: string;
	/** Determines the transparency of the `Decal` with 0 being completely opaque and 1 completely transparent.

Note, `Decal`s also respect the transparency of the original image file uploaded to Roblox. This means transparency can be changed prior to uploading to Roblox, and without the need to use the Transparency property.

`LocalTransparencyModifier` acts as a multiplier for the Decal's transparency and should be used when the transparency of the decal is likely to be changed by another script, as is the case with player Characters.

For `BasePart`s, see `Transparency`.

## Code Samples

### Fading Decal

The code below will create a transparent `Part` with a decal that will fade in and out using `TweenService` and `Transparency`.
```lua
local TweenService = game:GetService("TweenService")

-- create part 
local part = Instance.new("Part")
part.Size = Vector3.new(10, 10, 1)
part.Position = Vector3.new(0, 5, 0)
part.Anchored = true
part.Transparency = 1

-- create decal
local decal = Instance.new("Decal", part)
decal.Face = Enum.NormalId.Front
decal.Texture = "http://www.roblox.com/asset/?id=699259085" -- roblox logo

-- add to workspace
part.Parent = workspace

-- create tween
local tween = TweenService:Create(decal,
	TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, -1, true),
	{Transparency = 1}
)

-- play tween
tween:Play()

```
 */
	Transparency: number;
}
/** The Decal object is an object which applies an image to a face of a `BasePart`. 

## How does a Decal work?
A Decal will apply an image to the `BasePart` it is parented to. The surface this image is applied to is dependent on the `Face` property. The size of the decal is dependent on the size of the face, meaning the size and aspect ratio of a decal can be changed by changing its parent's `Size`.

The image a Decal applies is determined by its `Texture` property. Images can be uploaded to Roblox provided they adhere to the community guidelines. Information on how to upload images can be found `How to upload a here`.

## Alternatives to Decals

Although Decals have a wide variety of applications, in some cases developers may wish to pick one of the following classes instead.

 - For repeated tiled textures, the `Texture` object should be used
 - To apply GUI elements, the `SurfaceGui` object should be used
 - If the effect of lighting on the image needs to be altered, the `SurfaceGui` object should be used

  [1]: /articles/How-to-upload-a-Decal

## Code Samples

### Changing Decal Texture

The following code will create a `Part` on the ground with a `Decal` applied to its top face. When something hits the part, such as when a player walks over it, the texture applied to the decal will change and a sound will play.
```lua
-- create part 
local part = Instance.new("Part")
part.Size = Vector3.new(5, 1, 5)
part.Position = Vector3.new(0, 0.5, 0)
part.Anchored = true
part.TopSurface = Enum.SurfaceType.Smooth
part.BrickColor = BrickColor.new("Toothpaste")

-- create decal
local decal = Instance.new("Decal", part)
decal.Face = Enum.NormalId.Top

-- create sound
local sound = Instance.new("Sound", part)
sound.SoundId = "rbxasset://sounds/uuhhh.mp3" --ooff

-- define faces
local happyFace = "http://www.roblox.com/asset/?id=26424652"
local sadFace = "http://www.roblox.com/asset/?id=147144198"

decal.Texture = happyFace

-- touched event 
local cooldown = false
part.Touched:Connect(function(hit)
	if not cooldown then
		if hit and hit.Parent then
			cooldown = true
			sound:Play()
			decal.Texture = sadFace
			wait(1)
			decal.Texture = happyFace
			wait(0.2)
			cooldown = false
		end
	end
end)

-- add to workspace
part.Parent = workspace


```
 */
interface Decal extends RbxInternalDerivesFromDecal {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Decal";
}


/** A Texture object applies a repeating texture to the face of a `BasePart`.

## How does a Texture work?
A Texture will apply an image to the `BasePart` it is parented to. The surface this image is applied to is dependent on the `Face` property. When the `BasePart` is resized, the image will repeat. The size of the repeating textures is determined by the `StudsPerTileU` and `StudsPerTileV` properties.

```lua
local texture = Instance.new("Texture")
texture.Texture = "http://www.roblox.com/asset/?id=732339893" -- roblox logo
-- 1x1 studs repeating texture
texture.StudsPerTileU = 1
texture.StudsPerTileV = 1
```


The image a Texture applies is determined by its `Texture` property. Images can be uploaded to Roblox provided they adhere to the community guidelines. Information on how to upload images can be found `How to upload a here`. --&gt;

## What is the difference between Textures and Decals?
The texture object is very similar to the `Decal` object. However, whereas the image applied by a `Decal` scales when the `BasePart` is resized, the image applied by a Texture repeats.

Repeating textures have a wide range of applications such as floor tiles and wall textures.

## Alternatives to Textures

Although Decals have a wide variety of applications, in some cases developers may wish to pick one of the following classes instead.

 - For non repeating images `Decal` object should be used
 - To apply GUI elements, the `SurfaceGui` object should be used
 - If the effect of lighting on the image needs to be altered, the `SurfaceGui` object should be used

  [1]: /articles/How-to-upload-a-Decal */
interface Texture extends RbxInternalDerivesFromDecal {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Texture";
	/** Sets the horizontal size, in studs, of the tiled image applied by the `Texture`.

Larger values for this property will lead to the `Texture` appearing larger, and repeating less frequently. Unlike with `Decal`s, the size of the repeated image is unaffected by the dimensions of the `BasePart`. Instead, resizing the `BasePart` only increases the number of times the texture repeats.

See the code snippet below for an example of how this property can be used.
```lua
local texture = Instance.new("Texture")
texture.Texture = "http://www.roblox.com/asset/?id=732339893" -- roblox logo
-- 1x1 studs repeating texture
texture.StudsPerTileU = 1
texture.StudsPerTileV = 1
```


## Notes

 - This property can be set to very low values, but not zero
 - The horisontal / vertical distinction is relative to the `BasePart`s axis. Therefore, the `Texture` will rotate along with the `BasePart`. */
	StudsPerTileU: number;
	/** Sets the vertical size, in studs, of the tiled image applied by the `Texture`.

Larger values for this property will lead to the `Texture` appearing larger, and repeating less frequently. Unlike with `Decal`s, the size of the repeated image is unaffected by the dimensions of the `BasePart`. Instead, resizing the `BasePart` only increases the number of times the texture repeats.

See the code snippet below for an example of how this property can be used.
```lua
local texture = Instance.new("Texture")
texture.Texture = "http://www.roblox.com/asset/?id=732339893" -- roblox logo
-- 1x1 studs repeating texture
texture.StudsPerTileU = 1
texture.StudsPerTileV = 1
```


## Notes

 - This property can be set to very low values, but not zero
 - The horisontal / vertical distinction is relative to the `BasePart`s axis. Therefore, the `Texture` will rotate along with the `BasePart`. */
	StudsPerTileV: number;
}

interface RbxInternalFeature extends RbxInternalInstance {
	/** Sets what side of the Parent the object is on. */
	FaceId: Enum.NormalId;
	/** Controls how the Feature is positioned on it's parent's surface, in correspondence to the Feature's `LeftRight` and `TopBottom` properties. */
	InOut: Enum.InOut;
	/** Controls whether the feature is shifted to the left, center, or right on the surface. */
	LeftRight: Enum.LeftRight;
	/** Controls whether the feature is shifted to the top, center, or bottom on the surface. */
	TopBottom: Enum.TopBottom;
}
/** The base class for the legacy motor system. */
type Feature = Hole | MotorFeature;

/** A Hole is an unused type of surface joint. It can be connected to a `MotorFeature` object by using a `VelocityMotor`. */
interface Hole extends RbxInternalFeature {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Hole";
}

/** A MotorFeature is an unused type of surface joint. It can be connected to a `Hole` object by using a `VelocityMotor`. */
interface MotorFeature extends RbxInternalFeature {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "MotorFeature";
}

interface File extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "File";
}

/** The Fire class is of several particle-emitting classes. Like other particle emitters of its kind, Fire objects emit particles when parented to a `BasePart` (such as a `Part`) or an `Attachment` within such a `BasePart`. Compared to the `ParticleEmitter` class, Fire lacks many different customization properties and special methods, such as `Lifetime` or `Emit`. It is useful to create a quick special effect in a pinch; for more detailed work it is preferable to use a `ParticleEmitter` instead.

![A Fire object emitting particles at a neon part on top of a wooden part](https://developer.roblox.com/assets/blt614752ba08bb2e7c/Fire.png)

Fire objects do not emit any light on their own. To help create a cohesive environment around a burning object in your world, try adding a `PointLight` with a `Color` set to orange. This will make your fire look more realistic.

When `Enabled` is toggled off, particles emit by this object will continue to render until their lifetime expires. When a Fire object's `Parent` is set to nil (and/or `Destroy`ed), all particles will instantly disappear. If this effect is not desired, try hiding the parent object at a far away position, then removing the Fire after a few seconds using `Debris` to give the last particles a chance to expire. This object does not have a `Clear` method, but it is possible to set the `Parent` to nil and back to the exact same object for the same effect.

Fire particles are only emit from the center of `BasePart` to which they are parented. The particles are emit toward the top (+Y) direction; however, a negative `Heat` may be used to emit in the bottom (-Y) direction. Parenting a Fire object to an `Attachment` instead allows customization of the particles' start position and emission direction.

Fire object consist of two emitters. Each are affected differently by `Size`, `Heat`, `Color` and `SecondaryColor`. The particles emit from the smaller, secondary emitter have a significantly longer lifetime (and rise farther) than those emit by the primary emitter.
![A Fire objects' two emitter sources, in blue and white](https://developer.roblox.com/assets/blt925890091ac70b39/Fire_Colors.png)

Unlike actual flames, Fire objects on Roblox do not spread on their own. If you notice this behavior in your game, it is happening because a `Script` is spreading fire.

## Code Samples

### Lighting Torches

This code sample adds `Fire` to all `BasePart` in the `Workspace` named "Torch".
```lua
for _, child in pairs(workspace:GetChildren()) do
	if child.Name == "Torch" and child:IsA("BasePart") then
		local fire = Instance.new("Fire")
		fire.Heat = 10
		fire.Color = child.Color
		fire.SecondaryColor = Color3.new(1, 1, 1) -- White
		fire.Size = math.max(child.Size.X, child.Size.Z) -- Pick the larger of the two dimensions
		fire.Parent = child
	end
end
```
 */
interface Fire extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Fire";
	/** The Color property determines the color of the larger particles emit by a `Fire` object. It is essentially the color of the outer portion of the flame. Below, you can see the Color of the flame is set to blue to differentiate with the smaller, inner particles which have `SecondaryColor` set to white.

![A Fire with Color set to blue](https://developer.roblox.com/assets/blt925890091ac70b39/Fire_Colors.png)

In general, the cooler flames are on the outside of a fire. Therefore, fire looks more realistic if the outer portions are red or orange-yellow. A fire that is bright all throughout doesn't look very realistic, so avoid setting this property to yellow. Try adding a `PointLight` with the `Color` as a sibling to the `Fire`. This will provide light to the surrounding environment and make it feel more cohesive with the flame particles.

## Code Samples

### Lighting Torches

This code sample adds `Fire` to all `BasePart` in the `Workspace` named "Torch".
```lua
for _, child in pairs(workspace:GetChildren()) do
	if child.Name == "Torch" and child:IsA("BasePart") then
		local fire = Instance.new("Fire")
		fire.Heat = 10
		fire.Color = child.Color
		fire.SecondaryColor = Color3.new(1, 1, 1) -- White
		fire.Size = math.max(child.Size.X, child.Size.Z) -- Pick the larger of the two dimensions
		fire.Parent = child
	end
end
```
 */
	Color: Color3;
	/** The Enabled property, much like `Enabled`, determines whether flame particles are emit. Any particles already emit will continue to render until their lifetime expires. This property is useful for keeping pre-made fire effects off until they are needed later. Since flame particles are destroyed when the `Fire` object's `Parent` is set to nil, this property is useful in allowing existing particles the opportunity to expire before destroying the Fire object altogether. See the function below.

```lua
local Debris = game:GetService("Debris")
local part = script.Parent
function douseFlames(fire)
	fire.Enabled = false -- No more new particles
	Debris:AddItem(fire, 2) -- Remove the object after a delay (after existing particles have expired)
end
douseFlames(part.Fire)
```

## Code Samples

### Toggle Fire Effect

This code sample allows a player to click the parent `BasePart` to toggle a fire effect.
```lua
local part = script.Parent

local clickDetector = Instance.new("ClickDetector", part)
local fire = Instance.new("Fire", part)
local light = Instance.new("PointLight", part)

local function onClick()
	-- Toggle the fire
	fire.Enabled = not fire.Enabled
	-- Turn on the light if the fire is emitting
	light.Enabled = fire.Enabled
end

clickDetector.MouseClick:Connect(onClick)

```
 */
	Enabled: boolean;
	/** The Heat property determines how fast particles are emit from the `Fire` object. It is limited to the range [-25, 25]. Positive values are in the top (+Y) direction of the parent `BasePart` or `Attachment`. It also affects the `Acceleration` of the inner particles. Below, you can see the effects of higher heat on the velocity/acceleration of the flame particles (left has Heat = 9, right has Heat = 18).

![Two torches - the left has Heat = 9 and the right has Heat = 18](https://developer.roblox.com/assets/bltc9bf8cb45c829244/Fire_Heat.png)

## Code Samples

### Lighting Torches

This code sample adds `Fire` to all `BasePart` in the `Workspace` named "Torch".
```lua
for _, child in pairs(workspace:GetChildren()) do
	if child.Name == "Torch" and child:IsA("BasePart") then
		local fire = Instance.new("Fire")
		fire.Heat = 10
		fire.Color = child.Color
		fire.SecondaryColor = Color3.new(1, 1, 1) -- White
		fire.Size = math.max(child.Size.X, child.Size.Z) -- Pick the larger of the two dimensions
		fire.Parent = child
	end
end
```
The Heat property determines how fast particles are emit from the `Fire` object. It is limited to the range [-25, 25]. Positive values are in the top (+Y) direction of the parent `BasePart` or `Attachment`. It also affects the `Acceleration` of the inner particles. Below, you can see the effects of higher heat on the velocity/acceleration of the flame particles (left has Heat = 9, right has Heat = 18).

![Two torches - the left has Heat = 9 and the right has Heat = 18](https://developer.roblox.com/assets/bltc9bf8cb45c829244/Fire_Heat.png)

## Code Samples

### Lighting Torches

This code sample adds `Fire` to all `BasePart` in the `Workspace` named "Torch".
```lua
for _, child in pairs(workspace:GetChildren()) do
	if child.Name == "Torch" and child:IsA("BasePart") then
		local fire = Instance.new("Fire")
		fire.Heat = 10
		fire.Color = child.Color
		fire.SecondaryColor = Color3.new(1, 1, 1) -- White
		fire.Size = math.max(child.Size.X, child.Size.Z) -- Pick the larger of the two dimensions
		fire.Parent = child
	end
end
```


Tags: NotReplicated */
	Heat: number;
	/** The SecondaryColor property determines the color of the smaller particles emit by a `Fire` object. It is essentially the color of the inner portion of the flame. Below, you can see the SecondaryColor of the flame is set to white to differentiate with the larger, outer particles which have `Color` set to blue. It should be noted that the inner particles use a `LightEmission` of 1, so darker colors will instead cause the particles to appear transparent (and therefore black will stop rendering inner particles altogether).

![A Fire with SecondaryColor set to white](https://developer.roblox.com/assets/blt925890091ac70b39/Fire_Colors.png)

## Code Samples

### Lighting Torches

This code sample adds `Fire` to all `BasePart` in the `Workspace` named "Torch".
```lua
for _, child in pairs(workspace:GetChildren()) do
	if child.Name == "Torch" and child:IsA("BasePart") then
		local fire = Instance.new("Fire")
		fire.Heat = 10
		fire.Color = child.Color
		fire.SecondaryColor = Color3.new(1, 1, 1) -- White
		fire.Size = math.max(child.Size.X, child.Size.Z) -- Pick the larger of the two dimensions
		fire.Parent = child
	end
end
```
 */
	SecondaryColor: Color3;
	/** This  property determines the size of the flame particles. It must be in the range of [2, 30]. Unlike `Size`, the actual size of the flames will not match 1-to-1 with the equivalent size in studs; it is somewhat smaller.

![Two torches - the left has Size = 5 and the right has Size = 10](https://developer.roblox.com/assets/5c4e6f08d626b8290a8e3f7b/Fire_Size.png)

To make your environment more cohesive, try adding a `PointLight` as a sibling to the `Fire` object. Set the `Brightness` and `Range` proportional to this property so that larger flames produce more light.

## Code Samples

### Lighting Torches

This code sample adds `Fire` to all `BasePart` in the `Workspace` named "Torch".
```lua
for _, child in pairs(workspace:GetChildren()) do
	if child.Name == "Torch" and child:IsA("BasePart") then
		local fire = Instance.new("Fire")
		fire.Heat = 10
		fire.Color = child.Color
		fire.SecondaryColor = Color3.new(1, 1, 1) -- White
		fire.Size = math.max(child.Size.X, child.Size.Z) -- Pick the larger of the two dimensions
		fire.Parent = child
	end
end
```
This  property determines the size of the flame particles. It must be in the range of [2, 30]. Unlike `Size`, the actual size of the flames will not match 1-to-1 with the equivalent size in studs; it is somewhat smaller.

![Two torches - the left has Size = 5 and the right has Size = 10](https://developer.roblox.com/assets/5c4e6f08d626b8290a8e3f7b/Fire_Size.png)

To make your environment more cohesive, try adding a `PointLight` as a sibling to the `Fire` object. Set the `Brightness` and `Range` proportional to this property so that larger flames produce more light.

## Code Samples

### Lighting Torches

This code sample adds `Fire` to all `BasePart` in the `Workspace` named "Torch".
```lua
for _, child in pairs(workspace:GetChildren()) do
	if child.Name == "Torch" and child:IsA("BasePart") then
		local fire = Instance.new("Fire")
		fire.Heat = 10
		fire.Color = child.Color
		fire.SecondaryColor = Color3.new(1, 1, 1) -- White
		fire.Size = math.max(child.Size.X, child.Size.Z) -- Pick the larger of the two dimensions
		fire.Parent = child
	end
end
```


Tags: NotReplicated */
	Size: number;
}

/** This class was an internal service responsible for handling the now deprecated `FlagStand` and `Flag` objects.

The `Flag` and `FlagStand` objects were created to allow developers to make 'Capture the Flag' style games quickly. However they have been deprecated and developers are advised to design their own systems which will be more flexible and reliable. 

To get started with this, developers can use the 'Capture The Flag' template place provided by Roblox which has a fully functioning system developers can take and use in their own games. A link to the place, which is free to edit, is [here][1].


  [1]: https://www.roblox.com/games/92721754/Capture-The-Flag#!/about */
interface FlagStandService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FlagStandService";
}

interface RbxInternalFlyweightService extends RbxInternalInstance {}
/** Internal service with no functionality available to developers. */
type FlyweightService = CSGDictionaryService | NonReplicatedCSGDictionaryService;

/** CSGDictionaryService is an internal service that stores a cache of `BinaryStringValue` objects, each value representing a unique data set for [solid modeling][1] data. In general, it serves no purpose to developers.

  [1]: /articles/3D-Modeling-with-Parts */
interface CSGDictionaryService extends RbxInternalFlyweightService {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CSGDictionaryService";
}

/** A version of the `CSGDictionaryService` that does not replicate to clients. */
interface NonReplicatedCSGDictionaryService extends RbxInternalFlyweightService {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NonReplicatedCSGDictionaryService";
}

/** A simple container used to hold and organize Roblox objects. Unlike other container classes like `Model`, it offers no additional functionality. 

The Folder object is ideal for organizing and storing objects. It is not recommended to use folders to group `BasePart`s as `Model`s offer a range of useful functions for moving and manipulating the parts.

Folders form part of the game's hierarchy and can be accessed the same way as any object. For example:
```lua
local folder = game:GetService("ReplicatedStorage"):FindFirstChild("Folder")
 local subFolder = folder:FindFirstChild("Folder")
```

Folders behave the same way as folders in a computer file system, meaning they can also be parented to each other. They exist as a means for developers to better organize the multitude of objects required by complex games. See below for a simple example of how folders can be used to organize game objects in `ReplicatedStorage`.

![enter image description here](https://developer.roblox.com/assets/blta82462d9370edb83/Folders_-_Copy.png) */
interface Folder extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Folder";
}

/** A `ForceField` protects a `Humanoid` from taking damage using the `TakeDamage` function, and protects `BasePart`s from having their joints broken due to an `Explosion`. 

## ForceField Creation

ForceFields are created when a character spawns on a `SpawnLocation` and the `Duration` property is greater than zero.

ForeFields influence the instance they are parented to. When parented to a `Model` they will protect all of the `BasePart`s descending from that model. They may be parented to a `BasePart`, but the part's joints will only be protected if both the part and the part it is connected to also contain ForceField.

## Forcefields and Joints

When a ForceField is parented to a character `Model` the neck joint will be protected and thus the character can not be killed by `Explosions`. Developers can protect joints from Explosions without the need for a `ForceField` object by setting `DestroyJointRadiusPercent` to 0. 

**ForceFields and Damage**

ForceFields only protect `Humanoid`s from damage using the `TakeDamage` function. Humanoids can still be damaged by setting `Health` directly. For this reason, it is advised that developers use `TakeDamage`. Bearing in mind of course, that it is still possible to check if a `ForceField` exists before manually setting the humanoid's health as shown below:

    if not characterModel:FindFirstChildOfClass("ForceField") then
    	humanoid.Health = humanoid.Health - 10
    end

## ForceField Visuals

When `Visible` is set to true, a particle effect is created. A number of rules determine where this effect will be emitted from.

When parented to a `Model`, if the model includes a `Humanoid` named “Humanoid” with `RigType` set to R15, the effect will be emitted from the part named “UpperTorso”. Otherwise, the effect will be emitted from the part named “Torso”. The part must have the same parent as the ForceField, if it does not exist then the effect is emitted at 0, 0, 0.

When parented to a `BasePart` the effect will be emitted from the part's `Position`.

## Code Samples

### ForceField Instantiation

This code sample includes a function that will give a Player a ForceField for a specific duration.
```lua
local Debris = game:GetService("Debris")

local function giveForcefield(player, duration)
	local character = player.Character
	if character then
		local forceField = Instance.new("ForceField")
		forceField.Visible = true
		forceField.Parent = character
		if duration then
			Debris:AddItem(forceField, duration)
		end
	end
end
```

### SpawnLocation ForceField

This sample will create a neutral SpawnLocation in the Workspace that'll give players spawning a ForceField for 20 seconds.
```lua
local spawnLocation = Instance.new("SpawnLocation", game.Workspace)
spawnLocation.Anchored = true
spawnLocation.Size = Vector3.new(5, 1, 5)
spawnLocation.Neutral = true -- anyone can spawn here
spawnLocation.Duration = 20 -- ForceField duration 20s
```
 */
interface ForceField extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ForceField";
	/** Determines whether or not the `ForceField`'s particle effect is visible.

When is set to true, a particle effect is created, a number of rules determine where this effect will be emitted from.

When parented to a `Model`, if the model includes a `Humanoid` named “Humanoiod” with `RigType` set to R15, the effect will be emitted from the part named “UpperTorso”. Otherwise, the effect will be emitted from the part named “Torso”. The part must have the same parent as the ForceField, if it does not exist then the effect is emitted at 0, 0, 0.

When parented to a `BasePart` the effect will be emitted from the part's `Position`.

One use for this property is replacing the default particle effect with a custom effect using `ParticleEmitter`s.

## Code Samples

### Custom ForceField Effect

This sample includes a function that will replace the default ForceField particle effect with an effect using ParticleEmitters that can be modified by the developer.
```lua
local Debris = game:GetService("Debris")

local function createCustomForcefield(player, duration)
	local character = player.Character
	if character then
		local humanoid = character:FindFirstChild("Humanoid")
		if humanoid then
			-- find the torso
			local torsoName = humanoid.RigType == Enum.HumanoidRigType.R15 and "UpperTorso" or "Torso"
			local torso = character:FindFirstChild(torsoName)
			if torso then
				-- create a forcefield
				local forceField = Instance.new("ForceField")
				forceField.Visible = false -- not visible
				-- create a particle effect
				local particleEmitter = Instance.new("ParticleEmitter")
				particleEmitter.Enabled = true 
				particleEmitter.Parent = torso
				-- listen for the forcefield being removed
				forceField.AncestryChanged:Connect(function(child, parent)
					if not parent then
						if particleEmitter and particleEmitter.Parent then
							particleEmitter:Destroy()
						end	
					end
				end)
				-- parent the forcefield and set it to expire
				forceField.Parent = character
				if duration then
					Debris:AddItem(forceField, duration)
				end
			end
		end
	end
end
```
 */
	Visible: boolean;
}

/** A service which is used to send, cancel, accept and decline friend requests in-game. It is primarily used by the PlayerListScript to send friend requests with the leaderboard. */
interface FriendService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FriendService";
}

/** Deprecated. Use TestService instead */
interface FunctionalTest extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FunctionalTest";
	/** The description of the FunctionalTest. */
	Description: string;
	/** [LACKS DOCUMENTATION] */
	Error(message?: string): void;
	/** Prints a red message to the output, prefixed by *"TestService: "*. */
	Failed(message?: string): void;
	/** [LACKS DOCUMENTATION] */
	Pass(message?: string): void;
	/** [LACKS DOCUMENTATION] */
	Passed(message?: string): void;
	/** Prints if a condition is true, otherwise prints a warning.

## Code Samples

### FunctionalTest:Warn1

This code would print Warning: this action is invalid to the output, in yellow text.
```lua
game:GetService('TestService'):Warn(false, "this action is invalid")

```
 */
	Warn(message?: string): void;
}

/** The GamePassService is a service that supports legacy game passes using  *Asset IDs*. `MarketplaceService` should be used for all new game passes.

For more information about game passes, please see [this article][1].

## Legacy Game Passes

Historically, game passes on Roblox had an *Asset ID* associated with them. Although game passes created with an *Asset ID* still have an *Asset ID*, they now also have a *Game Pass ID*. All new game passes created today **only** have a *Game Pass ID*.

You can retrieve the *Game Pass ID* of any pass through its URL, for example the *Game Pass ID* of the below pass is 1:

```lua
https://www.roblox.com/game-pass/1/myGamePass
```


Whether you are using an *Asset ID* or a *Game Pass ID* determines which API members you can use. 

|  | Works with _Asset ID_ (Legacy) | Works with _Game Pass ID_ (Current) |
| Verify Ownership | [GamePassService:PlayerHasPass](https://developer.roblox.com/api-reference/function/GamePassService/PlayerHasPass) | [MarketplaceService:UserOwnsGamePassAsync](https://developer.roblox.com/api-reference/function/MarketplaceService/UserOwnsGamePassAsync) |
| Prompt a purchase | [MarketplaceService:PromptPurchase](https://developer.roblox.com/api-reference/function/MarketplaceService/PromptPurchase) | [MarketplaceService:PromptGamePassPurchase](https://developer.roblox.com/api-reference/function/MarketplaceService/PromptGamePassPurchase) |
| Prompted purchase finished | [MarketplaceService.PromptPurchaseFinished](https://developer.roblox.com/api-reference/event/MarketplaceService/PromptPurchaseFinished) | [MarketplaceService.PromptGamePassPurchaseFinished](https://developer.roblox.com/api-reference/event/MarketplaceService/PromptGamePassPurchaseFinished) |


API members that work with *Asset IDs* **will not** work with new game passes as they do not have them.

 [1]: /articles/Game-Passes-One-Time-Purchases */
interface GamePassService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GamePassService";
}

/** Various miscellaneous options for in-game. Can be accessed from Roblox Studio's settings menu under the _Game_
 tab. */
interface GameSettings extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GameSettings";
	/** Used internally by Roblox to add additional CoreScript loading directories.
The value of this string should be full paths to each directory, separated only by semicolons (`;`) */
	AdditionalCoreIncludeDirs: string;
	/** When a bubble of the official bubblechat appears, this property determines after how much seconds it should disappear automaticly. */
	BubbleChatLifetime: number;
	/** Max amounts of chat bubbles that may appear above one player's head. */
	BubbleChatMaxBubbles: number;
	/** The maximum number of chats that can be shown in the chat history. Does not seem to work because the chat gui's code does not read from here. */
	ChatHistory: number;
	/** The maximum number of chats that can stack and show on the screen. Does not seem to work because the chat gui's code does not read from here. */
	ChatScrollLength: number;
	/** Toggles whether or not Roblox should use the Hardware Mouse or the Software Mouse. */
	HardwareMouse: boolean;
	/** Describes a path to a .lua file that will be ran in place of the default StarterScript. */
	OverrideStarterScript: string;
	/** Sets how many of the latest chat messages should be included in an abuse report request. */
	ReportAbuseChatHistory: number;
	/** **(OBSOLETE)** */
	SoftwareSound: boolean;
	/** Toggles whether or not video capture is enabled. */
	VideoCaptureEnabled: boolean;
	/** Sets the quality level of Roblox's built-in video capture. */
	VideoQuality: Enum.VideoQualitySettings;
}

/** The GamepadService is internally responsible for handling inputs from various controllers (such as an Xbox One controller) */
interface GamepadService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GamepadService";
}

/** An ancient internal Roblox service, which appears to be responsible for all raw geometry shown in the game. */
interface Geometry extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Geometry";
}

interface RbxInternalGlobalDataStore extends RbxInternalInstance {
	/** This function sets **callback** as the function to be executed any time the value associated with the `data store's` key changes. For instance, the connected function will execute when functions like `IncrementAsync()`, `SetAsync()`, and `UpdateAsync()` change the key's value in the data store.

See the `Data Data Stores` article for an in-depth guide on data structure, management, error handling, etc.

It's recommended that you **disconnect** the connection when the subscription to the key is no longer needed.

## Code Samples

### Print Data Store Value on Update

The sample creates an `OnUpdate()` connection with the key `myKey` and the `printOut()` function, then it sets the `myKey` store to 11. Since the connection with `myKey` is open, `printOut()` executes and prints the input (the updated value). Immediately after this occurs, the script disconnects the connection.
```lua
local sampleDataStore = game:GetService("DataStoreService"):GetDataStore("MyDataStore")

local connection

local function printOut(input)
	print(input)
	-- Disconnect connection
	connection:Disconnect()
end
 
connection = sampleDataStore:OnUpdate("myKey", printOut)

local success, err = pcall(function()
	sampleDataStore:SetAsync("myKey", 11)
end)
```

@param key The key identifying the entry being retrieved from the data store
@param callback The function to be executed any time the value associated with **key** is changed
@returns The connection to the key being tracked for updates */
	OnUpdate<T = unknown>(key: string, callback: (value: T) => void): RBXScriptConnection;
	/** This function returns the value of the entry in the `GlobalDataStore` with the given key. If the key does not exist, returns `nil`. This function caches for about 4 seconds, so you cannot be sure that it returns the current value saved on the Roblox servers.

If this function throws an error, the `Datastore error message` will describe the problem. Note that there are also `Datastore limits` that apply to this function.

To save a data store entry, you can use one of several possible functions, including `SetAsync()`, `UpdateAsync()`, and `IncrementAsync()`.

## Code Samples

### Data Store to Leaderboard

This code sample retrieves a player's saved gold from a data store and puts the returned value onto the leaderboard. Note that this sample does not save players' gold&nbsp;&mdash; it only loads it.
```lua
local Players = game:GetService("Players")
local goldDataStore = game:GetService("DataStoreService"):GetDataStore("Gold") 

local STARTING_GOLD = 100

local function onPlayerAdded(player)
	local playerKey = "Player_" .. player.UserId

	local leaderstats = Instance.new("IntValue")
	leaderstats.Name = "leaderstats"

	local gold = Instance.new("IntValue", leaderstats)
	gold.Name = "Gold"

	local myGold
	local success, err = pcall(function()
		myGold = goldDataStore:GetAsync(playerKey)
	end)
	if success then
		gold.Value = myGold
	else
		gold.Value = STARTING_GOLD
	end

	leaderstats.Parent = player
end

for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)
```

@param key The key identifying the entry being retrieved from the data store
@returns The value of the entry in the data store with the given key */
	GetAsync<T = unknown>(key: string): T | undefined;
	/** Increments the value for a particular key and returns the incremented value. Only works on values that are integers. Note that you can use `OnUpdate()` to execute a function every time the database updates the key's value, such as after calling this function.

If this function throws an error, the `Datastore error message` will describe the problem. Note that there are also `Datastore limits` that apply to this function.

See the `Data Data Stores` article for an in-depth guide on data structure, management, error handling, etc.

## Code Samples

### Increment Data Store

This example uses a data store to increase the value of a key, reflecting how many times a player has visited your game. Because `IncrementAsync()` returns the incremented value, you can reward the player based on how many times they've visited.
```lua
local visitsDataStore = game:GetService("DataStoreService"):GetDataStore("PlayerVisits")

game.Players.PlayerAdded:Connect(function(player)
	local playerKey = "Player_" .. player.UserId

	local visits
	local success, err = pcall(function()
		visits = visitsDataStore:IncrementAsync(playerKey, 1)
	end)

	if success and visits == 10 then
		-- Reward player for visiting ten times
	end
end)
```

@param key The key identifying the entry being retrieved from the data store
@param delta The increment amount
@returns The value of the entry in the data store with the given key */
	IncrementAsync(key: string, delta?: number): number;
	/** This function removes the given key from the provided `GlobalDataStore` and returns the value that was associated with that key. If the key is not found in the data store, this function returns `nil`.

If this function throws an error, the `Datastore error message` will describe the problem. Note that there are also `Datastore limits` that apply to this function.

See the `Data Data Stores` article for an in-depth guide on data structure, management, error handling, etc.

## Code Samples

### Remove Player Data Store

This example removes a player's data store when they leave the game and prints its value at the time of removal.
```lua
local sampleDataStore = game:GetService("DataStoreService"):GetDataStore("MyDataStore")

game.Players.PlayerRemoving:Connect(function(player)
	local playerKey = "Player_" .. player.UserId

	local success, val = pcall(function()
		return sampleDataStore:RemoveAsync(playerKey)
	end)

	if success then
		print(val)
	end
end)
```

@param key The key identifying the entry being retrieved from the data store
@returns The value that was associated with the data store key, or `nil` if the key was not found */
	RemoveAsync<T = unknown>(key: string): T | undefined;
	/** Sets the value of the key. This overwrites any existing data stored in the key.

If the previous value of the key is important, use `UpdateAsync()` instead. Using `GetAsync()` to retrieve a value and then setting the key with `SetAsync()` is risky because `GetAsync()` sometimes returns cached data and other game servers may have modified the key.

Any string being stored in a data store must be valid `Lua utf8|UTF-8`. In UTF-8, values greater than 127 are used exclusively for encoding multi-byte codepoints, so a single byte greater than 127 will not be valid UTF-8 and the `SetAsync()` attempt will fail.


If this function throws an error, the `Datastore error message` will describe the problem. Note that there are also `Datastore limits` that apply to this function.

See the `Data Data Stores` article for an in-depth guide on data structure, management, error handling, etc.

## Code Samples

### Reset Player Data Store

The following example is how you would generally use `SetAsync()`. However, if more than one server will likely be writing to this key, it's recommended that you use `UpdateAsync()` instead.
```lua
local visitsDataStore = game:GetService("DataStoreService"):GetDataStore("PlayerVisits")

game.Players.PlayerAdded:Connect(function(player)
	local playerKey = "Player_" .. player.UserId
	local success, err = pcall(function()
		visitsDataStore:SetAsync(playerKey, 0)
	end)
end)
```

@param key The key identifying the entry being retrieved from the data store
@param value The value of the entry in the data store with the given key
@returns No return */
	SetAsync(key: string, value?: any): void;
	/** This function retrieves the value of a key from a data store and updates it with a new value. Since this function validates the data, it should be used in favor of `SetAsync()` when there's a chance that more than one server can edit the same data at the same time.

The second parameter is a function which you need to provide. The function takes the key's old value as input and returns the new value, with these exceptions:

 * If the key does not exist, the old value passed to the function will be `nil`.
 * If the function returns `nil`, the update is cancelled.

The value returned by this function is the new value, returned once the altered data is properly saved.

In cases where another game server updated the key in the short timespan between retrieving the key's current value and setting the key's value, `UpdateAsync()` will call the function again to ensure that no data is overwritten. The function will be called as many times as needed until the data is saved.

The function you define as the second parameter of `UpdateAsync()` cannot yield, so do **not** include calls like `wait()`.

Any string being stored in a data store must be valid `Lua utf8|UTF-8`. In UTF-8, values greater than 127 are used exclusively for encoding multi-byte codepoints, so a single byte greater than 127 will not be valid UTF-8 and the `UpdateAsync()` attempt will fail.


If this function throws an error, the `Datastore error message` will describe the problem. Note that there are also `Datastore limits` that apply to this function.

See the `Data Data Stores` article for an in-depth guide on data structure, management, error handling, etc.

## Code Samples

### Reward Players for Visiting

The code below awards players 50 points every time they join the game by updating a data store.
```lua
local pointsDataStore = game:GetService("DataStoreService"):GetDataStore("Points")
 
game.Players.PlayerAdded:Connect(function(player)
	local playerKey = "Player_" .. player.UserId
	-- Give 50 points to players each time they visit
	local success, err = pcall(function()
		pointsDataStore:UpdateAsync(playerKey, function(oldValue)
			local newValue = oldValue or 0
			newValue = newValue + 50
			return newValue
		end)
	end)
end)
```

@param key The key identifying the entry being retrieved from the data store.
@param transformFunction A function which you need to provide. The function takes the key's old value as input and returns the new value.
@returns The value of the entry in the data store with the given key. */
	UpdateAsync<O = unknown, R = unknown>(
		key: string,
		transformFunction: (oldValue: O | undefined) => R,
	): R extends undefined ? O | undefined : R;
}
/** @server */
	/** A **GlobalDataStore** exposes functions for saving and loading data for the `DataStoreService`.

See the `Data Data Stores` article for an in-depth
 guide on data structure, management, error handling, etc.

## Code Samples

### Data Store Game Config

This code sample uses data stores to read/write/listen to a global configuration value. It uses a defensive coding style so potential data store errors will not cause issues.
```lua
local DATA_STORE_NAME = "Config"
local DATA_STORE_SCOPE = "MyGameName"
local KEY_NEW_FEATURE = "NewFeatureEnabled"

local DataStoreService = game:GetService("DataStoreService")

local dsConfig = DataStoreService:GetDataStore(DATA_STORE_NAME, DATA_STORE_SCOPE)

local function checkFeature()
	local isFeatureEnabled
	local success, err = pcall(function()
		isFeatureEnabled = dsConfig:GetAsync(KEY_NEW_FEATURE)
	end)
	if success then
		print(KEY_NEW_FEATURE .. ": " .. tostring(isFeatureEnabled))
		if isFeatureEnabled == true then
			print("Feature is enabled!")
		elseif isFeatureEnabled == false then
			print("Feature is disabled!")
		elseif isFeatureEnabled == nil then
			print("Feature is not set!")
		else
			-- Some other value was found in this key
		end
	else
		print("Failed to load feature! Error: " .. tostring(err))
	end
	return success
end

local function onFeatureChanged(isFeatureEnabled)
	print("Feature toggled: " .. tostring(isFeatureEnabled))
end

-- Listen for changes
dsConfig:OnUpdate(KEY_NEW_FEATURE, onFeatureChanged)

local function setFeatureEnabled(isFeatureEnabled)
	local success, err = pcall(function()
		dsConfig:SetAsync(KEY_NEW_FEATURE, isFeatureEnabled)
	end) 
	return success
end

setFeatureEnabled(true)
checkFeature()
```

### Individual Player Data Stores

This code sample features a simple way to work with per-player data stores called "Stats" and "Resources."
```lua
local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")

local function onPlayerAdded(player)
	local scope = "Player_" .. player.UserId
	local playerStats = DataStoreService:GetDataStore("Stats", scope)
	local playerResources = DataStoreService:GetDataStore("Resources", scope)
	-- GetAsync()/UpdateAsync() can now be called on the 'Stats' and 'Resources' data stores
end

Players.PlayerAdded:Connect(onPlayerAdded)
```
 */
type GlobalDataStore = OrderedDataStore;

/** @server */
	/** A **OrderedDataStore** is essentially a `GlobalDataStore` with the exception that stored values must be **positive integers**. It exposes a method `GetSortedAsync()` which allows inspection of the entries in sorted order using a `DataStorePages` object.

See the `Data Data Stores` article for an overview on using ordered data stores.

## Code Samples

### OrderedDataStore Basics

This code sample demonstrates usage of an `OrderedDataStore` and pages.
```lua
local DataStoreService = game:GetService("DataStoreService")
local PointsODS = DataStoreService:GetOrderedDataStore("Points") 

local function printTopTenPlayers()
	local isAscending = false
	local pageSize = 10
	local pages = PointsODS:GetSortedAsync(isAscending, pageSize)
	local topTen = pages:GetCurrentPage()

	-- The data in 'topTen' is stored with the index being the index on the page
	-- For each item, 'data.key' is the key in the OrderedDataStore and 'data.value' is the value
	for rank, data in ipairs(topTen) do
		local name = data.key
		local points = data.value
		print(data.key .. " is ranked #" .. rank .. " with " .. data.value .. "points")
	end

	-- Potentially load the next page...
	--pages:AdvanceToNextPageAsync()
end

-- Create some data
PointsODS:SetAsync("Alex", 55)
PointsODS:SetAsync("Charley", 32)
PointsODS:SetAsync("Sydney", 68)

-- Display the top ten players
printTopTenPlayers()
```
 */
interface OrderedDataStore extends RbxInternalGlobalDataStore {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "OrderedDataStore";
	/** Returns a `DataStorePages` object. The sort order is determined by **isAscending**, the length of each page by **pageSize**, and **minValue***maxValue** are optional parameters which filter the results.

If this function throws an error, the `Datastore error message` will describe the problem.
@param ascending A boolean indicating whether the returned data pages are in ascending order.
@param pagesize The length of each page.
@param minValue Optional parameter. If set, data pages with a value less than than **minValue** will be excluded.
@param maxValue Optional parameter. If set, data pages with a value greater than **maxValue** will be excluded.
@returns A sorted `DataStorePages` object based on the provided arguments. */
	GetSortedAsync(ascending: boolean, pagesize: number, minValue?: number, maxValue?: number): DataStorePages;
}

/** GoogleAnalyticsConfiguration is a settings class that stores a unique identifier for your game client.
It is used by Roblox to persistently record analytics from your game client.
It is stored inside of the `AnalysticsSettings`. */
interface GoogleAnalyticsConfiguration extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GoogleAnalyticsConfiguration";
}

/** GroupService is a service that allows developers to fetch information about a Roblox group from within a game.

Basic information on the group, including it's name, description, owner, roles and emblem can be fetched using `GetGroupInfoAsync`. Lists of a group's allies and enemies can be fetched using `GetAlliesAsync` and `GetEnemiesAsync`.

GroupService can also be used to fetch a list of group's a player is a member of, using `GetGroupsAsync`. Note, developers wishing to verify if a player is in a group should use the `Player` `IsInGroup` function rather than `GetGroupsAsync`.

The service has a number of useful applications, such as detecting if a player is an ally or enemy upon joining the game.

## Code Samples

### Group Ally/Enemy Checker

This code sample demonstrates how `GroupService` and `IsInGroup` can be used to determine whether a player is a member of a group, or any of its allies or enemies.

Note as `GetAlliesAsync` and `GetEnemiesAsync` use `StandardPages` objects a utility function is used to convert them to allies.
```lua
    local GroupService = game:GetService("GroupService")
    local Players = game:GetService("Players")
    
    -- define group id here
    local GROUP_ID = 271454
    
    -- utility function for dealing with pages
    local function pagesToArray(pages)
    	local array = {}
    	while true do
    		for k, v in pairs(pages:GetCurrentPage()) do 
    			table.insert(array, v)
    		end
    		if pages.isFinished then
    			break
    		end
    		pages:AdvanceToNextPageAsync()
    	end
    	return array
    end
    
    -- get lists of allies and enemies
    local alliesPages = GroupService:GetAlliesAsync(GROUP_ID)
    local enemiesPages = GroupService:GetEnemiesAsync(GROUP_ID)
    
    -- convert to array
    local allies = pagesToArray(alliesPages)
    local enemies = pagesToArray(enemiesPages)
    
    local function playerAdded(player)
    	-- check to see if the player is in the group
    	if player:IsInGroup(GROUP_ID) then
    		print(player.Name.." is a member!")
    	else 
    		local isAlly, isEnemy = false, false 
    
    		-- check to see if the player is in any ally groups
    		for _, groupInfo in pairs(allies) do
    			local groupId = groupInfo.Id
    			if groupInfo then
    				if player:IsInGroup(groupId) then 
    					isAlly = true
    					break
    				end
    			end
    		end
    
    		-- check to see if the player is in any enemy groups
    		for _, groupInfo in pairs(enemies) do
    			local groupId = groupInfo.Id
    			if groupInfo then
    				if player:IsInGroup(groupId) then 
    					isEnemy = true
    					break
    				end
    			end
    		end
    
    		if isAlly and not isEnemy then 
    			print(player.Name.." is an ally!")
    		elseif isEnemy and not isAlly then
    			print(player.Name.." is an enemy!")
    		elseif isEnemy and isAlly then
    			print(player.Name.." is both an ally and an enemy!")
    		else 
    			print(player.Name.." is neither an ally or an enemy!")
    		end
    	end
    end
    
    -- listen for new players being added
    Players.PlayerAdded:Connect(playerAdded)
    
    -- handle players already in game
    for _, player in pairs(Players:GetPlayers()) do
    	playerAdded(player)
    end
```
 */
interface GroupService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GroupService";
	/** Returns a `StandardPages` object including information on all of the specified group's allies.

This pages does not include a list of group IDs but instead a list of group information tables, mirroring the format of those returned by `GetGroupInfoAsync`. See below for the structure of these tables.

    group = {
        Name = "Knights of the Seventh Sanctum",
        Id = 377251,
        Owner = {
            Name = "Vilicus",
            Id = 23415609
        },
        EmblemUrl = "http://www.roblox.com/asset/?id=60428602",
        Description = "We fight alongside the balance to make sure no one becomes to powerful",
        Roles = {
            [1] = {
                Name = "Apprentice",
                Rank = 1
            },
            [2] = {
                Name = "Warrior",
                Rank = 2
            },
            [3] = {
                Name = "Earth Walker",
                Rank = 255
            }
        }
    }

Note, as this function returns a `StandardPages` object rather than an array, developers may wish to convert it to an array for ease of use (see examples).

This function has a number of useful applications, including detecting if a player is a member of an allied group.

For enemies, use `GetEnemiesAsync`.

## Code Samples

### Group Ally/Enemy Checker

This code sample demonstrates how `GroupService` and `IsInGroup` can be used to determine whether a player is a member of a group, or any of its allies or enemies.

Note as `GetAlliesAsync` and `GetEnemiesAsync` use `StandardPages` objects a utility function is used to convert them to allies.
```lua
    local GroupService = game:GetService("GroupService")
    local Players = game:GetService("Players")
    
    -- define group id here
    local GROUP_ID = 271454
    
    -- utility function for dealing with pages
    local function pagesToArray(pages)
    	local array = {}
    	while true do
    		for k, v in pairs(pages:GetCurrentPage()) do 
    			table.insert(array, v)
    		end
    		if pages.isFinished then
    			break
    		end
    		pages:AdvanceToNextPageAsync()
    	end
    	return array
    end
    
    -- get lists of allies and enemies
    local alliesPages = GroupService:GetAlliesAsync(GROUP_ID)
    local enemiesPages = GroupService:GetEnemiesAsync(GROUP_ID)
    
    -- convert to array
    local allies = pagesToArray(alliesPages)
    local enemies = pagesToArray(enemiesPages)
    
    local function playerAdded(player)
    	-- check to see if the player is in the group
    	if player:IsInGroup(GROUP_ID) then
    		print(player.Name.." is a member!")
    	else 
    		local isAlly, isEnemy = false, false 
    
    		-- check to see if the player is in any ally groups
    		for _, groupInfo in pairs(allies) do
    			local groupId = groupInfo.Id
    			if groupInfo then
    				if player:IsInGroup(groupId) then 
    					isAlly = true
    					break
    				end
    			end
    		end
    
    		-- check to see if the player is in any enemy groups
    		for _, groupInfo in pairs(enemies) do
    			local groupId = groupInfo.Id
    			if groupInfo then
    				if player:IsInGroup(groupId) then 
    					isEnemy = true
    					break
    				end
    			end
    		end
    
    		if isAlly and not isEnemy then 
    			print(player.Name.." is an ally!")
    		elseif isEnemy and not isAlly then
    			print(player.Name.." is an enemy!")
    		elseif isEnemy and isAlly then
    			print(player.Name.." is both an ally and an enemy!")
    		else 
    			print(player.Name.." is neither an ally or an enemy!")
    		end
    	end
    end
    
    -- listen for new players being added
    Players.PlayerAdded:Connect(playerAdded)
    
    -- handle players already in game
    for _, player in pairs(Players:GetPlayers()) do
    	playerAdded(player)
    end
```

### GroupService:GetAlliesAsync


```lua
local Players = Game:GetService("Players")

--creates a table of all of the allies of a given group
local allies = {}
local groupID = 57

local pages = game:GetService("GroupService"):GetAlliesAsync(groupID)
while true do
   for _,group in pairs(pages:GetCurrentPage()) do
      table.insert(allies, group)
   end
   if pages.IsFinished then
      break
   end
   pages:AdvanceToNextPageAsync()
end

function OnPlayerAdded(player)
   for _,group in pairs(allies) do
      if player:IsInGroup(group.Id) then
         print("Player is an ally!")
      end
   end
end

Players.PlayerAdded:Connect(OnPlayerAdded)
--handle players who joined while the allies list was still loading
for _,player in pairs(Players:GetPlayers()) do
   OnPlayerAdded(player)
end
```

@param groupId The group's ID.
@returns A `StandardPages` object of the group's allies. */
	GetAlliesAsync(groupId: number): StandardPages;
	/** Returns a `StandardPages` object including information on all of the specified group's enemies.

This pages does not include a list of group IDs but instead a list of group information tables, mirroring the format of those returned by `GetGroupInfoAsync`. See below for the structure of these tables.

    group = {
        Name = "Knights of the Seventh Sanctum",
        Id = 377251,
        Owner = {
            Name = "Vilicus",
            Id = 23415609
        },
        EmblemUrl = "http://www.roblox.com/asset/?id=60428602",
        Description = "We fight alongside the balance to make sure no one becomes to powerful",
        Roles = {
            [1] = {
                Name = "Apprentice",
                Rank = 1
            },
            [2] = {
                Name = "Warrior",
                Rank = 2
            },
            [3] = {
                Name = "Earth Walker",
                Rank = 255
            }
        }
    }

Note, as this function returns a `StandardPages` object rather than an array, developers may wish to convert it to an array for ease of use (see examples).

This function has a number of useful applications, including detecting if a player is a member of an enemy group.

For allies, use `GetAlliesAsync`.

## Code Samples

### Group Ally/Enemy Checker

This code sample demonstrates how `GroupService` and `IsInGroup` can be used to determine whether a player is a member of a group, or any of its allies or enemies.

Note as `GetAlliesAsync` and `GetEnemiesAsync` use `StandardPages` objects a utility function is used to convert them to allies.
```lua
    local GroupService = game:GetService("GroupService")
    local Players = game:GetService("Players")
    
    -- define group id here
    local GROUP_ID = 271454
    
    -- utility function for dealing with pages
    local function pagesToArray(pages)
    	local array = {}
    	while true do
    		for k, v in pairs(pages:GetCurrentPage()) do 
    			table.insert(array, v)
    		end
    		if pages.isFinished then
    			break
    		end
    		pages:AdvanceToNextPageAsync()
    	end
    	return array
    end
    
    -- get lists of allies and enemies
    local alliesPages = GroupService:GetAlliesAsync(GROUP_ID)
    local enemiesPages = GroupService:GetEnemiesAsync(GROUP_ID)
    
    -- convert to array
    local allies = pagesToArray(alliesPages)
    local enemies = pagesToArray(enemiesPages)
    
    local function playerAdded(player)
    	-- check to see if the player is in the group
    	if player:IsInGroup(GROUP_ID) then
    		print(player.Name.." is a member!")
    	else 
    		local isAlly, isEnemy = false, false 
    
    		-- check to see if the player is in any ally groups
    		for _, groupInfo in pairs(allies) do
    			local groupId = groupInfo.Id
    			if groupInfo then
    				if player:IsInGroup(groupId) then 
    					isAlly = true
    					break
    				end
    			end
    		end
    
    		-- check to see if the player is in any enemy groups
    		for _, groupInfo in pairs(enemies) do
    			local groupId = groupInfo.Id
    			if groupInfo then
    				if player:IsInGroup(groupId) then 
    					isEnemy = true
    					break
    				end
    			end
    		end
    
    		if isAlly and not isEnemy then 
    			print(player.Name.." is an ally!")
    		elseif isEnemy and not isAlly then
    			print(player.Name.." is an enemy!")
    		elseif isEnemy and isAlly then
    			print(player.Name.." is both an ally and an enemy!")
    		else 
    			print(player.Name.." is neither an ally or an enemy!")
    		end
    	end
    end
    
    -- listen for new players being added
    Players.PlayerAdded:Connect(playerAdded)
    
    -- handle players already in game
    for _, player in pairs(Players:GetPlayers()) do
    	playerAdded(player)
    end
```

### GroupService:GetEnemiesAsync


```lua
-- creates a list of all of the enemies of a given group
local enemies = {}
local groupId = 57

local pages = game:GetService("GroupService"):GetEnemiesAsync(groupId)
while true do
   for _, group in pairs(pages:GetCurrentPage()) do
      table.insert(enemies, group)
   end
   if pages.IsFinished then
      break
   end
   pages:AdvanceToNextPageAsync()
end

function onPlayerAdded(player)
   for _, enemyGroup in pairs(enemies) do
      if player:IsInGroup(enemyGroup.Id) then
          print("Player is an enemy!")
          break
       end
    end
end

game.Players.PlayerAdded:Connect(onPlayerAdded)
-- handle players who joined while the enemies list was still loading
for _,player in pairs(game.Players:GetPlayers()) do
   onPlayerAdded(player)
end
```

@param groupId The group's ID.
@returns A `StandardPages` object of the group's enemies. */
	GetEnemiesAsync(groupId: number): StandardPages;
	/** Returns a table containing information about the given group.

The table returned is the same format as that returned in `GetAlliesAsync` and `GetEnemiesAsync`. This format can be seen below.

    group = {
        Name = "Knights of the Seventh Sanctum",
        Id = 377251,
        Owner = {
            Name = "Vilicus",
            Id = 23415609
        },
        EmblemUrl = "http://www.roblox.com/asset/?id=60428602",
        Description = "We fight alongside the balance to make sure no one becomes to powerful",
        Roles = {
            [1] = {
                Name = "Apprentice",
                Rank = 1
            },
            [2] = {
                Name = "Warrior",
                Rank = 2
            },
            [3] = {
                Name = "Earth Walker",
                Rank = 255
            }
        }
    }

Note, if a group has no owner the Owner field will be set to nil.

This function has a number of useful applications, including loading the latest description and logo of a group for display in a group base.

## Code Samples

### GroupService:GetGroupInfoAsync


```lua
local groupId = 377251
local group = game:GetService("GroupService"):GetGroupInfoAsync(groupId)

print(group.Name .. " has the following roles:")
for _, role in ipairs(group.Roles) do
   print("Rank " .. role.Rank .. ": " .. role.Name)
end
```

### Load Group Emblem

The code in this sample spawns a `Part` in the Workspace that includes a texture of the given group's emblem.
```lua
    local GroupService = game:GetService("GroupService")
    
    -- function to load a group's emblem
    local function getEmblemAsync(groupId)
    	local groupInfo = GroupService:GetGroupInfoAsync(groupId)
    	return groupInfo.EmblemUrl
    end
    
    -- create a part and decal to show the emblem
    local part = Instance.new("Part")
    part.Anchored = true
    part.CanCollide = false 
    part.Size = Vector3.new(5, 5, 1)
    part.Position = Vector3.new(0, 5, 0)
    local decal = Instance.new("Decal", part)
    
    -- parent the part to the workspace
    part.Parent = workspace
    
    -- set the texture
    decal.Texture = getEmblemAsync(377251)
```

@param groupId The group ID of the group.
@returns A dictionary of information about the group. */
	GetGroupInfoAsync(groupId: number): GroupInfo;
	/** This function returns a list of tables containing information on all of the groups a given `Player` is a member of. 

The list returned will include an entry for every group the player is a member of. These entries are tables with the following fields.

| Name | Description |
| --- | --- |
| Name The group's name |
| Id The group ID |
| EmblemUrl An asset url linking to the group's thumbnail (for example: http://www.roblox.com/asset/?id=276165514) |
| EmblemId The assetId of the emblem, the same which is used in the EmblemUrl |
| Rank The rankId the player has (for example: 255 for the owner) |
| Role The name of the player's grouprank (for example: Group Owner) |
| IsPrimary A boolean indicating if this is the player's primary group |
| IsInClan | A boolean indicating if the player is in this group's clan |


Note unlike `GetAlliesAsync` and `GetEnemiesAsync`, GetGroupsAsync returns a table rather than a `StandardPages` object.

## Code Samples

### Getting the Groups that a User is A Member Of

This code sample will print information on all of the groups a player is a member of when they join the game, using `GetGroupsAsync`.
```lua
    local GroupService = game:GetService("GroupService")
    local Players = game:GetService("Players")
    
    local function playerAdded(player)
    	-- load a list of info on all groups the player is a member of
    	local groups = GroupService:GetGroupsAsync(player.UserId)
    	
    	-- go through this list
    	for _, groupInfo in pairs(groups) do
    
    		-- print all of the entries
    		for key, value in pairs(groupInfo) do 
    			print(key..": "..tostring(value))
    		end
    
    		-- print a divider
    		print("--")
    	end
    end
    
    -- listen for new players
    Players.PlayerAdded:Connect(playerAdded)
    
    -- go through existing players
    for _, player in pairs(Players:GetPlayers()) do
    	playerAdded(player)
    end
```

@param userId The `Player/UserId` of the user
@returns An array of dictionaries containing information on the group's the `Player` is a member of */
	GetGroupsAsync(userId: number): Array<GetGroupsAsyncResult>;
}

interface RbxInternalGuiBase extends RbxInternalInstance {}
/** GuiBase is an abstract class which most graphical user interface objects inherit from. */
type GuiBase = GuiBase2d | GuiBase3d;

interface RbxInternalGuiBase2d extends RbxInternalGuiBase {
	/** AbsolutePosition is a read-only property that provides the screen position of a UI element in pixels. This represents the actual pixel position at which an element renders as a result of its ancestors' sizes and positions. The `AnchorPoint` also influences the AbsolutePosition. This property, `AbsoluteSize` and `AbsoluteRotation` are a group of properties that all describe the final rendered orientation of a UI element.

For example, on a 1920 by 1080 screen, a `Frame` with position {0.5, 0}, {0.5, 0} would have an AbsolutePosition of (960, 540). If you were to place another Frame with position {0, 50}, {0, 50} inside that one, its AbsolutePosition would be (1010, 590). This example assumes each Frame has the defualt `AnchorPoint` of (0, 0), the top left corner.

## Code Samples

### Copycat Frame

This code sample shows how a UI element's size, position and rotation can be copied without parenting a "copycat" to the original. It uses the Absolute-family of properties to orient a "copycat" Frame that covers on the screen space that the original does.
```lua
-- Place within a Frame, TextLabel, etc.
local guiObject = script.Parent

-- For this object to be rendered, it must be a descendant of a ScreenGui
local screenGui = guiObject:FindFirstAncestorOfClass("ScreenGui")

-- Create a copy
local copycat = Instance.new("Frame")
copycat.BackgroundTransparency = 0.5
copycat.BackgroundColor3 = Color3.new(.5, .5, 1) -- Light blue
copycat.BorderColor3 = Color3.new(1, 1, 1) -- White

-- Orient the copy just as the original; do so "absolutely"
copycat.AnchorPoint = Vector2.new(0, 0) 
copycat.Position = UDim2.new(0, guiObject.AbsolutePosition.X, 0, guiObject.AbsolutePosition.Y)
copycat.Size = UDim2.new(0, guiObject.AbsoluteSize.X, 0, guiObject.AbsoluteSize.Y)
copycat.Rotation = guiObject.AbsoluteRotation

-- Insert into ancestor ScreenGui
copycat.Parent = screenGui

```
AbsolutePosition is a read-only property that provides the screen position of a UI element in pixels. This represents the actual pixel position at which an element renders as a result of its ancestors' sizes and positions. The `AnchorPoint` also influences the AbsolutePosition. This property, `AbsoluteSize` and `AbsoluteRotation` are a group of properties that all describe the final rendered orientation of a UI element.

For example, on a 1920 by 1080 screen, a `Frame` with position {0.5, 0}, {0.5, 0} would have an AbsolutePosition of (960, 540). If you were to place another Frame with position {0, 50}, {0, 50} inside that one, its AbsolutePosition would be (1010, 590). This example assumes each Frame has the defualt `AnchorPoint` of (0, 0), the top left corner.

## Code Samples

### Copycat Frame

This code sample shows how a UI element's size, position and rotation can be copied without parenting a "copycat" to the original. It uses the Absolute-family of properties to orient a "copycat" Frame that covers on the screen space that the original does.
```lua
-- Place within a Frame, TextLabel, etc.
local guiObject = script.Parent

-- For this object to be rendered, it must be a descendant of a ScreenGui
local screenGui = guiObject:FindFirstAncestorOfClass("ScreenGui")

-- Create a copy
local copycat = Instance.new("Frame")
copycat.BackgroundTransparency = 0.5
copycat.BackgroundColor3 = Color3.new(.5, .5, 1) -- Light blue
copycat.BorderColor3 = Color3.new(1, 1, 1) -- White

-- Orient the copy just as the original; do so "absolutely"
copycat.AnchorPoint = Vector2.new(0, 0) 
copycat.Position = UDim2.new(0, guiObject.AbsolutePosition.X, 0, guiObject.AbsolutePosition.Y)
copycat.Size = UDim2.new(0, guiObject.AbsoluteSize.X, 0, guiObject.AbsoluteSize.Y)
copycat.Rotation = guiObject.AbsoluteRotation

-- Insert into ancestor ScreenGui
copycat.Parent = screenGui

```


Tags: ReadOnly, NotReplicated */
	readonly AbsolutePosition: Vector2;
	/** AbsoluteRotation is a read-only property that describes the actual screen rotation of a UI element, in degrees. This property, `AbsoluteSize` and `AbsolutePosition` are a group of properties that all describe the final rendered orientation of a UI element. It composes (sums) each of the UI element's ancestors' `Rotation` into one value. It does **not** perform bounds checking, so its value may not be in the range 0 ≤ x &lt; 360 degrees.

For example, if FrameA has a rotation of 40 degrees, and FrameB within it has a `Rotation` of 50 degrees, then FrameB's AbsoluteRotation would be 90 degrees.

## Code Samples

### Copycat Frame

This code sample shows how a UI element's size, position and rotation can be copied without parenting a "copycat" to the original. It uses the Absolute-family of properties to orient a "copycat" Frame that covers on the screen space that the original does.
```lua
-- Place within a Frame, TextLabel, etc.
local guiObject = script.Parent

-- For this object to be rendered, it must be a descendant of a ScreenGui
local screenGui = guiObject:FindFirstAncestorOfClass("ScreenGui")

-- Create a copy
local copycat = Instance.new("Frame")
copycat.BackgroundTransparency = 0.5
copycat.BackgroundColor3 = Color3.new(.5, .5, 1) -- Light blue
copycat.BorderColor3 = Color3.new(1, 1, 1) -- White

-- Orient the copy just as the original; do so "absolutely"
copycat.AnchorPoint = Vector2.new(0, 0) 
copycat.Position = UDim2.new(0, guiObject.AbsolutePosition.X, 0, guiObject.AbsolutePosition.Y)
copycat.Size = UDim2.new(0, guiObject.AbsoluteSize.X, 0, guiObject.AbsoluteSize.Y)
copycat.Rotation = guiObject.AbsoluteRotation

-- Insert into ancestor ScreenGui
copycat.Parent = screenGui

```
AbsoluteRotation is a read-only property that describes the actual screen rotation of a UI element, in degrees. This property, `AbsoluteSize` and `AbsolutePosition` are a group of properties that all describe the final rendered orientation of a UI element. It composes (sums) each of the UI element's ancestors' `Rotation` into one value. It does **not** perform bounds checking, so its value may not be in the range 0 ≤ x &lt; 360 degrees.

For example, if FrameA has a rotation of 40 degrees, and FrameB within it has a `Rotation` of 50 degrees, then FrameB's AbsoluteRotation would be 90 degrees.

## Code Samples

### Copycat Frame

This code sample shows how a UI element's size, position and rotation can be copied without parenting a "copycat" to the original. It uses the Absolute-family of properties to orient a "copycat" Frame that covers on the screen space that the original does.
```lua
-- Place within a Frame, TextLabel, etc.
local guiObject = script.Parent

-- For this object to be rendered, it must be a descendant of a ScreenGui
local screenGui = guiObject:FindFirstAncestorOfClass("ScreenGui")

-- Create a copy
local copycat = Instance.new("Frame")
copycat.BackgroundTransparency = 0.5
copycat.BackgroundColor3 = Color3.new(.5, .5, 1) -- Light blue
copycat.BorderColor3 = Color3.new(1, 1, 1) -- White

-- Orient the copy just as the original; do so "absolutely"
copycat.AnchorPoint = Vector2.new(0, 0) 
copycat.Position = UDim2.new(0, guiObject.AbsolutePosition.X, 0, guiObject.AbsolutePosition.Y)
copycat.Size = UDim2.new(0, guiObject.AbsoluteSize.X, 0, guiObject.AbsoluteSize.Y)
copycat.Rotation = guiObject.AbsoluteRotation

-- Insert into ancestor ScreenGui
copycat.Parent = screenGui

```


Tags: ReadOnly, NotReplicated */
	readonly AbsoluteRotation: number;
	/** AbsoluteSize is a read-only property that provides the screen size of a UI element in pixels. This represents the actual pixel size at which an element renders as a result of its ancestors' sizes. This property, `AbsolutePosition` and `AbsoluteRotation` are a group of properties that all describe the final rendered orientation of a UI element.

For example, on a 1920 by 1080 screen, if FrameA exists within FrameB, and they both have a Size of {.5, 0}, {.5, 0}, then the AbsoluteSize of FrameA (the inner frame) would be (490, 270) as the `Size` property determines the size of a child UI element relative to its parent. Both of the frames are set to 50% of the parent size. Since 50% of 50% is 25%, and 25% of our screen size, 1920 by 1080, is (490, 270), this would be the resultant AbsoluteSize of the inner frame.

## Code Samples

### Copycat Frame

This code sample shows how a UI element's size, position and rotation can be copied without parenting a "copycat" to the original. It uses the Absolute-family of properties to orient a "copycat" Frame that covers on the screen space that the original does.
```lua
-- Place within a Frame, TextLabel, etc.
local guiObject = script.Parent

-- For this object to be rendered, it must be a descendant of a ScreenGui
local screenGui = guiObject:FindFirstAncestorOfClass("ScreenGui")

-- Create a copy
local copycat = Instance.new("Frame")
copycat.BackgroundTransparency = 0.5
copycat.BackgroundColor3 = Color3.new(.5, .5, 1) -- Light blue
copycat.BorderColor3 = Color3.new(1, 1, 1) -- White

-- Orient the copy just as the original; do so "absolutely"
copycat.AnchorPoint = Vector2.new(0, 0) 
copycat.Position = UDim2.new(0, guiObject.AbsolutePosition.X, 0, guiObject.AbsolutePosition.Y)
copycat.Size = UDim2.new(0, guiObject.AbsoluteSize.X, 0, guiObject.AbsoluteSize.Y)
copycat.Rotation = guiObject.AbsoluteRotation

-- Insert into ancestor ScreenGui
copycat.Parent = screenGui

```
AbsoluteSize is a read-only property that provides the screen size of a UI element in pixels. This represents the actual pixel size at which an element renders as a result of its ancestors' sizes. This property, `AbsolutePosition` and `AbsoluteRotation` are a group of properties that all describe the final rendered orientation of a UI element.

For example, on a 1920 by 1080 screen, if FrameA exists within FrameB, and they both have a Size of {.5, 0}, {.5, 0}, then the AbsoluteSize of FrameA (the inner frame) would be (490, 270) as the `Size` property determines the size of a child UI element relative to its parent. Both of the frames are set to 50% of the parent size. Since 50% of 50% is 25%, and 25% of our screen size, 1920 by 1080, is (490, 270), this would be the resultant AbsoluteSize of the inner frame.

## Code Samples

### Copycat Frame

This code sample shows how a UI element's size, position and rotation can be copied without parenting a "copycat" to the original. It uses the Absolute-family of properties to orient a "copycat" Frame that covers on the screen space that the original does.
```lua
-- Place within a Frame, TextLabel, etc.
local guiObject = script.Parent

-- For this object to be rendered, it must be a descendant of a ScreenGui
local screenGui = guiObject:FindFirstAncestorOfClass("ScreenGui")

-- Create a copy
local copycat = Instance.new("Frame")
copycat.BackgroundTransparency = 0.5
copycat.BackgroundColor3 = Color3.new(.5, .5, 1) -- Light blue
copycat.BorderColor3 = Color3.new(1, 1, 1) -- White

-- Orient the copy just as the original; do so "absolutely"
copycat.AnchorPoint = Vector2.new(0, 0) 
copycat.Position = UDim2.new(0, guiObject.AbsolutePosition.X, 0, guiObject.AbsolutePosition.Y)
copycat.Size = UDim2.new(0, guiObject.AbsoluteSize.X, 0, guiObject.AbsoluteSize.Y)
copycat.Rotation = guiObject.AbsoluteRotation

-- Insert into ancestor ScreenGui
copycat.Parent = screenGui

```


Tags: ReadOnly, NotReplicated */
	readonly AbsoluteSize: Vector2;
	/** When set to true, localization will be applied to this GuiBase2d and its descendants based on the `RootLocalizationTable` specified for this GuiBase2d. */
	AutoLocalize: boolean;
	/** A reference to a `LocalizationTable` to be used to apply automated localization to this GuiBase2d and its descendants.


The `AutoLocalize` property must be set to true on this object and its ancestors for automated localization to be applied.

You can set this to reference a LocalizationTable anywhere in the DataModel. It is not required to be a child of LocalizationService.

When RootLocalizationTable is set on a GUI object then that object and all of its children will use that specific LocalizationTable and its parents for automatic text replacement, instead of using the tables under LocalizationService in an undefined order.

If there is no translation available in the referenced table it will look for a translation in the parent of that table, if it is also a LocalizationTable, and so on. */
	RootLocalizationTable?: LocalizationTable;
}
/** GuiBase2d is an abstract class inherited by 2D GUI Objects. */
type GuiBase2d = GuiObject | LayerCollector;

interface RbxInternalGuiObject extends RbxInternalGuiBase2d {
	/** This property determines whether a `GuiObject` will sink input to 3D space, such as underlying models with a `ClickDetector`. In other words, if the player attempts to click a ClickDetector with the mouse hovering over an Active UI element, the UI will block the input from reaching the ClickDetector.

For `GuiButton` objects (`ImageButton` and `TextButton`), this property determines whether `Activated` fires (`AutoButtonColor` will still work for those as well). The events `InputBegan`, `InputChanged`, and `InputEnded` work as normal no matter the value of this property.

## Code Samples

### TextButton Active Debounce

This code sample demonstrates the usage of the Active property as a debounce for the Activated event.
```lua
-- Place this LocalScript within a TextButton (or ImageButton)
local textButton = script.Parent

-- Initialize the state of the button
textButton.Text = "Click me"
textButton.Active = true

local function onActivated()
	-- Prevent future Activations
	-- This acts like a debounce
	textButton.Active = false

	-- Count backwards from 5
	for i = 5, 1, -1 do
		textButton.Text = "Time: " .. i
		wait(1)
	end
	textButton.Text = "Click me"
	
	-- Allow activations again
	textButton.Active = true
end

textButton.Activated:Connect(onActivated)

```
 */
	Active: boolean;
	/** This property determines a `GUI`, which is relative to its absolute size. The origin point determines from where the element is positioned (through `Position`) and from which the rendered `Size` expands.

A good rule of thumb for this property: if the GUI in question is aligned to the left, the X value should be 0. If horizontally centered, set to 0.5. Finally, if the element is aligned to the right, the X value ought to be 1. Similarly, set the Y value to 0, 0.5, and 1 for top, middle, and bottom for Y alignment.

To understand how AnchorPoint works, try creating a `Frame` with `Position` set to `UDim2.new(0.5, 0, 0.5, 0)` (this will set the Frame in the center of its parent object). If you were to change `Size`, you would notice that the Frame will expand to the right and downward. The very center of the frame would also not be at the exact center of the parent object. However, if you were to set the AnchorPoint to `(0.5, 0.5)`, the Frame would expand in all directions and the center of the frame would indeed be at the parent object's center.

## Code Samples

### AnchorPoint Demo

This code sample moves a UI element to different sides of the parent element. It starts at the top-left and ends at the bottom-right. Paste into a LocalScript in a Frame, within a ScreenGui.
```lua
local guiObject = script.Parent

while true do
	-- Top-left
	guiObject.AnchorPoint = Vector2.new(0, 0)
	guiObject.Position = UDim2.new(0, 0, 0, 0)
	wait(1)
	-- Top
	guiObject.AnchorPoint = Vector2.new(0.5, 0)
	guiObject.Position = UDim2.new(0.5, 0, 0, 0)
	wait(1)
	-- Top-right
	guiObject.AnchorPoint = Vector2.new(1, 0)
	guiObject.Position = UDim2.new(1, 0, 0, 0)
	wait(1)
	-- Left
	guiObject.AnchorPoint = Vector2.new(0, 0.5)
	guiObject.Position = UDim2.new(0, 0, 0.5, 0)
	wait(1)
	-- Dead center
	guiObject.AnchorPoint = Vector2.new(0.5, 0.5)
	guiObject.Position = UDim2.new(0.5, 0, 0.5, 0)
	wait(1)
	-- Right
	guiObject.AnchorPoint = Vector2.new(1, 0.5)
	guiObject.Position = UDim2.new(1, 0, 0.5, 0)
	wait(1)
	-- Bottom-left
	guiObject.AnchorPoint = Vector2.new(0, 1)
	guiObject.Position = UDim2.new(0, 0, 1, 0)
	wait(1)
	-- Bottom
	guiObject.AnchorPoint = Vector2.new(0.5, 1)
	guiObject.Position = UDim2.new(0.5, 0, 1, 0)
	wait(1)
	-- Bottom-right
	guiObject.AnchorPoint = Vector2.new(1, 1)
	guiObject.Position = UDim2.new(1, 0, 1, 0)
	wait(1)
end

```
 */
	AnchorPoint: Vector2;
	/** BackgroundColor3 determines the color of a UI element's rectangular background (the fill color). Another property that determines the visual properties of the background is `BackgroundTransparency`.

## Code Samples

### Rainbow Frame

This code sample causes a parent Frame to loop through all colors of the rainbow using Color3.fromHSV.
```lua
-- Put this code in a LocalScript in a Frame
local frame = script.Parent

while true do
	for hue = 0, 255, 4 do
		-- HSV = hue, saturation, value
		-- If we loop from 0 to 1 repeatedly, we get a rainbow!
		frame.BorderColor3 = Color3.fromHSV(hue/256, 1, 1)
		frame.BackgroundColor3 = Color3.fromHSV(hue/256, .5, .8)
		wait()
	end
end

```
 */
	BackgroundColor3: Color3;
	/** This property determines the transparency of the `GUI's` background and border.

It does not, however, determine the transparency of text if the GUI is a `Textbox`, `TextButton`, or `TextLabel`. Text transparency is determined `TextTransparency|`, `TextTransparency`, and `TextTransparency` respectively.

If the property is set to 1, neither the background nor the border will render and the GUI will be completely transparent.

## Code Samples

### Flash Fade a Gui Element

The example below demonstrates how to continuously fade a GUI element in and out (see image below). It relies on the `RenderService's` `RenderStepped` event to update and render the element's `BackgroundTransparency` every frame.

The GUI element fades in and out between the maximum transparency value, `MAX_TRANSPARENCY`, and minimum transparency value, `MIN_TRANSPARENCY`. It uses the `delta` variable to determine what amount to change the element's BackgroundTransparency.

This example should work as expected when placed in a `Script` or `LocalScript` that is the child of the GUI element you want to fade in and out.

![GUI Element Fading In and Out](https://developer.roblox.com/assets/5b8c5b3bacedd45c0bf7d33e/GuiObject_Fading_In_and_Out.gif)
```lua
local RunService = game:GetService("RunService")

local MIN_TRANSPARENCY = 0
local MAX_TRANSPARENCY = 0.9
local delta = 0

local function fadeGui()
	local element = script.Parent
	
	if element.BackgroundTransparency <= MIN_TRANSPARENCY then 
		delta = 0.01
	elseif element.BackgroundTransparency >= MAX_TRANSPARENCY then
		delta = -0.01
	end
	
	element.BackgroundTransparency = element.BackgroundTransparency + delta
end

RunService.RenderStepped:Connect(fadeGui)
```
 */
	BackgroundTransparency: number;
	/** BorderColor3 determines the color of a `UI` element's rectangular border (also known as the stroke color). 

This is separate from the UI element's `BackgroundColor3`. If you set a UI element's border and background colors to the same color, you will be unable to distinguish the two.

Other properties properties that determine the visual properties of the border include `BorderSizePixel` and `BackgroundTransparency`.

Note that you will not be able to see an element's border if its BorderSizePixel property is set to 0.

## Code Samples

### Button Highlight

This code sample causes the border of a parent GuiObject to highlight when the user hovers their mouse over the element.
```lua
-- Put me inside some GuiObject, preferrably an ImageButton/TextButton
local button = script.Parent

local function onEnter()
	button.BorderSizePixel = 2
	button.BorderColor3 = Color3.new(1, 1, 0) -- Yellow
end

local function onLeave()
	button.BorderSizePixel = 1
	button.BorderColor3 = Color3.new(0, 0, 0) -- Black
end

-- Connect events
button.MouseEnter:connect(onEnter)
button.MouseLeave:connect(onLeave)
-- Our default state is "not hovered"
onLeave()

```

### Rainbow Frame

This code sample causes a parent Frame to loop through all colors of the rainbow using Color3.fromHSV.
```lua
-- Put this code in a LocalScript in a Frame
local frame = script.Parent

while true do
	for hue = 0, 255, 4 do
		-- HSV = hue, saturation, value
		-- If we loop from 0 to 1 repeatedly, we get a rainbow!
		frame.BorderColor3 = Color3.fromHSV(hue/256, 1, 1)
		frame.BackgroundColor3 = Color3.fromHSV(hue/256, .5, .8)
		wait()
	end
end

```
 */
	BorderColor3: Color3;
	/** BorderSizePixel determines how wide a UI element's border should render, in pixels. This property and `BorderColor3` and `BackgroundTransparency` determine how the border of a UI element should look. Setting BorderSizePixel to 0 will disable the border altogether. The border width extends outward the perimeter of the rectangle.

## Code Samples

### Button Highlight

This code sample causes the border of a parent GuiObject to highlight when the user hovers their mouse over the element.
```lua
-- Put me inside some GuiObject, preferrably an ImageButton/TextButton
local button = script.Parent

local function onEnter()
	button.BorderSizePixel = 2
	button.BorderColor3 = Color3.new(1, 1, 0) -- Yellow
end

local function onLeave()
	button.BorderSizePixel = 1
	button.BorderColor3 = Color3.new(0, 0, 0) -- Black
end

-- Connect events
button.MouseEnter:connect(onEnter)
button.MouseLeave:connect(onLeave)
-- Our default state is "not hovered"
onLeave()

```
 */
	BorderSizePixel: number;
	/** This property determines if a `GUI` will *clip* (or make invisible) any portion of descendant GUI elements that would otherwise render outside the bounds of the rectangle. Further descendant GUI elements can also use ClipsDescendants. The behavior is similar to a `ScrollingFrame`.

Note that `Rotation` isn't supported by this property. If this or any ancestor GUI has a **non-zero** `Rotation`, this property is **ignored** and descendant GUI elements will be rendered regardless of this property's value.

The gif and code sample below demonstrate how to enabled and disable the property using a `LocalScript`. They also illustrate the affects the property has on descendant GUI elements.

```lua
lua
while true do
	script.Parent.ClipDescendants = true
	wait(2)
	script.Parent.ClipDescendants = false
	wait(2)
end
```

![ClipDescendants Demo](https://developer.roblox.com/assets/5b8d8873a3326f570bb89bae/ClipDescendantsDemo.gif)

In the gif below, the element labelled *Parent* toggles between ClipsDescendants enabled and disabled every two seconds. The elements labelled *Child* are descendants of `Parent` that are affected by changing the property. Also note that the rotated *Child* element is not affected by the property. */
	ClipsDescendants: boolean;
	/** This property controls the sorting order of a `GUI` when using a `UIGridStyleLayout` (such as `UIListLayout` or `UIPageLayout`) with `SortOrder` set to `Enum.SortOrder.LayoutOrder`. It has no functionality if the GUI does not have a sibling UI Layout.

It is a signed 32-bit int, so it can be set to any value from -2,147,483,648 to 2,147,483,647 (inclusive). GUIs are placed in ascending order where lower values take more priority over, and are ordered before, higher values. Values that are equal will fall back to the order they were added in. 

If you are unsure if you will need to add an element between two already-existing elements in the future, it can be a good idea to use multiples of 100, i.e. 0, 100, 200. This ensures a large gap of LayoutOrder values you can use for elements ordered in-between other elements.

## See also
 - `ZIndex`, which determines the GUI render order instead of placement order.

## Code Samples

### Ordering Images with a UIGridLayout

This example uses LayoutOrder within a UIGridLayout to change the order of images.
```lua
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = playerGui

local uiGridLayout = Instance.new("UIGridLayout")
uiGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
uiGridLayout.Parent = screenGui

local function createImage(color)
	local imageLabel = Instance.new("ImageLabel")
	imageLabel.Image = "rbxassetid://924320031"
	imageLabel.ImageColor3 = color
	imageLabel.Parent = screenGui
	return imageLabel
end

local firstImageLabel = createImage(Color3.new(255, 0, 0))
local secondImageLabel = createImage(Color3.new(0, 255, 0))
local thirdImageLabel = createImage(Color3.new(0, 0, 255))

wait(3) -- wait time to show change in LayoutOrder

firstImageLabel.LayoutOrder = 3
secondImageLabel.LayoutOrder = 1
thirdImageLabel.LayoutOrder = 2
```

### UI Sort Order

This code sample demonstrates sorting data using `SortOrder` and `LayoutOrder`.
```lua
-- Place in a script in a UIListLayout
local uiGridLayout = script.Parent

-- Some data to work with
local scores = {
	["Player1"] = 2048;
	["Ozzypig"] = 1337;
	["Shedletsky"] = 1250;
	["Builderman"] = 1000;  
}

-- Build a scoreboard
for name, score in pairs(scores) do
	local tl = Instance.new("TextLabel")
	tl.Text = name .. ": " .. score
	tl.Parent = script.Parent
	tl.LayoutOrder = -score -- We want higher scores first, so negate for descending order
	tl.Name = name
	tl.Size = UDim2.new(0, 200, 0, 50)
	tl.Parent = uiGridLayout.Parent
end

while true do
	-- The name is the player's name
	uiGridLayout.SortOrder = Enum.SortOrder.Name
	uiGridLayout:ApplyLayout()
	wait(2)
	-- Since we set the LayoutOrder to the score, this will sort by descending score!
	uiGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
	uiGridLayout:ApplyLayout()
	wait(2)
end
```
 */
	LayoutOrder: number;
	/** This property sets the `GUI` selected when the user moves the Gamepad selector downward. If this property is left blank, the moving the Gamepad downward will not change which selected GUI.

Moving the Gamepad selector downward sets the `SelectedObject` to this object unless the GUI is not `Selectable`. If the specified GUI is not selectable, it will not be selected when the gamepad selected moves upward. 

Note that since this property can be set to a GUI element even if it is not Selectable, you should ensure that the value of a GUI's selectable property matching your expected behavior.

## See also
 - `NextSelectionUp`
 - `NextSelectionLeft`
 - `NextSelectionRight`

## Code Samples

### Creating a Gamepad Selection Grid

This example demonstrates how to enable Gamepad navigation through a grid of `GUI` elements without manually having to connect the `NextSelectionUp`, `NextSelectionDown`, and `NextSelectionRight`, and `NextSelectionLeft` properties for every element in the grid.

Note that this code sample assumes your `UIGridLayout` is sorted by `name`, where elements are named in successive numerical order (see image below).

![UIGridLayout Sorted By Name](https://developer.roblox.com/assets/5b9d7cc90b3d1789514ec0ba/Screen_Shot_2018-09-15_at_5.41.52_PM.png)

The code relies on this to set the NextSelection properties for all `GuiObjects` in the same level as the UIGridLayout. In our example, the UIGridLayoutObject and GUI elements within the grid are all children of a `Frame` named *"Container"*. The code `gets the children` of *"Container"* and loops through each child. Children that are not GuiObjects are ignored. For each GUI element, the code attempts to assigned the NextSelection properties using the following logic:
 1. Starting with 1, the name of all GUI elements match their position in the grid
 2. Left: The item to the left will always be numbered 1 less than the current element
 3. Right: The item to the left will always be numbered 1 more than the current element
 4. Up: The item above (up) will always be number of GUIs in a row  1 less than the current element
 5. Down: The item below (down) will always be the number of GUIs in a row more than the current element
This logic also allows for the GUI elements at the begging and end of rows (excluding the first and last element) to wrap around to the next and previous rows. If an element doesn't exist to the left, right, up, or down, the NextSelection will remain nil and moving the Gamepad selector in the direction will not change the selected GUI.

This example also contains code to test the grid using the arrow keys (Up, Down, Left, Right) of your keyboard instead of a gamepad, just in case you don't have a gamepad to test with. This portion of code initially selects the element named *"1"* by assigning it to the `SelectedObject` property.

![Grid Demonstration Gif](https://developer.roblox.com/assets/5b9d83a783fc379f34f5c11b/NextSelectionGridGif.gif)
```lua
-- ========================================
-- Setup the Gamepad selection grid using the code below
local container = script.Parent:FindFirstChild("Container")
local grid = container:GetChildren()
local rowSize = container:FindFirstChild("UIGridLayout").FillDirectionMaxCells

for i, gui in pairs (grid) do
	if gui:IsA("GuiObject") then
		local pos = gui.Name
		
		-- Left edge
		gui.NextSelectionLeft = container:FindFirstChild(pos-1)		
		-- Right edge
		gui.NextSelectionRight = container:FindFirstChild(pos+1)		
		-- Above
		gui.NextSelectionUp = container:FindFirstChild(pos-rowSize)		
		-- Below
		gui.NextSelectionDown = container:FindFirstChild(pos+rowSize)
	end
end
-- ========================================

-- ========================================
-- Test the Gamepad selection grid using the code below
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")

GuiService.SelectedObject = container:FindFirstChild("1")

function updateSelection(input)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local key = input.KeyCode

		local selectedObject = GuiService.SelectedObject
		if not selectedObject then return end
		
		if key == Enum.KeyCode.Up then
			if not selectedObject.NextSelectionUp then
				GuiService.SelectedObject = selectedObject
			end
		elseif key == Enum.KeyCode.Down then
			if not selectedObject.NextSelectionDown then
				GuiService.SelectedObject = selectedObject
			end
		elseif key == Enum.KeyCode.Left then
			if not selectedObject.NextSelectionLeft then
				GuiService.SelectedObject = selectedObject
			end
		elseif key == Enum.KeyCode.Right then
			if not selectedObject.NextSelectionRight then
				GuiService.SelectedObject = selectedObject
			end
		end
	end
end

UserInputService.InputBegan:Connect(updateSelection)
-- ========================================
```
 */
	NextSelectionDown?: GuiObject;
	/** This property sets the `GUI` selected when the user moves the Gamepad selector to the left. If this property is left blank, the moving the Gamepad left will not change which selected GUI.

Moving the Gamepad selector left sets the `SelectedObject` to this object unless the GUI is not `Selectable`. If the specified GUI is not selectable, it will not be selected when the gamepad selected moves upward. 

Note that since this property can be set to a GUI element even if it is not Selectable, you should ensure that the value of a GUI's selectable property matching your expected behavior.

## See also
 - `NextSelectionUp`
 - `NextSelectionDown`
 - `NextSelectionRight`

## Code Samples

### Creating a Gamepad Selection Grid

This example demonstrates how to enable Gamepad navigation through a grid of `GUI` elements without manually having to connect the `NextSelectionUp`, `NextSelectionDown`, and `NextSelectionRight`, and `NextSelectionLeft` properties for every element in the grid.

Note that this code sample assumes your `UIGridLayout` is sorted by `name`, where elements are named in successive numerical order (see image below).

![UIGridLayout Sorted By Name](https://developer.roblox.com/assets/5b9d7cc90b3d1789514ec0ba/Screen_Shot_2018-09-15_at_5.41.52_PM.png)

The code relies on this to set the NextSelection properties for all `GuiObjects` in the same level as the UIGridLayout. In our example, the UIGridLayoutObject and GUI elements within the grid are all children of a `Frame` named *"Container"*. The code `gets the children` of *"Container"* and loops through each child. Children that are not GuiObjects are ignored. For each GUI element, the code attempts to assigned the NextSelection properties using the following logic:
 1. Starting with 1, the name of all GUI elements match their position in the grid
 2. Left: The item to the left will always be numbered 1 less than the current element
 3. Right: The item to the left will always be numbered 1 more than the current element
 4. Up: The item above (up) will always be number of GUIs in a row  1 less than the current element
 5. Down: The item below (down) will always be the number of GUIs in a row more than the current element
This logic also allows for the GUI elements at the begging and end of rows (excluding the first and last element) to wrap around to the next and previous rows. If an element doesn't exist to the left, right, up, or down, the NextSelection will remain nil and moving the Gamepad selector in the direction will not change the selected GUI.

This example also contains code to test the grid using the arrow keys (Up, Down, Left, Right) of your keyboard instead of a gamepad, just in case you don't have a gamepad to test with. This portion of code initially selects the element named *"1"* by assigning it to the `SelectedObject` property.

![Grid Demonstration Gif](https://developer.roblox.com/assets/5b9d83a783fc379f34f5c11b/NextSelectionGridGif.gif)
```lua
-- ========================================
-- Setup the Gamepad selection grid using the code below
local container = script.Parent:FindFirstChild("Container")
local grid = container:GetChildren()
local rowSize = container:FindFirstChild("UIGridLayout").FillDirectionMaxCells

for i, gui in pairs (grid) do
	if gui:IsA("GuiObject") then
		local pos = gui.Name
		
		-- Left edge
		gui.NextSelectionLeft = container:FindFirstChild(pos-1)		
		-- Right edge
		gui.NextSelectionRight = container:FindFirstChild(pos+1)		
		-- Above
		gui.NextSelectionUp = container:FindFirstChild(pos-rowSize)		
		-- Below
		gui.NextSelectionDown = container:FindFirstChild(pos+rowSize)
	end
end
-- ========================================

-- ========================================
-- Test the Gamepad selection grid using the code below
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")

GuiService.SelectedObject = container:FindFirstChild("1")

function updateSelection(input)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local key = input.KeyCode

		local selectedObject = GuiService.SelectedObject
		if not selectedObject then return end
		
		if key == Enum.KeyCode.Up then
			if not selectedObject.NextSelectionUp then
				GuiService.SelectedObject = selectedObject
			end
		elseif key == Enum.KeyCode.Down then
			if not selectedObject.NextSelectionDown then
				GuiService.SelectedObject = selectedObject
			end
		elseif key == Enum.KeyCode.Left then
			if not selectedObject.NextSelectionLeft then
				GuiService.SelectedObject = selectedObject
			end
		elseif key == Enum.KeyCode.Right then
			if not selectedObject.NextSelectionRight then
				GuiService.SelectedObject = selectedObject
			end
		end
	end
end

UserInputService.InputBegan:Connect(updateSelection)
-- ========================================
```
 */
	NextSelectionLeft?: GuiObject;
	/** This property sets the `GUI` selected when the user moves the Gamepad selector to the right. If this property is left blank, the moving the Gamepad right will not change which selected GUI.

Moving the Gamepad selector right sets the `SelectedObject` to this object unless the GUI is not `Selectable`. If the GUI is not selectable, it will not be selected when the gamepad selected moves right. 

Note that since this property can be set to a GUI element even if it is not Selectable, you should ensure that the value of a GUI's selectable property matching your expected behavior.

## See also
 - `NextSelectionUp`
 - `NextSelectionDown`
 - `NextSelectionLeft`

## Code Samples

### Creating a Gamepad Selection Grid

This example demonstrates how to enable Gamepad navigation through a grid of `GUI` elements without manually having to connect the `NextSelectionUp`, `NextSelectionDown`, and `NextSelectionRight`, and `NextSelectionLeft` properties for every element in the grid.

Note that this code sample assumes your `UIGridLayout` is sorted by `name`, where elements are named in successive numerical order (see image below).

![UIGridLayout Sorted By Name](https://developer.roblox.com/assets/5b9d7cc90b3d1789514ec0ba/Screen_Shot_2018-09-15_at_5.41.52_PM.png)

The code relies on this to set the NextSelection properties for all `GuiObjects` in the same level as the UIGridLayout. In our example, the UIGridLayoutObject and GUI elements within the grid are all children of a `Frame` named *"Container"*. The code `gets the children` of *"Container"* and loops through each child. Children that are not GuiObjects are ignored. For each GUI element, the code attempts to assigned the NextSelection properties using the following logic:
 1. Starting with 1, the name of all GUI elements match their position in the grid
 2. Left: The item to the left will always be numbered 1 less than the current element
 3. Right: The item to the left will always be numbered 1 more than the current element
 4. Up: The item above (up) will always be number of GUIs in a row  1 less than the current element
 5. Down: The item below (down) will always be the number of GUIs in a row more than the current element
This logic also allows for the GUI elements at the begging and end of rows (excluding the first and last element) to wrap around to the next and previous rows. If an element doesn't exist to the left, right, up, or down, the NextSelection will remain nil and moving the Gamepad selector in the direction will not change the selected GUI.

This example also contains code to test the grid using the arrow keys (Up, Down, Left, Right) of your keyboard instead of a gamepad, just in case you don't have a gamepad to test with. This portion of code initially selects the element named *"1"* by assigning it to the `SelectedObject` property.

![Grid Demonstration Gif](https://developer.roblox.com/assets/5b9d83a783fc379f34f5c11b/NextSelectionGridGif.gif)
```lua
-- ========================================
-- Setup the Gamepad selection grid using the code below
local container = script.Parent:FindFirstChild("Container")
local grid = container:GetChildren()
local rowSize = container:FindFirstChild("UIGridLayout").FillDirectionMaxCells

for i, gui in pairs (grid) do
	if gui:IsA("GuiObject") then
		local pos = gui.Name
		
		-- Left edge
		gui.NextSelectionLeft = container:FindFirstChild(pos-1)		
		-- Right edge
		gui.NextSelectionRight = container:FindFirstChild(pos+1)		
		-- Above
		gui.NextSelectionUp = container:FindFirstChild(pos-rowSize)		
		-- Below
		gui.NextSelectionDown = container:FindFirstChild(pos+rowSize)
	end
end
-- ========================================

-- ========================================
-- Test the Gamepad selection grid using the code below
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")

GuiService.SelectedObject = container:FindFirstChild("1")

function updateSelection(input)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local key = input.KeyCode

		local selectedObject = GuiService.SelectedObject
		if not selectedObject then return end
		
		if key == Enum.KeyCode.Up then
			if not selectedObject.NextSelectionUp then
				GuiService.SelectedObject = selectedObject
			end
		elseif key == Enum.KeyCode.Down then
			if not selectedObject.NextSelectionDown then
				GuiService.SelectedObject = selectedObject
			end
		elseif key == Enum.KeyCode.Left then
			if not selectedObject.NextSelectionLeft then
				GuiService.SelectedObject = selectedObject
			end
		elseif key == Enum.KeyCode.Right then
			if not selectedObject.NextSelectionRight then
				GuiService.SelectedObject = selectedObject
			end
		end
	end
end

UserInputService.InputBegan:Connect(updateSelection)
-- ========================================
```
 */
	NextSelectionRight?: GuiObject;
	/** This property sets the `GUI` selected when the user moves the Gamepad selector upward. If this property is left blank, the moving the Gamepad upward will not change the selected GUI.

Moving the Gamepad selector upward sets the `SelectedObject` to this object unless the GUI is not `Selectable`. If the specified GUI is not selectable, it will not be selected when the gamepad selected moves upward. 

Note that since this property can be set to a GUI element even if it is not Selectable, you should ensure that the value of a GUI's selectable property matching your expected behavior.

## See also
 - `NextSelectionDown`
 - `NextSelectionLeft`
 - `NextSelectionRight`

## Code Samples

### Creating a Gamepad Selection Grid

This example demonstrates how to enable Gamepad navigation through a grid of `GUI` elements without manually having to connect the `NextSelectionUp`, `NextSelectionDown`, and `NextSelectionRight`, and `NextSelectionLeft` properties for every element in the grid.

Note that this code sample assumes your `UIGridLayout` is sorted by `name`, where elements are named in successive numerical order (see image below).

![UIGridLayout Sorted By Name](https://developer.roblox.com/assets/5b9d7cc90b3d1789514ec0ba/Screen_Shot_2018-09-15_at_5.41.52_PM.png)

The code relies on this to set the NextSelection properties for all `GuiObjects` in the same level as the UIGridLayout. In our example, the UIGridLayoutObject and GUI elements within the grid are all children of a `Frame` named *"Container"*. The code `gets the children` of *"Container"* and loops through each child. Children that are not GuiObjects are ignored. For each GUI element, the code attempts to assigned the NextSelection properties using the following logic:
 1. Starting with 1, the name of all GUI elements match their position in the grid
 2. Left: The item to the left will always be numbered 1 less than the current element
 3. Right: The item to the left will always be numbered 1 more than the current element
 4. Up: The item above (up) will always be number of GUIs in a row  1 less than the current element
 5. Down: The item below (down) will always be the number of GUIs in a row more than the current element
This logic also allows for the GUI elements at the begging and end of rows (excluding the first and last element) to wrap around to the next and previous rows. If an element doesn't exist to the left, right, up, or down, the NextSelection will remain nil and moving the Gamepad selector in the direction will not change the selected GUI.

This example also contains code to test the grid using the arrow keys (Up, Down, Left, Right) of your keyboard instead of a gamepad, just in case you don't have a gamepad to test with. This portion of code initially selects the element named *"1"* by assigning it to the `SelectedObject` property.

![Grid Demonstration Gif](https://developer.roblox.com/assets/5b9d83a783fc379f34f5c11b/NextSelectionGridGif.gif)
```lua
-- ========================================
-- Setup the Gamepad selection grid using the code below
local container = script.Parent:FindFirstChild("Container")
local grid = container:GetChildren()
local rowSize = container:FindFirstChild("UIGridLayout").FillDirectionMaxCells

for i, gui in pairs (grid) do
	if gui:IsA("GuiObject") then
		local pos = gui.Name
		
		-- Left edge
		gui.NextSelectionLeft = container:FindFirstChild(pos-1)		
		-- Right edge
		gui.NextSelectionRight = container:FindFirstChild(pos+1)		
		-- Above
		gui.NextSelectionUp = container:FindFirstChild(pos-rowSize)		
		-- Below
		gui.NextSelectionDown = container:FindFirstChild(pos+rowSize)
	end
end
-- ========================================

-- ========================================
-- Test the Gamepad selection grid using the code below
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")

GuiService.SelectedObject = container:FindFirstChild("1")

function updateSelection(input)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local key = input.KeyCode

		local selectedObject = GuiService.SelectedObject
		if not selectedObject then return end
		
		if key == Enum.KeyCode.Up then
			if not selectedObject.NextSelectionUp then
				GuiService.SelectedObject = selectedObject
			end
		elseif key == Enum.KeyCode.Down then
			if not selectedObject.NextSelectionDown then
				GuiService.SelectedObject = selectedObject
			end
		elseif key == Enum.KeyCode.Left then
			if not selectedObject.NextSelectionLeft then
				GuiService.SelectedObject = selectedObject
			end
		elseif key == Enum.KeyCode.Right then
			if not selectedObject.NextSelectionRight then
				GuiService.SelectedObject = selectedObject
			end
		end
	end
end

UserInputService.InputBegan:Connect(updateSelection)
-- ========================================
```
 */
	NextSelectionUp?: GuiObject;
	/** This property determines a `GUI's` pixel and scalar size using a `UDim2`. Its value can be expressed as `UDim2.new(ScalarX, PixelX, ScalarY, PixelY)` or `({ScalarX, PixelX}, {ScalarY, PixelY})`. Position is centered around a GUI's `AnchorPoint`.

An element’s position can also be set by modifying both its scalar and pixel positions at the same time. For instance, tits position can be set to `({0.25, 100}, {0.25, 100})`.

The scalar size is relative to the scalar size of parent GUI elements, if any. For example, if AnchorPoint is set to `{0, 0}{0, 0}`  and Position is set to `{0, 0}, {0, 0}`, the element will render at the top left corner of the parent element. Similarly, if AnchorPoint is set to `{0, 0}{0, 0}` and Position is set to `{0.5, 0}, {0.5, 0}`, the top left corner of the element will render at the center of the parent element.

The pixel portions of the `UDim2` value are the same regardless of the parent GUI's size. The values represent the position of the object in pixels. For example, if set to `{0, 100}, {0, 150}` the element's AnchorPoint will render with on the screen 100 pixels from the left and 150 pixels from the top.

An object's actual pixel position can be read from the `AbsolutePosition` property.

## Code Samples

### Frame Moving in Circle

This code sample moves a GuiObject in a circle within its parent object using RunService's BindToRenderStep. It defines a parametric equation in a function to help with positioning the GuiObject.

To try this code out, put a ScreenGui in the StarterGui. Inside the ScreenGui, insert a Frame with a LocalScript. Paste this code into the LocalScript, then play the game. Watch the Frame travel counterclockwise within.
```lua
local RunService = game:GetService("RunService")

-- How fast the frame ought to move
local SPEED = 2

local frame = script.Parent
frame.AnchorPoint = Vector2.new(.5, .5)

-- A simple parametric equation of a circle
-- centered at (0.5, 0.5) with radius (0.5)
local function circle(t)
	return .5 + math.cos(t) * .5,
	       .5 + math.sin(t) * .5
end

-- Keep track of the current time
local currentTime = 0
local function onRenderStep(deltaTime)
	-- Update the current time
	currentTime = currentTime + deltaTime * SPEED
	-- ...and our frame's position
	local x, y = circle(currentTime)
	frame.Position = UDim2.new(x, 0, y, 0)
end

-- This is just a visual effect, so use the "Last" priority
RunService:BindToRenderStep("FrameCircle", Enum.RenderPriority.Last.Value, onRenderStep)
--RunService.RenderStepped:Connect(onRenderStep) -- Also works, but not recommended
```

### AnchorPoint Demo

This code sample moves a UI element to different sides of the parent element. It starts at the top-left and ends at the bottom-right. Paste into a LocalScript in a Frame, within a ScreenGui.
```lua
local guiObject = script.Parent

while true do
	-- Top-left
	guiObject.AnchorPoint = Vector2.new(0, 0)
	guiObject.Position = UDim2.new(0, 0, 0, 0)
	wait(1)
	-- Top
	guiObject.AnchorPoint = Vector2.new(0.5, 0)
	guiObject.Position = UDim2.new(0.5, 0, 0, 0)
	wait(1)
	-- Top-right
	guiObject.AnchorPoint = Vector2.new(1, 0)
	guiObject.Position = UDim2.new(1, 0, 0, 0)
	wait(1)
	-- Left
	guiObject.AnchorPoint = Vector2.new(0, 0.5)
	guiObject.Position = UDim2.new(0, 0, 0.5, 0)
	wait(1)
	-- Dead center
	guiObject.AnchorPoint = Vector2.new(0.5, 0.5)
	guiObject.Position = UDim2.new(0.5, 0, 0.5, 0)
	wait(1)
	-- Right
	guiObject.AnchorPoint = Vector2.new(1, 0.5)
	guiObject.Position = UDim2.new(1, 0, 0.5, 0)
	wait(1)
	-- Bottom-left
	guiObject.AnchorPoint = Vector2.new(0, 1)
	guiObject.Position = UDim2.new(0, 0, 1, 0)
	wait(1)
	-- Bottom
	guiObject.AnchorPoint = Vector2.new(0.5, 1)
	guiObject.Position = UDim2.new(0.5, 0, 1, 0)
	wait(1)
	-- Bottom-right
	guiObject.AnchorPoint = Vector2.new(1, 1)
	guiObject.Position = UDim2.new(1, 0, 1, 0)
	wait(1)
end

```
 */
	Position: UDim2;
	/** This property determines the number of degrees by which a `GUI` is rotated. Rotation is relative to the **center** of its parent GUI.

A GUI's `AnchorPoint` does not influence it's rotation. This means that you cannot change the center of rotation since it will always be in the center of the object. 

Additionally, this property is **not compatible** with `ClipsDescendants`. If an ancestor (parent) object has ClipsDescendants enabled and this property is nonzero, then descendant GUI elements will not be clipped.

## Code Samples

### Spin GuiObject

This code sample rotates a parent `GuiObject` (such as a `Frame`) using a given rotation speed and the `RenderStepped` event.
```lua
local RunService = game:GetService("RunService")

local guiObject = script.Parent

local degreesPerSecond = 180

local function onRenderStep(deltaTime)
	local deltaRotation = deltaTime * degreesPerSecond
	guiObject.Rotation = guiObject.Rotation + deltaRotation 
end
RunService.RenderStepped:Connect(onRenderStep)

```

### Copycat Frame

This code sample shows how a UI element's size, position and rotation can be copied without parenting a "copycat" to the original. It uses the Absolute-family of properties to orient a "copycat" Frame that covers on the screen space that the original does.
```lua
-- Place within a Frame, TextLabel, etc.
local guiObject = script.Parent

-- For this object to be rendered, it must be a descendant of a ScreenGui
local screenGui = guiObject:FindFirstAncestorOfClass("ScreenGui")

-- Create a copy
local copycat = Instance.new("Frame")
copycat.BackgroundTransparency = 0.5
copycat.BackgroundColor3 = Color3.new(.5, .5, 1) -- Light blue
copycat.BorderColor3 = Color3.new(1, 1, 1) -- White

-- Orient the copy just as the original; do so "absolutely"
copycat.AnchorPoint = Vector2.new(0, 0) 
copycat.Position = UDim2.new(0, guiObject.AbsolutePosition.X, 0, guiObject.AbsolutePosition.Y)
copycat.Size = UDim2.new(0, guiObject.AbsoluteSize.X, 0, guiObject.AbsoluteSize.Y)
copycat.Rotation = guiObject.AbsoluteRotation

-- Insert into ancestor ScreenGui
copycat.Parent = screenGui

```
 */
	Rotation: number;
	/** The Selectable property determines whether a UI element can be selected when navigating UI elements with a gamepad. If false, the object cannot be navigated to and `SelectedObject` will not be set to the UI element; setting this property to false will not change `SelectedObject` if it is already to the UI element. */
	Selectable: boolean;
	/** This property overrides the default selection adornment (used for gamepads). For best results, this should point to a `GUI`.

Note that the SelectionImageObject overlays the selected GUI with the `Size` of the image. For best results when using a non-default SelectionImageObject, you should size the SelectionImageObject via the scale `UDim2` values. This helps ensure that the object scales properly over the selected element.

The default SelectionImageObject is a blue and white square outline around the selected GUI element. In the image below, the selected GUI is a white `Frame`.

![Default SelectionImageObject](https://developer.roblox.com/assets/5b9b1d450b3d1789514ebdd7/Screen_Shot_2018-09-13_at_9.57.14_PM.png)

For instance, changing the SelectionImageObject to a `ImageLabel` with red and white square outline [image][2], `BackgroundTransparency` of 1,  `Size` of *UDim2(1.1, 0, 1.1, 0)*, and `Position` of *UDim2(-0.05, 0, -0.05, 0)* results in the image below:

![Custom SelectionImageObject](https://developer.roblox.com/assets/5b9b17dd1a346e537cf02152/Screen_Shot_2018-09-13_at_9.53.54_PM.png)

Changing the SelectionImageObject for a GUI element only affects that element. To change the SelectionImageObject for all of a user's GUI elements, you can set the `SelectionImageObject` property.

To determine or set which GUI element is selected by the user, you can use the `SelectedObject` property. The user uses the gamepad to select different GUI elements, invoking the `NextSelectionUp`, `NextSelectionDown`, `NextSelectionLeft`, and `NextSelectionRight` events.

  
  [2]: https://www.roblox.com/library/2347505468/SelectionImage-Red */
	SelectionImageObject?: GuiObject;
	/** This property determines a `GUI's` scalar and pixel size using a `UDim2`. Its value can be expressed as `UDim2.new(ScalarX, PixelX, ScalarY, PixelY)` or `({ScalarX, PixelX}, {ScalarY, PixelY})`.

The scalar size is relative to the scalar size of parent GUI elements, if any. For example, if the GUI's scalar size is `UDim2.new(0.5, 0, 0.5, 0) and it is not the descendant of a GUI, then it will occupy half of the screen horizontally and vertically. However, if the GUI is the child of a GUI with a scalar size of `UDim2.new(0.5, 0, 0.5, 0), then the GUI's scalar size will render to be half the scalar size of its parent both horizontally and vertically and will occupy a quarter of the screen in both dimensions.

The pixel portions of the `UDim2` value are the same regardless of the parent GUI's size. The values represent the size of the object in pixels. For example, if Position is set to `{0, 100}, {0, 150}` the element will render with a width of 100 pixels and height of 150 pixels.

If the GUI has a parent, its size of each axis is also influenced by the parent's `SizeConstraint`. 

Although it is possible to use negative sizes when creating GUIs, it's more often better to manipulate `AnchorPoint` instead. 

An object's actual pixel size can be read from the `AbsoluteSize` property.

## Code Samples

### Health Bar

This code sample allows you to create a simple color-changing health bar using two nested Frames. Paste this into a LocalScript on the inner frame.
```lua
local player = game.Players.LocalPlayer

-- Paste script into a LocalScript that is 
-- parented to a Frame within a Frame
local frame = script.Parent
local container = frame.Parent
container.BackgroundColor3 = Color3.new(0, 0, 0) -- black

-- This function is called when the humanoid's health changes
local function onHealthChanged()
	local human = player.Character.Humanoid
	local percent = human.Health / human.MaxHealth
	-- Change the size of the inner bar
	frame.Size = UDim2.new(percent, 0, 1, 0)
	-- Change the color of the health bar
	if percent < .1 then
		frame.BackgroundColor3 = Color3.new(1, 0, 0) -- black
	elseif percent < .4 then
		frame.BackgroundColor3 = Color3.new(1, 1, 0) -- yellow
	else
		frame.BackgroundColor3 = Color3.new(0, 1, 0) -- green
	end
end

-- This function runs is called the player spawns in
local function onCharacterAdded(character)
	local human = character:WaitForChild("Humanoid")
	-- Pattern: update once now, then any time the health changes
	human.HealthChanged:Connect(onHealthChanged)
	onHealthChanged()
end

-- Connect our spawn listener; call it if already spawned
player.CharacterAdded:Connect(onCharacterAdded)
if player.Character then
	onCharacterAdded(player.Character)
end

```
 */
	Size: UDim2;
	/** This property works in conjunction with the `GuiObject.Size|Size` property to determine the screen size of a GUI element.

The `SizeConstraint` enum will determine the axes that influence the scalar size of an object.

This property is useful for creating onscreen controls that are meant to scale with either the width or height of a parent object, but not both. This preserves the aspect ratio of the GUI element in question. For example, setting to RelativeYY with a Size of `{1, 0}, {1, 0}` will make the UI element square, with both the X and Y sizes equal to the parent element's Y size.

## Code Samples

### SizeConstraint

This code sample sets the SizeConstraint of a parent UI element.
```lua
local guiObject = script.Parent
guiObject.SizeConstraint = Enum.SizeConstraint.RelativeXX
```
 */
	SizeConstraint: Enum.SizeConstraint;
	/** This property is deprecated, and a mix of `BackgroundTransparency` and `TextTransparency`.

When indexing, this will return the BackgroundTranparency.

When setting, this will change the BackgroundTransparency **and** TextTransparency of a `GUI` element. */
	Transparency: number;
	/** This property determines whether a `GUI` will render shapes, images and/or text on screen. If set to false, the GUI and all of its descedants (children) will not render. 

The rendering of individual components of a GUI can be controlled individually through transparency properties such as  `BackgroundTransparency`, `TextTransparency` and `ImageTransparency`.

When this property is true, the GUI will be ignored by `UIGridStyleLayout` objects (such as `UIGridLayout`, `UIListLayout` and `UITableLayout`). In other words, the space that the element would otherwise occupy in the layout is used by other elements instead.

## Code Samples

### UI Window

This code sample adds open/close functionality to a Window UI. Paste as a LocalScript that is a sibling of a Frame named Window, a TextButton/ImageButton named Window, and a TextButton/ImageButton within the Window called Close.
```lua
local gui = script.Parent
local window = gui:WaitForChild("Window")
local toggleButton = gui:WaitForChild("ToggleWindow")
local closeButton = window:WaitForChild("Close")

local function toggleWindowVisbility()
	-- Flip a boolean using the `not` keyword
	window.Visible = not window.Visible
end

toggleButton.Activated:Connect(toggleWindowVisbility)
closeButton.Activated:Connect(toggleWindowVisbility)

```

### Blink UI Element

This code sample blinks a UI element on/off, much like HTML's beloved  tag. They still have that, right?
```lua
local guiObject = script.Parent

while true do
	guiObject.Visible = true
	wait(1)
	guiObject.Visible = false
	wait(1)
end

```
 */
	Visible: boolean;
	/** This property determines the order in which a `GUI` renders to the screen relative to other GUIs. 

By default, GUIs render in ascending priority order where lower values are rendered first. As a result, GUIs with lower ZIndex values appear under higher values. You can change the render order by changing the value of `ScreenGui.ZIndexBehavior`.

The range of valid values is 1 to 999,999,999, inclusive. If you are unsure if you will need to layer an element between two already-existing elements in the future, it can be a good idea to use multiples of 100, i.e. 0, 100, 200. This ensures a large gap of ZIndex values you can use for elements rendered in-between other elements.

## See also
 -  `LayoutOrder`, which controls the sort order of a GUI when used with a `UIGridStyleLayout` instead of render order.

## Code Samples

### ZIndex Alternate

This code sample flips the ZIndex rendering order of two frames.
```lua
-- Place this in a LocalScript that is a sibling of
-- two GuiObjects called "FrameA" and "FrameB"
local gui = script.Parent
local frameA = gui:WaitForChild("FrameA")
local frameB = gui:WaitForChild("FrameB")

while true do
	-- A < B, so A a renders first (on bottom) 
	frameA.ZIndex = 1
	frameB.ZIndex = 2
	wait(1)
	-- A > B, so A renders second (on top)
	frameA.ZIndex = 2
	frameB.ZIndex = 1
	wait(1)
end

```
 */
	ZIndex: number;
	/** Smoothly moves a GUI to a new `UDim2` position in the specified time using the specified `EasingDirection` and `EasingStyle`.

This function will return whether the tween will play. It will not play if another tween is acting on the `GuiObject` and the override parameter is false.

## See also
 - `TweenSize`, tweens a GUI's size
 - `TweenSizeAndPosition`, tweens a GUI's size and position synchronously

## Code Samples

### Tween a GUI's Position

If the GUI is at UDim2.new(0, 0, 0, 0) and you want it to move to UDim2.new(1, 0, 1, 0), you would use:
```lua
GUI:TweenPosition(UDim2.new(1, 0, 1, 0))
```

@param endPosition Where the GUI should move to
@param easingDirection The direction in which to ease the GUI to the *endPosition*
@param easingStyle The style in which to ease the GUI to the *endPosition*
@param time How long, in seconds, the tween should take to complete
@param override Whether the tween can be overridden by another tween before it finishes
@param callback A callback function to execute when the tween completes
@returns Whether the tween will play */
	TweenPosition(
		endPosition: UDim2,
		easingDirection?: CastsToEnum<Enum.EasingDirection>,
		easingStyle?: CastsToEnum<Enum.EasingStyle>,
		time?: number,
		override?: boolean,
		callback?: (finishedTween: Enum.TweenStatus) => void,
	): boolean;
	/** Smoothly resizes a GUI to a new `UDim2` in the specified time using the specified `EasingDirection` and `EasingStyle`. 

This function will return whether the tween will play. Normally this will always return true, but it will return false if another tween is active and override is set to false.

## See also
 - `TweenPosition`, tweens a GUI's position
 - `TweenSizeAndPosition`, tweens a GUI's size and position synchronously

## Code Samples

### Tween a GuiObject's Size

This code sample demonstrates the usage of the `TweenSize` function. It initiates an animation on the parent's `Size` property to `UDim2.new(0.5, 0, 0.5, 0)`, which is half the `GuiObject`'s parent size on both axes.

Additionally, it demonstrates how the callback parameter can be used to detect when the tween stops (whether it was cancelled by another tween or completed).
```lua
local guiObject = script.Parent

local function callback(didComplete)
	if didComplete then
		print("The tween completed successfully")
	else
		print("The tween was cancelled")
	end
end

local willTween = guiObject:TweenSize(
	UDim2.new(0.5, 0, 0.5, 0),  -- endSize (required)
	Enum.EasingDirection.In,    -- easingDirection (default Out)
	Enum.EasingStyle.Sine,      -- easingStyle (default Quad)
	2,                          -- time (default: 1)
	true,                       -- should this tween override ones in-progress? (default: false)
	callback                    -- a function to call when the tween completes (default: nil)
)

if willTween then
	print("The GuiObject will tween") 
else
	print("The GuiObject will not tween")
end

```

@param endSize The size that the GUI should resize
@param easingDirection The direction in which to ease the GUI to the *endPosition*
@param easingStyle The style in which to ease the GUI to the *endPosition*
@param time How long, in seconds, the tween should take to complete
@param override Whether another tween play, cancelling this tween, before the GUI reaches the *endPosition*
@param callback A callback function to execute when the tween completes
@returns Whether the tween will play */
	TweenSize(
		endSize: UDim2,
		easingDirection?: CastsToEnum<Enum.EasingDirection>,
		easingStyle?: CastsToEnum<Enum.EasingStyle>,
		time?: number,
		override?: boolean,
		callback?: (finishedTween: Enum.TweenStatus) => void,
	): boolean;
	/** Smoothly resizes and moves a GUI to a new `UDim2` size and position in the specified time using the specified `EasingDirection` and `EasingStyle`. 

This function will return whether the tween will play. Normally this will always return true, but it will return false if another tween is active and override is set to false.

## See also
 - `TweenSize`, tweens a GUI's size
 - `TweenPosition`, tweens a GUI's position

## Code Samples

### Tween a GUI's Size and Position

The below example would tween a `/Frame` to the top left of the parent's size and resize it down to 0.
```lua
local frame = script.Parent.Frame
frame:TweenSizeAndPosition(UDim2.new(0,0,0,0), UDim2.new(0,0,0,0))

```

@param endSize The size that the GUI should resize
@param endPosition Where the GUI should move to
@param easingDirection The direction in which to ease the GUI to the *endPosition*
@param easingStyle The style in which to ease the GUI to the *endPosition*
@param time How long, in seconds, the tween should take to complete
@param override Whether another tween play, cancelling this tween, before the GUI reaches the *endPosition*
@param callback A callback function to execute when the tween completes
@returns Whether the tween will play */
	TweenSizeAndPosition(
		endSize: UDim2,
		endPosition: UDim2,
		easingDirection?: CastsToEnum<Enum.EasingDirection>,
		easingStyle?: CastsToEnum<Enum.EasingStyle>,
		time?: number,
		override?: boolean,
		callback?: (finishedTween: Enum.TweenStatus) => void,
	): boolean;
	/** This event fires when a user begins interacting with the `GuiObject` via a Human-Computer Interface device (Mouse button down, touch begin, keyboard button down, etc).

The `UserInputService` has a similarly named event that is not restricted to a specific UI element: `InputBegan`.

This event will always fire regardless of game state.

## See also
 - `InputEnded`
 - `InputChanged`

## Code Samples

### Tracking the Beginning of Input on a GuiObject

The following example demonstrates one of many usage examples of handling user input from InputBegan depending on its type.

In order for this to work as expected, it must be placed in a `LocalScript` and a child of *gui*.
```lua
-- In order to use the InputBegan event, you must specify the GuiObject
local gui = script.Parent

-- A sample function providing multiple usage cases for various types of user input
local function inputBegan(input)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyPressed = input.KeyCode
		print("A key is being pushed down! Key:",input.KeyCode)
	elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
		print("The left mouse button has been pressed down at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		print("The right mouse button has been pressed down at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Touch then
		print("A touchscreen input has started at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
		print("A button is being pressed on a gamepad! Button:",input.KeyCode)
	end
end

gui.InputBegan:Connect(inputBegan)
```
 */
	readonly InputBegan: RBXScriptSignal<(input: InputObject) => void>;
	/** This event fires when a user changes how they're interacting via a Human-Computer Interface device (Mouse button down, touch begin, keyboard button down, etc).

The `UserInputService` has a similarly named event that is not restricted to a specific UI element: `InputChanged`.

This event will always fire regardless of game state.

## See also
 - `InputBegan`
 - `InputEnded`

## Code Samples

### GuiObject InputChanged Demo

The following example demonstrates one of many usage examples of handling user input from InputChanged depending on its type.

In order for this to work as expected, it must be placed in a `LocalScript` and a child of *gui*.
```lua
-- In order to use the InputChanged event, you must specify a GuiObject
local gui = script.Parent

-- Prints the current input position and the change (delta) in position 
local function printMovement(input)
	print("\tPosition:",input.Position)
	print("\tMovement Delta:",input.Delta)
end
 
-- A sample function providing multiple usage cases for various types of user input
local function inputChanged(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		print("The mouse has been moved!")
		printMovement(input)
	elseif input.UserInputType == Enum.UserInputType.MouseWheel then
		print("The mouse wheel has been scrolled!")
		print("\tWheel Movement:",input.Position.Z)
	elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
		if input.KeyCode == Enum.KeyCode.Thumbstick1 then
			print("The left thumbstick has been moved!")
			printMovement(input)
		elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
			print("The right thumbstick has been moved!")
			printMovement(input)
		elseif input.KeyCode == Enum.KeyCode.ButtonL2 then
			print("The pressure being applied to the left trigger has changed!")
			print("\tPressure:",input.Position.Z)
		elseif input.KeyCode == Enum.KeyCode.ButtonR2 then
			print("The pressure being applied to the right trigger has changed!")
			print("\tPressure:",input.Position.Z)
		end
	elseif input.UserInputType == Enum.UserInputType.Touch then
		print("The user's finger is moving on the screen!")
		printMovement(input)
	elseif input.UserInputType == Enum.UserInputType.Gyro then
		local rotInput,rotCFrame = UserInputService:GetDeviceRotation()
		local rotX,rotY,rotZ = rotCFrame:toEulerAnglesXYZ()
		local rot = Vector3.new(math.deg(rotX),math.deg(rotY),math.deg(rotZ))
		print("The rotation of the user's mobile device has been changed!")
		print("\tPosition",rotCFrame.p)
		print("\tRotation:",rot)
	elseif input.UserInputType == Enum.UserInputType.Accelerometer then
		print("The acceleration of the user's mobile device has been changed!")
		printMovement(input)
	end	
end

gui.InputChanged:Connect(inputChanged)
```
 */
	readonly InputChanged: RBXScriptSignal<(input: InputObject) => void>;
	/** The InputEnded event fires when a user stops interacting via a Human-Computer Interface device (Mouse button down, touch begin, keyboard button down, etc).

The `UserInputService` has a similarly named event that is not restricted to a specific UI element: `InputEnded`.

This event will always fire regardless of game state.

## See also
 - `InputBegan`
 - `InputChanged`

## Code Samples

### Tracking the End of Input on a GuiObject

The following example demonstrates one of many usage examples of handling user input from InputEnded depending on its type.

In order for this to work as expected, it must be placed in a `LocalScript` and a child of *gui*.
```lua
-- In order to use the InputChanged event, you must specify a GuiObject
local gui = script.Parent
 
-- A sample function providing multiple usage cases for various types of user input
local function inputEnded(input)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyPressed = input.KeyCode
		print("A key has been released! Key:",input.KeyCode)
	elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
		print("The left mouse button has been released at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		print("The right mouse button has been released at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Touch then
		print("A touchscreen input has been released at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
		print("A button has been released on a gamepad! Button:",input.KeyCode)
	end
end

gui.InputEnded:Connect(inputEnded)
```
 */
	readonly InputEnded: RBXScriptSignal<(input: InputObject) => void>;
	/** The MouseEnter event fires when a user moves their mouse into a `GUI` element.

Please do not rely on the `x` and `y` arguments passed by this event as a fool-proof way to to determine where the user's mouse is when it enters a GUI. These coordinates may vary even when the mouse enters the GUI via the same edge - particularly when the mouse enters the element quickly. This is due to the fact the coordinates indicate the position of the mouse when the event fires rather than the exact moment the mouse enters the GUI.

This event fires even when the GUI element renders beneath another element.

If you would like to track when a user's mouse leaves a GUI element, you can use the `MouseLeave` event.

## See also
 - `MouseLeave`
 - `MouseMoved`
 - `MouseWheelForward`
 - `MouseWheelBackward`

## Code Samples

### Drawing Canvas GUI

The code sample below creates a GUI `Frame` that acts as a canvas that can be drawn on and cleared.

It uses two `UserInputService` events, `InputBegan` and `InputEnded` to determine when the user's left mouse button is down. These events set the `hold` variable so that the `paint` function only draws a new pixel if the user's left mouse button is pressed.

When the user's mouse moves on the canvas, the pointer GUI moves to follow the mouse and, if the `hold` is true, clones the pointer to draw a new pixel onto the canvas at the pointer's location. The pointer's visibility is set to false when the mouse exits the GUI and to true when the mouse enters the GUI.

Pressing the clear button destroys all Canvas children named "Pixel" to clear the canvas.

![Canvas GUI Demonstration](https://developer.roblox.com/assets/5b99be8c884dfd197f6a4f12/CanvasGuiDemo.gif)

![Gui in Studio Explorer](https://developer.roblox.com/assets/5b99beaa8c2893307fc1149a/CanvasGuiExplorer.png)
```lua
-- Services
local UserInputService = game:GetService("UserInputService")

-- GUI Elements
local Canvas = script.Parent
local ClearButton = script.Parent.Parent:FindFirstChild("ClearButton")
local pointer = Canvas:FindFirstChild("Pointer")

-- Player's Mouse
local mouse = game.Players.LocalPlayer:GetMouse()

-- Global boolean indicating whether player's MouseButton1 is down
local hold = false

function paint(X, Y)	
	local gui_X = Canvas.AbsolutePosition.X
	local gui_Y = Canvas.AbsolutePosition.Y
		
	local offset = Vector2.new(math.abs(X - gui_X), math.abs(Y - gui_Y - 36))
	pointer.Position = UDim2.new(0, offset.X, 0, offset.Y)
	
	if hold == false then return end
		
	local pixel = pointer:Clone()
	pixel.Name = "Pixel"
	pixel.Parent = Canvas
end

function clear()
	local children = Canvas:GetChildren()
	
	for i, child in pairs (children) do
		if child.Name == "Pixel" then
			child:Destroy()
		end
	end
end

function showPointer()
	pointer.Visible = true
end

function hidePointer()
	pointer.Visible = false
end

function inputBegan(input)
	local inputType = input.UserInputType
	  if inputType == Enum.UserInputType.MouseButton1 then
        hold = true
    end
end

function inputEnded(input)
	local inputType = input.UserInputType
	if inputType == Enum.UserInputType.MouseButton1 then
		hold = false
	end
end

-- Events
ClearButton.MouseButton1Click:Connect(clear)

UserInputService.InputBegan:Connect(inputBegan)
UserInputService.InputEnded:Connect(inputEnded)

Canvas.MouseMoved:Connect(paint)
Canvas.MouseEnter:Connect(showPointer)
Canvas.MouseLeave:Connect(hidePointer)
```

### Printing where a Mouse Enters a GuiObject

The following example prints the mouse location, in pixels, when it enters GUI element.
```lua

GuiObject.MouseEnter:Connect(function(x, y)
	print("The user's mouse cursor has entered the GuiObject at position (" .. x .. ", " .. y .. ").")
end)

```
 */
	readonly MouseEnter: RBXScriptSignal<(x: number, y: number) => void>;
	/** The MouseLeave event fires when a user moves their mouse out of a `GUI` element.

Please do not rely on the `x` and `y` arguments passed by this event as a fool-proof way to to determine where the user's mouse is when it leaves a GUI. These coordinates may vary even when the mouse leaves the GUI via the same edge - particularly when the mouse leaves the element quickly. This is due to the fact the coordinates indicate the position of the mouse when the event fires rather than the exact moment the mouse leaves the GUI.

This event fires even when the GUI element renders beneath another element.

## See also
 - `MouseEnter`
 - `MouseMoved`
 - `MouseWheelForward`
 - `MouseWheelBackward`

## Code Samples

### Drawing Canvas GUI

The code sample below creates a GUI `Frame` that acts as a canvas that can be drawn on and cleared.

It uses two `UserInputService` events, `InputBegan` and `InputEnded` to determine when the user's left mouse button is down. These events set the `hold` variable so that the `paint` function only draws a new pixel if the user's left mouse button is pressed.

When the user's mouse moves on the canvas, the pointer GUI moves to follow the mouse and, if the `hold` is true, clones the pointer to draw a new pixel onto the canvas at the pointer's location. The pointer's visibility is set to false when the mouse exits the GUI and to true when the mouse enters the GUI.

Pressing the clear button destroys all Canvas children named "Pixel" to clear the canvas.

![Canvas GUI Demonstration](https://developer.roblox.com/assets/5b99be8c884dfd197f6a4f12/CanvasGuiDemo.gif)

![Gui in Studio Explorer](https://developer.roblox.com/assets/5b99beaa8c2893307fc1149a/CanvasGuiExplorer.png)
```lua
-- Services
local UserInputService = game:GetService("UserInputService")

-- GUI Elements
local Canvas = script.Parent
local ClearButton = script.Parent.Parent:FindFirstChild("ClearButton")
local pointer = Canvas:FindFirstChild("Pointer")

-- Player's Mouse
local mouse = game.Players.LocalPlayer:GetMouse()

-- Global boolean indicating whether player's MouseButton1 is down
local hold = false

function paint(X, Y)	
	local gui_X = Canvas.AbsolutePosition.X
	local gui_Y = Canvas.AbsolutePosition.Y
		
	local offset = Vector2.new(math.abs(X - gui_X), math.abs(Y - gui_Y - 36))
	pointer.Position = UDim2.new(0, offset.X, 0, offset.Y)
	
	if hold == false then return end
		
	local pixel = pointer:Clone()
	pixel.Name = "Pixel"
	pixel.Parent = Canvas
end

function clear()
	local children = Canvas:GetChildren()
	
	for i, child in pairs (children) do
		if child.Name == "Pixel" then
			child:Destroy()
		end
	end
end

function showPointer()
	pointer.Visible = true
end

function hidePointer()
	pointer.Visible = false
end

function inputBegan(input)
	local inputType = input.UserInputType
	  if inputType == Enum.UserInputType.MouseButton1 then
        hold = true
    end
end

function inputEnded(input)
	local inputType = input.UserInputType
	if inputType == Enum.UserInputType.MouseButton1 then
		hold = false
	end
end

-- Events
ClearButton.MouseButton1Click:Connect(clear)

UserInputService.InputBegan:Connect(inputBegan)
UserInputService.InputEnded:Connect(inputEnded)

Canvas.MouseMoved:Connect(paint)
Canvas.MouseEnter:Connect(showPointer)
Canvas.MouseLeave:Connect(hidePointer)
```
 */
	readonly MouseLeave: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fires whenever a user moves their mouse while it is inside a `GUI` element. It is similar to `Move`, which fires regardless whether the user's mouse is over a GUI element.

Note, this event fires when the mouse's position is updated, therefore it will fire repeatedly whilst being moved.

The `x` and `y` arguments indicate the updated screen coordinates of the user's mouse in pixels. These can be useful to determine the mouse's location on the GUI, screen, and delta since the mouse's previous position if it is being tracked in a global variable.

The code below demonstrates how to determine the `Vector2` offset of the user's mouse relative to a GUI element:

```lua
local CustomScrollingFrame = script.Parent
local SubFrame = CustomScrollingFrame:FindFirstChild("SubFrame")

local mouse = game.Players.LocalPlayer:GetMouse()
function getPosition(X, Y)
	local gui_X = CustomScrollingFrame.AbsolutePosition.X
	local gui_Y = CustomScrollingFrame.AbsolutePosition.Y
	
	
	local pos = Vector2.new(math.abs(X - gui_X), math.abs(Y - gui_Y - 36))
	print(pos)
end

CustomScrollingFrame.MouseMoved:Connect(getPosition)
```


Note that this event may not fire exactly when the user's mouse enters or exits a GUI element. Therefore, the `x` and `y` arguments may not match up perfectly to the coordinates of the GUI's edges.

## See also
 - `MouseEnter`
 - `MouseLeave`
 - `MouseWheelForward`
 - `MouseWheelBackward`

## Code Samples

### Drawing Canvas GUI

The code sample below creates a GUI `Frame` that acts as a canvas that can be drawn on and cleared.

It uses two `UserInputService` events, `InputBegan` and `InputEnded` to determine when the user's left mouse button is down. These events set the `hold` variable so that the `paint` function only draws a new pixel if the user's left mouse button is pressed.

When the user's mouse moves on the canvas, the pointer GUI moves to follow the mouse and, if the `hold` is true, clones the pointer to draw a new pixel onto the canvas at the pointer's location. The pointer's visibility is set to false when the mouse exits the GUI and to true when the mouse enters the GUI.

Pressing the clear button destroys all Canvas children named "Pixel" to clear the canvas.

![Canvas GUI Demonstration](https://developer.roblox.com/assets/5b99be8c884dfd197f6a4f12/CanvasGuiDemo.gif)

![Gui in Studio Explorer](https://developer.roblox.com/assets/5b99beaa8c2893307fc1149a/CanvasGuiExplorer.png)
```lua
-- Services
local UserInputService = game:GetService("UserInputService")

-- GUI Elements
local Canvas = script.Parent
local ClearButton = script.Parent.Parent:FindFirstChild("ClearButton")
local pointer = Canvas:FindFirstChild("Pointer")

-- Player's Mouse
local mouse = game.Players.LocalPlayer:GetMouse()

-- Global boolean indicating whether player's MouseButton1 is down
local hold = false

function paint(X, Y)	
	local gui_X = Canvas.AbsolutePosition.X
	local gui_Y = Canvas.AbsolutePosition.Y
		
	local offset = Vector2.new(math.abs(X - gui_X), math.abs(Y - gui_Y - 36))
	pointer.Position = UDim2.new(0, offset.X, 0, offset.Y)
	
	if hold == false then return end
		
	local pixel = pointer:Clone()
	pixel.Name = "Pixel"
	pixel.Parent = Canvas
end

function clear()
	local children = Canvas:GetChildren()
	
	for i, child in pairs (children) do
		if child.Name == "Pixel" then
			child:Destroy()
		end
	end
end

function showPointer()
	pointer.Visible = true
end

function hidePointer()
	pointer.Visible = false
end

function inputBegan(input)
	local inputType = input.UserInputType
	  if inputType == Enum.UserInputType.MouseButton1 then
        hold = true
    end
end

function inputEnded(input)
	local inputType = input.UserInputType
	if inputType == Enum.UserInputType.MouseButton1 then
		hold = false
	end
end

-- Events
ClearButton.MouseButton1Click:Connect(clear)

UserInputService.InputBegan:Connect(inputBegan)
UserInputService.InputEnded:Connect(inputEnded)

Canvas.MouseMoved:Connect(paint)
Canvas.MouseEnter:Connect(showPointer)
Canvas.MouseLeave:Connect(hidePointer)
```
 */
	readonly MouseMoved: RBXScriptSignal<(x: number, y: number) => void>;
	/** The WheelBackward event fires when a user scrolls their mouse wheel back when the mouse is over a `GUI` element. It is similar to `WheelBackward`, which fires regardless whether the user's mouse is over a GUI element.

This event fires merely as an indicator of the wheel's forward movement. This means that the x and y mouse coordinate arguments do not change as a result of this event. These coordinates only change when the mouse moves, which can be tracked by the `MouseMoved` event.

## See also
 - `MouseEnter`
 - `MouseLeave`
 - `MouseMoved`
 - `MouseWheelForward`

## Code Samples

### Custom Scrolling GUI

The example below creates a custom scrolling frame using a `Frame` to mimic a `ScrollingFrame` using the `MouseWheelForward` and `MouseWheelBackward`.

The example works by moving a Frame that is the child of our **CustomScrollingFrame** and parent to the `TextBoxes`. Thus, we use a Frame to act as a container for the GUI elements we want to scroll. The script adjust's the `UDim2` **Y** scale position of the Frame between 0 and -1 when the user scroll's their mouse forward and backward to mimic the scrolling of a traditional ScrollingFrame element.

Although this is a simple application of the MouseWheel events, it can be expanded upon for more complex `GUI` layouts and interaction such as custom ScrollingFrames that scroll at different rates or with different elasticity.

The gif below demonstrates the expected functionality of the code based on the GUI layout also shown below.

![Code sample demonstration](https://developer.roblox.com/assets/5b98786746674ff33ad968be/CustomScrollingFrameDemo.gif)

![GUI Layout in Studio Explorer Window](https://developer.roblox.com/assets/5b98787873f3b02c7fa58f32/Screen_Shot_2018-09-11_at_10.21.41_PM.png)
```lua
local CustomScrollingFrame = script.Parent
local SubFrame = CustomScrollingFrame:FindFirstChild("SubFrame")

function scrollUp(x, y)
	if SubFrame.Position.Y.Scale < 0  then
		SubFrame.Position = SubFrame.Position + UDim2.new(0, 0, .015, 0)
	elseif SubFrame.Position.Y.Scale > 0 then
		SubFrame.Position = UDim2.new(SubFrame.Position.X.Scale, 
			SubFrame.Position.X.Offset, 0, SubFrame.Position.Y.Offset)
	end
end

function scrollDown(x, y)
	if SubFrame.Position.Y.Scale > -1 then
		SubFrame.Position = SubFrame.Position - UDim2.new(0, 0, .015, 0)
	elseif SubFrame.Position.Y.Scale < -1 then
		SubFrame.Position = UDim2.new(SubFrame.Position.X.Scale, 
			SubFrame.Position.X.Offset, -1, SubFrame.Position.Y.Offset)
	end
end

CustomScrollingFrame.MouseWheelForward:Connect(scrollUp)
CustomScrollingFrame.MouseWheelBackward:Connect(scrollDown)
```
 */
	readonly MouseWheelBackward: RBXScriptSignal<(x: number, y: number) => void>;
	/** The WheelForward event fires when a user scrolls their mouse wheel forward when the mouse is over a `GUI` element. It is similar to `WheelForward`, which fires regardless whether the user's mouse is over a GUI element.

This event fires merely as an indicator of the wheel's forward movement. This means that the x and y mouse coordinate arguments do not change as a result of this event. These coordinates only change when the mouse moves, which can be tracked by the `MouseMoved` event.

## See also
 - `MouseEnter`
 - `MouseLeave`
 - `MouseMoved`
 - `MouseWheelBackward`

## Code Samples

### Custom Scrolling GUI

The example below creates a custom scrolling frame using a `Frame` to mimic a `ScrollingFrame` using the `MouseWheelForward` and `MouseWheelBackward`.

The example works by moving a Frame that is the child of our **CustomScrollingFrame** and parent to the `TextBoxes`. Thus, we use a Frame to act as a container for the GUI elements we want to scroll. The script adjust's the `UDim2` **Y** scale position of the Frame between 0 and -1 when the user scroll's their mouse forward and backward to mimic the scrolling of a traditional ScrollingFrame element.

Although this is a simple application of the MouseWheel events, it can be expanded upon for more complex `GUI` layouts and interaction such as custom ScrollingFrames that scroll at different rates or with different elasticity.

The gif below demonstrates the expected functionality of the code based on the GUI layout also shown below.

![Code sample demonstration](https://developer.roblox.com/assets/5b98786746674ff33ad968be/CustomScrollingFrameDemo.gif)

![GUI Layout in Studio Explorer Window](https://developer.roblox.com/assets/5b98787873f3b02c7fa58f32/Screen_Shot_2018-09-11_at_10.21.41_PM.png)
```lua
local CustomScrollingFrame = script.Parent
local SubFrame = CustomScrollingFrame:FindFirstChild("SubFrame")

function scrollUp(x, y)
	if SubFrame.Position.Y.Scale < 0  then
		SubFrame.Position = SubFrame.Position + UDim2.new(0, 0, .015, 0)
	elseif SubFrame.Position.Y.Scale > 0 then
		SubFrame.Position = UDim2.new(SubFrame.Position.X.Scale, 
			SubFrame.Position.X.Offset, 0, SubFrame.Position.Y.Offset)
	end
end

function scrollDown(x, y)
	if SubFrame.Position.Y.Scale > -1 then
		SubFrame.Position = SubFrame.Position - UDim2.new(0, 0, .015, 0)
	elseif SubFrame.Position.Y.Scale < -1 then
		SubFrame.Position = UDim2.new(SubFrame.Position.X.Scale, 
			SubFrame.Position.X.Offset, -1, SubFrame.Position.Y.Offset)
	end
end

CustomScrollingFrame.MouseWheelForward:Connect(scrollUp)
CustomScrollingFrame.MouseWheelBackward:Connect(scrollDown)
```
 */
	readonly MouseWheelForward: RBXScriptSignal<(x: number, y: number) => void>;
	/** This event fires when the Gamepad selector starts focusing on the `GuiObject`.

If you want to check from the Gamepad select stops focusing on the GUI element, you can use the `SelectionLost` event.

When a GUI gains selection focus, the value of the `SelectionObject` property also changes to the that gains selection. To determine which GUI gained selection, check the value of this property.

## Code Samples

### Handling GUI Selection Gained

The following example prints a message when the user selects the object with a gamepad.

In order for this to work as expected, it must be placed in a `LocalScript` and a child of *gui*.
```lua
local gui = script.Parent

local function selectionGained()
	print("The user has selected this button with a gamepad.")
end

GuiObject.SelectionGained:Connect(selectionGained)
```
 */
	readonly SelectionGained: RBXScriptSignal<() => void>;
	/** This event fires when the Gamepad selector stops focusing on the `GUI`.

If you want to check from the Gamepad select starts focusing on the GUI element, you can use the `SelectionGained` event.

When a GUI loses selection focus, the value of the `SelectionObject` property changes either to nil or to the GUI element that gains selection focus. To determine which GUI gained selection, or if no GUI is selected, check the value of this property.

## Code Samples

### Handling GUI Selection Lost

The following example prints a message when the element has its focus lost on a gamepad.

In order for this to work as expected, it must be placed in a `LocalScript` and a child of *gui*.
```lua
local gui = script.Parent

local function selectionLost()
	print("The user no longer has this selected with their gamepad.")
end

GuiObject.SelectionLost:Connect(selectionLost)
```
 */
	readonly SelectionLost: RBXScriptSignal<() => void>;
	/** The TouchLongPress event fires after a brief moment when the player holds their finger on the UI element using a touch-enabled device. It fires with a table of `Vector2` that describe the relative screen positions of the fingers involved in the gesture. In addition, it fires multiple times with multiple `UserInputState`s: Begin after a brief delay, Change if the player moves their finger during the gesture and finally with End. The delay is platform dependent; in Studio it is a little longer than one second.

Since this event only requires one finger, this event can be simulated in Studio using the emulator and a mouse. Below is an example of TouchLongPress firing on a Frame that is `Active`. Below, the event fires after a brief delay (Begin) and then continually as as the finger is moved (Change). It fires one last time after it is released (End).

![TouchLongPress gesture](https://developer.roblox.com/assets/blt0bff2c10ae8eddd2/TouchLongPress.gif)

This event is part of a family of touch-related events. Other events like this one are `TouchTap`, `TouchRotate`, `TouchPinch`, `TouchPan` and `TouchSwipe`. In addition, `UserInputService` has a similarly named event that is not restricted to a specific UI element: `TouchLongPress`.

## Code Samples

### Move UI Element with TouchLongPress

This code sample allows the player to manipulate the screen position of some UI element, like a `Frame`, by holding down on the UI element for a brief moment. Then, the player moves their finger and releases. During the gesture the Frame is colored blue with a white outline.
```lua
local frame = script.Parent
frame.Active = true

local dragging = false
local basePosition
local startTouchPosition
local borderColor3
local backgroundColor3

local function onTouchLongPress(touchPositions, state)
	if state == Enum.UserInputState.Begin and not dragging then
		-- Start a drag 
		dragging = true
		basePosition = frame.Position
		startTouchPosition = touchPositions[1]
		-- Color the frame to indicate the drag is happening
		borderColor3 = frame.BorderColor3
		backgroundColor3 = frame.BackgroundColor3
		frame.BorderColor3 = Color3.new(1, 1, 1) -- White
		frame.BackgroundColor3 = Color3.new(0, 0, 1) -- Blue
	elseif state == Enum.UserInputState.Change then
		local touchPosition = touchPositions[1]
		local deltaPosition = UDim2.new(
			0, touchPosition.X - startTouchPosition.X,
			0, touchPosition.Y - startTouchPosition.Y
		)
		frame.Position = basePosition + deltaPosition
	elseif state == Enum.UserInputState.End and dragging then
		-- Stop the drag
		dragging = false
		frame.BorderColor3 = borderColor3
		frame.BackgroundColor3 = backgroundColor3
	end
end

frame.TouchLongPress:Connect(onTouchLongPress)
```
 */
	readonly TouchLongPress: RBXScriptSignal<(touchPositions: Array<Vector2>, state: Enum.UserInputState) => void>;
	/** The TouchPan event fires when the player moves their finger on the UI element using a touch-enabled device. It fires shortly before `TouchSwipe` would, and does not fire with `TouchTap`. This event is useful for allowing the player to manipulate the position of UI elements on the screen.

This event fires with a table of `Vector2` that describe the relative screen positions of the fingers involved in the gesture. In addition, it fires several times with multiple `UserInputState`s: Begin after a brief delay, Change when the player moves their finger during the gesture and finally once more with End.

This event cannot be simulated in Studio using the emulator and a mouse; you must have a real touch enabled device to fire this event. Below is an animation of TouchPan firing on the black semitransparent `Frame` that covers the screen. The event is being used to manipulate the position of the pink inner `Frame`. The code for this can be found in the code samples.

![TouchPan firing on a real touch-enabled device](https://developer.roblox.com/assets/bltdc72a67282ec5330/TouchPan.gif)

This event is part of a family of touch-related events. Other events like this one are `TouchTap`, `TouchRotate`, `TouchPinch`, `TouchLongPress` and `TouchSwipe`. In addition, `UserInputService` has a similarly named event that is not restricted to a specific UI element: `TouchPan`.

## Code Samples

### Panning UI Element

This code sample is meant to be placed in a `LocalScript` within an inner `Frame` that is inside an outer `Frame`, or other `GuiObject`. It allows the player to manipulate the position of the inner frame by moving their finger on the outer frame.
```lua
local innerFrame = script.Parent
local outerFrame = innerFrame.Parent
outerFrame.BackgroundTransparency = 0.75
outerFrame.Active = true
outerFrame.Size = UDim2.new(1, 0, 1, 0)
outerFrame.Position = UDim2.new(0, 0, 0, 0)
outerFrame.AnchorPoint = Vector2.new(0, 0)
outerFrame.ClipsDescendants = true

local dragging = false
local basePosition

local function onTouchPan(touchPositions, totalTranslation, velocity, state)
	if state == Enum.UserInputState.Begin and not dragging then
		dragging = true
		basePosition = innerFrame.Position
		outerFrame.BackgroundTransparency = 0.25
	elseif state == Enum.UserInputState.Change then
		innerFrame.Position = basePosition + UDim2.new(
			0, totalTranslation.X,
			0, totalTranslation.Y
		)
	elseif state == Enum.UserInputState.End and dragging then
		dragging = false
		outerFrame.BackgroundTransparency = 0.75
	end
end

outerFrame.TouchPan:Connect(onTouchPan)
```
 */
	readonly TouchPan: RBXScriptSignal<
		(
			touchPositions: Array<Vector2>,
			totalTranslation: Vector2,
			velocity: Vector2,
			state: Enum.UserInputState,
		) => void
	>;
	/** The TouchPinch event fires when the player uses two fingers to make a pinch or pull gesture on the UI element using a touch-enabled device. A **pinch** happens when two or more fingers move closer together, and a **pull** happens when they move apart. This event fires in conjunction with `TouchPan`. This event is useful for allowing the player to manipulate the scale (size) of UI elements on the screen, and is most often used for zooming features.

This event fires with a table of `Vector2` that describe the relative screen positions of the fingers involved in the gesture. In addition, it fires several times with multiple `UserInputState`s: Begin after a brief delay, Change when the player moves a finger during the gesture and finally once more with End. It should be noted that the scale should be used **multiplicatively**. 

Since this event requires at least two fingers, it is not possible to be simulated in Studio using the emulator and a mouse; you must have a real touch-enabled device (and also least two fingers, try asking a friend). Below is an animation of TouchPinch firing on the black semitransparent `Frame` that covers the screen (note the touch positions marked with white circles). The event is being used to manipulate the scale of the `TextLabel` that says "Hi!". The code for this can be found in the code samples.

![TouchPinch firing on a real touch device](https://developer.roblox.com/assets/bltca171fa11cf4782d/TouchPinch.gif)

This event is part of a family of touch-related events. Other events like this one are `TouchTap`, `TouchRotate`, `TouchPan`, `TouchLongPress` and `TouchSwipe`. In addition, `UserInputService` has a similarly named event that is not restricted to a specific UI element: `TouchPinch`.

## Code Samples

### Pinch/Pull Scaling

This code sample is meant for a `LocalScript` within an inner `Frame` that is inside an outer `Frame`, or other `GuiObject`. It allows the player to scale the inner frame by performing a `TouchPinch` gesture on the outer frame.
```lua
local innerFrame = script.Parent
local outerFrame = innerFrame.Parent
outerFrame.BackgroundTransparency = 0.75
outerFrame.Active = true
outerFrame.Size = UDim2.new(1, 0, 1, 0)
outerFrame.Position = UDim2.new(0, 0, 0, 0)
outerFrame.AnchorPoint = Vector2.new(0, 0)
outerFrame.ClipsDescendants = true

local dragging = false
local uiScale = Instance.new("UIScale")
uiScale.Parent = innerFrame
local baseScale

local function onTouchPinch(touchPositions, scale, velocity, state)
	if state == Enum.UserInputState.Begin and not dragging then
		dragging = true
		baseScale = uiScale.Scale
		outerFrame.BackgroundTransparency = 0.25
	elseif state == Enum.UserInputState.Change then
		uiScale.Scale = baseScale * scale -- Notice the multiplication here
	elseif state == Enum.UserInputState.End and dragging then
		dragging = false
		outerFrame.BackgroundTransparency = 0.75
	end
end

outerFrame.TouchPinch:Connect(onTouchPinch)
```
 */
	readonly TouchPinch: RBXScriptSignal<
		(touchPositions: Array<Vector2>, scale: number, velocity: number, state: Enum.UserInputState) => void
	>;
	/** The TouchRotate event fires when the player uses two fingers to make a pinch or pull gesture on the UI element using a touch-enabled device. Rotation occurs when the angle of the line between two fingers changes. This event fires in conjunction with `TouchPan`. This event is useful for allowing the player to manipulate the rotation of UI elements on the screen.

This event fires with a table of `Vector2` that describe the relative screen positions of the fingers involved in the gesture. In addition, it fires several times with multiple `UserInputState`s: Begin after a brief delay, Change when the player moves a finger during the gesture and finally once more with End.

Since this event requires at least two fingers, it is not possible to be simulated in Studio using the emulator and a mouse; you must have a real touch-enabled device (and also least two fingers, try asking a friend). 

This event is part of a family of touch-related events. Other events like this one are `TouchTap`, `TouchPinch`, `TouchPan`, `TouchLongPress` and `TouchSwipe`. In addition, `UserInputService` has a similarly named event that is not restricted to a specific UI element: `TouchRotate`.

## Code Samples

### Touch Rotation

This code sample is meant for a `LocalScript` within an inner `Frame` that is inside an outer `Frame`, or other `GuiObject`. It allows the player to rotate the inner frame by performing a `TouchRotate` gesture on the outer frame.
```lua
local innerFrame = script.Parent
local outerFrame = innerFrame.Parent
outerFrame.BackgroundTransparency = 0.75
outerFrame.Active = true
outerFrame.Size = UDim2.new(1, 0, 1, 0)
outerFrame.Position = UDim2.new(0, 0, 0, 0)
outerFrame.AnchorPoint = Vector2.new(0, 0)
outerFrame.ClipsDescendants = true

local dragging = false
local baseRotation = innerFrame.Rotation

local function onTouchRotate(touchPositions, rotation, velocity, state)
	if state == Enum.UserInputState.Begin and not dragging then
		dragging = true
		baseRotation = innerFrame.Rotation
		outerFrame.BackgroundTransparency = 0.25
	elseif state == Enum.UserInputState.Change then
		innerFrame.Rotation = baseRotation + rotation
	elseif state == Enum.UserInputState.End and dragging then
		dragging = false
		outerFrame.BackgroundTransparency = 0.75
	end
end

outerFrame.TouchRotate:Connect(onTouchRotate)
```
 */
	readonly TouchRotate: RBXScriptSignal<
		(touchPositions: Array<Vector2>, rotation: number, velocity: number, state: Enum.UserInputState) => void
	>;
	/** The TouchSwipe event fires when the player performs a swipe gesture on the UI element using a touch-enabled device. It fires with the direction of the gesture (Up, Down, Left or Right) and the number of touch points involved in the gesture. Swipe gestures are often used to change tabs in mobile UIs.

Since this event only requires one finger, this event can be simulated in Studio using the emulator and a mouse. Below is an example of TouchSwipe being fired on a Frame that is `Active`. Below, the event fires when the Frame moves and changes color slightly. The code for this can be found the code samples.

![TouchSwipe event firing on a Frame](https://developer.roblox.com/assets/bltca477d4e524ee20d/TouchSwipe.gif)

This event is part of a family of touch-related events. Other events like this one are `TouchTap`, `TouchRotate`, `TouchPinch`, `TouchPan` and `TouchLongPress`. In addition, `UserInputService` has a similarly named event that is not restricted to a specific UI element: `TouchSwipe`.

## Code Samples

### Bouncing Color Picker

This code sample will cause a `Frame` (or other `GuiObject`) to bounce when a swipe gesture is performed on a touch-enabled device (or Studio's emulator). Horizontal swipes will change the hue of the `BackgroundColor3`, while vertical swipes will change the saturation.
```lua
local frame = script.Parent
frame.Active = true

-- How far the frame should bounce on a successful swipe
local BOUNCE_DISTANCE = 50

-- Current state of the frame
local basePosition = frame.Position
local hue = 0
local saturation = 128

local function updateColor()
	frame.BackgroundColor3 = Color3.fromHSV(hue/256, saturation/256, 1)
end

local function onTouchSwipe(swipeDir, touchCount)
	-- Change the BackgroundColor3 based on the swipe direction
	local deltaPos
	if swipeDir == Enum.SwipeDirection.Right then
		deltaPos = UDim2.new(0, BOUNCE_DISTANCE, 0, 0)
		hue = (hue + 16) % 255
	elseif swipeDir == Enum.SwipeDirection.Left then
		deltaPos = UDim2.new(0, -BOUNCE_DISTANCE, 0, 0)
		hue = (hue - 16) % 255
	elseif swipeDir == Enum.SwipeDirection.Up then
		deltaPos = UDim2.new(0, 0, 0, -BOUNCE_DISTANCE)
		saturation = (saturation + 16) % 255
	elseif swipeDir == Enum.SwipeDirection.Down then
		deltaPos = UDim2.new(0, 0, 0, BOUNCE_DISTANCE)
		saturation = (saturation - 16) % 255
	else
		deltaPos = UDim2.new()
	end
	-- Update the color and bounce the frame a little
	updateColor()
	frame.Position = basePosition + deltaPos
	frame:TweenPosition(basePosition, Enum.EasingDirection.Out, Enum.EasingStyle.Bounce, .7, true)
end

frame.TouchSwipe:Connect(onTouchSwipe)
updateColor()

```
 */
	readonly TouchSwipe: RBXScriptSignal<(swipeDirection: Enum.SwipeDirection, numberOfTouches: number) => void>;
	/** The TouchTap event fires when the player performs a tap gesture on the UI element using a touch-enabled device. A tap is a quick single touch without any movement involved (a longer press would fire `TouchLongPress`, and moving during the touch would fire `TouchPan` and/or `TouchSwipe`). It fires with a table of `Vector2`s that describe the relative positions of the fingers involved in the gesture.

Since this event only requires one finger, this event can be simulated in Studio using the emulator and a mouse. Below is an example of TouchTap being fired on a Frame that is `Active`. Below, the event fires when the cursor briefly pauses (to simulate a tap) and the Frame toggles its `BackgroundTransparency`. The code for this can be found the code samples.

![TouchTap being fired on a Frame using Studio's emulator](https://developer.roblox.com/assets/blta6f0c03b744fa52b/TouchTap.gif)

This event is part of a family of touch-related events. Other events like this one are `TouchSwipe`, `TouchRotate`, `TouchPinch`, `TouchPan` and `TouchLongPress`. In addition, `UserInputService` has a similarly named event that is not restricted to a specific UI element: `TouchSwipe`.

## Code Samples

### Tap Transparency Toggle

This code sample will toggle the `BackgroundTransparency` of a UI element, like a `Frame`, when it is tapped on a touch-enabled device.
```lua
local frame = script.Parent
frame.Active = true

local function onTouchTap()
	-- Toggle background transparency
	if frame.BackgroundTransparency > 0 then
		frame.BackgroundTransparency = 0
	else
		frame.BackgroundTransparency = 0.75
	end
end

frame.TouchTap:Connect(onTouchTap)
```
 */
	readonly TouchTap: RBXScriptSignal<(touchPositions: Array<Vector2>) => void>;
}
/** GuiObject is an abstract class (much like `BasePart`) for a 2D user interface object. It defines all the properties relating to the display of a graphical user interface (GUI) object such as `Size` and `Position`. It also has some useful read-only properties like `AbsolutePosition`, `AbsoluteSize`, and `AbsoluteRotation`. It should be noted that `GuiObject` can have negative sizes and render normally, though `AnchorPoint` ought to be used to better control rendering.

To manipulate the layout of a GuiObject in special ways, you can use a `UIComponent` class such as `UIListLayout`, `UIPadding` or `UIScale`.

This class defines very simple animation methods: `TweenPosition`, `TweenSize` and `TweenSizeAndPosition` are good alternatives to `TweenService` for beginners.

GuiObject also defines events for user input like `MouseEnter`, `TouchTap`, `InputBegan`, `InputChanged` and `InputEnded`. The last three of these mimic the events of `UserinputService` of the same name. Although it is possible to detect mouse button events on any GuiObject using `InputBegan`, only `ImageButton` and `TextButton` have dedicated events for these (e.g. `MouseButton1Down`). This event ought not be used for general button activation since not all platforms use a mouse; see `Activated`. */
type GuiObject = Frame | GuiButton | GuiLabel | ScrollingFrame | TextBox | ViewportFrame;

/** Frame is a `GuiObject` that renders as a plain rectangle with no other content. They are the simplest concrete example of a `GuiObject`, as they provide very little additional functionality (`Frame.FrameStyle`). Despite this, Frames are useful as containers for other `GuiObject`s, such as `TextLabel`, `ImageLabel`. The key benefit to using a Frame over a `Folder` as a container object is the ability to further manipulate the `GuiObject.Size` and `GuiObject.Position` of any descendant `GuiObject`s. */
interface Frame extends RbxInternalGuiObject {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Frame";
	/** Sets what the frame looks like from a selection of pre-determined styles. */
	Style: Enum.FrameStyle;
}

interface RbxInternalGuiButton extends RbxInternalGuiObject {
	/** If true, the button will automatically change color when the mouse hovers over or clicks on it. */
	AutoButtonColor: boolean;
	/** If true while the GUI element is visible, the mouse will not be locked unless the right mouse button is down. */
	Modal: boolean;
	/** A boolean property which indicates whether the object has been selected. */
	Selected: boolean;
	/** Sets the style of the GuiButton based on a list of pre-determined styles. */
	Style: Enum.ButtonStyle;
	/** Fires when the button is activated. */
	readonly Activated: RBXScriptSignal<(inputObject: InputObject) => void>;
	/** Fired when the mouse has fully left clicked the GUI object. By clicking, the mouse has to be in bounds of the button and has to be pressed down and up again before this event fires.

## Code Samples

### GuiButton.MouseButton1Click


```lua

script.Parent.MouseButton1Click:connect(function()
  print("Button1 Clicked")
end)
```
 */
	readonly MouseButton1Click: RBXScriptSignal<() => void>;
	/** Fired when the mouse is in the left mouse down state on the GUI object.

## Code Samples

### GuiButton.MouseButton1Down

The below example would print the position of where the GuiButton was clicked on the screen.
```lua

Gui.MouseButton1Down:Connect(function(X, Y)
    print(("Left mouse click at (%s, %s)"):format(X, Y))
end)

```
 */
	readonly MouseButton1Down: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fired when the left mouse has released the GUI object.

## Code Samples

### GuiButton.MouseButton1Up1

The below example assumes that 'GUI' has previously been defined, and will print "Left mouse button released" each time the event fires.
```lua

GUI.MouseButton1Up:connect(function()
    print("Left mouse button released")
end)

```
 */
	readonly MouseButton1Up: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fired when the mouse has right clicked the GUI object. */
	readonly MouseButton2Click: RBXScriptSignal<() => void>;
	/** Fired when the mouse is in the right mouse down state on the GUI object.

## Code Samples

### GuiButton.MouseButton2Down

The below example assumes that 'GUI' has previously been defined, and will print "Button2 down." each time the event fires.
```lua

GUI.MouseButton2Down:Connect(function()
   print("Button2 down.")
end)

```
 */
	readonly MouseButton2Down: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fired when the right mouse button has been released on a GUI Object.

## Code Samples

### GuiButton.MouseButton2Up

The below example assumes that 'GUI' has previously been defined, and will print Button2 up. each time the event fires.
```lua

GUI.MouseButton2Up:connect(function()
    print("Button2 up.")
end)

```
 */
	readonly MouseButton2Up: RBXScriptSignal<(x: number, y: number) => void>;
}
/** GuiLabel is an abstract class that inherits from `GuiObject`. It is the base class for `ImageButton` and `TextButton`. Objects of this type serve to be interactive, clickable user interface elements. It defines several properties for interaction behavior, namely `AutoButtonColor` and `Modal`, as well as a handful of events for mouse buttons (`MouseButton1Click`, `MouseButton1Down`, etc).

The most import ant event of a GuiButton is `Activated`, a **multi-platform event** that fires when the button is activated. When using a mouse, this means clicking the button and releasing with the cursor still over the UI object. For touch, the same applies but with a touch instead of button press. Finally, for gamepads, `Activated` fires if a GuiButton is selected when the A-button is pressed and released. In short, this event is very useful for multi-platform user interface programming as it provides a nice general interface for a single user input. */
type GuiButton = ImageButton | TextButton;

/** An ImageButton behaves similarly to an `ImageLabel` in regards to rendering with the additional behaviors of a `GuiButton`. It defines the same image-rendering properties as a `ImageLabel` does.

You can disable image rendering by setting `ImageTransparency` to 1. This will leave you with a plain rectangle that can be used as a button. However, it may be better to use a blank `TextButton` for this.

## Code Samples

### ImageButton Press Color

This code sample gives custom colors to an ImageButton of a backpack while it is hovered and pressed.
```lua
-- Place this code in a LocalScript in an ImageButton
local imageButton = script.Parent

local colorNormal = Color3.new(1, 1, 1) -- white
local colorHover = Color3.new(0, 1, 0) -- green
local colorPress = Color3.new(1, 0, 0) -- red

-- This is a 32x32 image of a backpack
imageButton.Image = "rbxassetid://787458668"
imageButton.BackgroundTransparency = 1

local function onActivated()
	print("Let's open the inventory")
end

local function onPressed()
	imageButton.ImageColor3 = colorPress
end

local function onReleased()
	imageButton.ImageColor3 = colorHover
end

local function onEntered()
	imageButton.ImageColor3 = colorHover
end

local function onLeft()
	imageButton.ImageColor3 = colorNormal
end

-- Connect all of our events
imageButton.MouseEnter:Connect(onEntered)
imageButton.MouseLeave:Connect(onLeft)
imageButton.MouseButton1Down:Connect(onPressed)
imageButton.MouseButton1Up:Connect(onReleased)
imageButton.Activated:Connect(onActivated)
-- Start with the default, non-hovered state
onLeft()

```
 */
interface ImageButton extends RbxInternalGuiButton {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ImageButton";
	/** A textureId that could be set on the `ImageButton’s` properties. When the button is hovered, it will render HoverImage if specified. */
	HoverImage: string;
	/** The Image property is a content-type property that should hold the asset ID of a Decal or Image on the Roblox website. It functions identically to `Texture` with regards to loading the image from the Roblox website. The rendered image will be colorized using `ImageColor3`. It is possible to further manipulate the rendered image into sliced (`SliceCenter`), tiled (`ScaleType`) and nine-slice images using other image properties.

## Code Samples

### Image Hover Lock

This code sample causes an ImageLabel/ImageButton to display a red padlock. When the mouse is hovered, it changes to a green unlocked padlock.
```lua
local imageLabel = script.Parent

-- The images in this example are 64x64
imageLabel.Size = UDim2.new(0, 64, 0, 64)

local function unlock()
	imageLabel.Image = "rbxassetid://284402785" -- Unlocked padlock (64x64)
	imageLabel.ImageColor3 = Color3.new(0, 0.5, 0) -- Dark green
end

local function lock()
	imageLabel.Image = "rbxassetid://284402752" -- Locked padlock (64x64)
	imageLabel.ImageColor3 = Color3.new(0.5, 0, 0) -- Dark red
end

-- Connect events; our default state is locked
imageLabel.MouseEnter:Connect(unlock)
imageLabel.MouseLeave:Connect(lock)
lock()

```
 */
	Image: string;
	/** The ImageColor3 property determines how an image is colorized. When set to white, no colorization occurs. This property is very useful for reusing image assets: If the source image is completely white with transparency, you can set the entire color of the image at once with this property.

## Code Samples

### Image Hover Lock

This code sample causes an ImageLabel/ImageButton to display a red padlock. When the mouse is hovered, it changes to a green unlocked padlock.
```lua
local imageLabel = script.Parent

-- The images in this example are 64x64
imageLabel.Size = UDim2.new(0, 64, 0, 64)

local function unlock()
	imageLabel.Image = "rbxassetid://284402785" -- Unlocked padlock (64x64)
	imageLabel.ImageColor3 = Color3.new(0, 0.5, 0) -- Dark green
end

local function lock()
	imageLabel.Image = "rbxassetid://284402752" -- Locked padlock (64x64)
	imageLabel.ImageColor3 = Color3.new(0.5, 0, 0) -- Dark red
end

-- Connect events; our default state is locked
imageLabel.MouseEnter:Connect(unlock)
imageLabel.MouseLeave:Connect(lock)
lock()

```

### Rainbow Image

This code sample loops an ImageLabel or ImageButton's ImageColor3 through the entire rainbow using RunService's RenderStepped.
```lua
local imageLabel = script.Parent

local RunService = game:GetService("RunService")

local function onRenderStep()
	imageLabel.ImageColor3 = Color3.fromHSV(workspace.DistributedGameTime/8%1, 1, 1)
end
RunService.RenderStepped:Connect(onRenderStep)

```
 */
	ImageColor3: Color3;
	/** Allows the partial display of an image in conjunction with `ImageRectSize`. This property determines the pixel offset (from the top-left) of the image area to be displayed.

This property behaves identically to `ImageRectSize`.

## Code Samples

### Image ScaleType Demo

This code sample demonstrates the different ScaleType options - Stretch, Tile and Slice. It does this by resizing an ImageLabel/ImageButton in a circle.
```lua
local imageLabel = script.Parent

-- Set the source image to be a 64x64 padlock
imageLabel.Image = "rbxassetid://284402752"
imageLabel.BackgroundTransparency = 0
imageLabel.BackgroundColor3 = Color3.new(1, 1, 1) -- White
imageLabel.ImageColor3 = Color3.new(0, 0, 0) -- Black

local function resizeInACircle()
	for theta = 0, 2, .02 do
		imageLabel.Size = UDim2.new(
			0, 100 + math.cos(theta*2*math.pi) * 50,
			0, 100 + math.sin(theta*2*math.pi) * 50
		)
		wait()
	end
end

while true do
	-- Stretch simply stretches the source image to fit
	-- the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Stretch
	resizeInACircle()	
	-- Tile will render the source image multiple times
	-- enough to fill the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Tile
	imageLabel.TileSize = UDim2.new(0, 64, 0, 64)
	resizeInACircle()	
	-- Slice will turn the image into a nine-slice UI.
	imageLabel.ScaleType = Enum.ScaleType.Slice
	imageLabel.SliceCenter = Rect.new(30, 30, 34, 34)
	resizeInACircle()	
end


```

### Image Animation using Spritesheet

This code sample uses ImageRectOffset/ImageRectSize in order to play an animation of a man throwing a punch
```lua
-- Place this in an ImageLabel/ImageButton with size 256x256
local imageLabel = script.Parent

-- The following image is 1024x1024 with 12 frames (256x256)
-- The frames play an animation of a man throwing a punch
imageLabel.Image = "rbxassetid://848623155"
imageLabel.ImageRectSize = Vector2.new(256, 256)

-- The order of the frames to be displayed (left-to-right, then top-to-bottom)
local frames = {
	Vector2.new(0, 0); Vector2.new(1, 0); Vector2.new(2, 0); Vector2.new(3, 0);
	Vector2.new(0, 1); Vector2.new(1, 1); Vector2.new(2, 1); Vector2.new(3, 1);
	Vector2.new(0, 2); Vector2.new(1, 2); Vector2.new(2, 2); Vector2.new(3, 2);
}

-- Animate the frames one at a time in a loop
while true do
	for i = 1, #frames do
		imageLabel.ImageRectOffset = frames[i] * imageLabel.ImageRectSize
		wait(.1)
	end
end

```
 */
	ImageRectOffset: Vector2;
	/** Allows the partial display of an image in conjunction with `ImageRectOffset`. This property determines the pixel size of the image area to be displayed. If either dimension is set to 0, the entire image is displayed instead.

This property behaves identically to `ImageRectOffset`.

## Code Samples

### Image ScaleType Demo

This code sample demonstrates the different ScaleType options - Stretch, Tile and Slice. It does this by resizing an ImageLabel/ImageButton in a circle.
```lua
local imageLabel = script.Parent

-- Set the source image to be a 64x64 padlock
imageLabel.Image = "rbxassetid://284402752"
imageLabel.BackgroundTransparency = 0
imageLabel.BackgroundColor3 = Color3.new(1, 1, 1) -- White
imageLabel.ImageColor3 = Color3.new(0, 0, 0) -- Black

local function resizeInACircle()
	for theta = 0, 2, .02 do
		imageLabel.Size = UDim2.new(
			0, 100 + math.cos(theta*2*math.pi) * 50,
			0, 100 + math.sin(theta*2*math.pi) * 50
		)
		wait()
	end
end

while true do
	-- Stretch simply stretches the source image to fit
	-- the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Stretch
	resizeInACircle()	
	-- Tile will render the source image multiple times
	-- enough to fill the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Tile
	imageLabel.TileSize = UDim2.new(0, 64, 0, 64)
	resizeInACircle()	
	-- Slice will turn the image into a nine-slice UI.
	imageLabel.ScaleType = Enum.ScaleType.Slice
	imageLabel.SliceCenter = Rect.new(30, 30, 34, 34)
	resizeInACircle()	
end


```

### Image Animation using Spritesheet

This code sample uses ImageRectOffset/ImageRectSize in order to play an animation of a man throwing a punch
```lua
-- Place this in an ImageLabel/ImageButton with size 256x256
local imageLabel = script.Parent

-- The following image is 1024x1024 with 12 frames (256x256)
-- The frames play an animation of a man throwing a punch
imageLabel.Image = "rbxassetid://848623155"
imageLabel.ImageRectSize = Vector2.new(256, 256)

-- The order of the frames to be displayed (left-to-right, then top-to-bottom)
local frames = {
	Vector2.new(0, 0); Vector2.new(1, 0); Vector2.new(2, 0); Vector2.new(3, 0);
	Vector2.new(0, 1); Vector2.new(1, 1); Vector2.new(2, 1); Vector2.new(3, 1);
	Vector2.new(0, 2); Vector2.new(1, 2); Vector2.new(2, 2); Vector2.new(3, 2);
}

-- Animate the frames one at a time in a loop
while true do
	for i = 1, #frames do
		imageLabel.ImageRectOffset = frames[i] * imageLabel.ImageRectSize
		wait(.1)
	end
end

```
 */
	ImageRectSize: Vector2;
	/** ImageTransparency determines the alpha of a UI element's rendered image. A value of 0 is completely opaque, and a value of 1 is completely transparent (invisible). This property behaves similarly to `BackgroundTransparency` or `Transparency`.

## Code Samples

### Oscillate ImageTransparency

This code sample oscillates the ImageTransparency of an ImageLabel/ImageButton from 0 to 1 using a sine wave.
```lua
local imageLabel = script.Parent

local RunService = game:GetService("RunService")

local function onRenderStep()
	-- Oscillate ImageTransparency from 0 to 1 using a sine wave
	imageLabel.ImageTransparency = math.sin(workspace.DistributedGameTime*math.pi)*.5+.5
end
RunService.RenderStepped:Connect(onRenderStep)

```
 */
	ImageTransparency: number;
	/** The IsLoaded property indicates if the `Image` property finished loading from the Roblox website. Images declined by moderation will never load.

## Code Samples

### Image Load Time

This code sample measures how long an ImageLabel or ImageButton takes to load an image. If the image was already loaded, this will be 0.
```lua
local imageLabel = script.Parent

local startTime = workspace.DistributedGameTime

-- Wait for the image to load
while not imageLabel.IsLoaded do wait() end

-- Measure and display how long it took to load
local deltaTime = workspace.DistributedGameTime - startTime
print(("Image loaded in %.3f seconds"):format(deltaTime))

```
The IsLoaded property indicates if the `Image` property finished loading from the Roblox website. Images declined by moderation will never load.

## Code Samples

### Image Load Time

This code sample measures how long an ImageLabel or ImageButton takes to load an image. If the image was already loaded, this will be 0.
```lua
local imageLabel = script.Parent

local startTime = workspace.DistributedGameTime

-- Wait for the image to load
while not imageLabel.IsLoaded do wait() end

-- Measure and display how long it took to load
local deltaTime = workspace.DistributedGameTime - startTime
print(("Image loaded in %.3f seconds"):format(deltaTime))

```


Tags: ReadOnly, NotReplicated */
	readonly IsLoaded: boolean;
	/** A textureId that could be set on the `ImageButton’s` properties. When the button is pressed, it will render HoverImage if specified. */
	PressedImage: string;
	/** The ScaleType property determines in what way an `Image` is rendered when the UI element's absolute size differs from the source image's size.

By default, this property is `Stretch`, which will simply stretch/compact the image dimensions so it fits the UI element's space exactly. Since transparent pixels are set to black when uploading to the Roblox website, transparent images should apply alpha blending to avoid a blackish outline around scaled images.

For `Slice`, the `SliceCenter` property will be revealed in the Properties window. This is for nine-slice UI: when scaling up, the corners will remain the source image size. The edges of the image will stretch to the width/height of the image. Finally, the center of the image will stretch to fill the center area of the image.

Finally, for `Tile`, the `TileSize` property will be revealed in the Properties window. This is for tiled images, where the size of each image tile is determined by the `TileSize` property.

## Code Samples

### Image ScaleType Demo

This code sample demonstrates the different ScaleType options - Stretch, Tile and Slice. It does this by resizing an ImageLabel/ImageButton in a circle.
```lua
local imageLabel = script.Parent

-- Set the source image to be a 64x64 padlock
imageLabel.Image = "rbxassetid://284402752"
imageLabel.BackgroundTransparency = 0
imageLabel.BackgroundColor3 = Color3.new(1, 1, 1) -- White
imageLabel.ImageColor3 = Color3.new(0, 0, 0) -- Black

local function resizeInACircle()
	for theta = 0, 2, .02 do
		imageLabel.Size = UDim2.new(
			0, 100 + math.cos(theta*2*math.pi) * 50,
			0, 100 + math.sin(theta*2*math.pi) * 50
		)
		wait()
	end
end

while true do
	-- Stretch simply stretches the source image to fit
	-- the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Stretch
	resizeInACircle()	
	-- Tile will render the source image multiple times
	-- enough to fill the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Tile
	imageLabel.TileSize = UDim2.new(0, 64, 0, 64)
	resizeInACircle()	
	-- Slice will turn the image into a nine-slice UI.
	imageLabel.ScaleType = Enum.ScaleType.Slice
	imageLabel.SliceCenter = Rect.new(30, 30, 34, 34)
	resizeInACircle()	
end


```
 */
	ScaleType: Enum.ScaleType;
	/** The SliceCenter property determines the center of a nine-slice image when `ScaleType` is set to `Slice`.

## Code Samples

### Image ScaleType Demo

This code sample demonstrates the different ScaleType options - Stretch, Tile and Slice. It does this by resizing an ImageLabel/ImageButton in a circle.
```lua
local imageLabel = script.Parent

-- Set the source image to be a 64x64 padlock
imageLabel.Image = "rbxassetid://284402752"
imageLabel.BackgroundTransparency = 0
imageLabel.BackgroundColor3 = Color3.new(1, 1, 1) -- White
imageLabel.ImageColor3 = Color3.new(0, 0, 0) -- Black

local function resizeInACircle()
	for theta = 0, 2, .02 do
		imageLabel.Size = UDim2.new(
			0, 100 + math.cos(theta*2*math.pi) * 50,
			0, 100 + math.sin(theta*2*math.pi) * 50
		)
		wait()
	end
end

while true do
	-- Stretch simply stretches the source image to fit
	-- the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Stretch
	resizeInACircle()	
	-- Tile will render the source image multiple times
	-- enough to fill the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Tile
	imageLabel.TileSize = UDim2.new(0, 64, 0, 64)
	resizeInACircle()	
	-- Slice will turn the image into a nine-slice UI.
	imageLabel.ScaleType = Enum.ScaleType.Slice
	imageLabel.SliceCenter = Rect.new(30, 30, 34, 34)
	resizeInACircle()	
end


```
 */
	SliceCenter: Rect;
	/** [LACKS DOCUMENTATION] */
	SliceScale: number;
	/** TileSize sets the tiling size of the ImageButton. The default `UDim2` values are 1,0,1,0. The scale component of the UDim2 will scale the tile based on the size of the ImageButton. The offset is in raw pixels. The tiling starts at the upper left-hand corner of the image. For example a scale of 0.5 will mean the tile will be half the size of the ImageButton (in the corresponding axis).

This property is only active if the ScaleType for the ImageButton is set to Tile instead of Slice or Stretch.

## Code Samples

### Image ScaleType Demo

This code sample demonstrates the different ScaleType options - Stretch, Tile and Slice. It does this by resizing an ImageLabel/ImageButton in a circle.
```lua
local imageLabel = script.Parent

-- Set the source image to be a 64x64 padlock
imageLabel.Image = "rbxassetid://284402752"
imageLabel.BackgroundTransparency = 0
imageLabel.BackgroundColor3 = Color3.new(1, 1, 1) -- White
imageLabel.ImageColor3 = Color3.new(0, 0, 0) -- Black

local function resizeInACircle()
	for theta = 0, 2, .02 do
		imageLabel.Size = UDim2.new(
			0, 100 + math.cos(theta*2*math.pi) * 50,
			0, 100 + math.sin(theta*2*math.pi) * 50
		)
		wait()
	end
end

while true do
	-- Stretch simply stretches the source image to fit
	-- the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Stretch
	resizeInACircle()	
	-- Tile will render the source image multiple times
	-- enough to fill the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Tile
	imageLabel.TileSize = UDim2.new(0, 64, 0, 64)
	resizeInACircle()	
	-- Slice will turn the image into a nine-slice UI.
	imageLabel.ScaleType = Enum.ScaleType.Slice
	imageLabel.SliceCenter = Rect.new(30, 30, 34, 34)
	resizeInACircle()	
end


```
 */
	TileSize: UDim2;
}

/** A TextButton behaves similarly to `TextLabel` in regards to rendering with the additional behaviors of a `GuiButton`. It defines the same text-rendering properties as a `TextLabel` does.

You can disable text rendering by setting `TextTransparency` to 1. This will leave you with a plain rectangle that can be used as a button.

## Code Samples

### Click Counter

This code sample allows a player to click a button which keeps track of how many times it has been clicked.
```lua
-- Place this code in a LocalScript in a TextButton
local textButton = script.Parent

-- Initialize the state of the button
local counter = 0
textButton.Text = "Click me!"

-- Here, we define a function that increments the counter
-- and updates the button text after doing so
local function onActivated()
	counter = counter + 1
	textButton.Text = "Clicks: " .. counter
end

-- Connect the "Activated" event to our function
textButton.Activated:Connect(onActivated)

```
 */
interface TextButton extends RbxInternalGuiButton {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TextButton";
	/** The Font property selects one of several pre-defined fonts with which the UI element will render its text. Some fonts have bold, italic and/or light variants (as there is no font-weight or font-style properties).

With the exception of the "Legacy" font, each font will render text with the line height equal to the `TextSize` property. The "Code" font is the only monospace font. It has the unique property that each character has the exact same width and height ratio of 1:2. The width of each character is approximately half the `TextSize` property.

## Code Samples

### Show All Fonts

This code sample renders a list of all the available fonts.
```lua
local frame = script.Parent

-- Create a TextLabel displaying each font
for i, font in pairs(Enum.Font:GetEnumItems()) do
	local tl = Instance.new("TextLabel")
	tl.Name = font.Name
	-- Set the text properties
	tl.Text = font.Name
	tl.Font = font
	-- Some rendering properties
	tl.TextSize = 24
	tl.TextXAlignment = Enum.TextXAlignment.Left
	-- Size the frame equal to the height of the text
	tl.Size = UDim2.new(1, 0, 0, tl.TextSize)
	-- Add to the parent frame
	tl.Parent = frame
end

-- Layout the frames in a list (if they aren't already)
if not frame:FindFirstChildOfClass("UIListLayout") then
	Instance.new("UIListLayout", frame)
end

```

### Cycle Font

This code sample sets a parent TextLabel's Font and Text properties to all the different fonts available.
```lua
local textLabel = script.Parent

while true do
	-- Iterate over all the different fonts
	for i, font in pairs(Enum.Font:GetEnumItems()) do
		textLabel.Font = font
		textLabel.Text = font.Name
		wait(1)
	end
end

```
 */
	Font: Enum.Font;
	/** Scales the spacing between lines of text in the TextButton. */
	LineHeight: number;
	/** This property sets whether a `TextButton` should be `Localize` or not.This property sets whether a `TextButton` should be `Localize` or not.

Tags: Hidden, ReadOnly, NotReplicated */
	readonly LocalizedText: string;
	/** The Text property determines the content rendered by the UI element. The visual properties of the string rendered to the screen is determined by `TextColor3`, `TextTransparency`, `TextSize`, `Font`, `TextScaled`, `TextWrapped`, `TextXAlignment` and `TextYAlignment`.

It is possible to render emoji (for example, 😃) and other symbols. These special symbols aren't affected by the `TextColor3` property. These can be pasted into `Script` and `LocalScript` objects, as well as the field within the Properties window.

This property may contain newline characters, however, it is not possible to type newline characters within the Properties window. Similarly, this property may contain a tab character, but it will render as a space instead.

## Code Samples

### Emoji in Text

This code sample demonstrates emoji rendering using the Text property.
```lua
local textLabel = script.Parent

local moods = {
	["happy"] = "😃";
	["sad"] = "😢";
	["neutral"] = "😐";
	["tired"] = "😫";
}

while true do
	for mood, face in pairs(moods) do
		textLabel.Text = "I am feeling " .. mood .. "! " .. face
		wait(1)
	end
end

```

### Long Text Wrapping

This code sample demonstrates TextWrap by spelling out a long chunk of text progressively. If the text doesn't fit, it turns a different color.
```lua
local textLabel = script.Parent

-- This text wrapping demo is best shown on a 200x50 px rectangle  
textLabel.Size = UDim2.new(0, 200, 0, 50)

-- Some content to spell out
local content = "Here's a long string of words that will " ..
                "eventually exceed the UI element's width " ..
                "and form line breaks. Useful for paragraphs " ..
                "that are really long."

-- A function that will spell text out two characters at a time
local function spellTheText()
	-- Iterate from 1 to the length of our content
	for i = 1, content:len() do
		-- Get a substring of our content: 1 to i
		textLabel.Text = content:sub(1, i)
		-- Color the text if it doesn't fit in our box
		if textLabel.TextFits then
			textLabel.TextColor3 = Color3.new(0, 0, 0) -- Black
		else
			textLabel.TextColor3 = Color3.new(1, 0, 0) -- Red
		end		
		-- Wait a brief moment on even lengths
		if i % 2 == 0 then wait() end
	end
end

while true do
	-- Spell the text with scale/wrap off
	textLabel.TextWrapped = false
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with wrap on
	textLabel.TextWrapped = true
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with text scaling on
	-- Note: Text turns red (TextFits = false) once text has to be
	-- scaled down in order to fit within the UI element. 
	textLabel.TextScaled = true
	-- Note: TextWrapped is enabled implicitly when TextScaled = true
	--textLabel.TextWrapped = true 
	spellTheText()
	wait(1)
end
```

### "Kaboom!" Text

This code sample repeatedly tweens a TextLabel's TextSize from 5 to 100 and fades out the text as it grows in size.
```lua
local textLabel = script.Parent

textLabel.Text = "Kaboom!"

while true do
	for size = 5, 100, 5 do
		textLabel.TextSize = size
		textLabel.TextTransparency = size / 100
		wait()
	end
	wait(1)
end

```

### Fading Banner

This code sample creates a fading banner for a TextLabel. It fades text out, chooses a random string (avoiding repetition), and fades back in.
```lua
local textLabel = script.Parent

local content = {
	"Welcome to my game!";
	"Be sure to have fun!";
	"Please give suggestions!";
	"Be nice to other players!";
	"Don't grief other players!";
	"Check out the shop!";
	"Tip: Don't die!";
}

local function fadeOut()
	for i = textLabel.TextTransparency, 1, .1 do
		wait(.1)
		textLabel.TextTransparency = i
	end
end

local function fadeIn()
	for i = textLabel.TextTransparency, 0, -.1 do
		wait(.1)
		textLabel.TextTransparency = i
	end
end

local lastIndex
while true do
	-- Step 0: Fade out before doing anything 
	fadeOut()
	
	-- Step 1: pick content that wasn't the last displayed
	local index	
	repeat
		index = math.random(1, #content)
	until lastIndex ~= index
	-- Make sure we don't show the same thing next time
	lastIndex = index
	
	-- Step 2: show the content
	textLabel.Text = content[index]
	fadeIn()
	wait(2)
end

```

### Show All Fonts

This code sample renders a list of all the available fonts.
```lua
local frame = script.Parent

-- Create a TextLabel displaying each font
for i, font in pairs(Enum.Font:GetEnumItems()) do
	local tl = Instance.new("TextLabel")
	tl.Name = font.Name
	-- Set the text properties
	tl.Text = font.Name
	tl.Font = font
	-- Some rendering properties
	tl.TextSize = 24
	tl.TextXAlignment = Enum.TextXAlignment.Left
	-- Size the frame equal to the height of the text
	tl.Size = UDim2.new(1, 0, 0, tl.TextSize)
	-- Add to the parent frame
	tl.Parent = frame
end

-- Layout the frames in a list (if they aren't already)
if not frame:FindFirstChildOfClass("UIListLayout") then
	Instance.new("UIListLayout", frame)
end

```
 */
	Text: string;
	/** The read-only property TextBounds reflects the absolute pixel size of rendered text. In other words, if you were to try to fit text into a rectangle, this property would reflect the minimum dimensions of the rectangle you would need in order to fit the text.

Using `GetTextSize`, you can predict what TextBounds will be on a TextLabel given a string, `Font`, `TextSize` and frame size.

## Code Samples

### Dynamic TextBox Size

This code sample dynamically resizes a TextLabel, TextButton or TextBox to match the size of its TextBounds. Try changing the minimum width/height and pasting into a LocalScript in a TextBox.
```lua
local textBox = script.Parent

-- The smallest the TextBox will go
local minWidth, minHeight = 10, 10

-- Set alignment so our text doesn't wobble a bit while we type
textBox.TextXAlignment = Enum.TextXAlignment.Left
textBox.TextYAlignment = Enum.TextYAlignment.Top

local function updateSize()
	textBox.Size = UDim2.new(
		0, math.max(minWidth, textBox.TextBounds.X),
		0, math.max(minHeight, textBox.TextBounds.Y)
	)
end

textBox:GetPropertyChangedSignal("TextBounds"):Connect(updateSize)

```
The read-only property TextBounds reflects the absolute pixel size of rendered text. In other words, if you were to try to fit text into a rectangle, this property would reflect the minimum dimensions of the rectangle you would need in order to fit the text.

Using `GetTextSize`, you can predict what TextBounds will be on a TextLabel given a string, `Font`, `TextSize` and frame size.

## Code Samples

### Dynamic TextBox Size

This code sample dynamically resizes a TextLabel, TextButton or TextBox to match the size of its TextBounds. Try changing the minimum width/height and pasting into a LocalScript in a TextBox.
```lua
local textBox = script.Parent

-- The smallest the TextBox will go
local minWidth, minHeight = 10, 10

-- Set alignment so our text doesn't wobble a bit while we type
textBox.TextXAlignment = Enum.TextXAlignment.Left
textBox.TextYAlignment = Enum.TextYAlignment.Top

local function updateSize()
	textBox.Size = UDim2.new(
		0, math.max(minWidth, textBox.TextBounds.X),
		0, math.max(minHeight, textBox.TextBounds.Y)
	)
end

textBox:GetPropertyChangedSignal("TextBounds"):Connect(updateSize)

```


Tags: ReadOnly, NotReplicated */
	readonly TextBounds: Vector2;
	/** This property determines the color of all the text rendered by a `GUI` element. This property along with `Font`, `TextSize` and `TextTransparency` will determine the visual properties of text. Text is rendered after the text stroke (`TextStrokeColor3`).

It's important that text is easily read by players! Be sure to choose colors with little-to-no saturation, like white, grey, or black. Make sure the color of your text is contrasted by the `BackgroundColor3` of the UI element. If the element has a transparent background, try applying a black `TextStrokeColor3` to help contrast the text with the 3D world behind it.

## Code Samples

### Vowel Detector

This code sample, when placed within a TextBox, will turn the text color red if the typed string contains no vowels (A, E, I, O or U).
```lua
local textBox = script.Parent

local function hasVowels(str)
	return str:lower():find("[aeiou]")
end

local function onTextChanged()
	local text = textBox.Text
	-- Check for vowels
	if hasVowels(text) then
		textBox.TextColor3 = Color3.new(0, 0, 0) -- Black
	else
		textBox.TextColor3 = Color3.new(1, 0, 0) -- Red
	end
end
textBox:GetPropertyChangedSignal("Text"):Connect(onTextChanged)

```

### TextBox Secret Word

This code sample creates a password-like interface for a TextBox, giving visual feedback on the player's input.
```lua
-- Place this code in a LocalScript inside a TextBox
local textBox = script.Parent

local secretWord = "roblox"
local colorNormal = Color3.new(1, 1, 1) -- white
local colorWrong = Color3.new(1, 0, 0) -- red
local colorCorrect = Color3.new(0, 1, 0) -- green

-- Initialize the state of the textBox
textBox.ClearTextOnFocus = true
textBox.Text = ""
textBox.Font = Enum.Font.Code
textBox.PlaceholderText = "What is the secret word?"
textBox.BackgroundColor3 = colorNormal

local function onFocused()
	textBox.BackgroundColor3 = colorNormal
end

local function onFocusLost(enterPressed, inputObject)
	if enterPressed then
		local guess = textBox.Text
		if guess == secretWord then
			textBox.Text = "ACCESS GRANTED"
			textBox.BackgroundColor3 = colorCorrect
		else
			textBox.Text = "ACCESS DENIED"
			textBox.BackgroundColor3 = colorWrong
		end
	else
		-- The player stopped editing without pressing Enter
		textBox.Text = ""
		textBox.BackgroundColor3 = colorNormal
	end
end

textBox.FocusLost:Connect(onFocusLost)
textBox.Focused:Connect(onFocused)

```

### Game State Text

This code sample mirrors the contents of a StringValue into a TextLabel, updating and setting the color of the text as it changes.
```lua
-- Place a StringValue called "GameState" in the ReplicatedStorage
local vGameState = game.ReplicatedStorage:WaitForChild("GameState")
-- Place this code in a TextLabel
local textLabel = script.Parent

-- Some colors we'll use with TextColor3
local colorNormal = Color3.new(0, 0, 0) -- black
local colorCountdown = Color3.new(1, .5, 0) -- orange
local colorRound = Color3.new(.25, .25, 1) -- blue

-- We'll run this function to update the TextLabel as the state of the
-- game changes.
local function update()
	-- Update the text
	textLabel.Text = "State: " .. vGameState.Value
	-- Set the color of the text based on the current game state
	if vGameState.Value == "Countdown" then
		textLabel.TextColor3 = colorCountdown
	elseif vGameState.Value == "Round" then
		textLabel.TextColor3 = colorRound
	else
		textLabel.TextColor3 = colorNormal
	end
end

-- Pattern: update once when we start and also when vGameState changes
-- We should always see the most updated GameState.
update()
vGameState.Changed:Connect(update) 

```

### Countdown Text

This code sample makes a TextLabel or TextButton count backwards from 10, setting the text color as it does so.
```lua
-- Place this code in a LocalScript within a TextLabel/TextButton
local textLabel = script.Parent

-- Some colors we'll use with TextColor3
local colorNormal = Color3.new(0, 0, 0) -- black
local colorSoon = Color3.new(1, .5, .5) -- red
local colorDone = Color3.new(.5, 1, .5) -- green

-- Loop infinitely
while true do
	-- Count backwards from 10 to 1
	for i = 10, 1, -1 do
		-- Set the text
		textLabel.Text = "Time: " .. i
		-- Set the color based on how much time is left
		if i > 3 then
			textLabel.TextColor3 = colorNormal
		else
			textLabel.TextColor3 = colorSoon
		end
		wait(1)
	end
	textLabel.Text = "GO!"
	textLabel.TextColor3 = colorDone
	wait(2)
end

```
 */
	TextColor3: Color3;
	/** A boolean representation of whether the TextButton's text fits within the size of it.A boolean representation of whether the TextButton's text fits within the size of it.

Tags: ReadOnly, NotReplicated */
	readonly TextFits: boolean;
	/** Changes whether text is resized to fit within the TextButton.

## Code Samples

### Long Text Wrapping

This code sample demonstrates TextWrap by spelling out a long chunk of text progressively. If the text doesn't fit, it turns a different color.
```lua
local textLabel = script.Parent

-- This text wrapping demo is best shown on a 200x50 px rectangle  
textLabel.Size = UDim2.new(0, 200, 0, 50)

-- Some content to spell out
local content = "Here's a long string of words that will " ..
                "eventually exceed the UI element's width " ..
                "and form line breaks. Useful for paragraphs " ..
                "that are really long."

-- A function that will spell text out two characters at a time
local function spellTheText()
	-- Iterate from 1 to the length of our content
	for i = 1, content:len() do
		-- Get a substring of our content: 1 to i
		textLabel.Text = content:sub(1, i)
		-- Color the text if it doesn't fit in our box
		if textLabel.TextFits then
			textLabel.TextColor3 = Color3.new(0, 0, 0) -- Black
		else
			textLabel.TextColor3 = Color3.new(1, 0, 0) -- Red
		end		
		-- Wait a brief moment on even lengths
		if i % 2 == 0 then wait() end
	end
end

while true do
	-- Spell the text with scale/wrap off
	textLabel.TextWrapped = false
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with wrap on
	textLabel.TextWrapped = true
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with text scaling on
	-- Note: Text turns red (TextFits = false) once text has to be
	-- scaled down in order to fit within the UI element. 
	textLabel.TextScaled = true
	-- Note: TextWrapped is enabled implicitly when TextScaled = true
	--textLabel.TextWrapped = true 
	spellTheText()
	wait(1)
end
```
 */
	TextScaled: boolean;
	/** The TextSize property determines the pixel height of one line of rendered text. The unit is in screen pixels, not points (which is used in most document editing programs). The "Legacy" font does not hold this property.

## Code Samples

### "Kaboom!" Text

This code sample repeatedly tweens a TextLabel's TextSize from 5 to 100 and fades out the text as it grows in size.
```lua
local textLabel = script.Parent

textLabel.Text = "Kaboom!"

while true do
	for size = 5, 100, 5 do
		textLabel.TextSize = size
		textLabel.TextTransparency = size / 100
		wait()
	end
	wait(1)
end

```
 */
	TextSize: number;
	/** The TextStrokeColor3 property sets the color of the stroke, or outline, of rendered text. This property and `TextStrokeTransparency` determine the visual properties of the text stroke.

Text stroke is rendered before normal text and is simply 4 renderings of the same text in +/- 1 pixel offsets in each direction. Text stroke rendering works independently and identically to `TextColor3` and `TextTransparency`.

## Code Samples

### Text Highlight Oscillation

This code sample oscillates a TextLabel's TextStrokeTransparency so that it blinks the highlight of a text.
```lua
local textLabel = script.Parent

-- How fast the highlight ought to blink
local freq = 2

-- Set to yellow highlight color
textLabel.TextStrokeColor3 = Color3.new(1, 1, 0)

while true do
	-- math.sin oscillates from -1 to 1, so we change the range to 0 to 1:
	local transparency = math.sin(workspace.DistributedGameTime*math.pi*freq)*.5+.5
	textLabel.TextStrokeTransparency = transparency
	wait()
end

```
 */
	TextStrokeColor3: Color3;
	/** .The TextStrokeTransparency property sets the transparency of the stroke, or outline, of rendered text. This property and `TextStrokeColor3` determine the visual properties of the text stroke.

Text stroke is rendered before normal text and is simply 4 renderings of the same text in +/- 1 pixel offsets in each direction. Text stroke rendering works independently and identically to `TextColor3` and `TextTransparency`. Since text stroke is simply multiple renderings of the same transparency, this property is essentially multiplicative on itself four times over (e.g. a TextStrokeTransparency of 0.5 appears about the same as TextTransparency of 0.0625, or 0.5^4). Therefore, it's recommended to set TextStrokeTransparency to a value in the range of 0.75 to 1 for more a more subtle effect.

## Code Samples

### Text Highlight Oscillation

This code sample oscillates a TextLabel's TextStrokeTransparency so that it blinks the highlight of a text.
```lua
local textLabel = script.Parent

-- How fast the highlight ought to blink
local freq = 2

-- Set to yellow highlight color
textLabel.TextStrokeColor3 = Color3.new(1, 1, 0)

while true do
	-- math.sin oscillates from -1 to 1, so we change the range to 0 to 1:
	local transparency = math.sin(workspace.DistributedGameTime*math.pi*freq)*.5+.5
	textLabel.TextStrokeTransparency = transparency
	wait()
end

```
 */
	TextStrokeTransparency: number;
	/** The TextColor3 property determines the transparency of all the text rendered by a UI element. This property along with `Font`, `TextSize` and `TextColor3` will determine the visual properties of text. Text is rendered after the text stroke (`TextStrokeTransparency`).

Fading text in using a numeric for-loop is a fantastic way to draw a player's attention to text appearing on screen.

```lua
-- Count backwards from 1 to 0, decrementing by 0.1
for i = 1, 0, -.1 do
   textLabel.TextTransparency = i
   wait(.1)
end
```

## Code Samples

### "Kaboom!" Text

This code sample repeatedly tweens a TextLabel's TextSize from 5 to 100 and fades out the text as it grows in size.
```lua
local textLabel = script.Parent

textLabel.Text = "Kaboom!"

while true do
	for size = 5, 100, 5 do
		textLabel.TextSize = size
		textLabel.TextTransparency = size / 100
		wait()
	end
	wait(1)
end

```

### Fading Banner

This code sample creates a fading banner for a TextLabel. It fades text out, chooses a random string (avoiding repetition), and fades back in.
```lua
local textLabel = script.Parent

local content = {
	"Welcome to my game!";
	"Be sure to have fun!";
	"Please give suggestions!";
	"Be nice to other players!";
	"Don't grief other players!";
	"Check out the shop!";
	"Tip: Don't die!";
}

local function fadeOut()
	for i = textLabel.TextTransparency, 1, .1 do
		wait(.1)
		textLabel.TextTransparency = i
	end
end

local function fadeIn()
	for i = textLabel.TextTransparency, 0, -.1 do
		wait(.1)
		textLabel.TextTransparency = i
	end
end

local lastIndex
while true do
	-- Step 0: Fade out before doing anything 
	fadeOut()
	
	-- Step 1: pick content that wasn't the last displayed
	local index	
	repeat
		index = math.random(1, #content)
	until lastIndex ~= index
	-- Make sure we don't show the same thing next time
	lastIndex = index
	
	-- Step 2: show the content
	textLabel.Text = content[index]
	fadeIn()
	wait(2)
end

```
 */
	TextTransparency: number;
	/** Controls the truncation of the text displayed in this TextButton. */
	TextTruncate: Enum.TextTruncate;
	/** When enabled, this property will render text on multiple lines within a `GUI` element's space so that `TextBounds` will never exceed the `AbsoluteSize` of the UI element.

This is achieved by breaking long lines of text into multiple lines. Line breaks will prefer whitespace; should a long unbroken word exceed the width of the element, that word will be broken into multiple lines.

If further line breaks would cause the vertical height of the text (the Y component of `TextBounds`) to exceed the vertical height of the element (the Y component of `AbsoluteSize`), then that line will not be rendered at all.

## Code Samples

### Long Text Wrapping

This code sample demonstrates TextWrap by spelling out a long chunk of text progressively. If the text doesn't fit, it turns a different color.
```lua
local textLabel = script.Parent

-- This text wrapping demo is best shown on a 200x50 px rectangle  
textLabel.Size = UDim2.new(0, 200, 0, 50)

-- Some content to spell out
local content = "Here's a long string of words that will " ..
                "eventually exceed the UI element's width " ..
                "and form line breaks. Useful for paragraphs " ..
                "that are really long."

-- A function that will spell text out two characters at a time
local function spellTheText()
	-- Iterate from 1 to the length of our content
	for i = 1, content:len() do
		-- Get a substring of our content: 1 to i
		textLabel.Text = content:sub(1, i)
		-- Color the text if it doesn't fit in our box
		if textLabel.TextFits then
			textLabel.TextColor3 = Color3.new(0, 0, 0) -- Black
		else
			textLabel.TextColor3 = Color3.new(1, 0, 0) -- Red
		end		
		-- Wait a brief moment on even lengths
		if i % 2 == 0 then wait() end
	end
end

while true do
	-- Spell the text with scale/wrap off
	textLabel.TextWrapped = false
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with wrap on
	textLabel.TextWrapped = true
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with text scaling on
	-- Note: Text turns red (TextFits = false) once text has to be
	-- scaled down in order to fit within the UI element. 
	textLabel.TextScaled = true
	-- Note: TextWrapped is enabled implicitly when TextScaled = true
	--textLabel.TextWrapped = true 
	spellTheText()
	wait(1)
end
```
 */
	TextWrapped: boolean;
	/** TextXAlignment determines the horizontal alignment (X-axis) of text rendered within a UI element's space. It functions similarly to the CSS text-align property, with left, right and center values (there is no justify option). For Left and Right, text is rendered such that the left/right text bounds just touch the edge of the UI element rectangle. For Center, each line of text is centered on the very center of the UI element rectangle.

This property is used in conjunction with `TextYAlignment` to fully determine text alignment on both axes. This property won't affect the read-only properties `TextBounds` and `TextFits`.

## Code Samples

### Text Alignment

This code sample shows all the different text alignment combinations by iterating over each enum item. It is meant to be placed within a TextLabel, TextButton or TextBox.
```lua
-- Paste this in a LocalScript within a TextLabel/TextButton/TextBox
local textLabel = script.Parent

local function setAlignment(xAlign, yAlign)
	textLabel.TextXAlignment = xAlign
	textLabel.TextYAlignment = yAlign
	textLabel.Text = xAlign.Name .. " + " .. yAlign.Name
end

while true do
	-- Iterate over both TextXAlignment and TextYAlignment enum items
	for j, yAlign in pairs(Enum.TextYAlignment:GetEnumItems()) do
		for i, xAlign in pairs(Enum.TextXAlignment:GetEnumItems()) do
			setAlignment(xAlign, yAlign)
			wait(1)
		end
	end
end

```
 */
	TextXAlignment: Enum.TextXAlignment;
	/** TextYAlignment determines the vertical alignment (Y-axis) of text rendered within a UI element's space. For Top and Bottom, text is rendered such that the top/bottom text bounds just touch the edge of the UI element rectangle. For Center, text is rendered such that there is an equal space from the top bounds of the text to the top of the element and the bottom bounds of the text to the bottom of the element.

This property is used in conjunction with `TextXAlignment` to fully determine text alignment on both axes. This property won't affect the read-only properties `TextBounds` and `TextFits`.

## Code Samples

### Text Alignment

This code sample shows all the different text alignment combinations by iterating over each enum item. It is meant to be placed within a TextLabel, TextButton or TextBox.
```lua
-- Paste this in a LocalScript within a TextLabel/TextButton/TextBox
local textLabel = script.Parent

local function setAlignment(xAlign, yAlign)
	textLabel.TextXAlignment = xAlign
	textLabel.TextYAlignment = yAlign
	textLabel.Text = xAlign.Name .. " + " .. yAlign.Name
end

while true do
	-- Iterate over both TextXAlignment and TextYAlignment enum items
	for j, yAlign in pairs(Enum.TextYAlignment:GetEnumItems()) do
		for i, xAlign in pairs(Enum.TextXAlignment:GetEnumItems()) do
			setAlignment(xAlign, yAlign)
			wait(1)
		end
	end
end

```
 */
	TextYAlignment: Enum.TextYAlignment;
}

interface RbxInternalGuiLabel extends RbxInternalGuiObject {}
/** GuiLabel is an abstract class that inherits from `GuiObject`. It is the base class for `ImageLabel` and `TextLabel`. Unlike `GuiButton`, objects of this type will not register click events, but instead serve as non-interactive labels. It does not implement any further properties, events or methods. */
type GuiLabel = ImageLabel | TextLabel;

/** An ImageLabel renders a rectangle, like a `Frame` does, with an image. The image must be a decal uploaded to the Roblox website. The display of the image can be manipulated through the `ImageColor3` and `ImageTransparency` properties. To display only the image and hide the rectangle, set `BackgroundTransparency` to 1.

The image is scaled to fit the entirety of the rectangle, but remember that images look best when displayed at their native resolution. Before uploading your image asset, you may want to apply alpha bleeding and take a few more steps when building UI for high-DPI devices (like phones).

## Advanced ImageLabel usage

 - **Spritesheets** can be used with ImageLabel through the use of `ImageRectOffset` and `ImageRectSize`. Packing multiple images into one and using this property can make your game's image assets load much quicker, especially if you use many small icons in your GUIs.
 - Nine-slice images can be created by setting `ScaleType` to `Enum.ScaleType.Slice`, then `SliceCenter` to the center area of the nine-slice image.
 - Tiled images can be created by setting `ScaleType` to `Enum.ScaleType.Tiled`, then `TileSize` to be the size of rendered tiles.

## Code Samples

### Image Animation using Spritesheet

This code sample uses ImageRectOffset/ImageRectSize in order to play an animation of a man throwing a punch
```lua
-- Place this in an ImageLabel/ImageButton with size 256x256
local imageLabel = script.Parent

-- The following image is 1024x1024 with 12 frames (256x256)
-- The frames play an animation of a man throwing a punch
imageLabel.Image = "rbxassetid://848623155"
imageLabel.ImageRectSize = Vector2.new(256, 256)

-- The order of the frames to be displayed (left-to-right, then top-to-bottom)
local frames = {
	Vector2.new(0, 0); Vector2.new(1, 0); Vector2.new(2, 0); Vector2.new(3, 0);
	Vector2.new(0, 1); Vector2.new(1, 1); Vector2.new(2, 1); Vector2.new(3, 1);
	Vector2.new(0, 2); Vector2.new(1, 2); Vector2.new(2, 2); Vector2.new(3, 2);
}

-- Animate the frames one at a time in a loop
while true do
	for i = 1, #frames do
		imageLabel.ImageRectOffset = frames[i] * imageLabel.ImageRectSize
		wait(.1)
	end
end

```
 */
interface ImageLabel extends RbxInternalGuiLabel {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ImageLabel";
	/** The Image property is a content-type property that should hold the asset ID of a Decal or Image on the Roblox website. It functions identically to `Texture` with regards to loading the image from the Roblox website. The rendered image will be colorized using `ImageColor3`. It is possible to further manipulate the rendered image into sliced (`SliceCenter`), tiled (`ScaleType`) and nine-slice images using other image properties.

## Code Samples

### Image Hover Lock

This code sample causes an ImageLabel/ImageButton to display a red padlock. When the mouse is hovered, it changes to a green unlocked padlock.
```lua
local imageLabel = script.Parent

-- The images in this example are 64x64
imageLabel.Size = UDim2.new(0, 64, 0, 64)

local function unlock()
	imageLabel.Image = "rbxassetid://284402785" -- Unlocked padlock (64x64)
	imageLabel.ImageColor3 = Color3.new(0, 0.5, 0) -- Dark green
end

local function lock()
	imageLabel.Image = "rbxassetid://284402752" -- Locked padlock (64x64)
	imageLabel.ImageColor3 = Color3.new(0.5, 0, 0) -- Dark red
end

-- Connect events; our default state is locked
imageLabel.MouseEnter:Connect(unlock)
imageLabel.MouseLeave:Connect(lock)
lock()

```
 */
	Image: string;
	/** The ImageColor3 property determines how an image is colorized. When set to white, no colorization occurs. This property is very useful for reusing image assets: If the source image is completely white with transparency, you can set the entire color of the image at once with this property.

## Code Samples

### Image Hover Lock

This code sample causes an ImageLabel/ImageButton to display a red padlock. When the mouse is hovered, it changes to a green unlocked padlock.
```lua
local imageLabel = script.Parent

-- The images in this example are 64x64
imageLabel.Size = UDim2.new(0, 64, 0, 64)

local function unlock()
	imageLabel.Image = "rbxassetid://284402785" -- Unlocked padlock (64x64)
	imageLabel.ImageColor3 = Color3.new(0, 0.5, 0) -- Dark green
end

local function lock()
	imageLabel.Image = "rbxassetid://284402752" -- Locked padlock (64x64)
	imageLabel.ImageColor3 = Color3.new(0.5, 0, 0) -- Dark red
end

-- Connect events; our default state is locked
imageLabel.MouseEnter:Connect(unlock)
imageLabel.MouseLeave:Connect(lock)
lock()

```

### Rainbow Image

This code sample loops an ImageLabel or ImageButton's ImageColor3 through the entire rainbow using RunService's RenderStepped.
```lua
local imageLabel = script.Parent

local RunService = game:GetService("RunService")

local function onRenderStep()
	imageLabel.ImageColor3 = Color3.fromHSV(workspace.DistributedGameTime/8%1, 1, 1)
end
RunService.RenderStepped:Connect(onRenderStep)

```
 */
	ImageColor3: Color3;
	/** Allows the partial display of an image in conjunction with `ImageRectSize`. This property determines the pixel offset (from the top-left) of the image area to be displayed.

This property behaves identically to `ImageRectSize`.

## Code Samples

### Image ScaleType Demo

This code sample demonstrates the different ScaleType options - Stretch, Tile and Slice. It does this by resizing an ImageLabel/ImageButton in a circle.
```lua
local imageLabel = script.Parent

-- Set the source image to be a 64x64 padlock
imageLabel.Image = "rbxassetid://284402752"
imageLabel.BackgroundTransparency = 0
imageLabel.BackgroundColor3 = Color3.new(1, 1, 1) -- White
imageLabel.ImageColor3 = Color3.new(0, 0, 0) -- Black

local function resizeInACircle()
	for theta = 0, 2, .02 do
		imageLabel.Size = UDim2.new(
			0, 100 + math.cos(theta*2*math.pi) * 50,
			0, 100 + math.sin(theta*2*math.pi) * 50
		)
		wait()
	end
end

while true do
	-- Stretch simply stretches the source image to fit
	-- the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Stretch
	resizeInACircle()	
	-- Tile will render the source image multiple times
	-- enough to fill the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Tile
	imageLabel.TileSize = UDim2.new(0, 64, 0, 64)
	resizeInACircle()	
	-- Slice will turn the image into a nine-slice UI.
	imageLabel.ScaleType = Enum.ScaleType.Slice
	imageLabel.SliceCenter = Rect.new(30, 30, 34, 34)
	resizeInACircle()	
end


```

### Image Animation using Spritesheet

This code sample uses ImageRectOffset/ImageRectSize in order to play an animation of a man throwing a punch
```lua
-- Place this in an ImageLabel/ImageButton with size 256x256
local imageLabel = script.Parent

-- The following image is 1024x1024 with 12 frames (256x256)
-- The frames play an animation of a man throwing a punch
imageLabel.Image = "rbxassetid://848623155"
imageLabel.ImageRectSize = Vector2.new(256, 256)

-- The order of the frames to be displayed (left-to-right, then top-to-bottom)
local frames = {
	Vector2.new(0, 0); Vector2.new(1, 0); Vector2.new(2, 0); Vector2.new(3, 0);
	Vector2.new(0, 1); Vector2.new(1, 1); Vector2.new(2, 1); Vector2.new(3, 1);
	Vector2.new(0, 2); Vector2.new(1, 2); Vector2.new(2, 2); Vector2.new(3, 2);
}

-- Animate the frames one at a time in a loop
while true do
	for i = 1, #frames do
		imageLabel.ImageRectOffset = frames[i] * imageLabel.ImageRectSize
		wait(.1)
	end
end

```
 */
	ImageRectOffset: Vector2;
	/** Allows the partial display of an image in conjunction with `ImageRectOffset`. This property determines the pixel size of the image area to be displayed. If either dimension is set to 0, the entire image is displayed instead.

This property behaves identically to `ImageRectOffset`.

## Code Samples

### Image ScaleType Demo

This code sample demonstrates the different ScaleType options - Stretch, Tile and Slice. It does this by resizing an ImageLabel/ImageButton in a circle.
```lua
local imageLabel = script.Parent

-- Set the source image to be a 64x64 padlock
imageLabel.Image = "rbxassetid://284402752"
imageLabel.BackgroundTransparency = 0
imageLabel.BackgroundColor3 = Color3.new(1, 1, 1) -- White
imageLabel.ImageColor3 = Color3.new(0, 0, 0) -- Black

local function resizeInACircle()
	for theta = 0, 2, .02 do
		imageLabel.Size = UDim2.new(
			0, 100 + math.cos(theta*2*math.pi) * 50,
			0, 100 + math.sin(theta*2*math.pi) * 50
		)
		wait()
	end
end

while true do
	-- Stretch simply stretches the source image to fit
	-- the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Stretch
	resizeInACircle()	
	-- Tile will render the source image multiple times
	-- enough to fill the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Tile
	imageLabel.TileSize = UDim2.new(0, 64, 0, 64)
	resizeInACircle()	
	-- Slice will turn the image into a nine-slice UI.
	imageLabel.ScaleType = Enum.ScaleType.Slice
	imageLabel.SliceCenter = Rect.new(30, 30, 34, 34)
	resizeInACircle()	
end


```

### Image Animation using Spritesheet

This code sample uses ImageRectOffset/ImageRectSize in order to play an animation of a man throwing a punch
```lua
-- Place this in an ImageLabel/ImageButton with size 256x256
local imageLabel = script.Parent

-- The following image is 1024x1024 with 12 frames (256x256)
-- The frames play an animation of a man throwing a punch
imageLabel.Image = "rbxassetid://848623155"
imageLabel.ImageRectSize = Vector2.new(256, 256)

-- The order of the frames to be displayed (left-to-right, then top-to-bottom)
local frames = {
	Vector2.new(0, 0); Vector2.new(1, 0); Vector2.new(2, 0); Vector2.new(3, 0);
	Vector2.new(0, 1); Vector2.new(1, 1); Vector2.new(2, 1); Vector2.new(3, 1);
	Vector2.new(0, 2); Vector2.new(1, 2); Vector2.new(2, 2); Vector2.new(3, 2);
}

-- Animate the frames one at a time in a loop
while true do
	for i = 1, #frames do
		imageLabel.ImageRectOffset = frames[i] * imageLabel.ImageRectSize
		wait(.1)
	end
end

```
 */
	ImageRectSize: Vector2;
	/** ImageTransparency determines the alpha of a UI element's rendered image. A value of 0 is completely opaque, and a value of 1 is completely transparent (invisible). This property behaves similarly to `BackgroundTransparency` or `Transparency`.

## Code Samples

### Oscillate ImageTransparency

This code sample oscillates the ImageTransparency of an ImageLabel/ImageButton from 0 to 1 using a sine wave.
```lua
local imageLabel = script.Parent

local RunService = game:GetService("RunService")

local function onRenderStep()
	-- Oscillate ImageTransparency from 0 to 1 using a sine wave
	imageLabel.ImageTransparency = math.sin(workspace.DistributedGameTime*math.pi)*.5+.5
end
RunService.RenderStepped:Connect(onRenderStep)

```
 */
	ImageTransparency: number;
	/** The IsLoaded property indicates if the `Image` property finished loading from the Roblox website. Images declined by moderation will never load.

## Code Samples

### Image Load Time

This code sample measures how long an ImageLabel or ImageButton takes to load an image. If the image was already loaded, this will be 0.
```lua
local imageLabel = script.Parent

local startTime = workspace.DistributedGameTime

-- Wait for the image to load
while not imageLabel.IsLoaded do wait() end

-- Measure and display how long it took to load
local deltaTime = workspace.DistributedGameTime - startTime
print(("Image loaded in %.3f seconds"):format(deltaTime))

```
The IsLoaded property indicates if the `Image` property finished loading from the Roblox website. Images declined by moderation will never load.

## Code Samples

### Image Load Time

This code sample measures how long an ImageLabel or ImageButton takes to load an image. If the image was already loaded, this will be 0.
```lua
local imageLabel = script.Parent

local startTime = workspace.DistributedGameTime

-- Wait for the image to load
while not imageLabel.IsLoaded do wait() end

-- Measure and display how long it took to load
local deltaTime = workspace.DistributedGameTime - startTime
print(("Image loaded in %.3f seconds"):format(deltaTime))

```


Tags: ReadOnly, NotReplicated */
	readonly IsLoaded: boolean;
	/** The ScaleType property determines in what way an `Image` is rendered when the UI element's absolute size differs from the source image's size.

By default, this property is `Stretch`, which will simply stretch/compact the image dimensions so it fits the UI element's space exactly. Since transparent pixels are set to black when uploading to the Roblox website, transparent images should apply alpha blending to avoid a blackish outline around scaled images.

For `Slice`, the `SliceCenter` property will be revealed in the Properties window. This is for nine-slice UI: when scaling up, the corners will remain the source image size. The edges of the image will stretch to the width/height of the image. Finally, the center of the image will stretch to fill the center area of the image.

Finally, for `Tile`, the `TileSize` property will be revealed in the Properties window. This is for tiled images, where the size of each image tile is determined by the `TileSize` property.

## Code Samples

### Image ScaleType Demo

This code sample demonstrates the different ScaleType options - Stretch, Tile and Slice. It does this by resizing an ImageLabel/ImageButton in a circle.
```lua
local imageLabel = script.Parent

-- Set the source image to be a 64x64 padlock
imageLabel.Image = "rbxassetid://284402752"
imageLabel.BackgroundTransparency = 0
imageLabel.BackgroundColor3 = Color3.new(1, 1, 1) -- White
imageLabel.ImageColor3 = Color3.new(0, 0, 0) -- Black

local function resizeInACircle()
	for theta = 0, 2, .02 do
		imageLabel.Size = UDim2.new(
			0, 100 + math.cos(theta*2*math.pi) * 50,
			0, 100 + math.sin(theta*2*math.pi) * 50
		)
		wait()
	end
end

while true do
	-- Stretch simply stretches the source image to fit
	-- the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Stretch
	resizeInACircle()	
	-- Tile will render the source image multiple times
	-- enough to fill the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Tile
	imageLabel.TileSize = UDim2.new(0, 64, 0, 64)
	resizeInACircle()	
	-- Slice will turn the image into a nine-slice UI.
	imageLabel.ScaleType = Enum.ScaleType.Slice
	imageLabel.SliceCenter = Rect.new(30, 30, 34, 34)
	resizeInACircle()	
end


```
 */
	ScaleType: Enum.ScaleType;
	/** The SliceCenter property determines the center of a nine-slice image when `ScaleType` is set to `Enum.ScaleType.Slice`.

## Code Samples

### Image ScaleType Demo

This code sample demonstrates the different ScaleType options - Stretch, Tile and Slice. It does this by resizing an ImageLabel/ImageButton in a circle.
```lua
local imageLabel = script.Parent

-- Set the source image to be a 64x64 padlock
imageLabel.Image = "rbxassetid://284402752"
imageLabel.BackgroundTransparency = 0
imageLabel.BackgroundColor3 = Color3.new(1, 1, 1) -- White
imageLabel.ImageColor3 = Color3.new(0, 0, 0) -- Black

local function resizeInACircle()
	for theta = 0, 2, .02 do
		imageLabel.Size = UDim2.new(
			0, 100 + math.cos(theta*2*math.pi) * 50,
			0, 100 + math.sin(theta*2*math.pi) * 50
		)
		wait()
	end
end

while true do
	-- Stretch simply stretches the source image to fit
	-- the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Stretch
	resizeInACircle()	
	-- Tile will render the source image multiple times
	-- enough to fill the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Tile
	imageLabel.TileSize = UDim2.new(0, 64, 0, 64)
	resizeInACircle()	
	-- Slice will turn the image into a nine-slice UI.
	imageLabel.ScaleType = Enum.ScaleType.Slice
	imageLabel.SliceCenter = Rect.new(30, 30, 34, 34)
	resizeInACircle()	
end


```
 */
	SliceCenter: Rect;
	/** [LACKS DOCUMENTATION] */
	SliceScale: number;
	/** TileSize sets the tiling size of the ImageLabel. The default `UDim2` values are 1,0,1,0. The scale component of the UDim2 will scale the tile based on the size of the ImageLabel. The offset is in raw pixels. The tiling starts at the upper left-hand corner of the image. For example a scale of 0.5 will mean the tile will be half the size of the ImageLabel (in the corresponding axis).

This property is only active if the ScaleType for the ImageLabel is set to Tile instead of Slice or Stretch.

## Code Samples

### Image ScaleType Demo

This code sample demonstrates the different ScaleType options - Stretch, Tile and Slice. It does this by resizing an ImageLabel/ImageButton in a circle.
```lua
local imageLabel = script.Parent

-- Set the source image to be a 64x64 padlock
imageLabel.Image = "rbxassetid://284402752"
imageLabel.BackgroundTransparency = 0
imageLabel.BackgroundColor3 = Color3.new(1, 1, 1) -- White
imageLabel.ImageColor3 = Color3.new(0, 0, 0) -- Black

local function resizeInACircle()
	for theta = 0, 2, .02 do
		imageLabel.Size = UDim2.new(
			0, 100 + math.cos(theta*2*math.pi) * 50,
			0, 100 + math.sin(theta*2*math.pi) * 50
		)
		wait()
	end
end

while true do
	-- Stretch simply stretches the source image to fit
	-- the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Stretch
	resizeInACircle()	
	-- Tile will render the source image multiple times
	-- enough to fill the UI element's space
	imageLabel.ScaleType = Enum.ScaleType.Tile
	imageLabel.TileSize = UDim2.new(0, 64, 0, 64)
	resizeInACircle()	
	-- Slice will turn the image into a nine-slice UI.
	imageLabel.ScaleType = Enum.ScaleType.Slice
	imageLabel.SliceCenter = Rect.new(30, 30, 34, 34)
	resizeInACircle()	
end


```
 */
	TileSize: UDim2;
}

/** A TextLabel renders a rectangle, like a `Frame`, with styled text. The rectangle can be used to define text boundaries, text scaling (`TextScaled`) and wrapping (`TextWrapped`, `TextXAlignment`, `TextYAlignment`).

This class contains properties that control the display of the text, such as `Font` and `TextColor3`. All text rendered by a single text label will have the same visual properties; multiple TextLabel objects must be used in order to render multiple styles of text. To display only text and hide the rectangle, set `BackgroundTransparency` to 1.

`GetTextSize` can be used to get the size (bounds) of text that would be rendered in a TextLabel given a font size, font, and frame size.

A `UITextSizeConstraint` object can be used to constrain the size of text with `TextScaled` enabled.

## Code Samples

### Game State Text

This code sample mirrors the contents of a StringValue into a TextLabel, updating and setting the color of the text as it changes.
```lua
-- Place a StringValue called "GameState" in the ReplicatedStorage
local vGameState = game.ReplicatedStorage:WaitForChild("GameState")
-- Place this code in a TextLabel
local textLabel = script.Parent

-- Some colors we'll use with TextColor3
local colorNormal = Color3.new(0, 0, 0) -- black
local colorCountdown = Color3.new(1, .5, 0) -- orange
local colorRound = Color3.new(.25, .25, 1) -- blue

-- We'll run this function to update the TextLabel as the state of the
-- game changes.
local function update()
	-- Update the text
	textLabel.Text = "State: " .. vGameState.Value
	-- Set the color of the text based on the current game state
	if vGameState.Value == "Countdown" then
		textLabel.TextColor3 = colorCountdown
	elseif vGameState.Value == "Round" then
		textLabel.TextColor3 = colorRound
	else
		textLabel.TextColor3 = colorNormal
	end
end

-- Pattern: update once when we start and also when vGameState changes
-- We should always see the most updated GameState.
update()
vGameState.Changed:Connect(update) 

```

### Countdown Text

This code sample makes a TextLabel or TextButton count backwards from 10, setting the text color as it does so.
```lua
-- Place this code in a LocalScript within a TextLabel/TextButton
local textLabel = script.Parent

-- Some colors we'll use with TextColor3
local colorNormal = Color3.new(0, 0, 0) -- black
local colorSoon = Color3.new(1, .5, .5) -- red
local colorDone = Color3.new(.5, 1, .5) -- green

-- Loop infinitely
while true do
	-- Count backwards from 10 to 1
	for i = 10, 1, -1 do
		-- Set the text
		textLabel.Text = "Time: " .. i
		-- Set the color based on how much time is left
		if i > 3 then
			textLabel.TextColor3 = colorNormal
		else
			textLabel.TextColor3 = colorSoon
		end
		wait(1)
	end
	textLabel.Text = "GO!"
	textLabel.TextColor3 = colorDone
	wait(2)
end

```
 */
interface TextLabel extends RbxInternalGuiLabel {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TextLabel";
	/** The Font property selects one of several pre-defined fonts with which the UI element will render its text. Some fonts have bold, italic and/or light variants (as there is no font-weight or font-style properties).

With the exception of the "Legacy" font, each font will render text with the line height equal to the `TextSize` property. The "Code" font is the only monospace font. It has the unique property that each character has the exact same width and height ratio of 1:2. The width of each character is approximately half the `TextSize` property.

## Code Samples

### Show All Fonts

This code sample renders a list of all the available fonts.
```lua
local frame = script.Parent

-- Create a TextLabel displaying each font
for i, font in pairs(Enum.Font:GetEnumItems()) do
	local tl = Instance.new("TextLabel")
	tl.Name = font.Name
	-- Set the text properties
	tl.Text = font.Name
	tl.Font = font
	-- Some rendering properties
	tl.TextSize = 24
	tl.TextXAlignment = Enum.TextXAlignment.Left
	-- Size the frame equal to the height of the text
	tl.Size = UDim2.new(1, 0, 0, tl.TextSize)
	-- Add to the parent frame
	tl.Parent = frame
end

-- Layout the frames in a list (if they aren't already)
if not frame:FindFirstChildOfClass("UIListLayout") then
	Instance.new("UIListLayout", frame)
end

```

### Cycle Font

This code sample sets a parent TextLabel's Font and Text properties to all the different fonts available.
```lua
local textLabel = script.Parent

while true do
	-- Iterate over all the different fonts
	for i, font in pairs(Enum.Font:GetEnumItems()) do
		textLabel.Font = font
		textLabel.Text = font.Name
		wait(1)
	end
end

```
 */
	Font: Enum.Font;
	/** Scales the spacing between lines of text in the TextLabel. */
	LineHeight: number;
	/** This property sets whether a `TextLabel` should be `Localize` or not.This property sets whether a `TextLabel` should be `Localize` or not.

Tags: Hidden, ReadOnly, NotReplicated */
	readonly LocalizedText: string;
	/** The Text property determines the content rendered by the UI element. The visual properties of the string rendered to the screen is determined by `TextColor3`, `TextTransparency`, `TextSize`, `Font`, `TextScaled`, `TextWrapped`, `TextXAlignment` and `TextYAlignment`.

It is possible to render emoji (for example, 😃) and other symbols. These special symbols aren't affected by the `TextColor3` property. These can be pasted into `Script` and `LocalScript` objects, as well as the field within the Properties window.

This property may contain newline characters, however, it is not possible to type newline characters within the Properties window. Similarly, this property may contain a tab character, but it will render as a space instead.

## Code Samples

### Emoji in Text

This code sample demonstrates emoji rendering using the Text property.
```lua
local textLabel = script.Parent

local moods = {
	["happy"] = "😃";
	["sad"] = "😢";
	["neutral"] = "😐";
	["tired"] = "😫";
}

while true do
	for mood, face in pairs(moods) do
		textLabel.Text = "I am feeling " .. mood .. "! " .. face
		wait(1)
	end
end

```

### Long Text Wrapping

This code sample demonstrates TextWrap by spelling out a long chunk of text progressively. If the text doesn't fit, it turns a different color.
```lua
local textLabel = script.Parent

-- This text wrapping demo is best shown on a 200x50 px rectangle  
textLabel.Size = UDim2.new(0, 200, 0, 50)

-- Some content to spell out
local content = "Here's a long string of words that will " ..
                "eventually exceed the UI element's width " ..
                "and form line breaks. Useful for paragraphs " ..
                "that are really long."

-- A function that will spell text out two characters at a time
local function spellTheText()
	-- Iterate from 1 to the length of our content
	for i = 1, content:len() do
		-- Get a substring of our content: 1 to i
		textLabel.Text = content:sub(1, i)
		-- Color the text if it doesn't fit in our box
		if textLabel.TextFits then
			textLabel.TextColor3 = Color3.new(0, 0, 0) -- Black
		else
			textLabel.TextColor3 = Color3.new(1, 0, 0) -- Red
		end		
		-- Wait a brief moment on even lengths
		if i % 2 == 0 then wait() end
	end
end

while true do
	-- Spell the text with scale/wrap off
	textLabel.TextWrapped = false
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with wrap on
	textLabel.TextWrapped = true
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with text scaling on
	-- Note: Text turns red (TextFits = false) once text has to be
	-- scaled down in order to fit within the UI element. 
	textLabel.TextScaled = true
	-- Note: TextWrapped is enabled implicitly when TextScaled = true
	--textLabel.TextWrapped = true 
	spellTheText()
	wait(1)
end
```

### "Kaboom!" Text

This code sample repeatedly tweens a TextLabel's TextSize from 5 to 100 and fades out the text as it grows in size.
```lua
local textLabel = script.Parent

textLabel.Text = "Kaboom!"

while true do
	for size = 5, 100, 5 do
		textLabel.TextSize = size
		textLabel.TextTransparency = size / 100
		wait()
	end
	wait(1)
end

```

### Fading Banner

This code sample creates a fading banner for a TextLabel. It fades text out, chooses a random string (avoiding repetition), and fades back in.
```lua
local textLabel = script.Parent

local content = {
	"Welcome to my game!";
	"Be sure to have fun!";
	"Please give suggestions!";
	"Be nice to other players!";
	"Don't grief other players!";
	"Check out the shop!";
	"Tip: Don't die!";
}

local function fadeOut()
	for i = textLabel.TextTransparency, 1, .1 do
		wait(.1)
		textLabel.TextTransparency = i
	end
end

local function fadeIn()
	for i = textLabel.TextTransparency, 0, -.1 do
		wait(.1)
		textLabel.TextTransparency = i
	end
end

local lastIndex
while true do
	-- Step 0: Fade out before doing anything 
	fadeOut()
	
	-- Step 1: pick content that wasn't the last displayed
	local index	
	repeat
		index = math.random(1, #content)
	until lastIndex ~= index
	-- Make sure we don't show the same thing next time
	lastIndex = index
	
	-- Step 2: show the content
	textLabel.Text = content[index]
	fadeIn()
	wait(2)
end

```

### Show All Fonts

This code sample renders a list of all the available fonts.
```lua
local frame = script.Parent

-- Create a TextLabel displaying each font
for i, font in pairs(Enum.Font:GetEnumItems()) do
	local tl = Instance.new("TextLabel")
	tl.Name = font.Name
	-- Set the text properties
	tl.Text = font.Name
	tl.Font = font
	-- Some rendering properties
	tl.TextSize = 24
	tl.TextXAlignment = Enum.TextXAlignment.Left
	-- Size the frame equal to the height of the text
	tl.Size = UDim2.new(1, 0, 0, tl.TextSize)
	-- Add to the parent frame
	tl.Parent = frame
end

-- Layout the frames in a list (if they aren't already)
if not frame:FindFirstChildOfClass("UIListLayout") then
	Instance.new("UIListLayout", frame)
end

```
 */
	Text: string;
	/** The read-only property TextBounds reflects the absolute pixel size of rendered text. In other words, if you were to try to fit text into a rectangle, this property would reflect the minimum dimensions of the rectangle you would need in order to fit the text.

Using `GetTextSize`, you can predict what TextBounds will be on a TextLabel given a string, `Font`, `TextSize` and frame size.

## Code Samples

### Dynamic TextBox Size

This code sample dynamically resizes a TextLabel, TextButton or TextBox to match the size of its TextBounds. Try changing the minimum width/height and pasting into a LocalScript in a TextBox.
```lua
local textBox = script.Parent

-- The smallest the TextBox will go
local minWidth, minHeight = 10, 10

-- Set alignment so our text doesn't wobble a bit while we type
textBox.TextXAlignment = Enum.TextXAlignment.Left
textBox.TextYAlignment = Enum.TextYAlignment.Top

local function updateSize()
	textBox.Size = UDim2.new(
		0, math.max(minWidth, textBox.TextBounds.X),
		0, math.max(minHeight, textBox.TextBounds.Y)
	)
end

textBox:GetPropertyChangedSignal("TextBounds"):Connect(updateSize)

```
The read-only property TextBounds reflects the absolute pixel size of rendered text. In other words, if you were to try to fit text into a rectangle, this property would reflect the minimum dimensions of the rectangle you would need in order to fit the text.

Using `GetTextSize`, you can predict what TextBounds will be on a TextLabel given a string, `Font`, `TextSize` and frame size.

## Code Samples

### Dynamic TextBox Size

This code sample dynamically resizes a TextLabel, TextButton or TextBox to match the size of its TextBounds. Try changing the minimum width/height and pasting into a LocalScript in a TextBox.
```lua
local textBox = script.Parent

-- The smallest the TextBox will go
local minWidth, minHeight = 10, 10

-- Set alignment so our text doesn't wobble a bit while we type
textBox.TextXAlignment = Enum.TextXAlignment.Left
textBox.TextYAlignment = Enum.TextYAlignment.Top

local function updateSize()
	textBox.Size = UDim2.new(
		0, math.max(minWidth, textBox.TextBounds.X),
		0, math.max(minHeight, textBox.TextBounds.Y)
	)
end

textBox:GetPropertyChangedSignal("TextBounds"):Connect(updateSize)

```


Tags: ReadOnly, NotReplicated */
	readonly TextBounds: Vector2;
	/** This property determines the color of all the text rendered by a `GUI` element. This property along with `Font`, `TextSize` and `TextTransparency` will determine the visual properties of text. Text is rendered after the text stroke (`TextStrokeColor3`).

It's important that text is easily read by players! Be sure to choose colors with little-to-no saturation, like white, grey, or black. Make sure the color of your text is contrasted by the `BackgroundColor3` of the GUI element. If the element has a transparent background, try applying a black `TextStrokeColor3` to help contrast the text with the 3D world behind it.

## Code Samples

### Vowel Detector

This code sample, when placed within a TextBox, will turn the text color red if the typed string contains no vowels (A, E, I, O or U).
```lua
local textBox = script.Parent

local function hasVowels(str)
	return str:lower():find("[aeiou]")
end

local function onTextChanged()
	local text = textBox.Text
	-- Check for vowels
	if hasVowels(text) then
		textBox.TextColor3 = Color3.new(0, 0, 0) -- Black
	else
		textBox.TextColor3 = Color3.new(1, 0, 0) -- Red
	end
end
textBox:GetPropertyChangedSignal("Text"):Connect(onTextChanged)

```

### TextBox Secret Word

This code sample creates a password-like interface for a TextBox, giving visual feedback on the player's input.
```lua
-- Place this code in a LocalScript inside a TextBox
local textBox = script.Parent

local secretWord = "roblox"
local colorNormal = Color3.new(1, 1, 1) -- white
local colorWrong = Color3.new(1, 0, 0) -- red
local colorCorrect = Color3.new(0, 1, 0) -- green

-- Initialize the state of the textBox
textBox.ClearTextOnFocus = true
textBox.Text = ""
textBox.Font = Enum.Font.Code
textBox.PlaceholderText = "What is the secret word?"
textBox.BackgroundColor3 = colorNormal

local function onFocused()
	textBox.BackgroundColor3 = colorNormal
end

local function onFocusLost(enterPressed, inputObject)
	if enterPressed then
		local guess = textBox.Text
		if guess == secretWord then
			textBox.Text = "ACCESS GRANTED"
			textBox.BackgroundColor3 = colorCorrect
		else
			textBox.Text = "ACCESS DENIED"
			textBox.BackgroundColor3 = colorWrong
		end
	else
		-- The player stopped editing without pressing Enter
		textBox.Text = ""
		textBox.BackgroundColor3 = colorNormal
	end
end

textBox.FocusLost:Connect(onFocusLost)
textBox.Focused:Connect(onFocused)

```

### Game State Text

This code sample mirrors the contents of a StringValue into a TextLabel, updating and setting the color of the text as it changes.
```lua
-- Place a StringValue called "GameState" in the ReplicatedStorage
local vGameState = game.ReplicatedStorage:WaitForChild("GameState")
-- Place this code in a TextLabel
local textLabel = script.Parent

-- Some colors we'll use with TextColor3
local colorNormal = Color3.new(0, 0, 0) -- black
local colorCountdown = Color3.new(1, .5, 0) -- orange
local colorRound = Color3.new(.25, .25, 1) -- blue

-- We'll run this function to update the TextLabel as the state of the
-- game changes.
local function update()
	-- Update the text
	textLabel.Text = "State: " .. vGameState.Value
	-- Set the color of the text based on the current game state
	if vGameState.Value == "Countdown" then
		textLabel.TextColor3 = colorCountdown
	elseif vGameState.Value == "Round" then
		textLabel.TextColor3 = colorRound
	else
		textLabel.TextColor3 = colorNormal
	end
end

-- Pattern: update once when we start and also when vGameState changes
-- We should always see the most updated GameState.
update()
vGameState.Changed:Connect(update) 

```

### Countdown Text

This code sample makes a TextLabel or TextButton count backwards from 10, setting the text color as it does so.
```lua
-- Place this code in a LocalScript within a TextLabel/TextButton
local textLabel = script.Parent

-- Some colors we'll use with TextColor3
local colorNormal = Color3.new(0, 0, 0) -- black
local colorSoon = Color3.new(1, .5, .5) -- red
local colorDone = Color3.new(.5, 1, .5) -- green

-- Loop infinitely
while true do
	-- Count backwards from 10 to 1
	for i = 10, 1, -1 do
		-- Set the text
		textLabel.Text = "Time: " .. i
		-- Set the color based on how much time is left
		if i > 3 then
			textLabel.TextColor3 = colorNormal
		else
			textLabel.TextColor3 = colorSoon
		end
		wait(1)
	end
	textLabel.Text = "GO!"
	textLabel.TextColor3 = colorDone
	wait(2)
end

```
 */
	TextColor3: Color3;
	/** The TextFits is a read-only property that is true if rendered `Text` content does not fit within the `AbsoluteSize` when rendered. If `TextWrapped` is true, this indicates that some text is truncated and not rendering. Otherwise, it indicates if the line of text is rendering outside the UI element's rectangle. If `TextScaled` is enabled, this property will disable when text must be scaled down in order to fit.

## Code Samples

### Long Text Wrapping

This code sample demonstrates TextWrap by spelling out a long chunk of text progressively. If the text doesn't fit, it turns a different color.
```lua
local textLabel = script.Parent

-- This text wrapping demo is best shown on a 200x50 px rectangle  
textLabel.Size = UDim2.new(0, 200, 0, 50)

-- Some content to spell out
local content = "Here's a long string of words that will " ..
                "eventually exceed the UI element's width " ..
                "and form line breaks. Useful for paragraphs " ..
                "that are really long."

-- A function that will spell text out two characters at a time
local function spellTheText()
	-- Iterate from 1 to the length of our content
	for i = 1, content:len() do
		-- Get a substring of our content: 1 to i
		textLabel.Text = content:sub(1, i)
		-- Color the text if it doesn't fit in our box
		if textLabel.TextFits then
			textLabel.TextColor3 = Color3.new(0, 0, 0) -- Black
		else
			textLabel.TextColor3 = Color3.new(1, 0, 0) -- Red
		end		
		-- Wait a brief moment on even lengths
		if i % 2 == 0 then wait() end
	end
end

while true do
	-- Spell the text with scale/wrap off
	textLabel.TextWrapped = false
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with wrap on
	textLabel.TextWrapped = true
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with text scaling on
	-- Note: Text turns red (TextFits = false) once text has to be
	-- scaled down in order to fit within the UI element. 
	textLabel.TextScaled = true
	-- Note: TextWrapped is enabled implicitly when TextScaled = true
	--textLabel.TextWrapped = true 
	spellTheText()
	wait(1)
end
```
The TextFits is a read-only property that is true if rendered `Text` content does not fit within the `AbsoluteSize` when rendered. If `TextWrapped` is true, this indicates that some text is truncated and not rendering. Otherwise, it indicates if the line of text is rendering outside the UI element's rectangle. If `TextScaled` is enabled, this property will disable when text must be scaled down in order to fit.

## Code Samples

### Long Text Wrapping

This code sample demonstrates TextWrap by spelling out a long chunk of text progressively. If the text doesn't fit, it turns a different color.
```lua
local textLabel = script.Parent

-- This text wrapping demo is best shown on a 200x50 px rectangle  
textLabel.Size = UDim2.new(0, 200, 0, 50)

-- Some content to spell out
local content = "Here's a long string of words that will " ..
                "eventually exceed the UI element's width " ..
                "and form line breaks. Useful for paragraphs " ..
                "that are really long."

-- A function that will spell text out two characters at a time
local function spellTheText()
	-- Iterate from 1 to the length of our content
	for i = 1, content:len() do
		-- Get a substring of our content: 1 to i
		textLabel.Text = content:sub(1, i)
		-- Color the text if it doesn't fit in our box
		if textLabel.TextFits then
			textLabel.TextColor3 = Color3.new(0, 0, 0) -- Black
		else
			textLabel.TextColor3 = Color3.new(1, 0, 0) -- Red
		end		
		-- Wait a brief moment on even lengths
		if i % 2 == 0 then wait() end
	end
end

while true do
	-- Spell the text with scale/wrap off
	textLabel.TextWrapped = false
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with wrap on
	textLabel.TextWrapped = true
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with text scaling on
	-- Note: Text turns red (TextFits = false) once text has to be
	-- scaled down in order to fit within the UI element. 
	textLabel.TextScaled = true
	-- Note: TextWrapped is enabled implicitly when TextScaled = true
	--textLabel.TextWrapped = true 
	spellTheText()
	wait(1)
end
```


Tags: ReadOnly, NotReplicated */
	readonly TextFits: boolean;
	/** The TextScaled property determines whether text is scaled so that it fills the entire UI element's space. When this is enabled, `TextSize` is ignored and `TextWrapped` is automatically enabled. This property is useful for text-rendering UI elements within `BillboardGuis`.

When this property is used for screen-space UI, it may be desirable to use a `UITextSizeConstraint` to restrict the range of possible text sizes.

## Code Samples

### Long Text Wrapping

This code sample demonstrates TextWrap by spelling out a long chunk of text progressively. If the text doesn't fit, it turns a different color.
```lua
local textLabel = script.Parent

-- This text wrapping demo is best shown on a 200x50 px rectangle  
textLabel.Size = UDim2.new(0, 200, 0, 50)

-- Some content to spell out
local content = "Here's a long string of words that will " ..
                "eventually exceed the UI element's width " ..
                "and form line breaks. Useful for paragraphs " ..
                "that are really long."

-- A function that will spell text out two characters at a time
local function spellTheText()
	-- Iterate from 1 to the length of our content
	for i = 1, content:len() do
		-- Get a substring of our content: 1 to i
		textLabel.Text = content:sub(1, i)
		-- Color the text if it doesn't fit in our box
		if textLabel.TextFits then
			textLabel.TextColor3 = Color3.new(0, 0, 0) -- Black
		else
			textLabel.TextColor3 = Color3.new(1, 0, 0) -- Red
		end		
		-- Wait a brief moment on even lengths
		if i % 2 == 0 then wait() end
	end
end

while true do
	-- Spell the text with scale/wrap off
	textLabel.TextWrapped = false
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with wrap on
	textLabel.TextWrapped = true
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with text scaling on
	-- Note: Text turns red (TextFits = false) once text has to be
	-- scaled down in order to fit within the UI element. 
	textLabel.TextScaled = true
	-- Note: TextWrapped is enabled implicitly when TextScaled = true
	--textLabel.TextWrapped = true 
	spellTheText()
	wait(1)
end
```
 */
	TextScaled: boolean;
	/** The TextSize property determines the pixel height of one line of rendered text. The unit is in screen pixels, not points (which is used in most document editing programs). It's worth noting that the "Legacy" font's line height behaves differently, and won't match this property exactly.

This property and `TextColor3`, `TextTransparency`, `TextStrokeColor3` and `TextStrokeTransparency` each influence the way text is rendered.

This property supersedes `FontSize` since it is a number and not an enum. Internally, Roblox uses several sets of pre-rendered character images for each size of each font. It chooses the closest size to TextSize, then scales that set of character images to render text. Before the introduction of this property, you could only pick from the pre-rendered sizes, which were listed by the `FontSize` enum.

## Code Samples

### "Kaboom!" Text

This code sample repeatedly tweens a TextLabel's TextSize from 5 to 100 and fades out the text as it grows in size.
```lua
local textLabel = script.Parent

textLabel.Text = "Kaboom!"

while true do
	for size = 5, 100, 5 do
		textLabel.TextSize = size
		textLabel.TextTransparency = size / 100
		wait()
	end
	wait(1)
end

```
 */
	TextSize: number;
	/** The TextStrokeColor3 property sets the color of the stroke, or outline, of rendered text. This property and `TextStrokeTransparency` determine the visual properties of the text stroke.

Text stroke is rendered before normal text and is simply 4 renderings of the same text in +/- 1 pixel offsets in each direction. Text stroke rendering works independently and identically to `TextColor3` and `TextTransparency`.

## Code Samples

### Text Highlight Oscillation

This code sample oscillates a TextLabel's TextStrokeTransparency so that it blinks the highlight of a text.
```lua
local textLabel = script.Parent

-- How fast the highlight ought to blink
local freq = 2

-- Set to yellow highlight color
textLabel.TextStrokeColor3 = Color3.new(1, 1, 0)

while true do
	-- math.sin oscillates from -1 to 1, so we change the range to 0 to 1:
	local transparency = math.sin(workspace.DistributedGameTime*math.pi*freq)*.5+.5
	textLabel.TextStrokeTransparency = transparency
	wait()
end

```
 */
	TextStrokeColor3: Color3;
	/** .The TextStrokeTransparency property sets the transparency of the stroke, or outline, of rendered text. This property and `TextStrokeColor3` determine the visual properties of the text stroke.

Text stroke is rendered before normal text and is simply 4 renderings of the same text in +/- 1 pixel offsets in each direction. Text stroke rendering works independently and identically to `TextColor3` and `TextTransparency`. Since text stroke is simply multiple renderings of the same transparency, this property is essentially multiplicative on itself four times over (e.g. a TextStrokeTransparency of 0.5 appears about the same as TextTransparency of 0.0625, or 0.5^4). Therefore, it's recommended to set TextStrokeTransparency to a value in the range of 0.75 to 1 for more a more subtle effect.

## Code Samples

### Text Highlight Oscillation

This code sample oscillates a TextLabel's TextStrokeTransparency so that it blinks the highlight of a text.
```lua
local textLabel = script.Parent

-- How fast the highlight ought to blink
local freq = 2

-- Set to yellow highlight color
textLabel.TextStrokeColor3 = Color3.new(1, 1, 0)

while true do
	-- math.sin oscillates from -1 to 1, so we change the range to 0 to 1:
	local transparency = math.sin(workspace.DistributedGameTime*math.pi*freq)*.5+.5
	textLabel.TextStrokeTransparency = transparency
	wait()
end

```
 */
	TextStrokeTransparency: number;
	/** The TextColor3 property determines the transparency of all the text rendered by a UI element. This property along with `Font`, `TextSize` and `TextColor3` will determine the visual properties of text. Text is rendered after the text stroke (`TextStrokeTransparency`).

Fading text in using a numeric for-loop is a fantastic way to draw a player's attention to text appearing on screen.

```lua
-- Count backwards from 1 to 0, decrementing by 0.1
for i = 1, 0, -.1 do
   textLabel.TextTransparency = i
   wait(.1)
end
```

## Code Samples

### "Kaboom!" Text

This code sample repeatedly tweens a TextLabel's TextSize from 5 to 100 and fades out the text as it grows in size.
```lua
local textLabel = script.Parent

textLabel.Text = "Kaboom!"

while true do
	for size = 5, 100, 5 do
		textLabel.TextSize = size
		textLabel.TextTransparency = size / 100
		wait()
	end
	wait(1)
end

```

### Fading Banner

This code sample creates a fading banner for a TextLabel. It fades text out, chooses a random string (avoiding repetition), and fades back in.
```lua
local textLabel = script.Parent

local content = {
	"Welcome to my game!";
	"Be sure to have fun!";
	"Please give suggestions!";
	"Be nice to other players!";
	"Don't grief other players!";
	"Check out the shop!";
	"Tip: Don't die!";
}

local function fadeOut()
	for i = textLabel.TextTransparency, 1, .1 do
		wait(.1)
		textLabel.TextTransparency = i
	end
end

local function fadeIn()
	for i = textLabel.TextTransparency, 0, -.1 do
		wait(.1)
		textLabel.TextTransparency = i
	end
end

local lastIndex
while true do
	-- Step 0: Fade out before doing anything 
	fadeOut()
	
	-- Step 1: pick content that wasn't the last displayed
	local index	
	repeat
		index = math.random(1, #content)
	until lastIndex ~= index
	-- Make sure we don't show the same thing next time
	lastIndex = index
	
	-- Step 2: show the content
	textLabel.Text = content[index]
	fadeIn()
	wait(2)
end

```
 */
	TextTransparency: number;
	/** Controls the truncation of the text displayed in this TextLabel. */
	TextTruncate: Enum.TextTruncate;
	/** When enabled, this property will render text on multiple lines within a `GUI` element's space so that `TextBounds` will never exceed the `AbsoluteSize` of the UI element.

This is achieved by breaking long lines of text into multiple lines. Line breaks will prefer whitespace; should a long unbroken word exceed the width of the element, that word will be broken into multiple lines.

If further line breaks would cause the vertical height of the text (the Y component of `TextBounds`) to exceed the vertical height of the element (the Y component of `AbsoluteSize`), then that line will not be rendered at all.

## Code Samples

### Long Text Wrapping

This code sample demonstrates TextWrap by spelling out a long chunk of text progressively. If the text doesn't fit, it turns a different color.
```lua
local textLabel = script.Parent

-- This text wrapping demo is best shown on a 200x50 px rectangle  
textLabel.Size = UDim2.new(0, 200, 0, 50)

-- Some content to spell out
local content = "Here's a long string of words that will " ..
                "eventually exceed the UI element's width " ..
                "and form line breaks. Useful for paragraphs " ..
                "that are really long."

-- A function that will spell text out two characters at a time
local function spellTheText()
	-- Iterate from 1 to the length of our content
	for i = 1, content:len() do
		-- Get a substring of our content: 1 to i
		textLabel.Text = content:sub(1, i)
		-- Color the text if it doesn't fit in our box
		if textLabel.TextFits then
			textLabel.TextColor3 = Color3.new(0, 0, 0) -- Black
		else
			textLabel.TextColor3 = Color3.new(1, 0, 0) -- Red
		end		
		-- Wait a brief moment on even lengths
		if i % 2 == 0 then wait() end
	end
end

while true do
	-- Spell the text with scale/wrap off
	textLabel.TextWrapped = false
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with wrap on
	textLabel.TextWrapped = true
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with text scaling on
	-- Note: Text turns red (TextFits = false) once text has to be
	-- scaled down in order to fit within the UI element. 
	textLabel.TextScaled = true
	-- Note: TextWrapped is enabled implicitly when TextScaled = true
	--textLabel.TextWrapped = true 
	spellTheText()
	wait(1)
end
```
 */
	TextWrapped: boolean;
	/** TextXAlignment determines the horizontal alignment (X-axis) of text rendered within a UI element's space. It functions similarly to the CSS text-align property, with left, right and center values (there is no justify option). For Left and Right, text is rendered such that the left/right text bounds just touch the edge of the UI element rectangle. For Center, each line of text is centered on the very center of the UI element rectangle.

This property is used in conjunction with `TextYAlignment` to fully determine text alignment on both axes. This property won't affect the read-only properties `TextBounds` and `TextFits`.

## Code Samples

### Text Alignment

This code sample shows all the different text alignment combinations by iterating over each enum item. It is meant to be placed within a TextLabel, TextButton or TextBox.
```lua
-- Paste this in a LocalScript within a TextLabel/TextButton/TextBox
local textLabel = script.Parent

local function setAlignment(xAlign, yAlign)
	textLabel.TextXAlignment = xAlign
	textLabel.TextYAlignment = yAlign
	textLabel.Text = xAlign.Name .. " + " .. yAlign.Name
end

while true do
	-- Iterate over both TextXAlignment and TextYAlignment enum items
	for j, yAlign in pairs(Enum.TextYAlignment:GetEnumItems()) do
		for i, xAlign in pairs(Enum.TextXAlignment:GetEnumItems()) do
			setAlignment(xAlign, yAlign)
			wait(1)
		end
	end
end

```
 */
	TextXAlignment: Enum.TextXAlignment;
	/** TextYAlignment determines the vertical alignment (Y-axis) of text rendered within a UI element's space. For Top and Bottom, text is rendered such that the top/bottom text bounds just touch the edge of the UI element rectangle. For Center, text is rendered such that there is an equal space from the top bounds of the text to the top of the element and the bottom bounds of the text to the bottom of the element.

This property is used in conjunction with `TextXAlignment` to fully determine text alignment on both axes. This property won't affect the read-only properties `TextBounds` and `TextFits`.

## Code Samples

### Text Alignment

This code sample shows all the different text alignment combinations by iterating over each enum item. It is meant to be placed within a TextLabel, TextButton or TextBox.
```lua
-- Paste this in a LocalScript within a TextLabel/TextButton/TextBox
local textLabel = script.Parent

local function setAlignment(xAlign, yAlign)
	textLabel.TextXAlignment = xAlign
	textLabel.TextYAlignment = yAlign
	textLabel.Text = xAlign.Name .. " + " .. yAlign.Name
end

while true do
	-- Iterate over both TextXAlignment and TextYAlignment enum items
	for j, yAlign in pairs(Enum.TextYAlignment:GetEnumItems()) do
		for i, xAlign in pairs(Enum.TextXAlignment:GetEnumItems()) do
			setAlignment(xAlign, yAlign)
			wait(1)
		end
	end
end

```
 */
	TextYAlignment: Enum.TextYAlignment;
}

/** The ScrollingFrame is a special `Frame` that handles all scrolling for you, with a range of different ways to customize how the scrolling works. An in-depth tutorial for the ScrollingFrame can be found [here](https://developer.roblox.com/articles/Creating-a-Scrolling-Frame-GUI)
. */
interface ScrollingFrame extends RbxInternalGuiObject {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ScrollingFrame";
	/** The size in pixels of the frame, without the scrollbars.The size in pixels of the frame, without the scrollbars.

Tags: ReadOnly, NotReplicated */
	readonly AbsoluteWindowSize: Vector2;
	/** The Down image on the vertical scrollbar. Size of this is always ScrollBarThickness by ScrollBarThickness. This is also used as the image on the horizontal scroll bar. */
	BottomImage: string;
	/** The location within the canvas, in pixels, that should be drawn at the top left of the scroll frame */
	CanvasPosition: Vector2;
	/** Determines the size of the area that is scrollable. The UDim2 is calculated using the parent gui's size, similar to the regular Size property on gui objects. */
	CanvasSize: UDim2;
	/** This property determines when elastic scrolling is allowed. It can be used to dictate if and when the `ScrollingFrame` canvas is elastic. Defaults to WhenScrollable.

## What's the Differences Between Elastic and Non-Elastic
### Elastic
The image below demonstrates Enum.Elasticity.Always an Enum.Elasticity.WhenScrollable when the canvas is scrollable:
![Enum.Elasticity.Always](https://developer.roblox.com/assets/5c6366ca0a42866d41de58a4/ElasticityAlways.gif)

### Non-Elastic
The image below demonstrates Enum.Elasticity.Never:
![Enum.Elasticity.Never](https://developer.roblox.com/assets/5c6366e26d61b3c84129fe2f/ElasticityNever.gif)

## Enums
It can be set to several `ElasticBehavior` enum values, which determine how elastic scrolling behaves:

| Name | Description |
| --- | --- |
| Always | Regardless of scrolling, you can always move the canvas a bit outside the bounds |
| Never | You can never move the canvas outside the rect bounds |
| WhenScrollable | (default) Elastic scrolling is allowed when canvas size is larger than the rect size |


## See also
  - `ScrollingDirection`, the direction scrolling is allowed in this scrolling frame */
	ElasticBehavior: Enum.ElasticBehavior;
	/** Indicates the inset behavior of the horizontal scrolling bar. */
	HorizontalScrollBarInset: Enum.ScrollBarInset;
	/** The middle image on the vertical scrollbar. The size of this can vary in the y direction, but is always set as `ScrollBarThickness` in the x direction. This is also used as the middle image on the horizontal scroll bar. */
	MidImage: string;
	/** [LACKS DOCUMENTATION] */
	ScrollBarImageColor3: Color3;
	/** [LACKS DOCUMENTATION] */
	ScrollBarImageTransparency: number;
	/** How thick the scroll bar appears. This applies to both the horizontal and vertical scroll bars. If set to 0, no scroll bars are rendered. */
	ScrollBarThickness: number;
	/** This property determines the direction scrolling is allowed. If scrolling is disallowed in a direction, the scrollbar will not appear. Defaults to XY.

## What are the Different Scrolling Directions
### XY (Default)
The image below demonstrates Enum.ScrollingDirection.XY:
![Enum.ScrollingDirection.XY](https://developer.roblox.com/assets/5c636ba20a42866d41de58cc/ScrollingDirectionXY.gif)

### X
The image below demonstrates Enum.ScrollingDirection.X:
![Enum.ScrollingDirection.X](https://developer.roblox.com/assets/5c636bbfe2c86a6c4191bc61/ScrollingDirectionX.gif)

### Y
The image below demonstrates Enum.ScrollingDirection.Y:
![Enum.ScrollingDirection.Y](https://developer.roblox.com/assets/5c636bcb6d61b3c84129fe45/ScrollingDirectionY.gif)

## Enums
It can be set to several `ScrollingDirection` enum values, which determine how elastic scrolling behaves:

| Name | Description |
| --- | --- |
| XY | (default) Canvas can be scrolled along both X and Y axes |
| X | Canvas can only be scrolled along the X axis |
| Y | Canvas can only be scrolled along the Y axis |


## See also
  - `ElasticBehavior`, how elastic scrolling behaves for touch input */
	ScrollingDirection: Enum.ScrollingDirection;
	/** Determines whether or not scrolling is allowed on the frame. If false, no scroll bars will be rendered. */
	ScrollingEnabled: boolean;
	/** The Up image on the vertical scrollbar. The size of this is always ScrollBarThickness by ScrollBarThickness. This is also used as the left image on the horizontal scroll bar. */
	TopImage: string;
	/** Indicates the inset behavior of the vertical scrolling bar. */
	VerticalScrollBarInset: Enum.ScrollBarInset;
	/** Indicates the side that the vertical scrollbar will be located at. */
	VerticalScrollBarPosition: Enum.VerticalScrollBarPosition;
}

/** A GUI object which allows you to type within its boundaries. 

TextBox is specifically meant for user input.

Unlike `TextLabel`, TextBoxes will not be translated by `LocalizationService` because it's text is assumed to be user input. For a text field that is not meant for user input `TextLabel` should be used.

## Code Samples

### TextBox Secret Word

This code sample creates a password-like interface for a TextBox, giving visual feedback on the player's input.
```lua
-- Place this code in a LocalScript inside a TextBox
local textBox = script.Parent

local secretWord = "roblox"
local colorNormal = Color3.new(1, 1, 1) -- white
local colorWrong = Color3.new(1, 0, 0) -- red
local colorCorrect = Color3.new(0, 1, 0) -- green

-- Initialize the state of the textBox
textBox.ClearTextOnFocus = true
textBox.Text = ""
textBox.Font = Enum.Font.Code
textBox.PlaceholderText = "What is the secret word?"
textBox.BackgroundColor3 = colorNormal

local function onFocused()
	textBox.BackgroundColor3 = colorNormal
end

local function onFocusLost(enterPressed, inputObject)
	if enterPressed then
		local guess = textBox.Text
		if guess == secretWord then
			textBox.Text = "ACCESS GRANTED"
			textBox.BackgroundColor3 = colorCorrect
		else
			textBox.Text = "ACCESS DENIED"
			textBox.BackgroundColor3 = colorWrong
		end
	else
		-- The player stopped editing without pressing Enter
		textBox.Text = ""
		textBox.BackgroundColor3 = colorNormal
	end
end

textBox.FocusLost:Connect(onFocusLost)
textBox.Focused:Connect(onFocused)

```
 */
interface TextBox extends RbxInternalGuiObject {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TextBox";
	/** Determines whether clicking on the TextBox will clear its `Text` property */
	ClearTextOnFocus: boolean;

	CursorPosition: number;
	/** The Font property selects one of several pre-defined `fonts` with which the UI element will render its text. Some fonts have bold, italic and/or light variants (as there is no font-weight or font-style properties).

With the exception of the "Legacy" font, each font will render text with the line height equal to the `TextSize` property. The "Code" font is the only monospace font. It has the unique property that each character has the exact same width and height ratio of 1:2. The width of each character is approximately half the `TextSize` property.

## Code Samples

### Show All Fonts

This code sample renders a list of all the available fonts.
```lua
local frame = script.Parent

-- Create a TextLabel displaying each font
for i, font in pairs(Enum.Font:GetEnumItems()) do
	local tl = Instance.new("TextLabel")
	tl.Name = font.Name
	-- Set the text properties
	tl.Text = font.Name
	tl.Font = font
	-- Some rendering properties
	tl.TextSize = 24
	tl.TextXAlignment = Enum.TextXAlignment.Left
	-- Size the frame equal to the height of the text
	tl.Size = UDim2.new(1, 0, 0, tl.TextSize)
	-- Add to the parent frame
	tl.Parent = frame
end

-- Layout the frames in a list (if they aren't already)
if not frame:FindFirstChildOfClass("UIListLayout") then
	Instance.new("UIListLayout", frame)
end

```

### Cycle Font

This code sample sets a parent TextLabel's Font and Text properties to all the different fonts available.
```lua
local textLabel = script.Parent

while true do
	-- Iterate over all the different fonts
	for i, font in pairs(Enum.Font:GetEnumItems()) do
		textLabel.Font = font
		textLabel.Text = font.Name
		wait(1)
	end
end

```
 */
	Font: Enum.Font;
	/** Scales the spacing between lines of text in the TextBox. */
	LineHeight: number;
	/** When set to true, text inside a TextBox is able to move onto multiple lines. This also enables players to use the enter key to move onto a new line. */
	MultiLine: boolean;
	/** Sets the text color that gets used when no text has been entered into the TextBox yet. */
	PlaceholderColor3: Color3;
	/** Sets the text that gets displayed when no text has been entered into the TextBox yet. */
	PlaceholderText: string;
	/** If set to true, input native to the platform is used instead of Roblox's built-in keyboard. */
	ShowNativeInput: boolean;
	/** The Text property determines the content rendered by the UI element. The visual properties of the string rendered to the screen is determined by `TextColor3`, `TextTransparency`, `TextSize`, `Font`, `TextScaled`, `TextWrapped`, `TextXAlignment` and `TextYAlignment`.

It is possible to render emoji (for example, 😃) and other symbols. These special symbols aren't affected by the `TextColor3` property. These can be pasted into `Script` and `LocalScript` objects, as well as the field within the Properties window.

This property may contain newline characters, however, it is not possible to type newline characters within the Properties window. Similarly, this property may contain a tab character, but it will render as a space instead.

## Code Samples

### Emoji in Text

This code sample demonstrates emoji rendering using the Text property.
```lua
local textLabel = script.Parent

local moods = {
	["happy"] = "😃";
	["sad"] = "😢";
	["neutral"] = "😐";
	["tired"] = "😫";
}

while true do
	for mood, face in pairs(moods) do
		textLabel.Text = "I am feeling " .. mood .. "! " .. face
		wait(1)
	end
end

```

### Long Text Wrapping

This code sample demonstrates TextWrap by spelling out a long chunk of text progressively. If the text doesn't fit, it turns a different color.
```lua
local textLabel = script.Parent

-- This text wrapping demo is best shown on a 200x50 px rectangle  
textLabel.Size = UDim2.new(0, 200, 0, 50)

-- Some content to spell out
local content = "Here's a long string of words that will " ..
                "eventually exceed the UI element's width " ..
                "and form line breaks. Useful for paragraphs " ..
                "that are really long."

-- A function that will spell text out two characters at a time
local function spellTheText()
	-- Iterate from 1 to the length of our content
	for i = 1, content:len() do
		-- Get a substring of our content: 1 to i
		textLabel.Text = content:sub(1, i)
		-- Color the text if it doesn't fit in our box
		if textLabel.TextFits then
			textLabel.TextColor3 = Color3.new(0, 0, 0) -- Black
		else
			textLabel.TextColor3 = Color3.new(1, 0, 0) -- Red
		end		
		-- Wait a brief moment on even lengths
		if i % 2 == 0 then wait() end
	end
end

while true do
	-- Spell the text with scale/wrap off
	textLabel.TextWrapped = false
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with wrap on
	textLabel.TextWrapped = true
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with text scaling on
	-- Note: Text turns red (TextFits = false) once text has to be
	-- scaled down in order to fit within the UI element. 
	textLabel.TextScaled = true
	-- Note: TextWrapped is enabled implicitly when TextScaled = true
	--textLabel.TextWrapped = true 
	spellTheText()
	wait(1)
end
```

### "Kaboom!" Text

This code sample repeatedly tweens a TextLabel's TextSize from 5 to 100 and fades out the text as it grows in size.
```lua
local textLabel = script.Parent

textLabel.Text = "Kaboom!"

while true do
	for size = 5, 100, 5 do
		textLabel.TextSize = size
		textLabel.TextTransparency = size / 100
		wait()
	end
	wait(1)
end

```

### Fading Banner

This code sample creates a fading banner for a TextLabel. It fades text out, chooses a random string (avoiding repetition), and fades back in.
```lua
local textLabel = script.Parent

local content = {
	"Welcome to my game!";
	"Be sure to have fun!";
	"Please give suggestions!";
	"Be nice to other players!";
	"Don't grief other players!";
	"Check out the shop!";
	"Tip: Don't die!";
}

local function fadeOut()
	for i = textLabel.TextTransparency, 1, .1 do
		wait(.1)
		textLabel.TextTransparency = i
	end
end

local function fadeIn()
	for i = textLabel.TextTransparency, 0, -.1 do
		wait(.1)
		textLabel.TextTransparency = i
	end
end

local lastIndex
while true do
	-- Step 0: Fade out before doing anything 
	fadeOut()
	
	-- Step 1: pick content that wasn't the last displayed
	local index	
	repeat
		index = math.random(1, #content)
	until lastIndex ~= index
	-- Make sure we don't show the same thing next time
	lastIndex = index
	
	-- Step 2: show the content
	textLabel.Text = content[index]
	fadeIn()
	wait(2)
end

```

### Show All Fonts

This code sample renders a list of all the available fonts.
```lua
local frame = script.Parent

-- Create a TextLabel displaying each font
for i, font in pairs(Enum.Font:GetEnumItems()) do
	local tl = Instance.new("TextLabel")
	tl.Name = font.Name
	-- Set the text properties
	tl.Text = font.Name
	tl.Font = font
	-- Some rendering properties
	tl.TextSize = 24
	tl.TextXAlignment = Enum.TextXAlignment.Left
	-- Size the frame equal to the height of the text
	tl.Size = UDim2.new(1, 0, 0, tl.TextSize)
	-- Add to the parent frame
	tl.Parent = frame
end

-- Layout the frames in a list (if they aren't already)
if not frame:FindFirstChildOfClass("UIListLayout") then
	Instance.new("UIListLayout", frame)
end

```
 */
	Text: string;
	/** The read-only property TextBounds reflects the absolute pixel size of rendered text. In other words, if you were to try to fit text into a rectangle, this property would reflect the minimum dimensions of the rectangle you would need in order to fit the text.

Using `GetTextSize`, you can predict what TextBounds will be on a TextLabel given a string, `Font`, `TextSize` and frame size.

## Code Samples

### Dynamic TextBox Size

This code sample dynamically resizes a TextLabel, TextButton or TextBox to match the size of its TextBounds. Try changing the minimum width/height and pasting into a LocalScript in a TextBox.
```lua
local textBox = script.Parent

-- The smallest the TextBox will go
local minWidth, minHeight = 10, 10

-- Set alignment so our text doesn't wobble a bit while we type
textBox.TextXAlignment = Enum.TextXAlignment.Left
textBox.TextYAlignment = Enum.TextYAlignment.Top

local function updateSize()
	textBox.Size = UDim2.new(
		0, math.max(minWidth, textBox.TextBounds.X),
		0, math.max(minHeight, textBox.TextBounds.Y)
	)
end

textBox:GetPropertyChangedSignal("TextBounds"):Connect(updateSize)

```
 */
	readonly TextBounds: Vector2;
	/** This property determines the color of all the text rendered by a `GUI` element. This property along with `Font`, `TextSize` and `TextTransparency` will determine the visual properties of text. Text is rendered after the text stroke (`TextStrokeColor3`).

It's important that text is easily read by players! Be sure to choose colors with little-to-no saturation, like white, grey, or black. Make sure the color of your text is contrasted by the `BackgroundColor3` of the UI element. If the element has a transparent background, try applying a black `TextStrokeColor3` to help contrast the text with the 3D world behind it.

## Code Samples

### Vowel Detector

This code sample, when placed within a TextBox, will turn the text color red if the typed string contains no vowels (A, E, I, O or U).
```lua
local textBox = script.Parent

local function hasVowels(str)
	return str:lower():find("[aeiou]")
end

local function onTextChanged()
	local text = textBox.Text
	-- Check for vowels
	if hasVowels(text) then
		textBox.TextColor3 = Color3.new(0, 0, 0) -- Black
	else
		textBox.TextColor3 = Color3.new(1, 0, 0) -- Red
	end
end
textBox:GetPropertyChangedSignal("Text"):Connect(onTextChanged)

```

### TextBox Secret Word

This code sample creates a password-like interface for a TextBox, giving visual feedback on the player's input.
```lua
-- Place this code in a LocalScript inside a TextBox
local textBox = script.Parent

local secretWord = "roblox"
local colorNormal = Color3.new(1, 1, 1) -- white
local colorWrong = Color3.new(1, 0, 0) -- red
local colorCorrect = Color3.new(0, 1, 0) -- green

-- Initialize the state of the textBox
textBox.ClearTextOnFocus = true
textBox.Text = ""
textBox.Font = Enum.Font.Code
textBox.PlaceholderText = "What is the secret word?"
textBox.BackgroundColor3 = colorNormal

local function onFocused()
	textBox.BackgroundColor3 = colorNormal
end

local function onFocusLost(enterPressed, inputObject)
	if enterPressed then
		local guess = textBox.Text
		if guess == secretWord then
			textBox.Text = "ACCESS GRANTED"
			textBox.BackgroundColor3 = colorCorrect
		else
			textBox.Text = "ACCESS DENIED"
			textBox.BackgroundColor3 = colorWrong
		end
	else
		-- The player stopped editing without pressing Enter
		textBox.Text = ""
		textBox.BackgroundColor3 = colorNormal
	end
end

textBox.FocusLost:Connect(onFocusLost)
textBox.Focused:Connect(onFocused)

```

### Game State Text

This code sample mirrors the contents of a StringValue into a TextLabel, updating and setting the color of the text as it changes.
```lua
-- Place a StringValue called "GameState" in the ReplicatedStorage
local vGameState = game.ReplicatedStorage:WaitForChild("GameState")
-- Place this code in a TextLabel
local textLabel = script.Parent

-- Some colors we'll use with TextColor3
local colorNormal = Color3.new(0, 0, 0) -- black
local colorCountdown = Color3.new(1, .5, 0) -- orange
local colorRound = Color3.new(.25, .25, 1) -- blue

-- We'll run this function to update the TextLabel as the state of the
-- game changes.
local function update()
	-- Update the text
	textLabel.Text = "State: " .. vGameState.Value
	-- Set the color of the text based on the current game state
	if vGameState.Value == "Countdown" then
		textLabel.TextColor3 = colorCountdown
	elseif vGameState.Value == "Round" then
		textLabel.TextColor3 = colorRound
	else
		textLabel.TextColor3 = colorNormal
	end
end

-- Pattern: update once when we start and also when vGameState changes
-- We should always see the most updated GameState.
update()
vGameState.Changed:Connect(update) 

```

### Countdown Text

This code sample makes a TextLabel or TextButton count backwards from 10, setting the text color as it does so.
```lua
-- Place this code in a LocalScript within a TextLabel/TextButton
local textLabel = script.Parent

-- Some colors we'll use with TextColor3
local colorNormal = Color3.new(0, 0, 0) -- black
local colorSoon = Color3.new(1, .5, .5) -- red
local colorDone = Color3.new(.5, 1, .5) -- green

-- Loop infinitely
while true do
	-- Count backwards from 10 to 1
	for i = 10, 1, -1 do
		-- Set the text
		textLabel.Text = "Time: " .. i
		-- Set the color based on how much time is left
		if i > 3 then
			textLabel.TextColor3 = colorNormal
		else
			textLabel.TextColor3 = colorSoon
		end
		wait(1)
	end
	textLabel.Text = "GO!"
	textLabel.TextColor3 = colorDone
	wait(2)
end

```
 */
	TextColor3: Color3;
	/** Whether the text fits within the constraints of the TextBox. */
	readonly TextFits: boolean;
	/** Changes whether text is resized to fit the GUI object that renders it.

## Code Samples

### Long Text Wrapping

This code sample demonstrates TextWrap by spelling out a long chunk of text progressively. If the text doesn't fit, it turns a different color.
```lua
local textLabel = script.Parent

-- This text wrapping demo is best shown on a 200x50 px rectangle  
textLabel.Size = UDim2.new(0, 200, 0, 50)

-- Some content to spell out
local content = "Here's a long string of words that will " ..
                "eventually exceed the UI element's width " ..
                "and form line breaks. Useful for paragraphs " ..
                "that are really long."

-- A function that will spell text out two characters at a time
local function spellTheText()
	-- Iterate from 1 to the length of our content
	for i = 1, content:len() do
		-- Get a substring of our content: 1 to i
		textLabel.Text = content:sub(1, i)
		-- Color the text if it doesn't fit in our box
		if textLabel.TextFits then
			textLabel.TextColor3 = Color3.new(0, 0, 0) -- Black
		else
			textLabel.TextColor3 = Color3.new(1, 0, 0) -- Red
		end		
		-- Wait a brief moment on even lengths
		if i % 2 == 0 then wait() end
	end
end

while true do
	-- Spell the text with scale/wrap off
	textLabel.TextWrapped = false
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with wrap on
	textLabel.TextWrapped = true
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with text scaling on
	-- Note: Text turns red (TextFits = false) once text has to be
	-- scaled down in order to fit within the UI element. 
	textLabel.TextScaled = true
	-- Note: TextWrapped is enabled implicitly when TextScaled = true
	--textLabel.TextWrapped = true 
	spellTheText()
	wait(1)
end
```
 */
	TextScaled: boolean;
	/** The TextSize property determines the pixel height of one line of rendered text. The unit is in screen pixels, not points (which is used in most document editing programs). The "Legacy" font does not hold this property.

## Code Samples

### "Kaboom!" Text

This code sample repeatedly tweens a TextLabel's TextSize from 5 to 100 and fades out the text as it grows in size.
```lua
local textLabel = script.Parent

textLabel.Text = "Kaboom!"

while true do
	for size = 5, 100, 5 do
		textLabel.TextSize = size
		textLabel.TextTransparency = size / 100
		wait()
	end
	wait(1)
end

```
 */
	TextSize: number;
	/** The TextStrokeColor3 property sets the color of the stroke, or outline, of rendered text. This property and `TextStrokeTransparency` determine the visual properties of the text stroke.

Text stroke is rendered before normal text and is simply 4 renderings of the same text in +/- 1 pixel offsets in each direction. Text stroke rendering works independently and identically to `TextColor3` and `TextTransparency`.

## Code Samples

### Text Highlight Oscillation

This code sample oscillates a TextLabel's TextStrokeTransparency so that it blinks the highlight of a text.
```lua
local textLabel = script.Parent

-- How fast the highlight ought to blink
local freq = 2

-- Set to yellow highlight color
textLabel.TextStrokeColor3 = Color3.new(1, 1, 0)

while true do
	-- math.sin oscillates from -1 to 1, so we change the range to 0 to 1:
	local transparency = math.sin(workspace.DistributedGameTime*math.pi*freq)*.5+.5
	textLabel.TextStrokeTransparency = transparency
	wait()
end

```
 */
	TextStrokeColor3: Color3;
	/** .The TextStrokeTransparency property sets the transparency of the stroke, or outline, of rendered text. This property and `TextStrokeColor3` determine the visual properties of the text stroke.

Text stroke is rendered before normal text and is simply 4 renderings of the same text in +/- 1 pixel offsets in each direction. Text stroke rendering works independently and identically to `TextColor3` and `TextTransparency`. Since text stroke is simply multiple renderings of the same transparency, this property is essentially multiplicative on itself four times over (e.g. a TextStrokeTransparency of 0.5 appears about the same as TextTransparency of 0.0625, or 0.5^4). Therefore, it's recommended to set TextStrokeTransparency to a value in the range of 0.75 to 1 for more a more subtle effect.

## Code Samples

### Text Highlight Oscillation

This code sample oscillates a TextLabel's TextStrokeTransparency so that it blinks the highlight of a text.
```lua
local textLabel = script.Parent

-- How fast the highlight ought to blink
local freq = 2

-- Set to yellow highlight color
textLabel.TextStrokeColor3 = Color3.new(1, 1, 0)

while true do
	-- math.sin oscillates from -1 to 1, so we change the range to 0 to 1:
	local transparency = math.sin(workspace.DistributedGameTime*math.pi*freq)*.5+.5
	textLabel.TextStrokeTransparency = transparency
	wait()
end

```
 */
	TextStrokeTransparency: number;
	/** The TextColor3 property determines the transparency of all the text rendered by a UI element. This property along with `Font`, `TextSize` and `TextColor3` will determine the visual properties of text. Text is rendered after the text stroke (`TextStrokeTransparency`).

Fading text in using a numeric for-loop is a fantastic way to draw a player's attention to text appearing on screen.

```lua
-- Count backwards from 1 to 0, decrementing by 0.1
for i = 1, 0, -.1 do
   textLabel.TextTransparency = i
   wait(.1)
end
```

## Code Samples

### "Kaboom!" Text

This code sample repeatedly tweens a TextLabel's TextSize from 5 to 100 and fades out the text as it grows in size.
```lua
local textLabel = script.Parent

textLabel.Text = "Kaboom!"

while true do
	for size = 5, 100, 5 do
		textLabel.TextSize = size
		textLabel.TextTransparency = size / 100
		wait()
	end
	wait(1)
end

```

### Fading Banner

This code sample creates a fading banner for a TextLabel. It fades text out, chooses a random string (avoiding repetition), and fades back in.
```lua
local textLabel = script.Parent

local content = {
	"Welcome to my game!";
	"Be sure to have fun!";
	"Please give suggestions!";
	"Be nice to other players!";
	"Don't grief other players!";
	"Check out the shop!";
	"Tip: Don't die!";
}

local function fadeOut()
	for i = textLabel.TextTransparency, 1, .1 do
		wait(.1)
		textLabel.TextTransparency = i
	end
end

local function fadeIn()
	for i = textLabel.TextTransparency, 0, -.1 do
		wait(.1)
		textLabel.TextTransparency = i
	end
end

local lastIndex
while true do
	-- Step 0: Fade out before doing anything 
	fadeOut()
	
	-- Step 1: pick content that wasn't the last displayed
	local index	
	repeat
		index = math.random(1, #content)
	until lastIndex ~= index
	-- Make sure we don't show the same thing next time
	lastIndex = index
	
	-- Step 2: show the content
	textLabel.Text = content[index]
	fadeIn()
	wait(2)
end

```
 */
	TextTransparency: number;
	/** Controls the truncation of the text displayed in this TextBox. */
	TextTruncate: Enum.TextTruncate;
	/** When enabled, this property will render text on multiple lines within a `GUI` element's space so that `TextBounds` will never exceed the `AbsoluteSize` of the GUI element. 

This is achieved by breaking long lines of text into multiple lines. Line breaks will prefer whitespace; should a long unbroken word exceed the width of the element, that word will be broken into multiple lines.

If further line breaks would cause the vertical height of the text (the Y component of `TextBounds`) to exceed the vertical height of the element (the Y component of `AbsoluteSize`), then that line will not be rendered at all.

## Code Samples

### Long Text Wrapping

This code sample demonstrates TextWrap by spelling out a long chunk of text progressively. If the text doesn't fit, it turns a different color.
```lua
local textLabel = script.Parent

-- This text wrapping demo is best shown on a 200x50 px rectangle  
textLabel.Size = UDim2.new(0, 200, 0, 50)

-- Some content to spell out
local content = "Here's a long string of words that will " ..
                "eventually exceed the UI element's width " ..
                "and form line breaks. Useful for paragraphs " ..
                "that are really long."

-- A function that will spell text out two characters at a time
local function spellTheText()
	-- Iterate from 1 to the length of our content
	for i = 1, content:len() do
		-- Get a substring of our content: 1 to i
		textLabel.Text = content:sub(1, i)
		-- Color the text if it doesn't fit in our box
		if textLabel.TextFits then
			textLabel.TextColor3 = Color3.new(0, 0, 0) -- Black
		else
			textLabel.TextColor3 = Color3.new(1, 0, 0) -- Red
		end		
		-- Wait a brief moment on even lengths
		if i % 2 == 0 then wait() end
	end
end

while true do
	-- Spell the text with scale/wrap off
	textLabel.TextWrapped = false
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with wrap on
	textLabel.TextWrapped = true
	textLabel.TextScaled = false
	spellTheText()
	wait(1)
	-- Spell the text with text scaling on
	-- Note: Text turns red (TextFits = false) once text has to be
	-- scaled down in order to fit within the UI element. 
	textLabel.TextScaled = true
	-- Note: TextWrapped is enabled implicitly when TextScaled = true
	--textLabel.TextWrapped = true 
	spellTheText()
	wait(1)
end
```
 */
	TextWrapped: boolean;
	/** TextXAlignment determines the horizontal alignment (X-axis) of text rendered within a UI element's space. It functions similarly to the CSS text-align property, with left, right and center values (there is no justify option). For Left and Right, text is rendered such that the left/right text bounds just touch the edge of the UI element rectangle. For Center, each line of text is centered on the very center of the UI element rectangle.

This property is used in conjunction with `TextYAlignment` to fully determine text alignment on both axes. This property won't affect the read-only properties `TextBounds` and `TextFits`.

## Code Samples

### Text Alignment

This code sample shows all the different text alignment combinations by iterating over each enum item. It is meant to be placed within a TextLabel, TextButton or TextBox.
```lua
-- Paste this in a LocalScript within a TextLabel/TextButton/TextBox
local textLabel = script.Parent

local function setAlignment(xAlign, yAlign)
	textLabel.TextXAlignment = xAlign
	textLabel.TextYAlignment = yAlign
	textLabel.Text = xAlign.Name .. " + " .. yAlign.Name
end

while true do
	-- Iterate over both TextXAlignment and TextYAlignment enum items
	for j, yAlign in pairs(Enum.TextYAlignment:GetEnumItems()) do
		for i, xAlign in pairs(Enum.TextXAlignment:GetEnumItems()) do
			setAlignment(xAlign, yAlign)
			wait(1)
		end
	end
end

```
 */
	TextXAlignment: Enum.TextXAlignment;
	/** TextYAlignment determines the vertical alignment (Y-axis) of text rendered within a UI element's space. For Top and Bottom, text is rendered such that the top/bottom text bounds just touch the edge of the UI element rectangle. For Center, text is rendered such that there is an equal space from the top bounds of the text to the top of the element and the bottom bounds of the text to the bottom of the element.

This property is used in conjunction with `TextXAlignment` to fully determine text alignment on both axes. This property won't affect the read-only properties `TextBounds` and `TextFits`.

## Code Samples

### Text Alignment

This code sample shows all the different text alignment combinations by iterating over each enum item. It is meant to be placed within a TextLabel, TextButton or TextBox.
```lua
-- Paste this in a LocalScript within a TextLabel/TextButton/TextBox
local textLabel = script.Parent

local function setAlignment(xAlign, yAlign)
	textLabel.TextXAlignment = xAlign
	textLabel.TextYAlignment = yAlign
	textLabel.Text = xAlign.Name .. " + " .. yAlign.Name
end

while true do
	-- Iterate over both TextXAlignment and TextYAlignment enum items
	for j, yAlign in pairs(Enum.TextYAlignment:GetEnumItems()) do
		for i, xAlign in pairs(Enum.TextXAlignment:GetEnumItems()) do
			setAlignment(xAlign, yAlign)
			wait(1)
		end
	end
end

```
 */
	TextYAlignment: Enum.TextYAlignment;
	/** Forces the client to focus on the TextBox.

## Code Samples

### TextBox:CaptureFocus

The code shown below will force the client to focus on the `/TextBox` when the 'q' key is pressed by the player.
```lua
local Mouse = game.Players.LocalPlayer:GetMouse()
 
Mouse.KeyDown:Connect(function(Key)
	if Key:lower() == "q" then
		script.Parent:CaptureFocus()
	end
end)
```
 */
	CaptureFocus(): void;
	/** Returns true if the textbox is focused, or false if it is not. */
	IsFocused(): boolean;
	/** Forces the client to unfocus the TextBox.
The _submitted_ parameter allows you to over-ride the _enterPressed_ parameter in the [FocusLost](https://developer.roblox.com/api-reference/event/TextBox/FocusLost "FocusLost") event.

## Notes

* This item should be used with a `LocalScript` in order to work as expected in online mode.

## Example

The code shown below will force the client to unfocus the 'TextBox' 5 seconds after it's selected:

```lua
local TextBox = script.Parent
TextBox.Focused:Connect(function()
	wait(5)
	TextBox:ReleaseFocus()
end)
```

Please be aware that the above example assumes that it's in a LocalScript, as a child of a TextBox.

## Code Samples

### TextBox:ReleaseFocus

The code shown below will force the client to unfocus the 'TextBox' 5 seconds after it's selected:
```lua
local TextBox = script.Parent
TextBox.Focused:Connect(function()
	wait(5)
	TextBox:ReleaseFocus()
end)

```
 */
	ReleaseFocus(submitted?: boolean): void;
	/** The FocusLost event fires when the client lets their focus off the TextBox - typically when a client clicks/taps on a TextBox to begin text entry. This also fires if a TextBox forces focus on the user.

It can be used alongside `TextBox.Focus` to track when a TextBox gains and loses focus.

See also the `/UserInputService/TextBoxFocused` and `/UserInputService/TextBoxFocusReleased` for similar functions that rely on the UserInputService service.

This event will only fire when used in a `/LocalScript`.

## Code Samples

### TextBox.FocusLost1

The example shown below will print "Focus was lost because enter was pressed!" whenever the TextBox loses focus as a result of the enter key being pressed.
```lua

script.Parent.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        print("Focus was lost because enter was pressed!")
    end
end)

```

### FocusLost

This example works when placed in a `/LocalScript` that is the child of a TextBox. When the TextBox loses focus, the example prints either:

 1. "Player pressed Enter" - if the TextBox lost focus because the player pressed the Enter key.
***or***
 2. "Player pressed InputObject.*KeyCode*" - where "*KeyCode*" is the `/InputObject` KeyCode property of the input that caused the TextBox to lose focus. For example, pressing the Escape (esc) key to exit TextBox focus returns an InputObject instance with the KeyCode 'InputObject.Escape'.
```lua
TextBox.FocusLost:Connect(function(enterPressed, inputThatCausedFocusLost)
	if enterPressed then
		print("Player pressed Enter")
	else
		print("Player pressed", inputThatCausedFocusLost.KeyCode)
	end
end)
```
 */
	readonly FocusLost: RBXScriptSignal<(enterPressed: boolean, inputThatCausedFocusLoss: InputObject) => void>;
	/** The Focused event fires when the `/TextBox` gains focus - typically when a client clicks/taps on a TextBox to begin text entry. This also fires if a TextBox forces focus on the user.

It can be used alongside `TextBox.FocusLost` to track when a TextBox gains and loses focus.

See also the `/UserInputService/TextBoxFocused` and `/UserInputService/TextBoxFocusReleased` for similar functions that rely on the UserInputService service.

This event will only fire when used in a `/LocalScript`.

## Code Samples

### Focus

This example works when placed in a `/LocalScript` that is the child of a TextBox. When the TextBox gains focus, the example prints "Focus".
```lua
local TextBox = script.Parent

TextBox.Focused:Connect(function()
	print("Focused")
end)
```
 */
	readonly Focused: RBXScriptSignal<() => void>;
}

/** A `GUI` that can display children 3D objects inside its viewport. Children objects will not be rendered in the main scene. Background color is transparent.

This is a great way to display 3D objects/models in a 2D&nbsp;GUI space like a `ScreenGui`.

![ViewportFrame Catalog](https://developer.roblox.com/assets/5c5e4f396d61b3c84129f2a9/ViewportFrame1.gif)
![ViewportFrame Model](https://developer.roblox.com/assets/5c5e4f481a6434cd416210fd/ViewportFrame2.gif)

### Caveats
  - Currently 3D objects can only be displayed on `ScreenGuis` or `PluginGuis`
  - Objects inside ViewportFrames are rendered using a fixed `lighting` setting
  - No shadow or post effects are available. Neon and Glass `materials` will be rendered on lowest quality

### Using ViewportFrames

#### Through Studio UI
 1. Add a ViewportFrame into a `GuiLayerCollector`, such as a ScreenGui or `SurfaceGui`. This will cause a blank UI element to appear in the main window.

![ScreenGui->ViewportFrame in Explorer](https://developer.roblox.com/assets/5c5e4fa022bf52f7439e2708/ViewportFrameThroughStudioUI1.png)
![Empty ViewportFrame in Workspace](https://developer.roblox.com/assets/5c5e4fa800babade43223631/ViewportFrameThroughStudioUI2.png)

 2. Add a model that you want to show in the ViewportFrame into `Workspace`. Target your camera towards the `model`.

![Model being displayed by ViewportFrame](https://developer.roblox.com/assets/5c5e4fb70ab91ed943f43e17/ViewportFrameThroughStudioUI3.png)

 3. Set `CurrentCamera` to Workspace.Camera. Drag the model into the ViewportFrame. The model should show up there.

![ScreenGui->ViewportFrame->Model in Explorer](https://developer.roblox.com/assets/5c5e4fd5ab181759419c65d6/ViewportFrameThroughStudioUI4.png)
![ViewportFrame Rendering Model](https://developer.roblox.com/assets/5c5e5a5922bf52f7439e271e/ViewportFrameThroughStudioUI5.png)

 4. You can change the size, position or other properties of ViewportFrame like other GUIs. Now the CurrentCamera is a reference to the main camera in Workspace, so if you move the camera in the main scene, it will also affect ViewportFrame. When you find a good position, duplicate the camera and make sure it is not the one Workspace is using. Then set it to ViewportFrame.CurrentCamera so the camera won’t be changed by Workspace operations.

![Gif of ViewportFrame Rendering Model](https://developer.roblox.com/assets/5c5e4ff73f992ead41225138/ViewportFrameThroughStudioUI6.gif)

#### Through Scripts
You can also set up a ViewportFrame using scripts. Add the following `LocalScript` into a ScreenGui (or other proper Guis), run the game and you will get a `Part` rendered inside a ViewportFrame.

```lua
local vf = Instance.new("ViewportFrame", script.Parent)
vf.Size = UDim2.new(0.5, 0, 0.5, 0)
vf.Position = UDim2.new(0.25, 0, 0.25, 0)
vf.BackgroundColor3 = Color3.new(1, 1, 1)

local part = Instance.new("Part", vf)
part.Position = Vector3.new(0, 0, 0)

local camera = Instance.new("Camera", vf)
vf.CurrentCamera = camera

local cameraPosition = Vector3.new(3, 3, 3)
camera.CFrame = CFrame.new(cameraPosition, part.Position)
```

![ViewportFrame rendering Part from LocalScript](https://developer.roblox.com/assets/5c5e4f84c7b669b24175ebf0/ViewportFrameThroughScripts1.png)

### See also
If you are looking for an in-depth article exploring how the ViewportFrame GUI can render 3D objects inside its bounds, including a strep-by-step walkthrough, take a look at the `ViewportFrame ViewportFrame-GUI` article.

## Code Samples

### 


```lua
local viewportFrame = Instance.new("ViewportFrame")
viewportFrame.Size = UDim2.new(0.3, 0, 0.4, 0)
viewportFrame.Position = UDim2.new(0, 15, 0, 15)
viewportFrame.BackgroundColor3 = Color3.new(0, 0, 0)
viewportFrame.BorderColor3 = Color3.new(0.6, 0.5, 0.4)
viewportFrame.BorderSizePixel = 2
viewportFrame.BackgroundTransparency = 0.25
viewportFrame.Parent = script.Parent

local part = Instance.new("Part")
part.Material = Enum.Material.Concrete
part.Color = Color3.new(0.25, 0.75, 1)
part.Position = Vector3.new(0, 0, 0)
part.Parent = viewportFrame

local viewportCamera = Instance.new("Camera")
viewportFrame.CurrentCamera = viewportCamera
viewportCamera.Parent = viewportFrame

viewportCamera.CFrame = CFrame.new(Vector3.new(0, 2, 12), part.Position)
```

### 


```lua
local TweenService = game:GetService("TweenService")

local viewportFrame = Instance.new("ViewportFrame")
viewportFrame.Size = UDim2.new(0.3, 0, 0.4, 0)
viewportFrame.Position = UDim2.new(0, 15, 0, 15)
viewportFrame.BackgroundColor3 = Color3.new(0, 0, 0)
viewportFrame.BorderColor3 = Color3.new(0.6, 0.5, 0.4)
viewportFrame.BorderSizePixel = 2
viewportFrame.BackgroundTransparency = 0.25
viewportFrame.Parent = script.Parent

local part = Instance.new("Part")
part.Material = Enum.Material.Concrete
part.Color = Color3.new(0.25, 0.75, 1)
part.Position = Vector3.new(0, 0, 0)
part.Parent = viewportFrame

local viewportCamera = Instance.new("Camera")
viewportFrame.CurrentCamera = viewportCamera
viewportCamera.Parent = viewportFrame

viewportCamera.CFrame = CFrame.new(Vector3.new(0, 2, 12), part.Position)

wait(2)

local cameraGoal = {
	CFrame = CFrame.new(Vector3.new(0, 6, 4), part.Position)
}

local tweenInfo = TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

local tween = TweenService:Create(viewportCamera, tweenInfo, cameraGoal)

tween:Play()
```
 */
interface ViewportFrame extends RbxInternalGuiObject {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ViewportFrame";
	/** This property is a `Camera` instance that is used to render children objects. Defaults to *nil*.

The `Camera` object will not replicate so the `CurrentCamera` won’t replicate either. If you save a Camera in the server, it will not appear in the client. When you set this property, `CFrame` and `FieldOfView` will be saved and replicate with `ViewportFrame` internally so the client can render ViewportFrame without a Camera object. If you want to change the client’s Camera, you have to create a new Camera using a `LocalScript` at runtime.

### See also
  - `ViewportFrame ViewportFrame-GUI`, an article exploring how the ViewportFrame GUI can render 3D objects inside its bounds

## Code Samples

### 


```lua
local viewportFrame = Instance.new("ViewportFrame")
viewportFrame.Size = UDim2.new(0.3, 0, 0.4, 0)
viewportFrame.Position = UDim2.new(0, 15, 0, 15)
viewportFrame.BackgroundColor3 = Color3.new(0, 0, 0)
viewportFrame.BorderColor3 = Color3.new(0.6, 0.5, 0.4)
viewportFrame.BorderSizePixel = 2
viewportFrame.BackgroundTransparency = 0.25
viewportFrame.Parent = script.Parent

local part = Instance.new("Part")
part.Material = Enum.Material.Concrete
part.Color = Color3.new(0.25, 0.75, 1)
part.Position = Vector3.new(0, 0, 0)
part.Parent = viewportFrame

local viewportCamera = Instance.new("Camera")
viewportFrame.CurrentCamera = viewportCamera
viewportCamera.Parent = viewportFrame

viewportCamera.CFrame = CFrame.new(Vector3.new(0, 2, 12), part.Position)
```

### 


```lua
local TweenService = game:GetService("TweenService")

local viewportFrame = Instance.new("ViewportFrame")
viewportFrame.Size = UDim2.new(0.3, 0, 0.4, 0)
viewportFrame.Position = UDim2.new(0, 15, 0, 15)
viewportFrame.BackgroundColor3 = Color3.new(0, 0, 0)
viewportFrame.BorderColor3 = Color3.new(0.6, 0.5, 0.4)
viewportFrame.BorderSizePixel = 2
viewportFrame.BackgroundTransparency = 0.25
viewportFrame.Parent = script.Parent

local part = Instance.new("Part")
part.Material = Enum.Material.Concrete
part.Color = Color3.new(0.25, 0.75, 1)
part.Position = Vector3.new(0, 0, 0)
part.Parent = viewportFrame

local viewportCamera = Instance.new("Camera")
viewportFrame.CurrentCamera = viewportCamera
viewportCamera.Parent = viewportFrame

viewportCamera.CFrame = CFrame.new(Vector3.new(0, 2, 12), part.Position)

wait(2)

local cameraGoal = {
	CFrame = CFrame.new(Vector3.new(0, 6, 4), part.Position)
}

local tweenInfo = TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

local tween = TweenService:Create(viewportCamera, tweenInfo, cameraGoal)

tween:Play()
```
This property is a `Camera` instance that is used to render children objects. Defaults to *nil*.

The `Camera` object will not replicate so the `CurrentCamera` won’t replicate either. If you save a Camera in the server, it will not appear in the client. When you set this property, `CFrame` and `FieldOfView` will be saved and replicate with `ViewportFrame` internally so the client can render ViewportFrame without a Camera object. If you want to change the client’s Camera, you have to create a new Camera using a `LocalScript` at runtime.

### See also
  - `ViewportFrame ViewportFrame-GUI`, an article exploring how the ViewportFrame GUI can render 3D objects inside its bounds

## Code Samples

### 


```lua
local viewportFrame = Instance.new("ViewportFrame")
viewportFrame.Size = UDim2.new(0.3, 0, 0.4, 0)
viewportFrame.Position = UDim2.new(0, 15, 0, 15)
viewportFrame.BackgroundColor3 = Color3.new(0, 0, 0)
viewportFrame.BorderColor3 = Color3.new(0.6, 0.5, 0.4)
viewportFrame.BorderSizePixel = 2
viewportFrame.BackgroundTransparency = 0.25
viewportFrame.Parent = script.Parent

local part = Instance.new("Part")
part.Material = Enum.Material.Concrete
part.Color = Color3.new(0.25, 0.75, 1)
part.Position = Vector3.new(0, 0, 0)
part.Parent = viewportFrame

local viewportCamera = Instance.new("Camera")
viewportFrame.CurrentCamera = viewportCamera
viewportCamera.Parent = viewportFrame

viewportCamera.CFrame = CFrame.new(Vector3.new(0, 2, 12), part.Position)
```

### 


```lua
local TweenService = game:GetService("TweenService")

local viewportFrame = Instance.new("ViewportFrame")
viewportFrame.Size = UDim2.new(0.3, 0, 0.4, 0)
viewportFrame.Position = UDim2.new(0, 15, 0, 15)
viewportFrame.BackgroundColor3 = Color3.new(0, 0, 0)
viewportFrame.BorderColor3 = Color3.new(0.6, 0.5, 0.4)
viewportFrame.BorderSizePixel = 2
viewportFrame.BackgroundTransparency = 0.25
viewportFrame.Parent = script.Parent

local part = Instance.new("Part")
part.Material = Enum.Material.Concrete
part.Color = Color3.new(0.25, 0.75, 1)
part.Position = Vector3.new(0, 0, 0)
part.Parent = viewportFrame

local viewportCamera = Instance.new("Camera")
viewportFrame.CurrentCamera = viewportCamera
viewportCamera.Parent = viewportFrame

viewportCamera.CFrame = CFrame.new(Vector3.new(0, 2, 12), part.Position)

wait(2)

local cameraGoal = {
	CFrame = CFrame.new(Vector3.new(0, 6, 4), part.Position)
}

local tweenInfo = TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

local tween = TweenService:Create(viewportCamera, tweenInfo, cameraGoal)

tween:Play()
```


Tags: NotReplicated */
	CurrentCamera?: Camera;
	/** This property determines how a rendered image will be colorized. It allows you to change the image color without directly modifying the rendered object.The default colorization value is `Color3.new(1,1,1) (white). When set to white no colorization occurs.

It functions similarly to `ImageLabel/ImageColor3` and `Color3`except that it is applied to the rendered image.

The image below demonstrates the same ViewportFrame with two different colorizations. The first image has the default (white) colorization and the second image has a `Color3.new(255, 255, 102)` (yellow) colorization.
![ViewportFrame with the default white colorization](https://developer.roblox.com/assets/5c5f7f26e2c86a6c4191b094/Screen_Shot_2019-02-09_at_8.03.48_PM.png)
![ViewportFrame with a yellow colorization](https://developer.roblox.com/assets/5c5f7f3222bf52f7439e274e/Screen_Shot_2019-02-09_at_8.08.58_PM.png)

### See also
  - `ViewportFrame ViewportFrame-GUI`, an article exploring how the ViewportFrame GUI can render 3D objects inside its bounds
  - `ImageTransparency`, determines the transparency of the rendered image
  - `CurrentCamera`, the `Camera` that is used to render children objects */
	ImageColor3: Color3;
	/** This property determines the transparency of the rendered image. It allows you to change the image transparency without directly modifying the rendered object. A value of 0 is completely opaque, and a value of 1 is completely transparent (invisible). The default transparency is 0.

This property behaves similarly to `BackgroundTransparency` or `Transparency` except that it is applied to the rendered image.

The image below demonstrates the same ViewportFrame with two different transparency. The first image has a transparency of 0 and the second image has a transparency of 0.5.

![ViewportFrame with default 0 transparency](https://developer.roblox.com/assets/5c5f7f26e2c86a6c4191b094/Screen_Shot_2019-02-09_at_8.03.48_PM.png)
![ViewportFrame with 0.5 transparencu](https://developer.roblox.com/assets/5c5f835fc7b669b24175ec32/Screen_Shot_2019-02-09_at_8.23.38_PM.png)

### See also
  - `ViewportFrame ViewportFrame-GUI`, an article exploring how the ViewportFrame GUI can render 3D objects inside its bounds
  - `ImageColor3`, determines how a rendered image will be colorized
  - `CurrentCamera`, the `Camera` that is used to render children objects */
	ImageTransparency: number;
}

interface RbxInternalLayerCollector extends RbxInternalGuiBase2d {
	/** Toggles the visibility of the LayerCollector. */
	Enabled: boolean;
	/** If set to false, this LayerCollector will only be cloned once into each `Player` `PlayerGui`, and the LayerCollector will not be deleted when the player respawns.
If set to true, the LayerCollector will be cloned into each `Player` `PlayerGui` when they respawn, and it will delete itself when the player respawns again.Controls how this LayerCollector behaves when its associated `Player` respawns. */
	ResetOnSpawn: boolean;
	/** Changes how ZIndex behaves on all descendants of the LayerCollector. "Global" indicates current behavior (ZIndex sorts all guis regardless of hierarchy positioning, ties broken by hierarchy). "Sibling" would only use ZIndex property to sort order among sibling elements in the hierarchy, otherwise ordering is done via hierarchy (children are drawn on top of parents). */
	ZIndexBehavior: Enum.ZIndexBehavior;
}
/** LayerCollector is an abstract class inherited by 2D GUI Objects which render GuiObjects in layers. */
type LayerCollector = BillboardGui | PluginGui | ScreenGui | SurfaceGui | GuiMain;

/** BillboardGuis are containers for GUI objects that appear in the 3D space. A BillboardGui's position is determined by the position of it's `Adornee`. If the adornee is set to `Part` then the `Position` will be used. If it is set to `Attachment` then the `WorldPosition` will be used. BillboardGui always faces the camera, and can change its size with distance or remain the same size on the screen. Unlike the text that appears above models with Humanoids' heads, this does not disappear with distance. */
interface BillboardGui extends RbxInternalLayerCollector {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BillboardGui";
	/** Whether or not mouse events will be passed to objects layered below. */
	Active: boolean;
	/** Adornee sets the part or attachment that the BillboardGui is adorned too. */
	Adornee: PVInstance | Attachment | undefined;
	/** Determines whether the BillboardGui will always be rendered on top of other objects. */
	AlwaysOnTop: boolean;
	/** When set to true, portions of GuiObjects that fall outside of the BillboardGui's canvas borders will not be drawn. */
	ClipsDescendants: boolean;

	readonly CurrentDistance: number;

	DistanceLowerLimit: number;

	DistanceStep: number;

	DistanceUpperLimit: number;
	/** A Vector3 (x,y,z) defined in studs that will offset the GUI from the extents of the 3D object it is rendering from. */
	ExtentsOffset: Vector3;
	/** Offsets the BillboardGui relative to it's `Adornee`'s orientation and size. */
	ExtentsOffsetWorldSpace: Vector3;
	/** Controls how much the BillboardGui is influenced by the lighting in the game world. */
	LightInfluence: number;
	/** The MaxDistance property of a `BillboardGui` sets how far away in studs that billboard can be from the camera and still be drawn. If the camera and billboard are moved further apart than the maximum distance, then the billboard will not be visible regardless of any other properties of the billboard or any GUI objects it contains. The default value of this property is infinity 

If this value is set to less than or equal to 0 then the maximum distance will be treated as infinite and the billboard will always be drawable.

## Example

```lua
-- Wait for default camera/control scripts to load
wait(5)

-- Declare and initialize objects
local camera = game.Workspace.CurrentCamera
local part = Instance.new("Part")
local billboard = Instance.new("BillboardGui")
local label = Instance.new("TextLabel")

-- Set up camera type
camera.CameraType = Enum.CameraType.Scriptable

-- Set part's position and lock in place
part.CFrame = CFrame.new(0, 10, 0)
part.Anchored = true

-- Set up billboard
billboard.MaxDistance = 10
billboard.Adornee = part
billboard.AlwaysOnTop = true
billboard.Size = UDim2.new(0, 50, 0, 50)

-- Set up label
label.Size = UDim2.new(1, 0, 1, 0)

-- Set partents of objects
label.Parent = billboard
billboard.Parent = part
part.Parent = game.Workspace

-- Move camera next to part. Wait a bit and then move camera
local cameraPosition0 = part.Position + Vector3.new(0, 0, 10)
local cameraPosition1 = part.Position + Vector3.new(0, 0, 20)
camera.CFrame = CFrame.new(cameraPosition0, part.Position)
-- Contents of billboard will be visible here
wait(2)
camera.CFrame = CFrame.new(cameraPosition1, part.Position)
-- Contents of billboard will no longer be visible (outside MaxDistance)
``` */
	MaxDistance: number;
	/** Allows you to define a player who is unable to see the BillboardGui. */
	PlayerToHideFrom: Player | undefined;
	/** Sets the size of the BillboardGui as it'll appear in the Roblox "world". */
	Size: UDim2;
	/** Offsets the BillboardGui relative to it's AbsoluteSize. */
	SizeOffset: Vector2;
	/** The offset of the BillboardGui in studs, relative to the `Camera`'s orientation. */
	StudsOffset: Vector3;
	/** Offsets the BillboardGui relative to it's `Adornee`'s orientation, in studs. */
	StudsOffsetWorldSpace: Vector3;
}

interface RbxInternalPluginGui extends RbxInternalLayerCollector {
	/** The title that is displayed above the contents of the `PluginGui`. Defaults to empty string. */
	Title: string;
	/** This function binds a function to the `PluginGui’s` close button, overriding the default behavior.

By default, when the user clicks the ‘x’ button in the top right corner of the `PluginGui` the `Enabled` property is set to *false*, closing the window. When a custom function is bound using BindToClose this behavior is overwritten, allowing you to check if the user really wants to close the window or give them an opportunity to save their work.

As the default closing behavior is overwritten by this function, you’ll need to configure the `PluginGui` to close manually by setting `PluginGui.Enabled` to *false*. For example, in the below snippet users are required to click a confirm button to close the GUI:


```lua
local closing = false
pluginGui:BindToClose(function()
	-- make sure we haven't already made a button
	if closing then
		return
	end
	closing = true

	-- create confirm button
	local confirmButton = Instance.new("TextButton")
	confirmButton.AnchorPoint = Vector2.new(0.5, 0.5)
	confirmButton.Size = UDim2.new(0.5, 0, 0.5, 0)
	confirmButton.Position = UDim2.new(0.5, 0, 0.5, 0)
	confirmButton.BackgroundColor3 = Color3.new(1, 0, 0)
	confirmButton.Text = "Close?"
	confirmButton.Parent = pluginGui

	-- listen for click
	confirmButton.Activated:Connect(function()
		-- close the gui
		pluginGui.Enabled = false
	
		-- remove confirm button
		confirmButton:Destroy()
	end)
end)
```


You can call BindToClose with no argument to ‘unbind’ and revert to the default behavior described above. For example:

```lua
pluginGui:BindToClose()
```


## See also
 - `CreateDockWidgetPluginGui` to create a `PluginGui`
 - `BindToClose`, which can be used to bind a function to the game ending and should not be confused with this function
@param function The function to bind the close button to. If no function is specified then any previously specified function will be unbound  */
	BindToClose(callback?: Function): void;
}
/** PluginGui is an abstract class for GUIs that allow the display of `GuiObjects` in various Roblox Studio widgets. As of right now, the only available PluginGui type is `DockWidgetPluginGui`, but there may be more in the future! */
type PluginGui = DockWidgetPluginGui | QWidgetPluginGui;

/** **DockWidgetPluginGui** is a `PluginGui` that displays its contents inside a dockable Roblox Studio window. It is used to create widgets similar to the built-in
 **Animation Editor** and **Terrain Tools**
.

This GUI can be created using `Plugin:CreateDockWidgetPluginGui()`.

See the `building studio Building Studio Widgets` tutorial for details on working with custom Studio widgets. */
interface DockWidgetPluginGui extends RbxInternalPluginGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DockWidgetPluginGui";
	/** Describes whether the previous state of this `DockWidgetPluginGui` was restored when it was created.Describes whether the previous state of this `DockWidgetPluginGui` was restored when it was created.

Tags: ReadOnly, NotReplicated */
	readonly HostWidgetWasRestored: boolean;
}

interface QWidgetPluginGui extends RbxInternalPluginGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "QWidgetPluginGui";
}

interface RbxInternalDerivesFromScreenGui extends RbxInternalLayerCollector {
	/** This property controls the order that multiple ScreenGuis are drawn.
ScreenGuis with a higher DisplayOrder will be drawn on top of ScreenGuis with a lower DisplayOrder. DisplayOrder can have any value greater than 0 and defaults to 0.Controls the order that multiple ScreenGuis are drawn. */
	DisplayOrder: number;
	/** IgnoreGuiInset is a boolean property of ScreenGuis that, when set to true, will force the `GUI Inset` imposed by Roblox's CoreGuis to be ignored by this ScreenGui and its descendants. This means that an element with a UDim2 size of `{1,0},{1,0}` will fill up the entire screen, without a 36 pixel gap reserved for Roblox's top bar. */
	IgnoreGuiInset: boolean;
}
/** The main storage object for 2D `GuiObject` displayed on the player's screen. ScreenGuis will only be shown if parented to a player's `PlayerGui`.
To make sure a ScreenGui is displayed to your player, it should be parented into the `StarterGui`, as that service will clone it's contents into each player's `PlayerGui` when they join the game. */
interface ScreenGui extends RbxInternalDerivesFromScreenGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ScreenGui";
}


/** The original name of the `ScreenGui`. This class functions identically to the ScreenGui, and should not be used. */
interface GuiMain extends RbxInternalDerivesFromScreenGui {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GuiMain";
}

/** **Note:**
 SurfaceGuis must be descendants of PlayerGui in order to know the player who is interacting with it.Allows for the rendering of GUI elements onto a part's surface in the 3D world, whilst allowing for basic user interaction to occur. */
interface SurfaceGui extends RbxInternalLayerCollector {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SurfaceGui";
	/** Whether or not mouse events will be passed to objects layered below. */
	Active: boolean;
	/** Sets the object that the SurfaceGui is adorned too. In other words, this defines which `BasePart` the SurfaceGui is attached to. */
	Adornee: BasePart | undefined;
	/** Determines whether the SurfaceGui will always be rendered on top of other objects. */
	AlwaysOnTop: boolean;
	/** The size of a 'virtual screen', in 'virtual pixels', which makes SurfaceGuis pixel-to-pixel compatible with ScreenGuis. */
	CanvasSize: Vector2;
	/** When set to true, portions of GuiObjects that fall outside of the SurfaceGui's canvas borders will not be drawn. */
	ClipsDescendants: boolean;
	/** The face that the SurfaceGui is rendered on. */
	Face: Enum.NormalId;
	/** Controls how much the SurfaceGui is influenced by the lighting in the game world. */
	LightInfluence: number;

	PixelsPerStud: number;

	SizingMode: Enum.SurfaceGuiSizingMode;
	/** Sets the distance left clicking starts acting on the surface gui instead of the held tool. If a character is within this distance of the surface gui, then the tool will not activate on click. */
	ToolPunchThroughDistance: number;
	/** Offsets the SurfaceGui relative to the normal of the surface it is attached to. */
	ZOffset: number;
}

interface RbxInternalGuiBase3d extends RbxInternalGuiBase {
	/** Sets the color of a GUI object. */
	Color3: Color3;
	/** Sets the transparency of a GUI object, where 1 is invisible and 0 is completely visible. */
	Transparency: number;
	/** Determines whether the object and its descendants will be displayed. */
	Visible: boolean;
}
/** An abstract class for 3D GUI elements that are rendered in the world. */
type GuiBase3d = FloorWire | PVAdornment | PartAdornment | SelectionLasso;

/** A FloorWire attempts to make a wire from two of its properties: `From` and `To`, which both need to be set to a `BasePart`. It sometimes goes through bricks but the majority of the time it works fine. It starts at From's center and goes to To's center. Which side of each one it goes into depends on the BaseParts's positions. It chooses the fastest route. */
interface FloorWire extends RbxInternalGuiBase3d {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FloorWire";
	/** A decimal number between 0 and 1, through which you can control how far all of the decals are along the wire. */
	CycleOffset: number;
	/** The object that the FloorWire travels from. */
	From?: BasePart;
	/** The number of studs between each FloorWire segment. */
	StudsBetweenTextures: number;
	/** Sets the texture to be displayed on the FloorWire. */
	Texture: string;
	/** Sets the size of the texture used with the FloorWire. */
	TextureSize: Vector2;
	/** The object that the FloorWire travels to. */
	To?: BasePart;
	/** The speed that the textures flow along the wire. */
	Velocity: number;
	/** The radius of the wire. */
	WireRadius: number;
}

interface RbxInternalPVAdornment extends RbxInternalGuiBase3d {
	/** The [PVInstance](https://developer.roblox.com/api-reference/class/PVInstance "PVInstance")
 the PVAdornment is attached to. An adornment will stay positioned and rotated relative to its adornee, even if the adornee moves. */
	Adornee?: PVInstance;
}
/** The PVAdornment class is an abstract class of which the inheritors can be adorned to objects of the PVInstance class. */
type PVAdornment = HandleAdornment | ParabolaAdornment | SelectionBox | SelectionSphere;

interface RbxInternalHandleAdornment extends RbxInternalPVAdornment {
	/** Forces this object to render on top of all 3d objects in the Workspace. Even if the adornment is behind a part based on its `CFrame`, if **AlwaysOnTop**
 is true then the adornment will still draw on top.
The one exception to this behavior is if the `ZIndex` of the adornment is set to -1. If this is the case, the adornment will always draw behind 3d geometry.Forces this object to render on top of all 3d objects in the Workspace. */
	AlwaysOnTop: boolean;
	/** The position and rotation relative to its `Adornee`. This CFrame is in the local space of the adornee, so forward (0,0,-1) will be forward relative to the adornee. The offset and rotation of this CFrame is applied after any translations due to `SizeRelativeOffset`. */
	CFrame: CFrame;
	/** The positional offset of the adornment based on the adornee’s `Size`. By default, an adornment draws in the center of its adornee. By using this property, the position of the adornment can be shifted relative to the center of the adornee. The units of **SizeRelativeOffset** are a scale based on the size of the adornee itself. This scale is such that a value of 1 will move the adornment to the corresponding edge of the adornee.

This property is intended to allow adornments to easily be moved to the edges of a part.

For example, if the **SizeRelativeOffset**
 is set to (0,1,0), the adornment will be drawn with its center at the exact top of the adornee. If set to (1,1,1), the adornment will be drawn in the upper corner of the adornee. */
	SizeRelativeOffset: Vector3;
	/** The **ZIndex** property determines the draw order of the `HandleAdornment`. This **ZIndex**
 only refers to how the adornment will draw relative to other adornments or 3d objects in the workspace. This does not relate to the `ZIndex (page does not exist)` of GuiObjects. 
The valid values for ZIndex are from -1 to 10. If two HandleAdornments are drawn over one another, the one with the higher ZIndex will be drawn. This order of drawing will be respected even if the adormnent with higher ZIndex is behind the other adornment in terms of its position in 3d space.

If set to -1, ZIndex will force the adornment to draw behind other adornments and objects in the Workspace, even if the `AlwaysOnTop` property for the adornment is true.The ZIndex property determines the draw order of the HandleAdornment. */
	ZIndex: number;
	/** Fires when a user presses down on their left mouse button while hovering over the adornment. */
	readonly MouseButton1Down: RBXScriptSignal<() => void>;
	/** Fires when a user releases their left mouse button while hovering over the adornment. */
	readonly MouseButton1Up: RBXScriptSignal<() => void>;
	/** Fires when a user moves their mouse over the adornment. */
	readonly MouseEnter: RBXScriptSignal<() => void>;
	/** Fires when a user moves their mouse out of the adornment. */
	readonly MouseLeave: RBXScriptSignal<() => void>;
}
/** **Note:** For handles to be interactive, they must be parented to a player's `PlayerGui` or the `CoreGui`.**HandleAdornment**
 is an abstract class inherited by 3D handle adornments. */
type HandleAdornment = BoxHandleAdornment | ConeHandleAdornment | CylinderHandleAdornment | ImageHandleAdornment | LineHandleAdornment | SphereHandleAdornment;

/** For handles to be interactive, they must be parented to a player's PlayerGui or the CoreGui.


The **BoxHandleAdornment**
 is a rectangular prism that can be adorned to a `BasePart`. This adornment can listen to input events and is commonly used to make dragger tools. */
interface BoxHandleAdornment extends RbxInternalHandleAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BoxHandleAdornment";
	/** The size of the adornment. */
	Size: Vector3;
}

/** For handles to be interactive, they must be parented to a player's PlayerGui or the CoreGui.


A **ConeHandleAdornment**
 is a cone that can be adorned to a `BasePart`. This adornment can listen to input events and is commonly used to make dragger tools. */
interface ConeHandleAdornment extends RbxInternalHandleAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ConeHandleAdornment";
	/** The height of the cone adornment. */
	Height: number;
	/** The radius of the cone adornment. */
	Radius: number;
}

/** For handles to be interactive, they must be parented to a player's PlayerGui or the CoreGui.


The **CylinderHandleAdornment**
 is a cylinder that can be adorned to a `BasePart`. This adornment can listen to input events and is commonly used to make dragger tools. */
interface CylinderHandleAdornment extends RbxInternalHandleAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CylinderHandleAdornment";
	/** The height of the cylinder adornment. */
	Height: number;
	/** The radius of the cylinder adornment. */
	Radius: number;
}

/** For handles to be interactive, they must be parented to a player's PlayerGui or the CoreGui.


The **ImageHandleAdornment**
 is an image that can be adorned to a `BasePart`. This adornment can listen to input events and is commonly used to make dragger tools. */
interface ImageHandleAdornment extends RbxInternalHandleAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ImageHandleAdornment";
	/** The image to draw for the adornment. */
	Image: string;
	/** The size in studs of the image. */
	Size: Vector2;
}

/** For handles to be interactive, they must be parented to a player's PlayerGui or the CoreGui.


The **LineHandleAdornment**
 is a line that can be adorned to a `BasePart`. This line starts at the center of the adornment’s `CFrame` (offset by the adornment’s `SizeRelativeOffset`) and will be oriented along its CFrame. This adornment can listen to input events and is commonly used to make dragger tools. */
interface LineHandleAdornment extends RbxInternalHandleAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LineHandleAdornment";
	/** The length of the line. */
	Length: number;
	/** The thickness of the line in pixels. */
	Thickness: number;
}

/** For handles to be interactive, they must be parented to a player's PlayerGui or the CoreGui.


The **SphereHandleAdornment**
 is a sphere that can be adorned to a `BasePart`. This adornment can listen to input events and is commonly used to make dragger tools. */
interface SphereHandleAdornment extends RbxInternalHandleAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SphereHandleAdornment";
	/** The radius of the sphere adornment. */
	Radius: number;
}

/** A special type of Adornment that is still a work in progress.
This object can only be created by `CoreScript` at the moment. */
interface ParabolaAdornment extends RbxInternalPVAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ParabolaAdornment";
}

/** An object which is used to put a 3D box around the part it's adorned to. For more information on how to use SelectionBoxes go [here](https://developer.roblox.com/articles/Selection-Boxes)
. */
interface SelectionBox extends RbxInternalPVAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SelectionBox";
	/** The thickness of the `SelectionBox` outlines. Measured in studs. */
	LineThickness: number;
	/** The color of the `SelectionBox` surface */
	SurfaceColor3: Color3;
	/** The transparency of the SelectionBox's surface. A value of 1 makes the surface invisible, while a value of 0 makes it opaque. */
	SurfaceTransparency: number;
}

/** An object which is used to put a 3D sphere around the part it's adorned to. Intended for use on parts that have their `Shape` set to _Ball_
. */
interface SelectionSphere extends RbxInternalPVAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SelectionSphere";
	/** The color of the SelectionSphere's surface. */
	SurfaceColor3: Color3;
	/** The transparency of the SelectionSphere's surface. A value of 1 makes the surface invisible, while a value of 0 makes it opaque. */
	SurfaceTransparency: number;
}

interface RbxInternalPartAdornment extends RbxInternalGuiBase3d {
	/** Sets the object to adorn to. */
	Adornee?: BasePart;
}
/** An abstract class for GUI elements that are adorned to (displayed as attached to) objects deriving from `BasePart`. */
type PartAdornment = HandlesBase | SurfaceSelection;

interface RbxInternalHandlesBase extends RbxInternalPartAdornment {}
/** An abstract class for Handle objects, such as `/ArcHandles` and `/Handles`. */
type HandlesBase = ArcHandles | Handles;

/** For handles to be interactive, they must be parented to a player's PlayerGui or the CoreGui.


The **ArcHandles**
 object places 3D ArcHandles around any object that its Adornee is set to. The Adornee property must be set to a 3D object for the handles to appear. The color can be changed. */
interface ArcHandles extends RbxInternalHandlesBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ArcHandles";
	/** Sets the current Axes ArcHandles will show. */
	Axes: Axes;
	/** Fired when the left mouse button goes down on one of the GUI handles. */
	readonly MouseButton1Down: RBXScriptSignal<(axis: Enum.Axis) => void>;
	/** Fired when the left mouse button is released on one of the GUI handles. */
	readonly MouseButton1Up: RBXScriptSignal<(axis: Enum.Axis) => void>;
	/** Fired when the mouse moves while the MouseButton1Down event has fired, but the left mouse button has not been released yet. */
	readonly MouseDrag: RBXScriptSignal<(axis: Enum.Axis, relativeAngle: number, deltaRadius: number) => void>;
	/** Fired when a mouse "enters" the GUI handle. */
	readonly MouseEnter: RBXScriptSignal<(axis: Enum.Axis) => void>;
	/** Fired when the mouse leaves the GUI handle. */
	readonly MouseLeave: RBXScriptSignal<(axis: Enum.Axis) => void>;
}

/** For handles to be interactive, they must be parented to a player's PlayerGui or the CoreGui.


The **Handles**
 object places 3D handles around any object that its Adornee is set to. The Adornee property must be set to a 3D object for the handles to appear. The color can be changed, and the shape of the handles can be set to either arrows or spheres. */
interface Handles extends RbxInternalHandlesBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Handles";
	/** Sets which sides the GUI handles will appear. */
	Faces: Faces;
	/** Sets the GUI style of the handles. Currently there are only two types; Resize and Movement. */
	Style: Enum.HandlesStyle;
	/** Fired when the left mouse button goes down on one of the GUI handles. */
	readonly MouseButton1Down: RBXScriptSignal<(face: Enum.NormalId) => void>;
	/** Fired when the left mouse button is released on one of the GUI handles. */
	readonly MouseButton1Up: RBXScriptSignal<(face: Enum.NormalId) => void>;
	/** Fired when the mouse moves while the MouseButton1Down event has fired, but the left mouse button has not been released yet. */
	readonly MouseDrag: RBXScriptSignal<(face: Enum.NormalId, distance: number) => void>;
	/** Fired when a mouse "enters" the GUI handle. */
	readonly MouseEnter: RBXScriptSignal<(face: Enum.NormalId) => void>;
	/** Fired when the mouse leaves the GUI handle. */
	readonly MouseLeave: RBXScriptSignal<(face: Enum.NormalId) => void>;
}

/** An instance used to show a physical selection of a particular side of a `BasePart`. However, it should be noted that the `Transparency` property doesn't appear to currently work with this instance. */
interface SurfaceSelection extends RbxInternalPartAdornment {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SurfaceSelection";
	/** Sets which side the SurfaceSelection will appear on, on the adorned `BasePart`. */
	TargetSurface: Enum.NormalId;
}

interface RbxInternalSelectionLasso extends RbxInternalGuiBase3d {
	/** The Humanoid that the Lasso belongs to, and will come from. */
	Humanoid?: Humanoid;
}
/** The SelectionLasso class is an abstract class of which the inheritors are able to be attached to an object of the `Humanoid` class or the `BasePart` class. They can also be attached to a point in the tridimensional space indicated by a Vector3 value. */
type SelectionLasso = SelectionPartLasso | SelectionPointLasso;

/** An instance used to display a "lasso" between a `Humanoid` Torso and a `BasePart`. It should be noted that the `Transparency` property doesn't currently work. */
interface SelectionPartLasso extends RbxInternalSelectionLasso {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SelectionPartLasso";
	/** Sets the target of the lasso object. */
	Part?: BasePart;
}

/** A 3D GUI object which displays a lasso between the defined Humanoid and a given Vector3 point. */
interface SelectionPointLasso extends RbxInternalSelectionLasso {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SelectionPointLasso";
	/** Sets the Vector3 target of the lasso object. */
	Point: Vector3;
}

/** The GuiService is a service which currently allows developers to control what `GuiObject` is currently being selected by the gamepad navigator. It also allows clients to check if Roblox's main menu is currently open. 

This service has a lot of hidden members, which are mainly used internally by Roblox's `CoreScripts`. */
interface GuiService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GuiService";
	/** If the select button on a gamepad will automatically set a GUI as the selected object when the Select button is pressed. Turning this off will mean that Gui navigation will still work if GuiNavigationEnabled is enabled but you will have to set SelectedObject manually to start Gui navigation. */
	AutoSelectGuiEnabled: boolean;
	/** Toggles whether or not objects in the `CoreGui` can be navigated using a Gamepad. */
	CoreGuiNavigationEnabled: boolean;
	/** Used to enable and disable the default controller GUI navigation. */
	GuiNavigationEnabled: boolean;
	/** Status of the Roblox escape menu CoreGui. Returns true if the menu is open, false if not. */
	readonly MenuIsOpen: boolean;
	/** Sets the [GuiObject](https://developer.roblox.com/api-reference/class/GuiObject "GuiObject")
 currently being focused on by the GUI Navigator (used for Gamepads). This may reset to nil if the object is off-screen. */
	SelectedObject?: GuiObject;
	/** Creates a gui selection group where gamepad gui navigation will only consider selectable gui objects that are within the group (children of selectionParent).
A use case is you have a menu pop open, but there are other selectable objects on the screen (maybe from previous menus), but you want to the user to only be able to select gui objects in the new menu.Creates a gui selection group where gamepad gui navigation will only consider selectable gui objects that are within the group (children of selectionParent). */
	AddSelectionParent(selectionName: string, selectionParent: Instance): void;
	/** Functions similarly to `AddSelectionParent`, but you can give it a tuple of `GuiObject` that you want to be contained in the group.
@param selectionName The name of the added selection.
@param selections The selection(s) added.
@returns No return. */
	AddSelectionTuple(selectionName: string, selections: Array<any>): void;

	GetEmotesMenuOpen(): boolean;
	/** Returns two `Vector2` values representing the inset of user GUIs in pixels, from the top left corner of the screen and the bottom right corner of the screen respectively.

The inset values supplied by this function only take effect on `ScreenGuis` that have their `IgnoreGuiInset` property set to false.
@returns A tuple of two Vector2 values describing the current specified Gui Inset. */
	GetGuiInset(): LuaTuple<[Vector2, Vector2]>;
	/** Returns true if the client is using the ten foot interface, which is a special version of Roblox's UI, exclusive to consoles.
This is the only guaranteed way to verify if the user is on a console or not. */
	IsTenFootInterface(): boolean;
	/** Removes a group that was created with `AddSelectionParent` or `AddSelectionTuple`. */
	RemoveSelectionGroup(selectionName: string): void;

	SetEmotesMenuOpen(isOpen: boolean): void;
	/** Fires when the user **closes**
 the Roblox coregui escape menu. */
	readonly MenuClosed: RBXScriptSignal<() => void>;
	/** Fires when the user **opens**
 the Roblox coregui escape menu. */
	readonly MenuOpened: RBXScriptSignal<() => void>;
}

/** An internal service, whose functionality is not accessible to developers. */
interface GuidRegistryService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GuidRegistryService";
}

/** The _Xbox One_
 controller and some other USB gamepad controllers have motors built in to provide haptic feedback. Adding rumbles and vibrations can greatly enhance a game’s experience and provide subtle feedback that is hard to convey through visuals or audio. */
interface HapticService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HapticService";
	/** Returns the current vibration value set to the specified [UserInputType](https://developer.roblox.com/api-reference/property/InputObject/UserInputType "UserInputType") and [VibrationMotor](https://developer.roblox.com/api-reference/enum/VibrationMotor "VibrationMotor") .

This will not return anything if [SetMotor](https://developer.roblox.com/api-reference/function/HapticService/SetMotor "SetMotor")
 has not been called prior. */
	GetMotor(inputType: CastsToEnum<Enum.UserInputType>, vibrationMotor: CastsToEnum<Enum.VibrationMotor>): unknown;
	/** Returns true if the specified motor is available to be used with the specified `UserInputType`. */
	IsMotorSupported(inputType: CastsToEnum<Enum.UserInputType>, vibrationMotor: CastsToEnum<Enum.VibrationMotor>): boolean;
	/** Returns true if the specified `UserInputType` supports haptic feedback. */
	IsVibrationSupported(inputType: CastsToEnum<Enum.UserInputType>): boolean;
	/** Sets the vibration intensity of the specified [UserInputType](https://developer.roblox.com/api-reference/property/InputObject/UserInputType "UserInputType") and [VibrationMotor](https://developer.roblox.com/api-reference/enum/VibrationMotor "VibrationMotor")
.

## Code Samples

### HapticService:SetMotor

This example makes the small motor vibrate depending on how much pressure is applied to the left trigger, and the large motor vibrate depending on how much pressure is applied to the right trigger.
```lua
local userInput = game:GetService("UserInputService")
local haptics = game:GetService("HapticService")

local cachedInputs = {} -- Note that we use a cache so we don't attach a Changed event more than once.

local keyToVibration =
{
	[Enum.KeyCode.ButtonL2] = Enum.VibrationMotor.Small;
	[Enum.KeyCode.ButtonR2] = Enum.VibrationMotor.Large;
}

local function onInputBegan(input)
	if not cachedInputs[input] then
		local inputType = input.UserInputType
		if inputType.Name:find("Gamepad") then -- If this is a Gamepad input.
			local vibrationMotor = keyToVibration[input.KeyCode]
			if vibrationMotor then
				-- Watch this InputObject manually so we can accurately update the vibrationMotor.
				local function onChanged(property)
					if property == "Position" then
						haptics:SetMotor(inputType,vibrationMotor,input.Position.Z)
					end
				end
				cachedInputs[input] = input.Changed:Connect(onChanged)
			end
		end
	end
end

userInput.InputBegan:Connect(onInputBegan)
```
 */
	SetMotor(inputType: CastsToEnum<Enum.UserInputType>, vibrationMotor: CastsToEnum<Enum.VibrationMotor>, vibrationValues: Array<any>): void;
}

/** Hopper is the original name of the StarterPack service. If this service is ever instantiated, it moves all of its children into the StarterPack, and then deletes itself. */
interface Hopper extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Hopper";
}

/** A version of the `HttpService` used by the admins. 
Unlike the regular service, this one can send GET/POST requests to roblox.com */
interface HttpRbxApiService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HttpRbxApiService";
}

interface HttpRequest extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HttpRequest";
}

/** @server */
	/** This service allows HTTP requests to be sent from game servers. This enables users to create integration with a wide range of third party services such as analytics and storage. One exciting prospect for this service is that if you run and manage your own website, and communicate with it from Roblox, it opens the possibility of remote server management and real time communication with the server, through your site. 

If the limit of 500 http `GET` / `POST` requests per minute is exceeded, the Service will stall entirely for approximately 30 seconds.

## Enabling HTTP requests
HttpService starts off as disabled by default.

To `enable` HTTP requests, the HttpService must be enabled through Studio's Game Settings by opening the game's settings via the **Game Settings** button on the *Home* tab of the game's studio window (see image below):
![Navigate to the Game Settings button](https://developer.roblox.com/assets/5b7cc11cfcd8df450b22da14/HttpRequestsSetting.png)

Within the Game Settings window, navigate to the **Security** tab and select the *On* option under **Allow HTTP Requests** (see image below).
![Allow HTTP Requests](https://developer.roblox.com/assets/5b7cc0dfacedd45c0bf7b421/GameSettingsButton.png)

## Usage ideas
  * Cross server marketplace
  * Real time stock market
  * Cross server leaderboard

## Restrictions
  * Limit of 500 requests a minute (Per server)
  * This service is not allowed to send requests to any of the Roblox websites such as www.roblox.com or api.roblox.com

## See also
See [here][3] for a detailed guide on sending HTTP requests.Sending HTTP requests.


  
  
  [3]: http://robloxdev.com/articles/Sending-HTTP-requests

## Code Samples

### Astronauts in Space

This code sample uses HttpService's GetAsync to make a request to [Open Notify][1], a web service that provides data from NASA. The request is made to an endpoint that provides information on how many astronauts are currently in space. The response is provided in JSON format, so it is parsed using JSONDecode. Finally, the response data is then processed and printed to the Output.

Test this script by pasting the source code into a Script (HttpService cannot be used by LocalScripts). Also, be sure to enable HTTP Requests in your Game Settings (Home > Game Settings).

  [1]: http://open-notify.org
```lua
local HttpService = game:GetService("HttpService")

local URL_ASTROS = "http://api.open-notify.org/astros.json"

-- Make the request to our endpoint URL
local response = HttpService:GetAsync(URL_ASTROS)

-- Parse the JSON response
local data = HttpService:JSONDecode(response)

-- Information in the data table is dependent on the response JSON
if data.message == "success" then
	print("There are currently " .. data.number .. " astronauts in space:")
	for i, person in pairs(data.people) do
		print(i .. ": " .. person.name .. " is on " .. person.craft)
	end
end
```

### Where is the International Space Station?

This code sample uses HttpService's GetAsync to make a request to an endpoint at [Open Notify][1], a website that provides information from NASA. The endpoint provides information on the current location of the International Space Station. This example uses a **defensive coding technique** that you should use when making web requests. It wraps the call to GetAsync and JSONDecode in pcall, which protects our script from raising an error if either of these fail. Then, it checks the raw response for all proper data before using it. All of this is put inside a function that returns true or false depending of the request's success.

Whenever you're working with web requests, you should prepare for anything to go wrong. Perhaps your web endpoint changes or goes down - you don't want your game scripts raising errors and breaking your game. You want to handle both success **and failure** gracefully - have a plan in case your data is not available. Use `pcall` and make plenty of validity checks (if statements) on your data to make sure you're getting exactly what you expect.

  [1]: http://open-notify.org/Open-Notify-API/ISS-Location-Now/
```lua
local HttpService = game:GetService("HttpService")

-- Where is the International Space Station right now?
local URL_ISS = "http://api.open-notify.org/iss-now.json"

local function printISS()
	local response
	local data
	-- Use pcall in case something goes wrong
	pcall(function ()
		response = HttpService:GetAsync(URL_ISS)
		data = HttpService:JSONDecode(response)
	end)
	-- Did our request fail or our JSON fail to parse?
	if not data then return false end
	
	-- Fully check our data for validity. This is dependent on what endpoint you're 
	-- to which you're sending your requests. For this example, this endpoint is 
	-- described here:  http://open-notify.org/Open-Notify-API/ISS-Location-Now/
	if data.message == "success" and data.iss_position then
		if data.iss_position.latitude and data.iss_position.longitude then
			print("The International Space Station is currently at:")
			print(data.iss_position.latitude .. ", " .. data.iss_position.longitude)
			return true
		end
	end
	return false
end

if printISS() then
	print("Success")
else
	print("Something went wrong")
end
```

### New Pastebin Post

Pastebin.com is a website that allows users to paste text (usually source code) for others to view publicly. This code sample uses HttpService PostAsync and the pastebin web API to automatically create a new public paste on the website. Since pastebin's API is designed to take data in as a URL encoded string, the code uses a for-loop to turn the `dataFields` table into a URL encoded string, such as hello=world&foo=bar. This is used as the HTTP POST data.

Test this code by first going to [pastebin.com/api#1][1] and getting an API key (you'll need a pastebin account to do this). Then, paste your unique developer API key into the field `api_dev_key` in the code sample's `dataFields` table. Fill in any other information about the post you want to make, then run this code in a Script (not a LocalScript). If all goes well, you'll get a URL to your new paste in the Output window (or some error string from pastebin).

  [1]: https://pastebin.com/api#1
```lua
local HttpService = game:GetService("HttpService")

local URL_PASTEBIN_NEW_PASTE = "https://pastebin.com/api/api_post.php"
local dataFields = {
	-- Pastebin API developer key from
	-- https://pastebin.com/api#1
	["api_dev_key"] = "FILL THIS WITH YOUR API DEVELOPER KEY";    
	
	["api_option"] = "paste";                                -- keep as "paste"
	["api_paste_name"] = "HttpService:PostAsync";            -- paste name
	["api_paste_code"] = "Hello, world";                     -- paste content
	["api_paste_format"] = "text";                            -- paste format
	["api_paste_expire_date"] = "10M";                       -- expire date        
	["api_paste_private"] = "0";                             -- 0=public, 1=unlisted, 2=private
	["api_user_key"] = "";                                   -- user key, if blank post as guest
}

-- The pastebin API uses a URL encoded string for post data
-- Other APIs might use JSON, XML or some other format
local data = ""
for k, v in pairs(dataFields) do
	data = data .. ("&%s=%s"):format(
		HttpService:UrlEncode(k),
		HttpService:UrlEncode(v)
	)
end
data = data:sub(2) -- Remove the first &

-- Here's the data we're sending
print(data)

-- Make the request
local response = HttpService:PostAsync(URL_PASTEBIN_NEW_PASTE, data, Enum.HttpContentType.ApplicationUrlEncoded, false)
-- The response will be the URL to the new paste (or an error string if something was wrong)
print(response)
```
 */
interface HttpService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HttpService";
	/** GenerateGUID randomly creates a [universally unique identifier (UUID)][1] string. The sixteen octets of a UUID are represented as 32 hexadecimal (base 16) digits, displayed in 5 groups separated by hyphens in the form `8-4-4-4-12` for a total of 36 characters. For example: `123e4567-e89b-12d3-a456-426655440000`.

  [1]: https://en.wikipedia.org/wiki/Universally_unique_identifier

## Code Samples

### HttpService GenerateGUID

This example uses HttpService's GenerateGUI method to generate and print a universally unique identifier.
```lua
local HttpService = game:GetService("HttpService")
local result = HttpService:GenerateGUID(true)
print(result) --> Example output: {04AEBFEA-87FC-480F-A98B-E5E221007A90}
```
 */
	GenerateGUID(wrapInCurlyBraces?: boolean): string;
	/** The JSONDecode function transforms a [JSON object or array][1] into a Lua [table][2] with the following characteristics:

 - Keys of the table are strings or numbers but not both. If a JSON object contains both, string keys are ignored.
 - An empty JSON object generates an empty Lua table `{}`.
 - If the *input* string is not a valid JSON object, this function will throw an error. 

To encode a Lua table into a JSON object, you can use `HttpService's` `JSONEncode` function.

Many web endpoints use JSON, as it is commonly used on the Internet. Visit [JSON.org][3] to become more familiar with the format.

This method can be used regardless of whether HTTP Requests are `enabled`.


  [1]: http://robloxdev.com/articles/JSON-Storage-Format
  [2]: http://robloxdev.com/articles/Table
  [3]: http://www.json.org/

## Code Samples

### HttpService JSONDecode

This code sample gives an example [JSON][1] format string and parses it using HttpService's JSONDecode. It then verifies that the JSON was parsed correctly,  and prints out some of the information within the object.

Try editing the JSON string to experiment with the format. Also experiment with inspecting the data in Lua to get comfortable with the Lua representation of the data (tables and other values).

  [1]: http://www.json.org/
```lua
local HttpService = game:GetService("HttpService")

-- An example JSON formatted string 
-- For details, see: http://www.json.org/
local jsonString = [[
{
	"message": "success",
	"info": {
		"points": 120,
		"isLeader": true,
		"user": {
			"id": 12345,
			"name": "JohnDoe"
		},
		"past_scores": [50, 42, 95],
		"best_friend": null
	}
}
]]

local data = HttpService:JSONDecode(jsonString)
if data.message == "success" then
	-- Print the sample data
		
	-- Since tab["hello"] and tab.hello are equivalent,
	-- you could also use data["info"]["points"] here:
	print("I have " .. data.info.points .. " points")
	if data.info.isLeader then
		print("I am the leader")
	end
	print("I have " .. #data.info.past_scores .. " past scores")
	
	print("All the information:")
	for k, v in pairs(data.info) do
		print(k, type(v), v)
	end
end
```

@param input The JSON object being decoded
@returns The decoded JSON object as a Lua table */
	JSONDecode(input: string): unknown;
	/** JSONEncode transforms a Lua table into a JSON object or array.

 - Keys of the table must be either strings or numbers. If a table
   contains both, an array takes priority (string keys are ignored).
 - An empty Lua table `{}` generates an empty JSON array.
 - The value `nil` is never generated.
 - Cyclic table references generate the string `*** certain entries
   belong to the same table ***`.

Many web endpoints use JSON, and is commonly used on the Internet. Visit [JSON.org][1] to become more familiar with the format.

This method can be used regardless if HTTP Requests are enabled.

  [1]: http://www.json.org/

## Code Samples

### HttpService JSONEncode

This code sample turns a Lua table `tab` into a [JSON string][1] using HttpService's JSONEncode. Then, it prints out the string. Note that after the table is set, the sample creates a cyclic reference in the table by putting a reference to the table within itself. This is to demonstrate how the JSON encoder handles cyclic references.

Try editing the Lua table to see how the JSON output changes.

  [1]: http://www.json.org/
```lua
local HttpService = game:GetService("HttpService")

local tab = {
	-- Remember: these lines are equivalent
	["message"] = "succes";
	message = "success";
	
	info = {
		points = 120,
		isLeader = true,
		user = {
			id = 12345,
			name = "JohnDoe"
		},
		past_scores = {50, 42, 95},
		best_friend = nil
	}
}

-- A cyclic relationship like this...
tab.tab = tab
-- ...will be replaced with the string:
-- '* certain entries belong to the same table '*

local json = HttpService:JSONEncode(tab)
print(json)
```
 */
	JSONEncode(input?: any): string;
	/** [Percent-encodes][1] a given string so that reserved characters properly encoded with '%' and two hexadecimal characters. This is useful when formatting URLs for use with `GetAsync`/`PostAsync`, or POST data of the media type `x-www-form-urlencoded` (`Enum.HttpContentType.ApplicationUrlEncoded`).

  [1]: https://en.wikipedia.org/wiki/Percent-encoding

## Code Samples

### New Pastebin Post

Pastebin.com is a website that allows users to paste text (usually source code) for others to view publicly. This code sample uses HttpService PostAsync and the pastebin web API to automatically create a new public paste on the website. Since pastebin's API is designed to take data in as a URL encoded string, the code uses a for-loop to turn the `dataFields` table into a URL encoded string, such as hello=world&foo=bar. This is used as the HTTP POST data.

Test this code by first going to [pastebin.com/api#1][1] and getting an API key (you'll need a pastebin account to do this). Then, paste your unique developer API key into the field `api_dev_key` in the code sample's `dataFields` table. Fill in any other information about the post you want to make, then run this code in a Script (not a LocalScript). If all goes well, you'll get a URL to your new paste in the Output window (or some error string from pastebin).

  [1]: https://pastebin.com/api#1
```lua
local HttpService = game:GetService("HttpService")

local URL_PASTEBIN_NEW_PASTE = "https://pastebin.com/api/api_post.php"
local dataFields = {
	-- Pastebin API developer key from
	-- https://pastebin.com/api#1
	["api_dev_key"] = "FILL THIS WITH YOUR API DEVELOPER KEY";    
	
	["api_option"] = "paste";                                -- keep as "paste"
	["api_paste_name"] = "HttpService:PostAsync";            -- paste name
	["api_paste_code"] = "Hello, world";                     -- paste content
	["api_paste_format"] = "text";                            -- paste format
	["api_paste_expire_date"] = "10M";                       -- expire date        
	["api_paste_private"] = "0";                             -- 0=public, 1=unlisted, 2=private
	["api_user_key"] = "";                                   -- user key, if blank post as guest
}

-- The pastebin API uses a URL encoded string for post data
-- Other APIs might use JSON, XML or some other format
local data = ""
for k, v in pairs(dataFields) do
	data = data .. ("&%s=%s"):format(
		HttpService:UrlEncode(k),
		HttpService:UrlEncode(v)
	)
end
data = data:sub(2) -- Remove the first &

-- Here's the data we're sending
print(data)

-- Make the request
local response = HttpService:PostAsync(URL_PASTEBIN_NEW_PASTE, data, Enum.HttpContentType.ApplicationUrlEncoded, false)
-- The response will be the URL to the new paste (or an error string if something was wrong)
print(response)
```

### HttpService UrlEncode

This code sample uses `UrlEncode` to turn a string into a safe, [percent-encoded][1] string that can be used in a URL as an argument. Notice how only unreserved characters (letters, numbers and `-_.~`) are not transformed into percent-encoded equivalents. Characters with accents are also transformed (for example `é` is transformed into `%C3`).


  [1]: https://en.wikipedia.org/wiki/Percent-encoding
```lua
local HttpService = game:GetService("HttpService")
local content = "Je me suis allé au cinema." -- French for "I went to the movies"
local result = HttpService:UrlEncode(content)
print(result) --> Je%20me%20suis%20all%C3%A9%20au%20cinema%2E
```
 */
	UrlEncode(input: string): string;
	/** Send an HTTP GET request, blocking the current thread until a response is received. If the HTTP response code is not in 200 class of status codes, this function raises an error. A useful endpoint that can help you debug GET request is https://httpbin.org/get. It provides a JSON response with information about a GET request, such as headers and URL arguments.

## Code Samples

### Astronauts in Space

This code sample uses HttpService's GetAsync to make a request to [Open Notify][1], a web service that provides data from NASA. The request is made to an endpoint that provides information on how many astronauts are currently in space. The response is provided in JSON format, so it is parsed using JSONDecode. Finally, the response data is then processed and printed to the Output.

Test this script by pasting the source code into a Script (HttpService cannot be used by LocalScripts). Also, be sure to enable HTTP Requests in your Game Settings (Home > Game Settings).

  [1]: http://open-notify.org
```lua
local HttpService = game:GetService("HttpService")

local URL_ASTROS = "http://api.open-notify.org/astros.json"

-- Make the request to our endpoint URL
local response = HttpService:GetAsync(URL_ASTROS)

-- Parse the JSON response
local data = HttpService:JSONDecode(response)

-- Information in the data table is dependent on the response JSON
if data.message == "success" then
	print("There are currently " .. data.number .. " astronauts in space:")
	for i, person in pairs(data.people) do
		print(i .. ": " .. person.name .. " is on " .. person.craft)
	end
end
```

### Where is the International Space Station?

This code sample uses HttpService's GetAsync to make a request to an endpoint at [Open Notify][1], a website that provides information from NASA. The endpoint provides information on the current location of the International Space Station. This example uses a **defensive coding technique** that you should use when making web requests. It wraps the call to GetAsync and JSONDecode in pcall, which protects our script from raising an error if either of these fail. Then, it checks the raw response for all proper data before using it. All of this is put inside a function that returns true or false depending of the request's success.

Whenever you're working with web requests, you should prepare for anything to go wrong. Perhaps your web endpoint changes or goes down - you don't want your game scripts raising errors and breaking your game. You want to handle both success **and failure** gracefully - have a plan in case your data is not available. Use `pcall` and make plenty of validity checks (if statements) on your data to make sure you're getting exactly what you expect.

  [1]: http://open-notify.org/Open-Notify-API/ISS-Location-Now/
```lua
local HttpService = game:GetService("HttpService")

-- Where is the International Space Station right now?
local URL_ISS = "http://api.open-notify.org/iss-now.json"

local function printISS()
	local response
	local data
	-- Use pcall in case something goes wrong
	pcall(function ()
		response = HttpService:GetAsync(URL_ISS)
		data = HttpService:JSONDecode(response)
	end)
	-- Did our request fail or our JSON fail to parse?
	if not data then return false end
	
	-- Fully check our data for validity. This is dependent on what endpoint you're 
	-- to which you're sending your requests. For this example, this endpoint is 
	-- described here:  http://open-notify.org/Open-Notify-API/ISS-Location-Now/
	if data.message == "success" and data.iss_position then
		if data.iss_position.latitude and data.iss_position.longitude then
			print("The International Space Station is currently at:")
			print(data.iss_position.latitude .. ", " .. data.iss_position.longitude)
			return true
		end
	end
	return false
end

if printISS() then
	print("Success")
else
	print("Something went wrong")
end
```
 */
	GetAsync(url: string, nocache?: boolean, headers?: HttpHeaders): string;
	/** Send an HTTP POST request, blocking the current thread until a response is received. Certain HTTP response codes (like 404 or 403) will raise errors.  A useful endpoint that can help you debug POST requests is https://httpbin.org/post. It provides a JSON response with information about a POST request, such as headers and URL arguments.

## Code Samples

### New Pastebin Post

Pastebin.com is a website that allows users to paste text (usually source code) for others to view publicly. This code sample uses HttpService PostAsync and the pastebin web API to automatically create a new public paste on the website. Since pastebin's API is designed to take data in as a URL encoded string, the code uses a for-loop to turn the `dataFields` table into a URL encoded string, such as hello=world&foo=bar. This is used as the HTTP POST data.

Test this code by first going to [pastebin.com/api#1][1] and getting an API key (you'll need a pastebin account to do this). Then, paste your unique developer API key into the field `api_dev_key` in the code sample's `dataFields` table. Fill in any other information about the post you want to make, then run this code in a Script (not a LocalScript). If all goes well, you'll get a URL to your new paste in the Output window (or some error string from pastebin).

  [1]: https://pastebin.com/api#1
```lua
local HttpService = game:GetService("HttpService")

local URL_PASTEBIN_NEW_PASTE = "https://pastebin.com/api/api_post.php"
local dataFields = {
	-- Pastebin API developer key from
	-- https://pastebin.com/api#1
	["api_dev_key"] = "FILL THIS WITH YOUR API DEVELOPER KEY";    
	
	["api_option"] = "paste";                                -- keep as "paste"
	["api_paste_name"] = "HttpService:PostAsync";            -- paste name
	["api_paste_code"] = "Hello, world";                     -- paste content
	["api_paste_format"] = "text";                            -- paste format
	["api_paste_expire_date"] = "10M";                       -- expire date        
	["api_paste_private"] = "0";                             -- 0=public, 1=unlisted, 2=private
	["api_user_key"] = "";                                   -- user key, if blank post as guest
}

-- The pastebin API uses a URL encoded string for post data
-- Other APIs might use JSON, XML or some other format
local data = ""
for k, v in pairs(dataFields) do
	data = data .. ("&%s=%s"):format(
		HttpService:UrlEncode(k),
		HttpService:UrlEncode(v)
	)
end
data = data:sub(2) -- Remove the first &

-- Here's the data we're sending
print(data)

-- Make the request
local response = HttpService:PostAsync(URL_PASTEBIN_NEW_PASTE, data, Enum.HttpContentType.ApplicationUrlEncoded, false)
-- The response will be the URL to the new paste (or an error string if something was wrong)
print(response)
```
 */
	PostAsync(
		url: string,
		data: string,
		content_type?: CastsToEnum<Enum.HttpContentType>,
		compress?: boolean,
		headers?: HttpHeaders,
	): string;
	/** The **RequestAsync()** function sends an HTTP request using a dictionary to specify the request data, such as the target URL, method, headers and request body data. It returns a dictionary that describes the response data received.

## Request Dictionary Fields

| Name | Type | Required | Description |
| --- | --- | --- | --- |
| **Url** | string | yes | The target URL for this request. Must use `http` or `https` protocols. |
| **Method** | string | no | The HTTP method being used by this request, most often GET or POST. |
| **Headers** | dictionary | no | A dictionary of headers to be used with this request. Most HTTP headers are accepted here, but not all. |
| **Body** | string | no | The request body. Can be any string, including binary data. Must be excluded when using the GET or HEAD HTTP methods. It might be necessary to specify the `Content-Type` header when sending JSON or other formats. |

### HTTP Headers
In the request dictionary, you can specify custom HTTP headers to use in the request. However, some headers cannot be specified. For example, `Content-Length` is determined from the request body. `User-Agent` and `Roblox-Id` are locked by Roblox. Other headers like `Accept` or `Cache-Control` use default values but can be overridden. More commonly, some REST APIs may require API keys or other service authentication to be specified in request headers.

This method does not detect the format of body content. Many web servers require the `Content-Type` header be set appropriately when sending certain formats. Other methods of `HttpService` use the `HttpContentType` enum; for this method set the `Content-Type` header appropriately: `plain`, `xml`, `xml`, `json` or `x-www-form-urlencoded` are replacement `Content-Type` header values for the respective enum values.

## Response Dictionary Fields
The function returns a dictionary containing the following fields:

| Name | Type | Description |
| --- | --- | --- |
| **Success** | boolean | The success status of the request. This is true if and only if the **StatusCode** lies within the range [200, 299]. |
| **StatusCode** | integer | The HTTP response code identifying the status of the response. |
| **StatusMessage** | string | The status message that was sent back. |
| **Headers** | dictionary | A dictionary of headers that were set in this response. |
| **Body** |  | The request body (content) received in the response. |


## Error Cases
This method raises an error if the response times out or if the target server rejects the request. If a web service goes down for some reason, it can cause scripts that use this method to stop functioning altogether. It is often a good idea to wrap calls to this method in `pcall` and gracefully handle failure cases if the required information isn't available.

## Limitations
The current limitation for sending and receiving HTTP requests is 500 requests per minute. Requests over this threshold will fail. Additionally, Roblox domains are blacklisted. This means that HTTP requests cannot be sent to any Roblox owned site, such as [www.roblox.com][3].

  [3]: https://www.roblox.com

## Code Samples

### Sending an HTTP Request

This code sample demonstrates sending a single HTTP POST request with JSON data to the website httpbin.org, a website that helps debug HTTP requests. Here, we send some JSON data by using `JSONEncode` and also setting the `Content-Type`
 header.
```lua
-- Remember to set enable HTTP Requests in game settings!
local HttpService = game:GetService("HttpService")

local function request()
	local response = HttpService:RequestAsync(
		{
			Url = "http://httpbin.org/post",  -- This website helps debug HTTP requests
			Method = "POST",
			Headers = {
				["Content-Type"] = "application/json"  -- When sending JSON, set this!
			},
			Body = HttpService:JSONEncode({hello = "world"})
		}
	)

	-- Inspect the response table
	if response.Success then
		print("Status code:", response.StatusCode, response.StatusMessage)
		print("Response body:\n", response.Body)
	else
		print("The request failed:", response.StatusCode, response.StatusMessage)
	end
end

-- Remember to wrap the function in a 'pcall' to prevent the script from breaking if the request fails
local success, message = pcall(request)
if not success then
	print("Http Request failed:", message)
end
```

@param requestOptions A dictionary containing information to be requested from the server specified.
@returns A dictionary containing response information from the server specified. */
	RequestAsync(requestOptions: RequestAsyncRequest): RequestAsyncResponse;
}

/** The Humanoid is a special object that gives models the functionality of a character. It grants the model with the ability to physically walk around and interact with various components of a Roblox level. 

Humanoids are always parented inside of a `Model`, and the model is expected to be an assembly of `BasePart` and `Motor6D`; the root part of the assembly is expected to be named _HumanoidRootPart_ . It also expects a part named _Head_ to be connected to the character's torso part, either directly or indirectly.


By default, there are two official types of character rigs supplied by Roblox, each with their own set of rules:



### R6

* A basic character rig that uses 6 parts for limbs.

* The _Head_ part must be attached to a part named _Torso_, or the Humanoid will die immediately.

* BodyPart appearances are applied using `CharacterMesh` objects.

* Certain properties, such as `LeftLeg` and `RightLeg`, only work with R6.

### R15

* More complex than R6, but also far more flexible and robust.

* Uses 15 parts for limbs.

* The _Head_ part must be attached to a part named _UpperTorso_ or the Humanoid will die immediately.

* BodyPart appearances have to be assembled directly.

* Can be dynamically rescaled by using special `NumberValue` objects parented inside of the Humanoid.

* The Humanoid will automatically create `Vector3Value`
 objects named _OriginalSize_
 inside of each limb.
* If a NumberValue is parented inside of the Humanoid and is named one of the following, it will be used to control the scaling functionality:

* BodyDepthScale
* BodyHeightScale
* BodyWidthScale
* HeadScale

## Code Samples

### Walking Camera Bobble Effect

This LocalScript makes the camera bobble as the player's character walks around, utilizing both the Humanoid's CameraOffset and MoveDirection.
It should be parented inside of the StarterCharacterScripts so that it is distributed into a player's character as expected.
```lua
local RunService = game:GetService("RunService")

local playerModel = script.Parent
local humanoid = playerModel:WaitForChild("Humanoid")

local function updateBobbleEffect()
	local now = tick()
	if humanoid.MoveDirection.Magnitude > 0 then -- Are we walking?
		local velocity = humanoid.RootPart.Velocity
		local bobble_X = math.cos(now * 9) / 5
		local bobble_Y = math.abs(math.sin(now * 12)) / 5
		
		local bobble = Vector3.new(bobble_X,bobble_Y,0) * math.min(1, velocity.Magnitude / humanoid.WalkSpeed)
		humanoid.CameraOffset = humanoid.CameraOffset:lerp(bobble,.25)
	else
		-- Scale down the CameraOffset so that it shifts back to its regular position.
		humanoid.CameraOffset = humanoid.CameraOffset * 0.75
	end
end

-- Update the effect on every single frame.
RunService.RenderStepped:Connect(updateBobbleEffect)
```
 */
interface Humanoid extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Humanoid";
	/** AutoJumpEnabled sets whether or not the `Humanoid` will attempt to automatically jump over an obstacle it is walking towards.

Currently, this property only works when the following conditions are true:
* The Humanoid's character model is the `Character` of a `Player`.
* The Player in question is using touch controls.

When a player's character spawns, the property's value matches the player's `AutoJumpEnabled` property - which in turn matches the `AutoJumpEnabled` property.

## Code Samples

### Auto-Jump Toggle

This code sample is meant for a TextButton. It allows the player to toggle the auto-jumping behavior while on a mobile device.
```lua
local player = game.Players.LocalPlayer
local button = script.Parent

local function update()
	-- Update button text
	if player.AutoJumpEnabled then
		button.Text = "Auto-Jump is ON"
	else
		button.Text = "Auto-Jump is OFF"
	end
	-- Reflect the property in the player's character, if they have one
	if player.Character then
		local human = player.Character:FindFirstChild("Humanoid")
		if human then
			human.AutoJumpEnabled = player.AutoJumpEnabled
		end
	end
end

local function onActivated()
	-- Toggle auto-jump
	player.AutoJumpEnabled = not player.AutoJumpEnabled
	-- Update everything else
	update()
end
button.Activated:connect(onActivated)
update()

```
 */
	AutoJumpEnabled: boolean;
	/** The AutoRotate property is a boolean that describes whether or not the Humanoid will automatically rotate to face in the direction they are moving. When set to true, the character model will gradually turn to face their movement direction as the Humanoid walks around. When set to false, the character model will remain fixated in its current rotation, unless a rotating force is applied to the *HumanoidRootPart*.

If the character model happens to be the character of a player, then the behavior of the Humanoid's rotation is influenced by the UserGameSetting's RotateType property.

When the AutoRotate property is set to true, the RotateType property has the following effects on the Humanoid's rotation:
| RotationType | Behavior | Context |
| --- | --- | --- |
| CameraRelative | Character will rotate to face in the direction of the camera. | Player has their camera zoomed into first-person, or they are in shift-lock mode. |
| CameraRelative | Character will rotate to face in the direction of the camera. | Player has their camera zoomed into first-person, or they are in shift-lock mode. |

## Code Samples

### AutoRotate Button

This script adds the functionality of a button to a part, which switches the AutoRotate property of whoever touches it.
```lua
local button = script.Parent
local enabled = true

local ON_COLOR = BrickColor.Green()
local OFF_COLOR = BrickColor.Red()

local function touchButton(humanoid)
	if enabled then
		enabled = false
		button.BrickColor = OFF_COLOR
		
		if humanoid.AutoRotate then
			print(humanoid:GetFullName() .. " can no longer auto-rotate!")
			humanoid.AutoRotate = false
		else
			print(humanoid:GetFullName() .. " can now auto-rotate!")
			humanoid.AutoRotate = true
		end
		
		wait(1)
		button.BrickColor = ON_COLOR
		enabled = true
	end
end

local function onTouched(hit)
	local char = hit:FindFirstAncestorWhichIsA("Model")
	if char then
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if humanoid then
			touchButton(humanoid)
		end
	end
end

button.Touched:Connect(onTouched)
button.BrickColor = ON_COLOR
```
 */
	AutoRotate: boolean;

	AutomaticScalingEnabled: boolean;
	/** Determines whether a `Humanoid's` joints break when in the Dead state. Defaults to true.

If it is set to false, BreakJoints will not be called on death or after death. If it is set to true, the existing break-joints-every-frame behavior will be used. */
	BreakJointsOnDeath: boolean;
	/** CameraOffset specifies an offset to the Camera's subject position when its CameraSubject is set to this Humanoid.

The offset is applied in object-space, relative to the orientation of the Humanoid's *HumanoidRootPart*.

## Code Samples

### Walking Camera Bobble Effect

This LocalScript makes the camera bobble as the player's character walks around, utilizing both the Humanoid's CameraOffset and MoveDirection.
It should be parented inside of the StarterCharacterScripts so that it is distributed into a player's character as expected.
```lua
local RunService = game:GetService("RunService")

local playerModel = script.Parent
local humanoid = playerModel:WaitForChild("Humanoid")

local function updateBobbleEffect()
	local now = tick()
	if humanoid.MoveDirection.Magnitude > 0 then -- Are we walking?
		local velocity = humanoid.RootPart.Velocity
		local bobble_X = math.cos(now * 9) / 5
		local bobble_Y = math.abs(math.sin(now * 12)) / 5
		
		local bobble = Vector3.new(bobble_X,bobble_Y,0) * math.min(1, velocity.Magnitude / humanoid.WalkSpeed)
		humanoid.CameraOffset = humanoid.CameraOffset:lerp(bobble,.25)
	else
		-- Scale down the CameraOffset so that it shifts back to its regular position.
		humanoid.CameraOffset = humanoid.CameraOffset * 0.75
	end
end

-- Update the effect on every single frame.
RunService.RenderStepped:Connect(updateBobbleEffect)
```
 */
	CameraOffset: Vector3;
	/** This property selects the `HumanoidCollisionType` for R15 and Rthro non-player characters.

The collision geometry for the InnerBox type is calculated at run-time and will not be applied in Studio when the simulation is not running. 

For player `Characters` the CollisionType property will be decided by the Avatar Collision Option in Game Settings.

![Collision Options in Game Settings](https://developer.roblox.com/assets/5ca6c104d06594542e967074/HumanoidCollisionType.jpg)

This property is writable by `Plugins` and can be read by all scripts.

### Enums
| Name | Value | Description |
| --- | --- | --- |
| OuterBox | 0 | Dynamically sized collision boxes based on mesh sizes |
| Innerbox | 1 | Fixed size collision boxes, similar to the classic avatar collision | */
	readonly CollisionType: Enum.HumanoidCollisionType;
	/** The DisplayDistanceType property controls how the humanoid display's visibility behaves, based on the distance between the `Humanoid` and the player's view.

When a Humanoid's parent `BaseModel` has a part named *Head*, a visual display of the `Player`'s name and health is drawn 1.5 studs above the character's head. This visual display is known as the **Humanoid Display**.

This property is set using the `HumanoidDisplayDistanceType` enum. There are three available values for this property, each with their own set of rules:

None
---
When the DisplayDistanceType is set to **None**, the humanoid display will not be shown under any circumstances.

Viewer
---
When the DisplayDistanceType is set to **Viewer**, the humanoid display's visibility is locally controlled by the NameDisplayDistance and HealthDisplayDistance of each Player in the game. For instance, if a player has their display distance properties set to 50, and everyone else has their display distance properties set to 100,  then that player will not be able to see the name and health of the humanoid at a distance greater than 50 studs, while everyone else can still see the name and health of the humanoid up to a distance of 100 studs.

![Viewer example](https://developer.roblox.com/assets/blta3653f27a817f4f1/HumanoidViewerDistance.png)

In this example all of the NPC characters have their DisplayDistanceType set to Viewer. This means the distance the information will be displayed will be taken from the humanoid that is viewing them. In this case, the player character (who is in the foreground) has its HealthDisplayDistance set to 10 and NameDisplayDistance set to 20. The health bar is only visible on the closest NPC because it is within 10 studs, and the names of only the two closer NPCs are visible because they are within 20 studs.

----------

Subject
---

When the DisplayDistanceType is set to **Subject** the Humanoid's name and healthbar will be displayed based on the viewed humanoid's settings. This is useful when there are specific characters who you want to behave differently from other ones.

![Subject example](https://developer.roblox.com/assets/blt0484c3c0f5a98d64/HumanoidSubjectDistance.png)

In this example all of the NPC characters have their DisplayDistanceType set to Subject. This means the view distance of their information will depend on their individual HealthDisplayDistance and NameDisplayDistance properties.

* The NPC on the left has its HealthDisplayDistance and NameDisplayDistance set to 10. Since the NPC is 15 studs away, neither of the displays are visible.
* The NPC in the middle has its HealthDisplayDistance set to 10 and NameDisplayDistance set to 20. Since the NPC is 15 studs away, only the name is visible.
* The NPC on the right has its HealthDisplayDistance and NameDisplayDistance set to 20. Both name and health are visible, as the NPC is only 15 studs away.

## Code Samples

### Displaying a Humanoid's Health and Name

This example demonstrates how to set a `Humanoid`'s `DisplayerDistanceType`, `HealthDisplayDistance`, and `NameDisplayDistance` properties. These properties determine how a  humanoid's healthbar and name are rendered for a player.

First, we change the DisplayDistanceType to Viewer using `HumanoidDisplayDistanceType`. When set to viewer, the humanoid's Name and healthbar will be displayed based on the distance settings of the humanoid viewing them.

Then, the humanoid's HealthDisplayDistance is set to 0. Setting the property to 0 hides the healthbar completely. It is not displayed at any distance.

Finally, the humanoid's NameDisplayDistance is set to 100. This means that the humanoid's name will be visible to other humanoid's within 100 studs.

This example should work as expected when placed inside a `Script` that is a child of the humanoid.
```lua
local humanoid = script.Parent

humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
humanoid.HealthDisplayDistance = 0
humanoid.NameDisplayDistance = 100
```
 */
	DisplayDistanceType: Enum.HumanoidDisplayDistanceType;
	/** ![A visualization of the FloorMaterial property in action](https://developer.roblox.com/assets/blt911c31b19922748b/FloorMaterial.gif)

**FloorMaterial** is a read-only property that describes what type of Material the Humanoid is currently standing on. 
It works with both regular parts and terrain voxels. 

## Caveats ##
* When the Humanoid is not standing on a floor, the value of this property will be set to *Air*. 
  * This occurs because Enum properties cannot have an empty value. 
  * This can cause some confusion if a part has its material is set to Air, though in practice, parts are not supposed to use that material in the first place.
* The Humanoid's character model must be able to collide with the floor, or else it will not be detected.
  * You cannot test if the Humanoid is swimming with this property. You should instead use the Humanoid's GetState function. */
	readonly FloorMaterial: Enum.Material;
	/** ![A Humanoid with half of its health left.](https://developer.roblox.com/assets/blt1c35a737d3dcdb25/Half-Health.png)

**Health** is a property that represents the current health of the Humanoid.
Its value is constrained between 0, and the value of the Humanoid's MaxHealth.

----------

## Display Behavior ##

![The behavior of the HealthDIsplayType property](https://developer.roblox.com/assets/blt25d44cecfd3e9e09/HealthDisplayType.gif)

By default, the Humanoid displays a health bar under its name label when the Humanoid has taken damage. The display behavior of the health bar is dependent on the Humanoid's HealthDisplayDistance and HealthDisplayType properties.

![The default health bar displayed in Roblox's top bar](https://developer.roblox.com/assets/blt081a90d0f606c745/CoreGuiHealth.png)

From the perspective of a Player, their character will never display the standard humanoid name &amp; health label. Instead, it is displayed in the top right corner of the screen. The health bar will only be shown when the character's health isn't full. 

The player's character also has a default script inserted into it called **Health**, that regenerates their health by 1% continuously every second, until it is restored to full health.

----------

## Damaging Humanoids ##

![ForceFields make you immune to explosions!](https://developer.roblox.com/assets/bltfa7dc6cd34b05fae/ExplosionImmunity.png)

When making Humanoids take damage, you are advised to utilize the Humanoid's TakeDamage function. The TakeDamage function properly ignores damage when the Humanoid's character model has a ForceField parented inside of it.

The ForceField object makes the character immune to explosions and is expected to make them immune to damage as well. You are allowed to just subtract from the Humanoid's health, but it ultimately depends on whether or not you incorporate ForceFields into your game.
 
----------

## Out of Health! ##

![The same Humanoid from the beginning, after being bloxxed by an explosion.](https://developer.roblox.com/assets/blt9978f529dfcc80e6/Ooof.png)

When the value of the character's health reaches 0, the Humanoid will automatically change into its *Dead* state, which makes the character break its joints and fall into pieces.

If there is a joint connecting the Head part to the character, the Head **must** remain connected to the character, such that `Head:GetRootPart() == Humanoid.RootPart`. You can think of the joint connection as the character's neck. If you don't have a neck between your head and torso, you are very dead. */
	Health: number;
	/** HealthDisplayDistance is a number used in conjunction with the `Humanoid`'s `DisplayDistanceType` property to control how far a humanoid's health bar can be seen from in studs.

The DisplayDistanceType property is to one of three values using the `HumanoidDisplayDistanceType` enum.

----------

## DisplayDistanceType set to "None"##

When a humanoid's DisplayDistanceType is set to **None**, its health bar will never be visible to anyone under any circumstances.

----------

## DisplayDistanceType set to "Viewer"##

When a humanoid's DisplayDistanceType is set to **Viewer**, the visibility of its health bar is dependent upon the HealthDisplayDistance of the player viewing it. 

If the distance between the character models of the viewer and the humanoid is outside the range of the viewer's HealthDisplayDistance, then the health bar will not be shown to the viewer.

----------

## DisplayDistanceType set to "Subject"##

When a humanoid's DisplayDistanceType is set to **Subject**, the visibility of its health bar is dependent upon the value of the humanoid's own HealthDisplayDistance.

If the distance between the character models of the viewing player and the humanoid is outside the range of the humanoid's HealthDisplayDistance, then the health bar will not be shown to the viewing player.

----------

## Code Samples

### Displaying a Humanoid's Health and Name

This example demonstrates how to set a `Humanoid`'s `DisplayerDistanceType`, `HealthDisplayDistance`, and `NameDisplayDistance` properties. These properties determine how a  humanoid's healthbar and name are rendered for a player.

First, we change the DisplayDistanceType to Viewer using `HumanoidDisplayDistanceType`. When set to viewer, the humanoid's Name and healthbar will be displayed based on the distance settings of the humanoid viewing them.

Then, the humanoid's HealthDisplayDistance is set to 0. Setting the property to 0 hides the healthbar completely. It is not displayed at any distance.

Finally, the humanoid's NameDisplayDistance is set to 100. This means that the humanoid's name will be visible to other humanoid's within 100 studs.

This example should work as expected when placed inside a `Script` that is a child of the humanoid.
```lua
local humanoid = script.Parent

humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
humanoid.HealthDisplayDistance = 0
humanoid.NameDisplayDistance = 100
```
 */
	HealthDisplayDistance: number;
	/** ![A side by side visualization of how HealthDisplayType impacts the behavior of the health bar's display](https://developer.roblox.com/assets/blt25d44cecfd3e9e09/HealthDisplayType.gif)
HealthDisplayType controls when a humanoid's health bar is allowed to be displayed.

By default, this property is set to **DisplayWhenDamaged**, which makes the health bar only display when a humanoid's Health is less than its MaxHealth. It can also be set to **AlwaysOn**, which makes the health bar always display, or **AlwaysOff**, which prevents it from ever displaying.

This property functions independently of the humanoid's HealthDisplayDistance property, which is responsible for making the health bar fade out at certain distances. If the HealthDisplayType is set to AlwaysOn, it will still fade out depending the how the DisplayDistanceType is configured. */
	HealthDisplayType: Enum.HumanoidHealthDisplayType;
	/** HipHeight determines the distance (in studs) off the ground the `RootPart` should be when the Humanoid is standing. The `RigType` influences the way this property behaves:

## HipHeight for R15 Humanoids

With R15 rigs, a suitable HipHeight is preset to ensure the height of the `RootPart` is correct. The height of the legs is not used. The overall height of the Humanoid can be described in the following formula:

```lua
lua
Height = (0.5 * RootPart.Size.Y) + HipHeight
```


## HipHeight for R6 Humanoids

For R6 rigs, the `RootPart's` height is determined by the height of the character's legs and `RootPart`. HipHeight instead describes a relative offset. The overall height of the Humanoid can be described in the following formula:

```lua
lua
Height = LeftLeg.Size.Y + (0.5 * RootPart.Size.Y) + HipHeight
``` */
	HipHeight: number;
	/** Whether the Humanoid is jumping. If set to true, it will cause the Humanoid to jump. The humanoid jumps with an upwards force equal to the value of its JumpPower property.

![A character jumping over stairs that are 7 studs tall](https://developer.roblox.com/assets/blt61a464c982798678/Jumping.gif)

Humanoids are able to jump roughly 7.5 studs high by default, depending on both the Workspace's Gravity, and the JumpPower of the humanoid itself. */
	Jump: boolean;

	JumpHeight: number;
	/** Determines how much upwards force is applied to the `Humanoid` when jumping. The value of this property defaults to 50 and is constrained between 0 and 1000.

## Notes

* Jumps are also influenced by the `Gravity` property which determines the acceleration due to gravity.
* Although setting this property to 0 will prevent the `Humanoid` from jumping, developers are advised to disable the "Jumping" state using the `SetStateEnabled` function. */
	JumpPower: number;
	/** The maximum value of a humanoid's Health. The value of this property is used with the value of the health property to size the default health bar display.

When a humanoid's health reaches its maximum value, its health bar may not be displayed anymore, depending on its HealthDisplayType, as seen below:

![HealthDisplayType behaviors](https://developer.roblox.com/assets/blt25d44cecfd3e9e09/HealthDisplayType.gif) */
	MaxHealth: number;
	/** ![A visualization of how MaxSlopeAngle impacts characters walking on slanted surfaces.](https://developer.roblox.com/assets/bltd54b9a9a3f7ed230/MaxSlopeAngle.gif)

MaxSlopeAngle is a property of the Humanoid class, that determines the maximum slope angle that a humanoid can climb. If the angle of a slope is greater than a humanoid's MaxSlopeAngle, they will slide down the slope. 

In the visualization above, the MaxSlopeAngle is shown above each character's head. As you can see, the character with a MaxSlopeAngle lower than the 45° ramp ends up slipping into the lava.


The value of this property is constrained to values between 0° and 89°. It defaults to 89°, so humanoids can climb pretty much any slope they want by default. */
	MaxSlopeAngle: number;
	/** ![A visualization of the MoveDirection property.](https://developer.roblox.com/assets/blt2dece3266cda1b29/MoveDirection.gif)

MoveDirection is a read-only property that describes the direction a humanoid is walking in, as a unit vector along the X/Z axis. The direction is described in world space.

## Code Samples

### Walking Camera Bobble Effect

This LocalScript makes the camera bobble as the player's character walks around, utilizing both the Humanoid's CameraOffset and MoveDirection.
It should be parented inside of the StarterCharacterScripts so that it is distributed into a player's character as expected.
```lua
local RunService = game:GetService("RunService")

local playerModel = script.Parent
local humanoid = playerModel:WaitForChild("Humanoid")

local function updateBobbleEffect()
	local now = tick()
	if humanoid.MoveDirection.Magnitude > 0 then -- Are we walking?
		local velocity = humanoid.RootPart.Velocity
		local bobble_X = math.cos(now * 9) / 5
		local bobble_Y = math.abs(math.sin(now * 12)) / 5
		
		local bobble = Vector3.new(bobble_X,bobble_Y,0) * math.min(1, velocity.Magnitude / humanoid.WalkSpeed)
		humanoid.CameraOffset = humanoid.CameraOffset:lerp(bobble,.25)
	else
		-- Scale down the CameraOffset so that it shifts back to its regular position.
		humanoid.CameraOffset = humanoid.CameraOffset * 0.75
	end
end

-- Update the effect on every single frame.
RunService.RenderStepped:Connect(updateBobbleEffect)
```
 */
	readonly MoveDirection: Vector3;
	/** The NameDisplayDistance property is a number used in conjunction with the `Humanoid`'s `DisplayDistanceType` property to control how far a humanoid's name can be seen from.

The DisplayDistanceType property is to one of three values using the `HumanoidDisplayDistanceType` enum.

----------

## DisplayDistanceType set to "None"##

When a humanoid's DisplayDistanceType is set to **None**, its name will never be visible to anyone under any circumstances.

----------

## DisplayDistanceType set to "Viewer"##

When a humanoid's DisplayDistanceType is set to **Viewer**, the visibility of its name is dependent upon the NameDisplayDistance of the player viewing it. 

If the distance between the character models of the viewer and the humanoid is outside the range of the viewer's NameDisplayDistance, then the humanoid's name will not be shown to the viewer.

----------

## DisplayDistanceType set to "Subject"##

When a humanoid's DisplayDistanceType is set to **Subject**, the visibility of its name is dependent upon the value of the humanoid's own NameDisplayDistance.

If the distance between the character models of the viewing player and the humanoid is outside the range of the humanoid's NameDisplayDistance, then the humanoid's name will not be shown to the viewing player.

----------

## Code Samples

### Displaying a Humanoid's Health and Name

This example demonstrates how to set a `Humanoid`'s `DisplayerDistanceType`, `HealthDisplayDistance`, and `NameDisplayDistance` properties. These properties determine how a  humanoid's healthbar and name are rendered for a player.

First, we change the DisplayDistanceType to Viewer using `HumanoidDisplayDistanceType`. When set to viewer, the humanoid's Name and healthbar will be displayed based on the distance settings of the humanoid viewing them.

Then, the humanoid's HealthDisplayDistance is set to 0. Setting the property to 0 hides the healthbar completely. It is not displayed at any distance.

Finally, the humanoid's NameDisplayDistance is set to 100. This means that the humanoid's name will be visible to other humanoid's within 100 studs.

This example should work as expected when placed inside a `Script` that is a child of the humanoid.
```lua
local humanoid = script.Parent

humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
humanoid.HealthDisplayDistance = 0
humanoid.NameDisplayDistance = 100
```
 */
	NameDisplayDistance: number;
	/** Controls whether a Humanoid's name can be seen behind walls or other objects. This property applies based on the viewing players Humanoid. If the viewing player's Humanoid.NameOcclusion is set to OccludeAll, all humanoid name tags will be occluded for that player. */
	NameOcclusion: Enum.NameOcclusion;
	/** PlatformStand describes whether the `Humanoid` is currently in the *PlatformStanding* `HumanoidStateType`. When true, the Humanoid is in a state where it is free-falling and cannot move. This state behaves similar to sitting, except that jumping does not free the humanoid from the state.

The now-deprecated `SkateboardPlatform` puts the Humanoid into this state, much like how a `Seat` causes a sitting state.

## Code Samples

### Putting a Player into the PlatformStand State

The code below enables the `localplayer's` `PlatformStand` state, essentially freezing the player in place.
```lua
local player = game.Players.LocalPlayer
local character = player.CharacterAdded:wait()
local humanoid = character.Humanoid

humanoid.PlatformStand = true
```
 */
	PlatformStand: boolean;
	/** ![A comparison between the R6 rig and the R15 rig](https://developer.roblox.com/assets/blt2fb53ef69c9e060f/R6vsR15.png)

RigType describes whether a humanoid is utilizing the legacy R6 character rig, or the new R15 character rig.

The R6 rig uses 6 visible parts, while the R15 rig uses 15 visible parts.
R15 rigs also have more joints than R6 rigs, making them much more versatile to being animated. */
	RigType: Enum.HumanoidRigType;
	/** ![The HumanoidRootPart made visible!](https://developer.roblox.com/assets/blt477f5d6ada5478e2/HumanoidRootPart.gif)

A reference to the Humanoid's HumanoidRootPart, which is the root driving part of the Humanoid, that controls a humanoid's movement through the game world. This part is normally invisible. */
	readonly RootPart?: BasePart;
	/** ![A humanoid sitting on a Seat](https://developer.roblox.com/assets/blt8e6f26110beea0c1/SeatPart.png)

SeatPart is a reference to the seat that a humanoid is currently sitting in, if any. The value of this property can be either a Seat, or a VehicleSeat. It will be nil if the Humanoid is not currently sitting in a seat. */
	readonly SeatPart?: BasePart;
	/** ![A humanoid sitting on a Seat.](https://developer.roblox.comundefined)

The Sit property is a boolean that indicates whether the `Humanoid` is currently sitting. `Humanoids` can be forced into a sitting state by setting this property's value to true. If the `Humanoid` isn't attached to a seat while in its sitting state, it will trip over with no collision in its legs. A `Humanoid` can escape from the sitting state by jumping.

## Notes

 - The `Seat` or `VehicleSeat` the `Humanoid` is sitting on can be obtained using the `SeatPart` property
 - It is possible to detect when a Humanoid sits by connecting to the `Seated` event.

[1]:
/assets/blt8e6f26110beea0c1/SeatPart.png */
	Sit: boolean;
	/** **TargetPoint** describes a 3D position in space where the `Player` controlling this `Humanoid` last clicked with a `Tool` equipped.

This property is primarily used by classic tools to determine what a humanoid is targeting when they activate a tool. If you give an NPC a classic rocket launcher, set their **TargetPoint**, and then call the tool's `Activate` function, you can make the NPC fire a rocket at the target point. */
	TargetPoint: Vector3;

	UseJumpPower: boolean;
	/** WalkSpeed is a property that describes how quickly this Humanoid is able to walk, in studs per second. This property defaults to 16, so a Roblox character can move 16 studs in any direction each second by default.

When controlled on a mobile device or a gamepad, a humanoid can walk slower than their WalkSpeed if the controlling joystick is moved closer to its center. Roblox's default animation script scales a humanoid's movement animations based on how fast it is moving relative to the default speed of 16 studs/sec. */
	WalkSpeed: number;
	/** ![A visualization of how WalkToPart changes the behavior of WalkToPoint](https://developer.roblox.com/assets/bltc76671f1665d7da0/WalkToPart.gif)

WalkToPart is a reference to a part that the Humanoid is trying to reach. This property is normally set when a part is passed as the 2nd argument of the Humanoid's `MoveTo` function.

When WalkToPart is set and a humanoid is actively trying to reach the part, it will keep updating its Vector3 goal to be the position of the part, plus the `WalkToPoint` translated in object space relative to the rotation of the part.

This can be described in Lua as:
`goal = humanoid.WalkToPart.CFrame:pointToObjectSpace(humanoid.WalkToPoint)`

Caveats
----

* Setting the value of WalkToPart isn't sufficient enough to make a humanoid start following a part.
 * The Humanoid is prompted to start attempting to reach a goal when the value of WalkToPoint is changed. 
 * This may be changed in the future.
* The *reach goal* state of a humanoid will timeout after 8 seconds if it doesn't reach its goal. 
 * This is done so that NPCs won't get stuck waiting for `MoveToFinished` to fire. 
 * If you don't want this to happen, you should repeatedly call MoveTo so that the timeout will keep resetting. */
	WalkToPart?: BasePart;
	/** ![A humanoid attempting to reach the goal specified using WalkToPoint and WalkToPart](https://developer.roblox.com/assets/bltc76671f1665d7da0/WalkToPart.gif)

WalkToPoint describes the 3D position in space that a humanoid is trying to reach, after having been prompted to do so by the 
Humanoid's `MoveTo` function.

If a humanoid's `WalkToPart` is set, the goal is set by transforming WalkToPoint relative to the parts position and rotation. If WalkToPart is not set, then the humanoid will try to reach the 3D position specified by WalkToPoint directly.

Caveats
----

* The value of WalkToPoint must be changed to a different value in order for the humanoid to start walking towards it.
 * If you want to make a humanoid walk to `0,0,0`, you should use the Humanoid's MoveTo function.
 * This may be changed in the future.
* The *reach goal* state of a humanoid will timeout after 8 seconds if it doesn't reach its goal. 
 * This is done so that NPCs won't get stuck waiting for `MoveToFinished` to fire. 
 * If you don't want this to happen, you should repeatedly call MoveTo so that the timeout will keep resetting. */
	WalkToPoint: Vector3;
	/** ![A humanoid with an accessory that was attached using AddAccessory](https://developer.roblox.com/assets/5aae3895c7db666d0b74b15a/AddAccessory.png)

AddAccessory is a function that attaches the specified `Accessory` to the `Humanoid`. 

## How are Accessories attached to Humanoids?
![Attachments that share the same name, and thus are used to connect the accessory.](https://developer.roblox.com/assets/5aae3cca23d67a790b463318/AccessoryAttachment.png)

The `Accessory` is parented to the `Humanoid's` parent and then attached.

An `Accessory` is attached to the character by searching for an `Attachment` in the `Humanoid's` parent that shares the same name as an `Attachment` in the accessory's *Handle* `Part`. If one is found, the *Handle* part will be connected to the parent of the `Attachment` using a `Weld`. This weld will be configured so the `Attachments` occupy the same space.

If the required `Attachment` can not be found, then the `Accessory` will remain parented to the `Humanoid's` parent but it will be unattached.

## Code Samples

### [Humanoid] AddAccessory Example

This script generates the "Clockwork's Shades" Accessory from scratch, and then attaches it to the player's character using `Humanoid.AddAccessory` You should paste this code into a regular script, and then parent it inside of the `StarterPlayer`'s `StarterCharacterScripts` folder.
```lua
local playerModel = script.Parent
local humanoid = playerModel:WaitForChild("Humanoid")

-- Create the Accessory.
local clockworksShades = Instance.new("Accessory")
clockworksShades.Name = "ClockworksShades"

local handle = Instance.new("Part")
handle.Name = "Handle"
handle.Size = Vector3.new(1,1.6,1)
handle.Parent = clockworksShades

local faceFrontAttachment = Instance.new("Attachment")
faceFrontAttachment.Name = "FaceFrontAttachment"
faceFrontAttachment.Position = Vector3.new(0,-0.24,-0.45)
faceFrontAttachment.Parent = handle

local mesh = Instance.new("SpecialMesh")
mesh.Name = "Mesh"
mesh.Scale = Vector3.new(1,1.3,1)
mesh.MeshId = "rbxassetid://1577360"
mesh.TextureId = "rbxassetid://1577349"
mesh.Parent = handle

-- Attach the Accessory to the humanoid.
humanoid:AddAccessory(clockworksShades)
```

@param accessory The `Accessory` to be attached */
	AddAccessory(accessory: Accessory): void;
	/** BuildRigFromAttachments assembles a tree of `Motor6D` joints for a `Humanoid`. Motor6D joints are required for the playback of `Animations`

Starting from the humanoid's `RootPart`, the function collects all `Attachment`s parented in the current part, whose name ends with "RigAttachment". It then searches for a matching attachment in the character that shares the same name as the attachment. Using those two attachments, a Motor6D joint is generated based on the parts associated with the two attachments, and the `CFrame`s of the attachments. 

See the provided code sample below to see how this function works.

## Code Samples

### R15 Package Importer

A script that generates an R15 character from scratch using a package's assetId.
```lua
local PACKAGE_ASSET_ID = 193700907 -- Circuit Breaker

local AssetService = game:GetService("AssetService")
local InsertService = game:GetService("InsertService")
local MarketplaceService = game:GetService("MarketplaceService")

local function addAttachment(part,name,position,orientation)
	local attachment = Instance.new("Attachment")
	attachment.Name = name
	attachment.Parent = part
	if position then
		attachment.Position = position
	end
	if orientation then
		attachment.Orientation = orientation
	end
	return attachment
end

local function createBaseCharacter()
	local character = Instance.new("Model")

	local humanoid = Instance.new("Humanoid")
	humanoid.Parent = character
	
	local rootPart = Instance.new("Part")
	rootPart.Name = "HumanoidRootPart"
	rootPart.Size = Vector3.new(2,2,1)
	rootPart.Transparency = 1
	rootPart.Parent = character
	addAttachment(rootPart,"RootRigAttachment")
	
	local head = Instance.new("Part")
	head.Name = "Head"
	head.Size = Vector3.new(2,1,1)
	head.Parent = character
	
	local headMesh = Instance.new("SpecialMesh")
	headMesh.Scale = Vector3.new(1.25,1.25,1.25)
	headMesh.MeshType = Enum.MeshType.Head
	headMesh.Parent = head

	local face = Instance.new("Decal")
	face.Name = "face"
	face.Texture = "rbxasset://textures/face.png"
	face.Parent = head
	
	addAttachment(head,"FaceCenterAttachment")
	addAttachment(head,"FaceFrontAttachment",Vector3.new(0,0,-0.6))
	addAttachment(head,"HairAttachment",Vector3.new(0,0.6,0))
	addAttachment(head,"HatAttachment",Vector3.new(0,0.6,0))
	addAttachment(head,"NeckRigAttachment",Vector3.new(0,-0.5,0))
	
	return character,humanoid
end

local function createR15Package(packageAssetId)
	local packageAssetInfo = MarketplaceService:GetProductInfo(packageAssetId)
	
	local character,humanoid = createBaseCharacter()
	character.Name = packageAssetInfo.Name
	
	local assetIds = AssetService:GetAssetIdsForPackage(packageAssetId)
	for _,assetId in pairs(assetIds) do
		local limb = InsertService:LoadAsset(assetId)
		local r15 = limb:FindFirstChild("R15")
		if r15 then
			for _,part in pairs(r15:GetChildren()) do
				part.Parent = character
			end
		else
			for _,child in pairs(limb:GetChildren()) do
				child.Parent = character
			end
		end
	end
	
	humanoid:BuildRigFromAttachments()
	return character
end

local r15Package = createR15Package(PACKAGE_ASSET_ID)
r15Package.Parent = workspace
```

### Lua Port of BuildRigFromAttachments

A Lua port of the Humanoid's BuildRigFromAttachments function, so that the recursive behavior of the function can be seen.
```lua
local function createJoint(jointName,att0,att1)
	local part0,part1 = att0.Parent,att1.Parent
	local newMotor = part1:FindFirstChild(jointName)
	
	if not (newMotor and newMotor:IsA("Motor6D")) then
		newMotor = Instance.new("Motor6D")
	end
	
	newMotor.Name = jointName

	newMotor.Part0 = part0
	newMotor.Part1 = part1
	
	newMotor.C0 = att0.CFrame
	newMotor.C1 = att1.CFrame
	
	newMotor.Parent = part1
end

local function buildJointsFromAttachments(part,characterParts)
	if not part then 
		return 
	end
	
	-- first, loop thru all of the part's children to find attachments
	for _,attachment in pairs(part:GetChildren()) do
		if attachment:IsA("Attachment") then
			-- only do joint build from "RigAttachments"
			local attachmentName = attachment.Name
			local findPos = attachmentName:find("RigAttachment")
			if findPos then
				-- also don't make double joints (there is the same named
                -- rigattachment under two parts)
				local jointName = attachmentName:sub(1,findPos-1)
				if not part:FindFirstChild(jointName) then
					-- try to find other part with same rig attachment name
					for _,characterPart in pairs(characterParts) do
						if part ~= characterPart then
							local matchingAttachment = characterPart:FindFirstChild(attachmentName)
							if matchingAttachment and matchingAttachment:IsA("Attachment") then
								createJoint(jointName,attachment,matchingAttachment)
								buildJointsFromAttachments(characterPart,characterParts)
								break
							end
						end
					end
				end
			end
		end
	end
end

local function buildRigFromAttachments(humanoid)
	local rootPart = humanoid.RootPart
	assert(rootPart,"Humanoid has no HumanoidRootPart.")
	
	local characterParts = {}
	
	for i,descendant in ipairs(humanoid.Parent:GetDescendants()) do
		if descendant:IsA("BasePart") then
			table.insert(characterParts,descendant)
		end
	end
	
	buildJointsFromAttachments(rootPart,characterParts)
end
```
 */
	BuildRigFromAttachments(): void;
	/** This function causes the `Humanoid` to enter the given `HumanoidStateType`.

The humanoid state describes the activity the `Humanoid` is currently doing. 

You should check the page for `HumanoidStateType` for more information on what particular states do as some may have misleading names. For example, running describes a state where the `Humanoid's` legs are on the ground, including when stationary

Due to the default behavior of the `Humanoid` some states will automatically be changed when set to. Below are some examples of this:

 - Setting the state to *'Swimming*' when the `Humanoid` is not in the water will lead to it being automatically set to *'GettingUp'*
 - As it is unused, setting the state to *'PlatformStanding'* will lead to it being automatically set to *'Running'*

## See also
 - To enable or disable a paticular state use `SetStateEnabled`
 - To get the current state use `GetState`

## Code Samples

### 

This code, when placed inside a `LocalScript` in `StarterPlayer.StarterCharacterScripts` will allow the player's characters to perform a double jump.
```lua
local UserInputService = game:GetService("UserInputService")
local character = script.Parent

local humanoid = character:WaitForChild("Humanoid")

local doubleJumpEnabled = false 

humanoid.StateChanged:Connect(function(oldState, newState)
	if newState == Enum.HumanoidStateType.Jumping then
		if not doubleJumpEnabled then 
			wait(.2)
			if humanoid:GetState() == Enum.HumanoidStateType.Freefall then
				doubleJumpEnabled = true 
			end
		end
	elseif newState == Enum.HumanoidStateType.Landed then	
		doubleJumpEnabled = false
	end
end)

UserInputService.InputBegan:Connect(function(inputObject)
	if inputObject.KeyCode == Enum.KeyCode.Space then
		if doubleJumpEnabled then
			if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then
				humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				spawn(function()
					doubleJumpEnabled = false 
				end)
			end
		end		
	end
end)
```

@param state The `Enum/HumanoidStateType` that the `Humanoid` is to perform */
	ChangeState(state?: CastsToEnum<Enum.HumanoidStateType>): void;
	/** This function makes the `Humanoid` equip the given `Tool`.

The below example would cause *Player1* to equip a tool in `Workspace` named *'Tool'*. 
```lua
Workspace.Player1.Humanoid:EquipTool(Workspace.Tool)
```

When this function is called, the humanoid will automatically unequip any `Tools` that it currently has equipped

Although they will be equipped, `Tools` for which `RequiresHandle` is *true* will not function if they have no handle, regardless if this function is used to equip them or not

## See also
 - To unequip tools, use `UnequipTools`

## Code Samples

### Creating a Colorful Brick Tool

The code below creates a new tool and places into the `LocalPlayer`'s `Backpack`. Then, the code equips the tool for the player user `EquipTool`.

When the tool is equipped and the player uses it (e.g. pressed their mouse button in-game), the code spawns a new `part` at the position of the click using the `TargetPoint` position. The code also sets several of the part's properties, such as giving it a random `BrickColor`.
```lua
local player = game.Players.LocalPlayer
local character = player.CharacterAdded:wait()
local humanoid = character.Humanoid

-- Make a new tool and handle and put it in the player's Backpack
local function makeTool()
	-- Create tool
	local tool = Instance.new("Tool")
	tool.Parent = player:WaitForChild("Backpack")

	-- Create tool handle
	local handle = Instance.new("Part")
	handle.Name = "Handle"
	handle.Parent = tool
	handle.BrickColor = BrickColor.Random()
	
	-- Enable and equip tool
	tool.Enabled = true
	humanoid:EquipTool(tool)

	-- Handle tool use
	tool.Activated:Connect(onActivated)
end

-- Create a new randomly colored part at *pos* world position
local function spawnPart(pos)
	local part = Instance.new("Part")
	part.Anchored = true
	part.Size = Vector3.new(1,1,1)
	part.Position = pos
	part.Parent = game.Workspace
	part.BrickColor = BrickColor.Random()
end

-- Spawn a new part at TargetPoint when the tool is activated
function onActivated()
	spawnPart(humanoid.TargetPoint)
end

-- Make a new tool when the LocalScript first runs
makeTool()
```

@param tool The `Tool` to equip */
	EquipTool(tool: Tool | Flag): void;
	/** This function returns an array of `Accessories` that the `Humanoid` is currently wearing. 

All `Accessory` objects parented to the `Humanoid's` parent will be included, regardless of if they are attached to the `Humanoid` or not. If the humanoid is not wearing any accessories, the array will be empty.

If the `Humanoid` has no `Accessories` an empty array will be returned  

## See also
 - Use `AddAccessory` to attach an `Accessory` to a `Humanoid`

## Code Samples

### Remove and Return Hats

This code sample will remove all the hats from a `Character` once the character has fully loaded. After five seconds, if the character still exists and is alive, it will return them.
```lua
local Players = game:GetService("Players")

local function playerAdded(player)
	player.CharacterAppearanceLoaded:Connect(function(character)
		local humanoid = character:WaitForChild("Humanoid")

		-- save hats for later
		local accessories = {}
		for _, accessory in pairs(humanoid:GetAccessories()) do 
			table.insert(accessories, accessory:Clone())
		end

		-- remove hats
		humanoid:RemoveAccessories()

		wait(5)

		-- make sure the player still exists, and has the same character
		if player and player.Character and player.Character == character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
				-- give back the hats
				for _, accessory in pairs(accessories) do 
					humanoid:AddAccessory(accessory)
				end
			end
		end

		accessories = nil
	end)
end

-- get existing players
for _, player in pairs(Players:GetPlayers()) do 
	playerAdded(player)
end
-- listen for new players
Players.PlayerAdded:Connect(playerAdded)



```

@returns An array of `Accessory|Accessories` that are parented to the `Humanoid|Humanoid's` parent. */
	GetAccessories(): Array<Accessory>;

	GetAppliedDescription(): HumanoidDescription;
	/** Returns a Enum.BodyPartR15 given a body part in the Humanoid's Character. */
	GetBodyPartR15(part: BasePart): Enum.BodyPartR15;
	/** This function returns the `Limb` enum that is associated with the given `Part`

This function works for both R15 and R6 rigs, for example:

```lua
-- For R15
print(humanoid:GetLimb(character.LeftUpperLeg)) -- Enum.Limb.LeftLeg
print(humanoid:GetLimb(character.LeftLowerLeg)) -- Enum.Limb.LeftLeg
print(humanoid:GetLimb(character.LeftFoot)) -- Enum.Limb.LeftLeg

-- For R6
print(humanoid:GetLimb(character:FindFirstChild("Left Leg"))) -- Enum.Limb.LeftLeg
```


GetLimb will throw an error if the `Part's` parent is not set to the `Humanoid's` parent.

## Code Samples

### Humanoid:GetLimb

Put this in a LocalScript. The output will vary based on if the humanoid is R6 or R15.
```lua

local character = game.Players.LocalPlayer.Character
local humanoid = character.Humanoid
for _, child in pairs(character:GetChildren()) do
	local limb = humanoid:GetLimb(child)
	if limb ~= Enum.Limb.Unknown then
		print(child.Name .. " is part of limb " .. limb.Name)
	end
end

```

@param part The `Part` for which the `Enum/Limb` enum is to be retrieved.
@returns The `Enum/Limb` the part corresponds with. */
	GetLimb(part: BasePart): Enum.Limb;
	/** This function returns an array of all `AnimationTracks` that are currently being played on the `Humanoid`.

A typical use for this function is stopping currently playing tracks using `Stop`.

Note this function will not return `AnimationTracks` that have loaded but are not playing. If the developer wishes to track these they will need to index them manually. See below for one example of how this could be achieved:

```lua
local animationTracks = {}
local track = humanoid:LoadTrack(animation)
table.insert(animationTracks, track)
```

## Code Samples

### Stop Playing Animations

The code below gets a list of the `AnimationTracks` current being played for the `localplayer` using the `GetPlayingAnimationTracks` function. Then, the code iterates through the list and stops all of the tracks using the `Stop` function.
```lua
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer

if not localPlayer.Character then
	localPlayer.CharacterAdded:Wait()
end

local humanoid = localPlayer.Character:WaitForChild("Humanoid")

-- Get playing animations
local AnimationTracks = humanoid:GetPlayingAnimationTracks()

-- Stop all playing animations
for i, track in pairs (AnimationTracks) do
	track:Stop()
end

```

@returns An array of currently playing `AnimationTrack|AnimationTracks` */
	GetPlayingAnimationTracks(): Array<AnimationTrack>;
	/** This function returns the `Humanoid's` current `HumanoidStateType`.

The humanoid state describes the activity the `Humanoid` is currently doing, such as jumping or freefalling.

## See also
 - To change the `Humanoid's` state use `ChangeState`
 - To enable or disable a particular state use `SetStateEnabled`
 - For more information on the different states available, see `HumanoidStateType`

## Code Samples

### 

This code, when placed inside a `LocalScript` in `StarterPlayer.StarterCharacterScripts` will allow the player's characters to perform a double jump.
```lua
local UserInputService = game:GetService("UserInputService")
local character = script.Parent

local humanoid = character:WaitForChild("Humanoid")

local doubleJumpEnabled = false 

humanoid.StateChanged:Connect(function(oldState, newState)
	if newState == Enum.HumanoidStateType.Jumping then
		if not doubleJumpEnabled then 
			wait(.2)
			if humanoid:GetState() == Enum.HumanoidStateType.Freefall then
				doubleJumpEnabled = true 
			end
		end
	elseif newState == Enum.HumanoidStateType.Landed then	
		doubleJumpEnabled = false
	end
end)

UserInputService.InputBegan:Connect(function(inputObject)
	if inputObject.KeyCode == Enum.KeyCode.Space then
		if doubleJumpEnabled then
			if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then
				humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				spawn(function()
					doubleJumpEnabled = false 
				end)
			end
		end		
	end
end)
```

@returns The current `Enum/HumanoidStateType` of the `Humanoid` */
	GetState(): Enum.HumanoidStateType;
	/** The GetStateEnabled function returns whether a `HumanoidStateType` is enabled for the `Humanoid`.

The humanoid state describes the activity the humanoid is currently doing. 

When a particular `HumanoidStateType` is disabled, the humanoid can never enter that state. This is true regardless if the attempt to change state is made using `ChangeState` or Roblox internal humanoid code.

## See also
 - For an event that fires when a humanoid state is enabled or disabled see `StateEnabledChanged`
 - To enable or disable a `Humanoid` state use `SetStateEnabled`

## Code Samples

### Setting and Getting Humanoid States

The code below sets the value of the `humanoid jumping state` to *false* using `SetStateEnabled` and then retrieves and prints the value of this state (*false*) using `GetStateEnabled`.
```lua
local JUMPING = Enum.HumanoidStateType.Jumping

-- Set state
humanoid:SetStateEnabled(JUMPING, false)

-- Get state
print(humanoid:GetStateEnabled(JUMPING)) -- false
```

@param state The given `Enum/HumanoidStateType`
@returns Whether the given `Enum/HumanoidStateType` is enabled */
	GetStateEnabled(state: CastsToEnum<Enum.HumanoidStateType>): boolean;
	/** This function loads an `Animation` onto a `Humanoid`, returning an `AnimationTrack` that can be used for playback.

## How to load an Animation

The following code can be used to load an `Animation` onto a `Humanoid`.
```lua
local animationTrack = humanoid:LoadAnimation(animation)
animationTrack:Play()
```


## Should I load an Animation on the client or server?

If the `Humanoid` is controlled by a particular client, as is the case with `Player` `Characters` then `Animations` should be loaded and played from that client.

If the `Humanoid` belongs to a NPC (Non Player Character) which the server has [network ownership][1] of then the `Animations` should be loaded and played from the server.

Although generally it is not advisable to do so, these rules can be bypassed using the `Animator` object.

  [1]: http://robloxdev.com/articles/Network-Ownership

## Code Samples

### Humanoid:LoadAnimation

The following would cause the Humanoid to act out the loaded animation.
```lua

example=Humanoid:LoadAnimation(script.Parent.AnAnimation)
example:Play()

```

@param animation The `Animation` to load
@returns The `AnimationTrack` created */
	LoadAnimation(animation: Animation): AnimationTrack;
	/** This function causes the `Humanoid` to walk in the given direction.

When used on a NPC (Non Player Character) this function will cause the `Humanoid` to move until it is called again.
This function can be called on the client and the server, but the *relativeToCamera* paramater will not work correctly on the server as it has no `Camera`.

For `Player` `Characters` however this function needs calling every frame as the default control scripts overwrite it. This should be run from a `LocalScript` on the client. See below for an example:

```lua
RunService:BindToRenderStep("move",
	-- run after the character
	Enum.RenderPriority.Character.Value + 1,
	function()
		if localPlayer.Character then
			-- can save the below by using localPlayer:Move() instead
			local humanoid = localPlayer.Character:FindFirstChild("Humanoid")
			if humanoid then
				humanoid:Move(Vector3.new(0, 0, -1), true)
			end
		end
	end
)
```


## See also

 - To make a`Humanoid` walk to a point, use the `MoveTo` function
 - For `Players` the `Player:Move` function exists that calls this function
@param moveDirection The direction to walk in
@param relativeToCamera *True* if the *direction* parameter should be taken as relative to the `Workspace/CurrentCamera` */
	Move(moveDirection: Vector3, relativeToCamera?: boolean): void;
	/** This function causes the `Humanoid` to attempt to walk to the given location by setting the `WalkToPoint` and `WalkToPart` properties.

The *location* and *part* parameters correspond with what `WalkToPoint` and `WalkToPart` will be set to. 

If the *part* parameter is specified, the `Humanoid` will still attempt to walk to the point. However, if the part moves then the point the `Humanoid` is walking to will move to be at the same position relative to the part. For a visual demonstration of this, see below.

![A visualization of how WalkToPart changes the behavior of WalkToPoint](https://developer.roblox.com/assets/bltc76671f1665d7da0/WalkToPart.gif)

The *reach goal* state of a humanoid will timeout after 8 seconds if it doesn't reach its goal. This is done so that NPCs won't get stuck waiting for `MoveToFinished` to fire. If you don't want this to happen, you should repeatedly call MoveTo so that the timeout will keep resetting.

## Code Samples

### Humanoid MoveTo Without Time out

This code sample includes a function that avoids the 8 second timeout on `MoveTo` by calling `MoveTo` again before the timeout elapses. It also includes an optional *andThen* parameter where developers can pass a function to be called when the humanoid reaches its destination.
```lua
local function moveTo(humanoid, targetPoint, andThen)
	local targetReached = false

	-- listen for the humanoid reaching its target
	local connection
	connection = humanoid.MoveToFinished:Connect(function(reached)
		targetReached = true
		connection:Disconnect()
		connection = nil
		if andThen then
			andThen()
		end
	end)

	-- start walking
	humanoid:MoveTo(targetPoint)

	-- execute on a new thread so as to not yield function
	spawn(function()
		while not targetReached do
			-- does the humanoid still exist?
			if not (humanoid and humanoid.Parent) then
				break
			end
			-- has the target changed?
			if humanoid.WalkToPoint ~= targetPoint then
				break
			end
			-- refresh the timeout
			humanoid:MoveTo(targetPoint)
			wait(6)
		end
		
		-- disconnect the connection if it is still connected
		if connection then
			connection:Disconnect()
			connection = nil
		end
	end)
end
```

@param location The position to set `Humanoid/WalkToPoint` to
@param part The `BasePart` to set `Humanoid/WalkToPart` to */
	MoveTo(location: Vector3, part?: BasePart): void;
	/** This function removes all `Accessories` worn by the `Humanoid`.

## How does RemoveAccessories work?
When this function is called, all `Accessories` sharing an `Parent` with the `Humanoid` will be removed. For `Player`, `Characters` this will remove all hats being worn as hats take the form of `Accessories` in the data model.

`Destroy` is called on the removed `Accessories`, meaning their `Parents` are set to nil and locked.

The `Humanoid` does not need to belong to a `Player` `Character` for this to work. This function will remove `Accessories` parented to the `Humanoid's` `Parent` regardless of where the `Humanoid` is.

## See also
 - To attach an `Accessory` use the `AddAccessory` function
 - To get all `Accessories` belonging to a `Humanoid` use the `GetAccessories` function

## Code Samples

### Remove and Return Hats

This code sample will remove all the hats from a `Character` once the character has fully loaded. After five seconds, if the character still exists and is alive, it will return them.
```lua
local Players = game:GetService("Players")

local function playerAdded(player)
	player.CharacterAppearanceLoaded:Connect(function(character)
		local humanoid = character:WaitForChild("Humanoid")

		-- save hats for later
		local accessories = {}
		for _, accessory in pairs(humanoid:GetAccessories()) do 
			table.insert(accessories, accessory:Clone())
		end

		-- remove hats
		humanoid:RemoveAccessories()

		wait(5)

		-- make sure the player still exists, and has the same character
		if player and player.Character and player.Character == character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
				-- give back the hats
				for _, accessory in pairs(accessories) do 
					humanoid:AddAccessory(accessory)
				end
			end
		end

		accessories = nil
	end)
end

-- get existing players
for _, player in pairs(Players:GetPlayers()) do 
	playerAdded(player)
end
-- listen for new players
Players.PlayerAdded:Connect(playerAdded)



```
 */
	RemoveAccessories(): void;
	/** ReplaceBodyPartR15 dynamically replaces a R15/Rthro limb part in a Humanoid with a different part. The part is automatically scaled as normal. In the image below, a R15 avatar has had his right hand replaced with a slightly larger version (also pictured).

![An image of a Roblox avatar with a large right hand, replaced using ReplaceBodyPartR15. How handy.](https://developer.roblox.com/assets/5cc9fa35358b42d76596ba15/Humanoid.ReplaceBodyPartR15.png)

This function is useful for modifying characters during gameplay or building characters from a base rig. The related function `GetBodyPartR15` can come in handy when using this function. */
	ReplaceBodyPartR15(bodyPart: Enum.BodyPartR15, part: BasePart): boolean;
	/** This function sets whether a given `HumanoidStateType` is enabled for the `Humanoid`.

The humanoid state describes the activity the `Humanoid` is currently doing. 

When a particular `HumanoidStateType` is disabled, the `Humanoid` can never enter that state. This is true regardless if the attempt to change state is made using `ChangeState` or Roblox internal `Humanoid` code.

## Code Samples

### Jump Cooldown

The following sample will require a one second cooldown after a `Humanoid` has landed before it is able to jump again.

To try this sample, place it inside a `LocalScript` in `StarterPlayer.StarterCharacterScripts`.
```lua
local character = script.Parent

local JUMP_DEBOUNCE = 1

local humanoid = character:WaitForChild("Humanoid")

local isJumping = false
humanoid.StateChanged:Connect(function(oldState, newState)
	if newState == Enum.HumanoidStateType.Jumping then
		if not isJumping then
			isJumping = true
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
		end
	elseif newState == Enum.HumanoidStateType.Landed then
		if isJumping then
			isJumping = false
			wait(JUMP_DEBOUNCE)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
		end
	end
end)
```

@param state The `Enum/HumanoidStateType` to be enabled or disabled
@param enabled *True* if this state is to be enabled, *false* if it is to be disabled */
	SetStateEnabled(state: CastsToEnum<Enum.HumanoidStateType>, enabled: boolean): void;
	/** Subtracts the damage from the health of the targeted humanoid unless the character has a `ForceField`.

## Code Samples

### Humanoid:TakeDamage

This code, put in a `LocalScript`, would make the local player take 99 damage *only* if a ForceField wasn't present.
```lua
game.Players.LocalPlayer.Character.Humanoid:TakeDamage(99)
```
 */
	TakeDamage(amount: number): void;
	/** This function unequips any `Tool` currently equipped by the `Humanoid`

The unequipped `Tool` will be parented to the `Backpack` of the `Player` associated with the `Humanoid`.

If no `Tool` is equipped, this function will do nothing.

Although `Tools` can be equipped by NPCs (Non Player Characters), this function only works on `Humanoids` with a corresponding `Player`. This is because a `Backpack` object is required to parent the unequipped `Tool` to.

## See also
 - To instead equip a `Tool`, use `EquipTool`

## Code Samples

### Unequip Tool Keybind

The following sample will bind the U key to unequip any `Tools` the `Player` currently has equipped.

To use this sample, place it inside a `LocalScript` within `StarterPlayer.StarterPlayerScripts`.
```lua
local Players = game:GetService("Players")
local ContextActionService = game:GetService("ContextActionService")

local localPlayer = Players.LocalPlayer

ContextActionService:BindAction("unequipTools", 
	function(_, userInputState)
		if userInputState == Enum.UserInputState.Begin then 
			if localPlayer.Character then 
				local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
				if humanoid then 
					humanoid:UnequipTools()
				end
			end
		end
	end,
	false,
	Enum.KeyCode.U
)
```
 */
	UnequipTools(): void;
	/** This yield function makes the `character's` look match that of the passed in `HumanoidDescription`. A copy of the passed look will then be cached in the `Humanoid` as the current HumanoidDescription for the Humanoid.

It allows you to quickly set and store a character's appearance using a stored look without having to set each property every time.

## See also
 - `GetAppliedDescription`, returns the HumanoidDescription currently applied to the Humanoid
 - `GetHumanoidDescriptionFromUserId`, gives back a HumanoidDescription which describes the Avatar for the passed in user
 - `GetHumanoidDescriptionFromOutfitId`, gives back a HumanoidDescription whose parameters are initialized to match that of the passed in server-side outfit asset
 - `LoadCharacterWithHumanoidDescription`, spawns a player with the look from the HumanoidDescription Instance passed in
@param humanoidDescription The `HumanoidDescription` Instance which you want to set the character to match
@returns No return */
	ApplyDescription(humanoidDescription: HumanoidDescription): void;
	/** The AnimationPlayed event fires when an `AnimationTrack` begins playing on the `Humanoid`.

A common use for this function is to connect the `KeyframeReached` event for the playing AnimationTrack, so additional effects can be added to the animation (for example `Sounds` and `ParticleEmitters`).

This event can be used for any `Humanoid` regardless if it belongs to the local player's client or not.

## See also
 - For the `AnimationController` equivalent of this event, please see `AnimationPlayed`

## Code Samples

### Pausing An Animation When a KeyFrame is Reached

The example below pauses any AnimationTrack playing on the humanoid when a keyframe named 'PausePlayback' is reached.
```lua
humanoid.AnimationPlayed:Connect(function(animationTrack)
	-- make sure the track exists
	if not animationTrack then
		return
	end
	local connection
	-- connect the KeyframeReached event
	connection = animationTrack.KeyframeReached:Connect(function(keyframeName)
		if keyframeName == "PausePlayback" then
			-- adjust speed to 0, pausing the animation
			animationTrack:AdjustSpeed(0)
		end
	end)
	-- disconnect the KeyframeReached event when the animation finishes
	animationTrack.Stopped:Wait()
	connection:Disconnect()
end)
```
 */
	readonly AnimationPlayed: RBXScriptSignal<(animationTrack: AnimationTrack) => void>;
	/** Fires when the speed at which a `Humanoid` is climbing changes.

`Humanoids` can climb up ladders made out of `Parts` or `TrussParts`.

`Humanoids` climb at 70% of their `WalkSpeed`. 

This event will not always fire with a speed of 0 when the `Humanoid` stops climbing.

## See also
 - For swimming and running see the `Swimming` and `Running` events
 - You can also detect when a `Humanoid` is climbing using the `StateChanged` event
 - You can disable climbing using the `SetStateEnabled` function

## Code Samples

### Humanoid.Climbing


```lua

local function onCharacterClimbing(character, speed)
    print(character.Name, "is climbing at a speed of", speed, "studs / second.")
end
 
local function onCharacterAdded(character)
    character.Humanoid.Climbing:Connect(function(speed) onCharacterClimbing(character, speed) end)
end
 
local function onPlayerAdded(player)
    player.CharacterAdded:Connect(onCharacterAdded)
end

game.Players.PlayerAdded:Connect(onPlayerAdded)

```
 */
	readonly Climbing: RBXScriptSignal<(speed: number) => void>;
	/** This event fires when the `Humanoid` dies, usually when `Health` reaches 0. This could be caused either by disconnecting their head from their `Torso`, or directly setting the health property.

This event only fires if the `Humanoid` is a descendant of the `Workspace`. If the *Dead* `HumanoidStateType` is disabled it will not fire.

## Code Samples

### Humanoid.Died

The code below would print the player's name, followed by "has died!", whenever a player dies. For example, if the player was named "Shedletsky", "Shedletsky has died!" would be printed to the output when they died.
```lua

game:GetService('Players').PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		character:WaitForChild("Humanoid").Died:Connect(function()
			print(player.Name .. " has died!")
		end)
	end)
end)

```
 */
	readonly Died: RBXScriptSignal<() => void>;
	/** The FallingDown event fires when the `Humanoid` enters and leaves the *FallingDown* `HumanoidStateType`. It indicates whether the humanoid is falling.

Unless the `Humanoid` state is otherwise changed, this event will fire with an *active* value of *false* as the `GettingUp` event fires with an *active* value of *true*.

## Code Samples

### Humanoid action events

This code, when run from a `LocalScript` parented to a `Character` will listen to the `Humanoid’s` action events and print when they are fired.

This code sample is intended to demonstrate when each event does, and does not, fire.
```lua
local character = script.Parent 

local humanoid = character:WaitForChild("Humanoid")

humanoid.Climbing:Connect(function(speed)
	print("Climbing speed: ", speed)
end)

humanoid.FallingDown:Connect(function(isActive)
	print("Falling down: ", isActive)
end)

humanoid.GettingUp:Connect(function(isActive)
	print("Getting up: ", isActive)
end)

humanoid.Jumping:Connect(function(isActive)
	print("Jumping: ", isActive)
end)

humanoid.PlatformStanding:Connect(function(isActive)
	print("PlatformStanding: ", isActive)
end)

humanoid.Ragdoll:Connect(function(isActive)
	print("Ragdoll: ", isActive)
end)

humanoid.Running:Connect(function(speed)
	print("Running speed: ", speed)
end)

humanoid.Strafing:Connect(function(isActive)
	print("Strafing: ", isActive)
end)

humanoid.Swimming:Connect(function(speed)
	print("Swimming speed: ", speed)
end)
```
 */
	readonly FallingDown: RBXScriptSignal<(active: boolean) => void>;
	/** This event fires when the `Humanoid` enters or leaves the *Freefall* `HumanoidStateType`.

The *active* parameter represents whether the `Humanoid` is entering or leaving the *Freefall* state.

Although the *Freefall* state generally ends when the `Humanoid` reaches the ground, this event may fire with *active* equal to *false* if the state is changed whilst the `Humanoid` is falling. For this reason, developers should use `StateChanged` and listen for the *Landed* state to work out when a `Humanoid` has landed.

## Code Samples

### Humanoid action events

This code, when run from a `LocalScript` parented to a `Character` will listen to the `Humanoid’s` action events and print when they are fired.

This code sample is intended to demonstrate when each event does, and does not, fire.
```lua
local character = script.Parent 

local humanoid = character:WaitForChild("Humanoid")

humanoid.Climbing:Connect(function(speed)
	print("Climbing speed: ", speed)
end)

humanoid.FallingDown:Connect(function(isActive)
	print("Falling down: ", isActive)
end)

humanoid.GettingUp:Connect(function(isActive)
	print("Getting up: ", isActive)
end)

humanoid.Jumping:Connect(function(isActive)
	print("Jumping: ", isActive)
end)

humanoid.PlatformStanding:Connect(function(isActive)
	print("PlatformStanding: ", isActive)
end)

humanoid.Ragdoll:Connect(function(isActive)
	print("Ragdoll: ", isActive)
end)

humanoid.Running:Connect(function(speed)
	print("Running speed: ", speed)
end)

humanoid.Strafing:Connect(function(isActive)
	print("Strafing: ", isActive)
end)

humanoid.Swimming:Connect(function(speed)
	print("Swimming speed: ", speed)
end)
```
 */
	readonly FreeFalling: RBXScriptSignal<(active: boolean) => void>;
	/** This event fires when the `Humanoid` enters or leaves the *GettingUp* `HumanoidStateType`.

When a `Humanoid` attempts to get back up, this event will first fire with an *active* parameter of *true* before shortly after firing again with an *active* parameter of *false*.

## See also
 - To force a `Humanoid` to fall over, use the `ChangeState` function to change the `Humanoid's` state to *FallingDown*

## Code Samples

### Humanoid action events

This code, when run from a `LocalScript` parented to a `Character` will listen to the `Humanoid’s` action events and print when they are fired.

This code sample is intended to demonstrate when each event does, and does not, fire.
```lua
local character = script.Parent 

local humanoid = character:WaitForChild("Humanoid")

humanoid.Climbing:Connect(function(speed)
	print("Climbing speed: ", speed)
end)

humanoid.FallingDown:Connect(function(isActive)
	print("Falling down: ", isActive)
end)

humanoid.GettingUp:Connect(function(isActive)
	print("Getting up: ", isActive)
end)

humanoid.Jumping:Connect(function(isActive)
	print("Jumping: ", isActive)
end)

humanoid.PlatformStanding:Connect(function(isActive)
	print("PlatformStanding: ", isActive)
end)

humanoid.Ragdoll:Connect(function(isActive)
	print("Ragdoll: ", isActive)
end)

humanoid.Running:Connect(function(speed)
	print("Running speed: ", speed)
end)

humanoid.Strafing:Connect(function(isActive)
	print("Strafing: ", isActive)
end)

humanoid.Swimming:Connect(function(speed)
	print("Swimming speed: ", speed)
end)
```
 */
	readonly GettingUp: RBXScriptSignal<(active: boolean) => void>;
	/** Fires when the `Health` changes to a value equal or below the `MaxHealth` value.

This event can be used to show custom heatlh bars.

When `Health` reaches zero, the `Humanoid` will die and the `Died` event will fire. This event will fire with a value of zero.

## Code Samples

### Health Bar

This code sample allows you to create a simple color-changing health bar using two nested Frames. Paste this into a LocalScript on the inner frame.
```lua
local player = game.Players.LocalPlayer

-- Paste script into a LocalScript that is 
-- parented to a Frame within a Frame
local frame = script.Parent
local container = frame.Parent
container.BackgroundColor3 = Color3.new(0, 0, 0) -- black

-- This function is called when the humanoid's health changes
local function onHealthChanged()
	local human = player.Character.Humanoid
	local percent = human.Health / human.MaxHealth
	-- Change the size of the inner bar
	frame.Size = UDim2.new(percent, 0, 1, 0)
	-- Change the color of the health bar
	if percent < .1 then
		frame.BackgroundColor3 = Color3.new(1, 0, 0) -- black
	elseif percent < .4 then
		frame.BackgroundColor3 = Color3.new(1, 1, 0) -- yellow
	else
		frame.BackgroundColor3 = Color3.new(0, 1, 0) -- green
	end
end

-- This function runs is called the player spawns in
local function onCharacterAdded(character)
	local human = character:WaitForChild("Humanoid")
	-- Pattern: update once now, then any time the health changes
	human.HealthChanged:Connect(onHealthChanged)
	onHealthChanged()
end

-- Connect our spawn listener; call it if already spawned
player.CharacterAdded:Connect(onCharacterAdded)
if player.Character then
	onCharacterAdded(player.Character)
end

```

### Humanoid.HealthChanged

The following example determines the change in health, printing it to the output. It will only work in a LocalScript.
```lua

local humanoid = game.Players.LocalPlayer.Character.Humanoid
local currentHealth = humanoid.Health
humanoid.HealthChanged:Connect(function(health)
	local change = math.abs(currentHealth - health)
	print("The humanoid's health "..(currentHealth > health and "decreased by " or "increased by ")..change..".")
	currentHealth = health
end)

```
 */
	readonly HealthChanged: RBXScriptSignal<(health: number) => void>;
	/** This event fires when the `Humanoid` enters and leaves the *Jumping* `HumanoidStateType`.

When a `Humanoid` jumps this will fire with a *active* parameter of *true* before shortly afterwards firing again with an active parameter of *false*. This does not correspond with when a `Humanoid` has landed. For that, developers should listen for the *Landed* `HumanoidStateType` using `StateChanged`.

The *active* parameter of this event also corresponds with the `Humanoid's` `Jump` property.

You can disable jumping using the `SetStateEnabled` function.

## Code Samples

### Humanoid action events

This code, when run from a `LocalScript` parented to a `Character` will listen to the `Humanoid’s` action events and print when they are fired.

This code sample is intended to demonstrate when each event does, and does not, fire.
```lua
local character = script.Parent 

local humanoid = character:WaitForChild("Humanoid")

humanoid.Climbing:Connect(function(speed)
	print("Climbing speed: ", speed)
end)

humanoid.FallingDown:Connect(function(isActive)
	print("Falling down: ", isActive)
end)

humanoid.GettingUp:Connect(function(isActive)
	print("Getting up: ", isActive)
end)

humanoid.Jumping:Connect(function(isActive)
	print("Jumping: ", isActive)
end)

humanoid.PlatformStanding:Connect(function(isActive)
	print("PlatformStanding: ", isActive)
end)

humanoid.Ragdoll:Connect(function(isActive)
	print("Ragdoll: ", isActive)
end)

humanoid.Running:Connect(function(speed)
	print("Running speed: ", speed)
end)

humanoid.Strafing:Connect(function(isActive)
	print("Strafing: ", isActive)
end)

humanoid.Swimming:Connect(function(speed)
	print("Swimming speed: ", speed)
end)
```
 */
	readonly Jumping: RBXScriptSignal<(active: boolean) => void>;
	/** This event fires when the `Humanoid` finishes walking to a goal declared by the `WalkToPoint` and `WalkToPart` properties.

The `WalkToPoint` and `WalkToPart` properties can be set individually, or using the `MoveTo` function.

If the `Humanoid` reaches its goal within 8 seconds, this event will return with *reached* as true. If the goal is not reached within 8 seconds the `Humanoid` will stop walking and *reached* will be false. This timeout can be reset be calling `MoveTo` again within the timeout period.

## Code Samples

### Humanoid MoveTo Without Time out

This code sample includes a function that avoids the 8 second timeout on `MoveTo` by calling `MoveTo` again before the timeout elapses. It also includes an optional *andThen* parameter where developers can pass a function to be called when the humanoid reaches its destination.
```lua
local function moveTo(humanoid, targetPoint, andThen)
	local targetReached = false

	-- listen for the humanoid reaching its target
	local connection
	connection = humanoid.MoveToFinished:Connect(function(reached)
		targetReached = true
		connection:Disconnect()
		connection = nil
		if andThen then
			andThen()
		end
	end)

	-- start walking
	humanoid:MoveTo(targetPoint)

	-- execute on a new thread so as to not yield function
	spawn(function()
		while not targetReached do
			-- does the humanoid still exist?
			if not (humanoid and humanoid.Parent) then
				break
			end
			-- has the target changed?
			if humanoid.WalkToPoint ~= targetPoint then
				break
			end
			-- refresh the timeout
			humanoid:MoveTo(targetPoint)
			wait(6)
		end
		
		-- disconnect the connection if it is still connected
		if connection then
			connection:Disconnect()
			connection = nil
		end
	end)
end
```
 */
	readonly MoveToFinished: RBXScriptSignal<(reached: boolean) => void>;
	/** This event fires when the `Humanoid` enters or leaves the *PlatformStanding* `HumanoidStateType`.

Whilst the `Humanoid` is in the *PlatformStanding* state, the `PlatformStand` property will be *true*.

Whilst `PlatformStand` is set to *true*, the `Humanoid` will be unable to move. For more information please see the page for `PlatformStand`.

The PlatformStand `HumanoidStateType` was associated with the now disabled `Platform` part. Despite this, it can still be used by developers.

## Code Samples

### Humanoid.PlatformStanding

The below example, when used in a LocalScript, would print whether or not the player's character's PlatformProperty changed.
```lua

game.Players.LocalPlayer.Character.Humanoid.PlatformStanding:Connect(function(isPlatformStanding)
    if isPlatformStanding then
       print "The player is PlatformStanding"
    else
       print "The player is not PlatformStanding"
    end
end)

```
 */
	readonly PlatformStanding: RBXScriptSignal<(active: boolean) => void>;
	/** This event fires when the `Humanoid` enters or leaves the *Ragdoll* `HumanoidStateType`.

When the `Humanoid` enters the *Ragdoll* state this event will fire with an *active* parameter of *true*. The event will fire again when the `Humanoid` leaves the *Ragdoll* state, generally for the *GettingUp* `HumanoidStateType'.

You can disable tripping by disabling the *Ragdoll* and *FallingDown* states using `Humanoid/SetStateEnabled`.

## See also
 - `FallingDown` for the `Humanoid` event connected with the *FallingDown* state, which behaves similarly to *Ragdoll*

## Code Samples

### Humanoid action events

This code, when run from a `LocalScript` parented to a `Character` will listen to the `Humanoid’s` action events and print when they are fired.

This code sample is intended to demonstrate when each event does, and does not, fire.
```lua
local character = script.Parent 

local humanoid = character:WaitForChild("Humanoid")

humanoid.Climbing:Connect(function(speed)
	print("Climbing speed: ", speed)
end)

humanoid.FallingDown:Connect(function(isActive)
	print("Falling down: ", isActive)
end)

humanoid.GettingUp:Connect(function(isActive)
	print("Getting up: ", isActive)
end)

humanoid.Jumping:Connect(function(isActive)
	print("Jumping: ", isActive)
end)

humanoid.PlatformStanding:Connect(function(isActive)
	print("PlatformStanding: ", isActive)
end)

humanoid.Ragdoll:Connect(function(isActive)
	print("Ragdoll: ", isActive)
end)

humanoid.Running:Connect(function(speed)
	print("Running speed: ", speed)
end)

humanoid.Strafing:Connect(function(isActive)
	print("Strafing: ", isActive)
end)

humanoid.Swimming:Connect(function(speed)
	print("Swimming speed: ", speed)
end)
```
 */
	readonly Ragdoll: RBXScriptSignal<(active: boolean) => void>;
	/** This event fires when the speed at which a `Humanoid` is running changes.

Whilst running `Humanoids` cover, on average,  their `WalkSpeed` in studs per second.

When the `Humanoid` stops running this event will fire with a speed of 0.

## See also
 - For swimming and climbing see the `Swimming` and `Climbing` events
 - You can also detect when a `Humanoid` is running using the `StateChanged` event

## Code Samples

### Humanoid.Running

The below assumes that there's a player in Workspace named "Player" who has a Humanoid. It will print whether or not their character is running.
```lua

game.Workspace.Player.Humanoid.Running:Connect(function(speed)
    if speed > 0 then
        print("Player is running")
    else
        print("Player has stopped")
    end
end)

```

### Humanoid action events

This code, when run from a `LocalScript` parented to a `Character` will listen to the `Humanoid’s` action events and print when they are fired.

This code sample is intended to demonstrate when each event does, and does not, fire.
```lua
local character = script.Parent 

local humanoid = character:WaitForChild("Humanoid")

humanoid.Climbing:Connect(function(speed)
	print("Climbing speed: ", speed)
end)

humanoid.FallingDown:Connect(function(isActive)
	print("Falling down: ", isActive)
end)

humanoid.GettingUp:Connect(function(isActive)
	print("Getting up: ", isActive)
end)

humanoid.Jumping:Connect(function(isActive)
	print("Jumping: ", isActive)
end)

humanoid.PlatformStanding:Connect(function(isActive)
	print("PlatformStanding: ", isActive)
end)

humanoid.Ragdoll:Connect(function(isActive)
	print("Ragdoll: ", isActive)
end)

humanoid.Running:Connect(function(speed)
	print("Running speed: ", speed)
end)

humanoid.Strafing:Connect(function(isActive)
	print("Strafing: ", isActive)
end)

humanoid.Swimming:Connect(function(speed)
	print("Swimming speed: ", speed)
end)
```
 */
	readonly Running: RBXScriptSignal<(speed: number) => void>;
	/** This event fires when a `Humanoid` either sits in a `Seat` or `VehicleSeat` or gets up.

When a `Character` comes into contact with a seat they are attached to the seat and a sitting animation plays. For more information on this, please see the `Seat` page.

The *active* parameter will be true if a player has sat down, and false if they have gotten up. The *currentSeatPart* parameter will be the seat part the humanoid is sitting in if they are sat down, or *nil* if they have gotten up.

## See also
 - You can check if a humanoid is currently sitting using the `Sit` property
 - You can also check the current humanoid seat part using the `SeatPart` property

## Code Samples

### Finding a Player's Seat

The code below fires when the `LocalPlayer's` `Character` sits down or stands up. 

It should be placed inside a `LocalScript` parented to `StarterPlayer.StarterPlayerScripts`.
```lua
local character = script.Parent
local humanoid = character:WaitForChild("Humanoid")

humanoid.Seated:Connect(function(isSeated, seat)
	if isSeated then
		if seat then
			print ("The player is now sitting in the seat named "..seat.Name.."!")
		end
	else
		print("The player is no longer sitting!")
	end
end)
```
 */
	readonly Seated: RBXScriptSignal<(active: boolean, currentSeatPart: Seat | VehicleSeat) => void>;
	/** This event fires when the state of the `Humanoid` is changed.

The humanoid state describes the activity the `Humanoid` is currently doing. It takes the form of a `HumanoidStateType` value.

## See also:

 - To get and set the state use `GetState` and `ChangeState`
 - Individual states can be disabled using `SetStateEnabled`
 - As there is no idle humanoid state, you should instead use the `Running` event or listen to the `RootPart's` `Velocity` to work out when the `Humanoid` is standing still

## Code Samples

### Jump Cooldown

The following sample will require a one second cooldown after a `Humanoid` has landed before it is able to jump again.

To try this sample, place it inside a `LocalScript` in `StarterPlayer.StarterCharacterScripts`.
```lua
local character = script.Parent

local JUMP_DEBOUNCE = 1

local humanoid = character:WaitForChild("Humanoid")

local isJumping = false
humanoid.StateChanged:Connect(function(oldState, newState)
	if newState == Enum.HumanoidStateType.Jumping then
		if not isJumping then
			isJumping = true
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
		end
	elseif newState == Enum.HumanoidStateType.Landed then
		if isJumping then
			isJumping = false
			wait(JUMP_DEBOUNCE)
			humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
		end
	end
end)
```

### Jumping Particles

Emits particles from the `Player's` `Character` when they jump.

To try this code sample, place it inside a `LocalScript` parented to `StarterPlayer.StarterCharacterScripts`.
```lua
local character = script.Parent

local primaryPart = character.PrimaryPart

-- create particles
local particles = Instance.new("ParticleEmitter")
particles.Size = NumberSequence.new(1)
particles.Transparency = NumberSequence.new(0, 1)
particles.Acceleration = Vector3.new(0, -10, 0)
particles.Lifetime = NumberRange.new(1)
particles.Rate = 20
particles.EmissionDirection = Enum.NormalId.Back 
particles.Enabled = false
particles.Parent = primaryPart

local humanoid = character:WaitForChild("Humanoid")

local isJumping = false

-- listen to humanoid state
humanoid.StateChanged:Connect(function(oldState, newState)
	if newState == Enum.HumanoidStateType.Jumping then
		if not isJumping then
			isJumping = true
			particles.Enabled = true
		end
	elseif newState == Enum.HumanoidStateType.Landed then
		if isJumping then
			isJumping = false
			particles.Enabled = false
		end
	end
end)
```
 */
	readonly StateChanged: RBXScriptSignal<(oldValue: Enum.HumanoidStateType, newValue: Enum.HumanoidStateType) => void>;
	/** The StateEnableChanged event fires when `SetStateEnabled` is called on the `Humanoid`.

Parameters include the `HumanoidStateType` in question along with a bool indicating if this state is now enabled.

## See also
 - To find if a state is currently enabled, use `GetStateEnabled`
 - To listen to `Humanoid` state changes use `StateChanged`

## Code Samples

### Humanoid State Change Detector

When a humanoid state changes for the `LocalPlayer`, the code below prints whether the state has been enabled or disabled.

This code should work as expected when placed in a `LocalScript`.
```lua
local player = game.Players.LocalPlayer
local character = player.CharacterAdded:wait()
local humanoid = character.Humanoid

humanoid.StateEnabledChanged:Connect(function(state, enabled)
	if enabled then
		print(state.Name.." has been enabled")
	else
		print(state.Name.." has been disabled")
	end
end)
```
 */
	readonly StateEnabledChanged: RBXScriptSignal<(state: Enum.HumanoidStateType, isEnabled: boolean) => void>;
	/** This event is fired when the `Humanoid` enters or leaves the *StrafingNoPhysics* `HumanoidStateType`.

When the `Humanoid` enters the *StrafingNoPhysics* state this event will fire with an *active* parameter of *true*. The event will fire again with *active* equal to *false* when the `Humanoid` leaves the *StrafingNoPhysics* state.

This event is associated with the *StrafingNoPhysics* `Humanoid` state and does **not** fire when the `Humanoid` is moving perpendicular to the direction it is facing. This state is currently unused, if it is set using `ChangeState` the state will revert to *RunningNoPhysics*.

## Code Samples

### Humanoid action events

This code, when run from a `LocalScript` parented to a `Character` will listen to the `Humanoid’s` action events and print when they are fired.

This code sample is intended to demonstrate when each event does, and does not, fire.
```lua
local character = script.Parent 

local humanoid = character:WaitForChild("Humanoid")

humanoid.Climbing:Connect(function(speed)
	print("Climbing speed: ", speed)
end)

humanoid.FallingDown:Connect(function(isActive)
	print("Falling down: ", isActive)
end)

humanoid.GettingUp:Connect(function(isActive)
	print("Getting up: ", isActive)
end)

humanoid.Jumping:Connect(function(isActive)
	print("Jumping: ", isActive)
end)

humanoid.PlatformStanding:Connect(function(isActive)
	print("PlatformStanding: ", isActive)
end)

humanoid.Ragdoll:Connect(function(isActive)
	print("Ragdoll: ", isActive)
end)

humanoid.Running:Connect(function(speed)
	print("Running speed: ", speed)
end)

humanoid.Strafing:Connect(function(isActive)
	print("Strafing: ", isActive)
end)

humanoid.Swimming:Connect(function(speed)
	print("Swimming speed: ", speed)
end)
```
 */
	readonly Strafing: RBXScriptSignal<(active: boolean) => void>;
	/** This event fires when the speed at which a `Humanoid` is swimming in `Terrain` water changes.

`Humanoids` swim at 87.5% of their `WalkSpeed`. 

This event will not always fire with a speed of 0 when the `Humanoid` stops swimming.

## See also

 - For running and climbing see the `Running` and `Climbing` events
 - You can also detect when a `Humanoid` is swimming using the `StateChanged` event
 - You can disable swimming using the `SetStateEnabled` function

## Code Samples

### Humanoid action events

This code, when run from a `LocalScript` parented to a `Character` will listen to the `Humanoid’s` action events and print when they are fired.

This code sample is intended to demonstrate when each event does, and does not, fire.
```lua
local character = script.Parent 

local humanoid = character:WaitForChild("Humanoid")

humanoid.Climbing:Connect(function(speed)
	print("Climbing speed: ", speed)
end)

humanoid.FallingDown:Connect(function(isActive)
	print("Falling down: ", isActive)
end)

humanoid.GettingUp:Connect(function(isActive)
	print("Getting up: ", isActive)
end)

humanoid.Jumping:Connect(function(isActive)
	print("Jumping: ", isActive)
end)

humanoid.PlatformStanding:Connect(function(isActive)
	print("PlatformStanding: ", isActive)
end)

humanoid.Ragdoll:Connect(function(isActive)
	print("Ragdoll: ", isActive)
end)

humanoid.Running:Connect(function(speed)
	print("Running speed: ", speed)
end)

humanoid.Strafing:Connect(function(isActive)
	print("Strafing: ", isActive)
end)

humanoid.Swimming:Connect(function(speed)
	print("Swimming speed: ", speed)
end)
```
 */
	readonly Swimming: RBXScriptSignal<(speed: number) => void>;
	/** This event fires when one of the `Humanoid's` limbs come in contact with another `BasePart`.

The `BasePart` the `Humanoid's` limb is touching along with the limb itself is given.

This event will not fire when limbs belonging to the `Humanoid` come into contact with themselves. 

## Alternatives to the Humanoid Touched event

Although the Humanoid.Touched event is useful, developers should consider if there are alternatives that suit their needs better before using it.

 - In most cases it is advised to connect a `Touched` event for `BaseParts` of interest instead. This is because the Humanoid Touched event will constantly fire when the humanoid is moving. For example, in a dodgeball game it would be more practical to connect a touched event for the balls rather than the humanoid
 - For developers trying to work out when the `Humanoid` has landed on the ground, the `StateChanged` event is more suitable. Alternatively, developers can use `FloorMaterial` to see if the `Humanoid` is standing on anything
 

## Notes

 - Connecting to this event will cause a `TouchTransmitter` to be created in every limb
 - The is currently no equivalent of `BasePart.TouchEnded` for `Humanoids`

## Code Samples

### Midas Touch

When placed inside a `Character` model this code will give a player the 'Midas touch'. Everything their character touches will change to gold.

When the `Humanoid` dies, this change is undone and the golden `BaseParts` are returned to their original state.

To test this out, place this code inside a `Script` and place it in  `StarterPlayer.StarterCharacterScripts`.
```lua
local character = script.Parent 

local humanoid = character:WaitForChild("Humanoid")

local partInfo = {}

local debounce = false
local touchedConnection = humanoid.Touched:Connect(function(hit, limb)
	if debounce then
		return
	end

	-- make sure this part is valid 
	if not hit.CanCollide or hit.Transparency ~= 0 then
		return
	end

	-- make sure this part hasn't already been made gold
	if not partInfo[hit] then
		-- save info about this part for later
		partInfo[hit] = {
			BrickColor = hit.BrickColor,
			Material = hit.Material
		}

		-- make this part gold
		hit.BrickColor = BrickColor.new("Gold")
		hit.Material = Enum.Material.Ice

		-- apply debounce
		debounce = true
		wait(0.2)
		debounce = false
	end
end)

humanoid.Died:Connect(function()
	-- disconnect touched connection
	if touchedConnection then
		touchedConnection:Disconnect()
	end

	-- undo all of the gold
	for part, info in pairs(partInfo) do
		if part and part.Parent then
			part.BrickColor = info.BrickColor
			part.Material = info.Material
		end
	end
end)
```
 */
	readonly Touched: RBXScriptSignal<(touchingPart: BasePart, humanoidPart: BasePart) => void>;
}

/** #### Related methods:
 * - Humanoid.ApplyDescription()
 * - Humanoid.GetAppliedDescription()
 * - Player.LoadCharacterWithHumanoidDescription()
 * - Players.GetHumanoidDescriptionFromOutfitId()
 * - Players.GetHumanoidDescriptionFromUserId()
 */
	/** **HumanoidDescription** is an `Instance` which can be placed anywhere in the Explorer hierarchy. It allows you to dynamically change `Humanoid` traits like body parts/colors, body scaling, accessories, clothing, and default animations. For more details and code examples, see the `humanoiddescription HumanoidDescription System`
 article. */
interface HumanoidDescription extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "HumanoidDescription";

	BackAccessory: string;

	BodyTypeScale: number;

	ClimbAnimation: number;

	DepthScale: number;

	Face: number;

	FaceAccessory: string;

	FallAnimation: number;

	FrontAccessory: string;

	GraphicTShirt: number;

	HairAccessory: string;

	HatAccessory: string;

	Head: number;

	HeadColor: Color3;

	HeadScale: number;

	HeightScale: number;

	IdleAnimation: number;

	JumpAnimation: number;

	LeftArm: number;

	LeftArmColor: Color3;

	LeftLeg: number;

	LeftLegColor: Color3;

	NeckAccessory: string;

	Pants: number;

	ProportionScale: number;

	RightArm: number;

	RightArmColor: Color3;

	RightLeg: number;

	RightLegColor: Color3;

	RunAnimation: number;

	Shirt: number;

	ShouldersAccessory: string;

	SwimAnimation: number;

	Torso: number;

	TorsoColor: Color3;

	WaistAccessory: string;

	WalkAnimation: number;

	WidthScale: number;
}

/** An object created when an input begins that describes a particular user input, such as mouse movement, touches, keyboard, and more.

The object's properties vary according the the type of input. Properties can be used to determine input `state`, `type`, `position`, `delta`, and the `KeyCode` that triggered the input (if applicable).

Once created at the beginning of an input, the same object persists and is updated until the input ends. As a result, you can track the object's changes using the `Changed` event as the user changes the input in question. You can also place these objects into a list of active inputs track and interact with the object after it's creation by an event such as `InputBegan`.

#See also
 - Most `UserInputService` events and functions return an InputObject to describe user input events and states
 -  `GuiObject` events related to user input return an InputObject to describe user input

## Code Samples

### Handling InputChanged

The following example demonstrates one of many usage examples of handling user input from InputChanged depending on its type.
```lua
-- In order to use the InputChanged event, the UserInputService service must be used
local userInputService = game:GetService("UserInputService")

-- Prints the current input position and the change (delta) in position
local function printMovement(input)
    print("\tPosition:",input.Position)
    print("\tMovement Delta:",input.Delta)
end
 
-- A sample function providing multiple usage cases for various types of user input
local function InputChanged(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
   	 print("The mouse has been moved!")
   	 printMovement(input)
    elseif input.UserInputType == Enum.UserInputType.MouseWheel then
   	 print("The mouse wheel has been scrolled!")
   	 print("\tWheel Movement:",input.Position.Z)
    elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
   	 if input.KeyCode == Enum.KeyCode.Thumbstick1 then
   		 print("The left thumbstick has been moved!")
   		 printMovement(input)
   	 elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
   		 print("The right thumbstick has been moved!")
   		 printMovement(input)
   	 elseif input.KeyCode == Enum.KeyCode.ButtonL2 then
   		 print("The pressure being applied to the left trigger has changed!")
   		 print("\tPressure:",input.Position.Z)
   	 elseif input.KeyCode == Enum.KeyCode.ButtonR2 then
   		 print("The pressure being applied to the right trigger has changed!")
   		 print("\tPressure:",input.Position.Z)
   	 end
    elseif input.UserInputType == Enum.UserInputType.Touch then
   	 print("The user's finger is moving on the screen!")
   	 printMovement(input)
    elseif input.UserInputType == Enum.UserInputType.Gyro then
   	 local rotInput,rotCFrame = UserInputService:GetDeviceRotation()
   	 local rotX,rotY,rotZ = rotCFrame:toEulerAnglesXYZ()
   	 local rot = Vector3.new(math.deg(rotX),math.deg(rotY),math.deg(rotZ))
   	 print("The rotation of the user's mobile device has been changed!")
   	 print("\tPosition",rotCFrame.p)
   	 print("\tRotation:",rot)
    elseif input.UserInputType == Enum.UserInputType.Accelerometer then
   	 print("The acceleration of the user's mobile device has been changed!")
   	 printMovement(input)
    end    
end

userInputService.InputChanged:Connect(InputChanged)
```

### Handling InputBegan

The following example demonstrates one of many usage examples of handling user input from InputBegan depending on its type.
```lua
-- In order to use the InputBegan event, the UserInputService service must be used
local UserInputService = game:GetService("UserInputService")

-- A sample function providing multiple usage cases for various types of user input
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyPressed = input.KeyCode
		print("A key is being pushed down! Key:",input.KeyCode)
	elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
		print("The left mouse button has been pressed down at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		print("The right mouse button has been pressed down at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Touch then
		print("A touchscreen input has started at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
		print("A button is being pressed on a gamepad! Button:",input.KeyCode)
	end

	if gameProcessed then
		print("\tThe game engine internally observed this input!")
	else
		print("\tThe game engine did not internally observe this input!")
	end
end)
```

### Handling InputEnded

The following example demonstrates one of many usage examples of handling user input from InputEnded depending on its type.
```lua
-- In order to use the InputChanged event, the UserInputService service must be used
local UserInputService = game:GetService("UserInputService")
 
-- A sample function providing multiple usage cases for various types of user input
UserInputService.InputEnded:Connect(function(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyPressed = input.KeyCode
		print("A key has been released! Key:",input.KeyCode)
	elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
		print("The left mouse button has been released at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		print("The right mouse button has been released at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Touch then
		print("A touchscreen input has been released at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
		print("A button has been released on a gamepad! Button:",input.KeyCode)
	end
	
	if gameProcessed then
		print("\tThe game engine internally observed this input!")
	else
		print("\tThe game engine did not internally observe this input!")
	end
end)
```
 */
interface InputObject extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "InputObject";
	/** A `Vector3` describing the Delta (change) between mouse/joystick movements. 

This is useful when used with the input's `position` to track the position and movement of the user's mouse/joystick, such as when you're creating custom movement or camera scripts. Consider tracking input object changes using the `Changed` event or when user input changes via events such as `InputChanged` and `InputChanged`.

## See also
 - `KeyCode`
 - `Position`
 - `UserInputState`
 - `UserInputType`

## Code Samples

### Handling InputChanged

The following example demonstrates one of many usage examples of handling user input from InputChanged depending on its type.
```lua
-- In order to use the InputChanged event, the UserInputService service must be used
local userInputService = game:GetService("UserInputService")

-- Prints the current input position and the change (delta) in position
local function printMovement(input)
    print("\tPosition:",input.Position)
    print("\tMovement Delta:",input.Delta)
end
 
-- A sample function providing multiple usage cases for various types of user input
local function InputChanged(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
   	 print("The mouse has been moved!")
   	 printMovement(input)
    elseif input.UserInputType == Enum.UserInputType.MouseWheel then
   	 print("The mouse wheel has been scrolled!")
   	 print("\tWheel Movement:",input.Position.Z)
    elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
   	 if input.KeyCode == Enum.KeyCode.Thumbstick1 then
   		 print("The left thumbstick has been moved!")
   		 printMovement(input)
   	 elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
   		 print("The right thumbstick has been moved!")
   		 printMovement(input)
   	 elseif input.KeyCode == Enum.KeyCode.ButtonL2 then
   		 print("The pressure being applied to the left trigger has changed!")
   		 print("\tPressure:",input.Position.Z)
   	 elseif input.KeyCode == Enum.KeyCode.ButtonR2 then
   		 print("The pressure being applied to the right trigger has changed!")
   		 print("\tPressure:",input.Position.Z)
   	 end
    elseif input.UserInputType == Enum.UserInputType.Touch then
   	 print("The user's finger is moving on the screen!")
   	 printMovement(input)
    elseif input.UserInputType == Enum.UserInputType.Gyro then
   	 local rotInput,rotCFrame = UserInputService:GetDeviceRotation()
   	 local rotX,rotY,rotZ = rotCFrame:toEulerAnglesXYZ()
   	 local rot = Vector3.new(math.deg(rotX),math.deg(rotY),math.deg(rotZ))
   	 print("The rotation of the user's mobile device has been changed!")
   	 print("\tPosition",rotCFrame.p)
   	 print("\tRotation:",rot)
    elseif input.UserInputType == Enum.UserInputType.Accelerometer then
   	 print("The acceleration of the user's mobile device has been changed!")
   	 printMovement(input)
    end    
end

userInputService.InputChanged:Connect(InputChanged)
```

### Create a Binoculars Script

This example creates a binoculars script that decreases the player’s `FieldOfView` and `MouseDeltaSensitivity` when a player with a `MouseEnabled` left mouse clicks. The script also points the player’s `Camera` towards the `Vector3` world position of the mouse click determined by the `Mouse’s` `Mouse.Hit.p` property.

When the player left mouse clicks again, the player’s camera reverts back to the a custom `CameraType` with the same field of view and `CFrame` as before the player zoomed in with the script.

While the player uses the binoculars, the script locks the player’s mouse to the center of the screen by setting the player’s `MouseBehavior` to LockCenter. The player’s camera moves when the player moves their mouse according to the `InputObject.Delta` property passed by `InputChanged` indicating the mouse’s `Vector2` change in screen position.

In order for this example to work as expected, it should be placed in a `LocalScript`.
```lua
local UserInputService = game:GetService("UserInputService")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.CharacterAdded:Wait()
local head = character:WaitForChild("Head", false)

local mouse = player:GetMouse()

local zoomed = false
local camera = game.Workspace.CurrentCamera
local target = nil
local originalProperties =
{
	FieldOfView = nil,
	_CFrame = nil,
	MouseBehavior = nil,
	MouseDeltaSensitivity = nil
}

local AngleX,TargetAngleX = 0,0
local AngleY,TargetAngleY = 0,0

-- Reset camera back to CFrame and FieldOfView before zoom
local function ResetCamera()
	target = nil
	camera.CameraType = Enum.CameraType.Custom
	camera.CFrame = originalProperties._CFrame
	camera.FieldOfView = originalProperties.FieldOfView
	
	UserInputService.MouseBehavior = originalProperties.MouseBehavior
	UserInputService.MouseDeltaSensitivity = originalProperties.MouseDeltaSensitivity
end

local function ZoomCamera()
	-- Allow camera to be changed by script
	camera.CameraType = Enum.CameraType.Scriptable
		
	-- Store camera properties before zoom
	originalProperties._CFrame = camera.CFrame
	originalProperties.FieldOfView = camera.FieldOfView
	originalProperties.MouseBehavior = UserInputService.MouseBehavior
	originalProperties.MouseDeltaSensitivity = UserInputService.MouseDeltaSensitivity

	-- Zoom camera
	target = mouse.Hit.p
	local eyesight = head.Position
	camera.CFrame = CFrame.new(eyesight, target)
	camera.Focus = CFrame.new(target)
	camera.FieldOfView = 10
	
	-- Lock and slow down mouse
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	UserInputService.MouseDeltaSensitivity = 1
	
	-- Reset zoom angles
	AngleX,TargetAngleX = 0,0
	AngleY,TargetAngleY = 0,0
end

-- Toggle camera zoom/unzoom
local function MouseClick()
	if zoomed then
		-- Unzoom camera
		ResetCamera()
	else
		-- Zoom in camera
		ZoomCamera()
	end
	
	zoomed = not zoomed
end

local cameraRotation = Vector2.new(0,math.rad(-60))
local function MouseMoved(input)
	if zoomed then
		local sensitivity = 0.6		-- anything higher would make looking up and down harder; recommend anything between 0~1
		local smoothness = 0.05		-- recommend anything between 0~1

		local delta = Vector2.new(input.Delta.x/sensitivity,input.Delta.y/sensitivity) * smoothness

		local X = TargetAngleX - delta.y
		local Y = TargetAngleY - delta.x
		TargetAngleX = (X >= 80 and 80) or (X <= -80 and -80) or X
		TargetAngleY = (Y >= 80 and 80) or (Y <= -80 and -80) or Y
		
		AngleX = AngleX + (TargetAngleX - AngleX) *0.35
		AngleY = AngleY + (TargetAngleY - AngleY) *0.15
		
		camera.CFrame = CFrame.new(head.Position, target)
		* CFrame.Angles(0,math.rad(AngleY),0)
		* CFrame.Angles(math.rad(AngleX),0,0)
	end
end

local function InputBegan(input, gameProcessedEvent)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		MouseClick()
	end
end

local function InputChanged(input, gameProcessedEvent)
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		MouseMoved(input)
	end
end

if UserInputService.MouseEnabled then
	UserInputService.InputBegan:Connect(InputBegan)
	UserInputService.InputChanged:Connect(InputChanged)
end
```
 */
	Delta: Vector3;
	/** Contains a `KeyCode` enum that describes what kind of input was used. For types of input like keyboard, this describes what key was pressed. For inputs like the mouse, this provides no additional information.

### Enums
| Name | Value | Description |
| --- | --- | --- |
| Unknown | 0 |  |
| Backspace | 8 |  |
| Tab | 9 |  |
| Clear | 12 |  |
| Return | 13 |  |
| Pause | 19 |  |
| Escape | 27 |  |
| Space | 32 |  |
| QuotedDouble | 34 |  |
| Hash | 35 |  |
| Dollar | 36 |  |
| Percent | 37 |  |
| Ampersand | 38 |  |
| Quote | 39 |  |
| LeftParenthesis | 40 |  |
| RightParenthesis | 41 |  |
| Asterisk | 42 |  |
| Plus | 43 |  |
| Comma | 44 |  |
| Minus | 45 |  |
| Period | 46 |  |
| Slash | 47 |  |
| Zero | 48 |  |
| One | 49 |  |
| Two | 50 |  |
| Three | 51 |  |
| Four | 52 |  |
| Five | 53 |  |
| Six | 54 |  |
| Seven | 55 |  |
| Eight | 56 |  |
| Nine | 57 |  |
| Colon | 58 |  |
| Semicolon | 59 |  |
| LessThan | 60 |  |
| Equals | 61 |  |
| GreaterThan | 62 |  |
| Question | 63 |  |
| At | 64 |  |
| LeftBracket | 91 |  |
| BackSlash | 92 |  |
| RightBracket | 93 |  |
| Caret | 94 |  |
| Underscore | 95 |  |
| Backquote | 96 |  |
| A | 97 |  |
| B | 98 |  |
| C | 99 |  |
| D | 100 |  |
| E | 101 |  |
| F | 102 |  |
| G | 103 |  |
| H | 104 |  |
| I | 105 |  |
| J | 106 |  |
| K | 107 |  |
| L | 108 |  |
| M | 109 |  |
| N | 110 |  |
| O | 111 |  |
| P | 112 |  |
| Q | 113 |  |
| R | 114 |  |
| S | 115 |  |
| T | 116 |  |
| U | 117 |  |
| V | 118 |  |
| W | 119 |  |
| X | 120 |  |
| Y | 121 |  |
| Z | 122 |  |
| LeftCurly | 123 |  |
| Pipe | 124 |  |
| RightCurly | 125 |  |
| Tilde | 126 |  |
| Delete | 127 |  |
| KeypadZero | 256 |  |
| KeypadOne | 257 |  |
| KeypadTwo | 258 |  |
| KeypadThree | 259 |  |
| KeypadFour | 260 |  |
| KeypadFive | 261 |  |
| KeypadSix | 262 |  |
| KeypadSeven | 263 |  |
| KeypadEight | 264 |  |
| KeypadNine | 265 |  |
| KeypadPeriod | 266 |  |
| KeypadDivide | 267 |  |
| KeypadMultiply | 268 |  |
| KeypadMinus | 269 |  |
| KeypadPlus | 270 |  |
| KeypadEnter | 271 |  |
| KeypadEquals | 272 |  |
| Up | 273 |  |
| Down | 274 |  |
| Right | 275 |  |
| Left | 276 |  |
| Insert | 277 |  |
| Home | 278 |  |
| End | 279 |  |
| PageUp | 280 |  |
| PageDown | 281 |  |
| LeftShift | 304 |  |
| RightShift | 303 |  |
| LeftMeta | 310 |  |
| RightMeta | 309 |  |
| LeftAlt | 308 |  |
| RightAlt | 307 |  |
| LeftControl | 306 |  |
| RightControl | 305 |  |
| CapsLock | 301 |  |
| NumLock | 300 |  |
| ScrollLock | 302 |  |
| LeftSuper | 311 |  |
| RightSuper | 312 |  |
| Mode | 313 |  |
| Compose | 314 |  |
| Help | 315 |  |
| Print | 316 |  |
| SysReq | 317 |  |
| Break | 318 |  |
| Menu | 319 |  |
| Power | 320 |  |
| Euro | 321 |  |
| Undo | 322 |  |
| F1 | 282 |  |
| F2 | 283 |  |
| F3 | 284 |  |
| F4 | 285 |  |
| F5 | 286 |  |
| F6 | 287 |  |
| F7 | 288 |  |
| F8 | 289 |  |
| F9 | 290 |  |
| F10 | 291 |  |
| F11 | 292 |  |
| F12 | 293 |  |
| F13 | 294 |  |
| F14 | 295 |  |
| F15 | 296 |  |
| World0 | 160 |  |
| World1 | 161 |  |
| World2 | 162 |  |
| World3 | 163 |  |
| World4 | 164 |  |
| World5 | 165 |  |
| World6 | 166 |  |
| World7 | 167 |  |
| World8 | 168 |  |
| World9 | 169 |  |
| World10 | 170 |  |
| World11 | 171 |  |
| World12 | 172 |  |
| World13 | 173 |  |
| World14 | 174 |  |
| World15 | 175 |  |
| World16 | 176 |  |
| World17 | 177 |  |
| World18 | 178 |  |
| World19 | 179 |  |
| World20 | 180 |  |
| World21 | 181 |  |
| World22 | 182 |  |
| World23 | 183 |  |
| World24 | 184 |  |
| World25 | 185 |  |
| World26 | 186 |  |
| World27 | 187 |  |
| World28 | 188 |  |
| World29 | 189 |  |
| World30 | 190 |  |
| World31 | 191 |  |
| World32 | 192 |  |
| World33 | 193 |  |
| World34 | 194 |  |
| World35 | 195 |  |
| World36 | 196 |  |
| World37 | 197 |  |
| World38 | 198 |  |
| World39 | 199 |  |
| World40 | 200 |  |
| World41 | 201 |  |
| World42 | 202 |  |
| World43 | 203 |  |
| World44 | 204 |  |
| World45 | 205 |  |
| World46 | 206 |  |
| World47 | 207 |  |
| World48 | 208 |  |
| World49 | 209 |  |
| World50 | 210 |  |
| World51 | 211 |  |
| World52 | 212 |  |
| World53 | 213 |  |
| World54 | 214 |  |
| World55 | 215 |  |
| World56 | 216 |  |
| World57 | 217 |  |
| World58 | 218 |  |
| World59 | 219 |  |
| World60 | 220 |  |
| World61 | 221 |  |
| World62 | 222 |  |
| World63 | 223 |  |
| World64 | 224 |  |
| World65 | 225 |  |
| World66 | 226 |  |
| World67 | 227 |  |
| World68 | 228 |  |
| World69 | 229 |  |
| World70 | 230 |  |
| World71 | 231 |  |
| World72 | 232 |  |
| World73 | 233 |  |
| World74 | 234 |  |
| World75 | 235 |  |
| World76 | 236 |  |
| World77 | 237 |  |
| World78 | 238 |  |
| World79 | 239 |  |
| World80 | 240 |  |
| World81 | 241 |  |
| World82 | 242 |  |
| World83 | 243 |  |
| World84 | 244 |  |
| World85 | 245 |  |
| World86 | 246 |  |
| World87 | 247 |  |
| World88 | 248 |  |
| World89 | 249 |  |
| World90 | 250 |  |
| World91 | 251 |  |
| World92 | 252 |  |
| World93 | 253 |  |
| World94 | 254 |  |
| World95 | 255 |  |
| ButtonX | 1000 |  |
| ButtonY | 1001 |  |
| ButtonA | 1002 |  |
| ButtonB | 1003 |  |
| ButtonR1 | 1004 |  |
| ButtonL1 | 1005 |  |
| ButtonR2 | 1006 |  |
| ButtonL2 | 1007 |  |
| ButtonR3 | 1008 |  |
| ButtonL3 | 1009 |  |
| ButtonStart | 1010 |  |
| ButtonSelect | 1011 |  |
| DPadLeft | 1012 |  |
| DPadRight | 1013 |  |
| DPadUp | 1014 |  |
| DPadDown | 1015 |  |
| Thumbstick1 | 1016 |  |
| Thumbstick2 | 1017 |


### See also
 - `Delta`
 - `Position`
 - `UserInputState`
 - `UserInputType`

## Code Samples

### Binding Supported Gamepad KeyCodes

This example gets a list of navigation gamepads and a list of their supported `KeyCodes`. Then, it iterates through the supported KeyCode list and binds the *ButtonX* and *X* keys to functions if they are supported by a gamepad using the `ContextActionService`.

Check out this [article][1] to learn more about adding support for gamepad input into your game.

  [1]: /articles/Gamepad-Haptic-Feedback
```lua
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService(“ContextActionService”)

local function actionHandler(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin then 
		print("Action Handler: " .. actionName)
	end

	-- Since this function does not return anything, this handler will
	-- "sink" the input and no other action handlers will be called after
	-- this one.
end

local navGamepads = UserInputService:GetNavigationGamepads()
for _, gamepad in pairs(navGamepads) do
    local supportedKeyCodes = UserInputService:GetSupportedGamepadKeyCodes()

    for _, keycode in pairs(supportedKeyCodes) do
        if (keycode == Enum.KeyCode.ButtonX) then
            ContextActionService:BindAction(“SampleAction”, actionHandler, false, Enum.KeyCode.ButtonX)
        end
        if (keycode == Enum.KeyCode.X) then
            ContextActionService:BindAction(“SampleAction”, actionHandler, false, Enum.KeyCode.X)
        end
    end
end
```
 */
	KeyCode: Enum.KeyCode;
	/** This property describes a `Vector2` positional value of this input. 

For mouse and touch input, this is the screen position of the mouse/touch, described in the x and y components. 

For the mouse wheel input, the z component describes whether the wheel was moved forward (1), backwards (-1), or not at all (0).

For `KeyCode` input, this indicate's the position of the player's `Mouse`.

#See also
 - `Delta`
 - `KeyCode`
 - `UserInputState`
 - `UserInputType`

## Code Samples

### Handling InputChanged

The following example demonstrates one of many usage examples of handling user input from InputChanged depending on its type.
```lua
-- In order to use the InputChanged event, the UserInputService service must be used
local userInputService = game:GetService("UserInputService")

-- Prints the current input position and the change (delta) in position
local function printMovement(input)
    print("\tPosition:",input.Position)
    print("\tMovement Delta:",input.Delta)
end
 
-- A sample function providing multiple usage cases for various types of user input
local function InputChanged(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
   	 print("The mouse has been moved!")
   	 printMovement(input)
    elseif input.UserInputType == Enum.UserInputType.MouseWheel then
   	 print("The mouse wheel has been scrolled!")
   	 print("\tWheel Movement:",input.Position.Z)
    elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
   	 if input.KeyCode == Enum.KeyCode.Thumbstick1 then
   		 print("The left thumbstick has been moved!")
   		 printMovement(input)
   	 elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
   		 print("The right thumbstick has been moved!")
   		 printMovement(input)
   	 elseif input.KeyCode == Enum.KeyCode.ButtonL2 then
   		 print("The pressure being applied to the left trigger has changed!")
   		 print("\tPressure:",input.Position.Z)
   	 elseif input.KeyCode == Enum.KeyCode.ButtonR2 then
   		 print("The pressure being applied to the right trigger has changed!")
   		 print("\tPressure:",input.Position.Z)
   	 end
    elseif input.UserInputType == Enum.UserInputType.Touch then
   	 print("The user's finger is moving on the screen!")
   	 printMovement(input)
    elseif input.UserInputType == Enum.UserInputType.Gyro then
   	 local rotInput,rotCFrame = UserInputService:GetDeviceRotation()
   	 local rotX,rotY,rotZ = rotCFrame:toEulerAnglesXYZ()
   	 local rot = Vector3.new(math.deg(rotX),math.deg(rotY),math.deg(rotZ))
   	 print("The rotation of the user's mobile device has been changed!")
   	 print("\tPosition",rotCFrame.p)
   	 print("\tRotation:",rot)
    elseif input.UserInputType == Enum.UserInputType.Accelerometer then
   	 print("The acceleration of the user's mobile device has been changed!")
   	 printMovement(input)
    end    
end

userInputService.InputChanged:Connect(InputChanged)
```

### Handling InputBegan

The following example demonstrates one of many usage examples of handling user input from InputBegan depending on its type.
```lua
-- In order to use the InputBegan event, the UserInputService service must be used
local UserInputService = game:GetService("UserInputService")

-- A sample function providing multiple usage cases for various types of user input
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyPressed = input.KeyCode
		print("A key is being pushed down! Key:",input.KeyCode)
	elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
		print("The left mouse button has been pressed down at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		print("The right mouse button has been pressed down at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Touch then
		print("A touchscreen input has started at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
		print("A button is being pressed on a gamepad! Button:",input.KeyCode)
	end

	if gameProcessed then
		print("\tThe game engine internally observed this input!")
	else
		print("\tThe game engine did not internally observe this input!")
	end
end)
```

### Handling InputEnded

The following example demonstrates one of many usage examples of handling user input from InputEnded depending on its type.
```lua
-- In order to use the InputChanged event, the UserInputService service must be used
local UserInputService = game:GetService("UserInputService")
 
-- A sample function providing multiple usage cases for various types of user input
UserInputService.InputEnded:Connect(function(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyPressed = input.KeyCode
		print("A key has been released! Key:",input.KeyCode)
	elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
		print("The left mouse button has been released at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		print("The right mouse button has been released at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Touch then
		print("A touchscreen input has been released at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
		print("A button has been released on a gamepad! Button:",input.KeyCode)
	end
	
	if gameProcessed then
		print("\tThe game engine internally observed this input!")
	else
		print("\tThe game engine did not internally observe this input!")
	end
end)
```
 */
	Position: Vector3;
	/** Contains a `UserInputState` enum that describes the state of the user's input and indicates how a user’s input is currently interacting with your game.

## Enums
| Name | Value | Description |
| --- | --- | --- |
| Begin | 0 |

When an `InputObject`starts to interact with the game. For example, a mouse button down, or a key down, or when a touch begins touching the screen.  |
| Change | 1 |

When an `InputObject`has already begun interacting with the game, and part of it's state is changing. For example, a mouse position move, or a thumbstick moving, or when a touch begins to move across the screen.  |
| End | 2 |

When an `InputObject`finishes interacting with the game. For example, a mouse button up, or a key up, or when a touch stops touching the screen.  |
| Cancel | 3 |

A special circumstance state that indicates this input is now being used for some other function. For example, binding two actions to the same input will cause a function to fire with Cancel.  |
| None | 4 |

A state that should never be seen in a game, essentially just marks the end of the enum.  |


## See also
 - `Delta`
 - `KeyCode`
 - `Position`
 - `UserInputType`

## Code Samples

### Binding Supported Gamepad KeyCodes

This example gets a list of navigation gamepads and a list of their supported `KeyCodes`. Then, it iterates through the supported KeyCode list and binds the *ButtonX* and *X* keys to functions if they are supported by a gamepad using the `ContextActionService`.

Check out this [article][1] to learn more about adding support for gamepad input into your game.

  [1]: /articles/Gamepad-Haptic-Feedback
```lua
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService(“ContextActionService”)

local function actionHandler(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin then 
		print("Action Handler: " .. actionName)
	end

	-- Since this function does not return anything, this handler will
	-- "sink" the input and no other action handlers will be called after
	-- this one.
end

local navGamepads = UserInputService:GetNavigationGamepads()
for _, gamepad in pairs(navGamepads) do
    local supportedKeyCodes = UserInputService:GetSupportedGamepadKeyCodes()

    for _, keycode in pairs(supportedKeyCodes) do
        if (keycode == Enum.KeyCode.ButtonX) then
            ContextActionService:BindAction(“SampleAction”, actionHandler, false, Enum.KeyCode.ButtonX)
        end
        if (keycode == Enum.KeyCode.X) then
            ContextActionService:BindAction(“SampleAction”, actionHandler, false, Enum.KeyCode.X)
        end
    end
end
```

### Create a Custom CameraScript

By default, Roblox relies on a `LocalScript`, described [here][1], to control the user’s camera. However, this script can be overridden with a custom *CameraScript*. The example below demonstrates how to create a custom script to control the user’s camera using many of the `UserInputService` events.

The script is broken into two parts:

 1. Mobile camera events, which rely on touch events
 2. Non-mobile camera events, which rely on keyboard input and tracking the user’s movement

First, the camera script needs utility functions to setup the camera and set its `CameraType` to *Scriptable* so that the script can control the camera. It also needs a function to update the camera when it moves, rotates, and zooms.

Using touch events allows us to track user input as they interact with the touchscreen on their mobile device. These events allow us to handle camera movement, rotation, and zoom.

The second half of the code sample adds camera support for players on desktop devices. When input begans, the function Input() checks that the state of the input is `Enum.UserInputState.Begin` to ignore all keypress inputs other than when the user first presses a key down. When the user presses *I* and *O* the camera zooms in and out. When the presses down and moves their left mouse button, the script `locks` the player’s mouse by changing the `MouseBehavior` property. The camera rotates according to the mouse’s `change in screen position`. When the player moves their character, the camera moves with them.

All of the parts discussed above are combined and shown in the code sample below.
```lua
-- ========================================
-- GLOBAL VARIABLES
-- ========================================
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- The camera used by the LocalPlayer
local camera = game.Workspace.CurrentCamera

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")
local playerPosition = torso.Position

local default_CameraPosition = torso.Position
local default_CameraRotation = Vector2.new(0,math.rad(-60))
local default_CameraZoom = 15

local cameraPosition = default_CameraPosition
local cameraRotation = default_CameraRotation
local cameraZoom = default_CameraZoom

local cameraRotationBounds = {math.rad(-81),math.rad(20)}
local cameraZoomBounds = nil --{10,200}
local touchDragSpeed = 0.15
local cameraSpeed = 0.1
local cameraRotateSpeed = 10
local cameraMouseRotateSpeed = 0.25
local cameraTouchRotateSpeed = 10
-- ========================================
-- ========================================





-- ========================================
-- UTILITY FUNCTIONS
-- ========================================
local function SetCameraMode()
camera.CameraType = "Scriptable"
camera.FieldOfView = 80
camera.CameraSubject = nil
end

local function UpdateCamera()
SetCameraMode()
local cameraRotationCFrame = CFrame.Angles(0, cameraRotation.X, 0)*CFrame.Angles(cameraRotation.Y, 0, 0)
camera.CFrame = cameraRotationCFrame + cameraPosition + cameraRotationCFrame*Vector3.new(0, 0, cameraZoom)
camera.Focus = camera.CFrame - Vector3.new(0, camera.CFrame.p.Y, 0)
end
-- ========================================
-- ========================================




-- ========================================
-- MOBILE CAMERA EVENTS
-- ========================================
-- Events used to control the camera for players using a mobile device

-- ====================
-- CAMERA MOVE
-- ====================
-- Fired by UserInputService.TouchPan
local lastTouchTranslation = nil
local function TouchMove(touchPositions, totalTranslation, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = totalTranslation - lastTouchTranslation
	cameraPosition = cameraPosition + Vector3.new(difference.X, 0, difference.Y)
		UpdateCamera()
	end
	lastTouchTranslation = totalTranslation
end

-- ====================
-- CAMERA ROTATE
-- ====================
-- Fired by UserInputService.TouchRotate
local lastTouchRotation = nil
local function TouchRotate(touchPositions, rotation, velocity, state)
if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
local difference = rotation - lastTouchRotation
cameraRotation = cameraRotation + Vector2.new(-difference,0)*math.rad(cameraTouchRotateSpeed*cameraRotateSpeed)
		UpdateCamera()
	end
lastTouchRotation = rotation
end

-- ====================
-- CAMERA ZOOM
-- ====================
-- Fired by UserInputService.TouchPinch
local lastTouchScale = nil
local function TouchZoom(touchPositions, scale, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = scale - lastTouchScale
		cameraZoom = cameraZoom * (1 + difference)
		if cameraZoomBounds ~= nil then
			cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
		else
			cameraZoom = math.max(cameraZoom, 0)
end
		UpdateCamera()
	end
	lastTouchScale = scale
end

local function Input()
	UpdateCamera()
end
-- ========================================





-- ========================================
-- NON-MOBILE CAMERA EVENTS
-- ========================================

local function Input(inputObject)
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		if inputObject.UserInputState == Enum.UserInputState.Begin then						
			-- ====================
			-- CAMERA ZOOM
			-- ====================
			-- (I) Zoom In
			if inputObject.KeyCode == Enum.KeyCode.I then
			 	cameraZoom = cameraZoom - 15
			elseif inputObject.KeyCode == Enum.KeyCode.O then
				cameraZoom = cameraZoom + 15
			end
		
			-- (O) Zoom Out
			if cameraZoomBounds ~= nil then
				cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
			else
				cameraZoom = math.max(cameraZoom, 0)
			end
			
			UpdateCamera()
		end
	end
	
	-- ====================
	-- CAMERA ROTATE
	-- ====================
	local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
	if pressed then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		local rotation = userInputService:GetMouseDelta()
		cameraRotation = cameraRotation + rotation*math.rad(cameraMouseRotateSpeed)
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end

-- ====================
-- CAMERA MOVE
-- ====================
local function PlayerChanged()
	local movement = torso.Position - playerPosition
	cameraPosition = cameraPosition + movement
	playerPosition = torso.Position
		
	UpdateCamera()
end
-- ========================================
-- ========================================






-- ========================================
-- DEVICE CHECK
-- ========================================
-- Determine whether the user is on a mobile device

if UserInputService.TouchEnabled then
	-- The user is on a mobile device, use Touch events
UserInputService.TouchPan:Connect(TouchMove)
UserInputService.TouchRotate:Connect(TouchRotate)
UserInputService.TouchPinch:Connect(TouchZoom)
else
	
	-- The user is not on a mobile device use Input events
UserInputService.InputBegan:Connect(Input)
UserInputService.InputChanged:Connect(Input)
UserInputService.InputEnded:Connect(Input)

	-- Camera controlled by player movement
	wait(2)
	RunService:BindToRenderStep("PlayerChanged", Enum.RenderPriority.Camera.Value-1, PlayerChanged)
end	
-- ========================================
-- ========================================
```
 */
	UserInputState: Enum.UserInputState;
	/** Contains a `UserInputType` enum that describes the type of user input, such as whether the input is via keyboard, mouse, touch, gamepad, to name a few.

## Enums
| Name | Value | Description |
| --- | --- | --- |
| MouseButton1 | 0 |

The left mouse button.  |
| MouseButton2 | 1 |

The right mouse button.  |
| MouseButton3 | 2 |

The middle mouse button.  |
| MouseWheel | 3 |

The mouse wheel.  |
| MouseMovement | 4 |

Movement of the mouse.  |
| Touch | 7 |

A tap on the screen from a mobile device.  |
| Keyboard | 8 |

Key press on a keyboard.  |
| Focus | 9 |

The client regaining focus of the Roblox window.  |
| Accelerometer | 10 |

The accelerometer of a mobile device.  |
| Gyro | 11 |

The Gyroscope of a mobile device.  |
| Gamepad1 | 12 |

Input from the 1st plugged in Gamepad.  |
| Gamepad2 | 13 |

Input from the 2nd plugged in Gamepad.  |
| Gamepad3 | 14 |

Input from the 3rd plugged in Gamepad.  |
| Gamepad4 | 15 |

Input from the 4th plugged in Gamepad.  |
| Gamepad5 | 16 |

Input from the 5th plugged in Gamepad  |
| Gamepad6 | 17 |

Input from the 6th plugged in Gamepad.  |
| Gamepad7 | 18 |

Input from the 7th plugged in Gamepad.  |
| Gamepad8 | 19 |

Input from the 8th plugged in Gamepad.  |
| TextInput | 20 |

Input of Text into a text-based `GuiObject`. Normally this is only a `TextBox`.  |
| None | 21 |

Unknown UserInputType.  |


## See also
 - `Delta`
 - `KeyCode`
 - `Position`
 - `UserInputState`

## Code Samples

### Handling InputChanged

The following example demonstrates one of many usage examples of handling user input from InputChanged depending on its type.
```lua
-- In order to use the InputChanged event, the UserInputService service must be used
local userInputService = game:GetService("UserInputService")

-- Prints the current input position and the change (delta) in position
local function printMovement(input)
    print("\tPosition:",input.Position)
    print("\tMovement Delta:",input.Delta)
end
 
-- A sample function providing multiple usage cases for various types of user input
local function InputChanged(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
   	 print("The mouse has been moved!")
   	 printMovement(input)
    elseif input.UserInputType == Enum.UserInputType.MouseWheel then
   	 print("The mouse wheel has been scrolled!")
   	 print("\tWheel Movement:",input.Position.Z)
    elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
   	 if input.KeyCode == Enum.KeyCode.Thumbstick1 then
   		 print("The left thumbstick has been moved!")
   		 printMovement(input)
   	 elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
   		 print("The right thumbstick has been moved!")
   		 printMovement(input)
   	 elseif input.KeyCode == Enum.KeyCode.ButtonL2 then
   		 print("The pressure being applied to the left trigger has changed!")
   		 print("\tPressure:",input.Position.Z)
   	 elseif input.KeyCode == Enum.KeyCode.ButtonR2 then
   		 print("The pressure being applied to the right trigger has changed!")
   		 print("\tPressure:",input.Position.Z)
   	 end
    elseif input.UserInputType == Enum.UserInputType.Touch then
   	 print("The user's finger is moving on the screen!")
   	 printMovement(input)
    elseif input.UserInputType == Enum.UserInputType.Gyro then
   	 local rotInput,rotCFrame = UserInputService:GetDeviceRotation()
   	 local rotX,rotY,rotZ = rotCFrame:toEulerAnglesXYZ()
   	 local rot = Vector3.new(math.deg(rotX),math.deg(rotY),math.deg(rotZ))
   	 print("The rotation of the user's mobile device has been changed!")
   	 print("\tPosition",rotCFrame.p)
   	 print("\tRotation:",rot)
    elseif input.UserInputType == Enum.UserInputType.Accelerometer then
   	 print("The acceleration of the user's mobile device has been changed!")
   	 printMovement(input)
    end    
end

userInputService.InputChanged:Connect(InputChanged)
```

### Handling InputBegan

The following example demonstrates one of many usage examples of handling user input from InputBegan depending on its type.
```lua
-- In order to use the InputBegan event, the UserInputService service must be used
local UserInputService = game:GetService("UserInputService")

-- A sample function providing multiple usage cases for various types of user input
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyPressed = input.KeyCode
		print("A key is being pushed down! Key:",input.KeyCode)
	elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
		print("The left mouse button has been pressed down at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		print("The right mouse button has been pressed down at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Touch then
		print("A touchscreen input has started at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
		print("A button is being pressed on a gamepad! Button:",input.KeyCode)
	end

	if gameProcessed then
		print("\tThe game engine internally observed this input!")
	else
		print("\tThe game engine did not internally observe this input!")
	end
end)
```

### Create a Custom CameraScript

By default, Roblox relies on a `LocalScript`, described [here][1], to control the user’s camera. However, this script can be overridden with a custom *CameraScript*. The example below demonstrates how to create a custom script to control the user’s camera using many of the `UserInputService` events.

The script is broken into two parts:

 1. Mobile camera events, which rely on touch events
 2. Non-mobile camera events, which rely on keyboard input and tracking the user’s movement

First, the camera script needs utility functions to setup the camera and set its `CameraType` to *Scriptable* so that the script can control the camera. It also needs a function to update the camera when it moves, rotates, and zooms.

Using touch events allows us to track user input as they interact with the touchscreen on their mobile device. These events allow us to handle camera movement, rotation, and zoom.

The second half of the code sample adds camera support for players on desktop devices. When input begans, the function Input() checks that the state of the input is `Enum.UserInputState.Begin` to ignore all keypress inputs other than when the user first presses a key down. When the user presses *I* and *O* the camera zooms in and out. When the presses down and moves their left mouse button, the script `locks` the player’s mouse by changing the `MouseBehavior` property. The camera rotates according to the mouse’s `change in screen position`. When the player moves their character, the camera moves with them.

All of the parts discussed above are combined and shown in the code sample below.
```lua
-- ========================================
-- GLOBAL VARIABLES
-- ========================================
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- The camera used by the LocalPlayer
local camera = game.Workspace.CurrentCamera

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")
local playerPosition = torso.Position

local default_CameraPosition = torso.Position
local default_CameraRotation = Vector2.new(0,math.rad(-60))
local default_CameraZoom = 15

local cameraPosition = default_CameraPosition
local cameraRotation = default_CameraRotation
local cameraZoom = default_CameraZoom

local cameraRotationBounds = {math.rad(-81),math.rad(20)}
local cameraZoomBounds = nil --{10,200}
local touchDragSpeed = 0.15
local cameraSpeed = 0.1
local cameraRotateSpeed = 10
local cameraMouseRotateSpeed = 0.25
local cameraTouchRotateSpeed = 10
-- ========================================
-- ========================================





-- ========================================
-- UTILITY FUNCTIONS
-- ========================================
local function SetCameraMode()
camera.CameraType = "Scriptable"
camera.FieldOfView = 80
camera.CameraSubject = nil
end

local function UpdateCamera()
SetCameraMode()
local cameraRotationCFrame = CFrame.Angles(0, cameraRotation.X, 0)*CFrame.Angles(cameraRotation.Y, 0, 0)
camera.CFrame = cameraRotationCFrame + cameraPosition + cameraRotationCFrame*Vector3.new(0, 0, cameraZoom)
camera.Focus = camera.CFrame - Vector3.new(0, camera.CFrame.p.Y, 0)
end
-- ========================================
-- ========================================




-- ========================================
-- MOBILE CAMERA EVENTS
-- ========================================
-- Events used to control the camera for players using a mobile device

-- ====================
-- CAMERA MOVE
-- ====================
-- Fired by UserInputService.TouchPan
local lastTouchTranslation = nil
local function TouchMove(touchPositions, totalTranslation, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = totalTranslation - lastTouchTranslation
	cameraPosition = cameraPosition + Vector3.new(difference.X, 0, difference.Y)
		UpdateCamera()
	end
	lastTouchTranslation = totalTranslation
end

-- ====================
-- CAMERA ROTATE
-- ====================
-- Fired by UserInputService.TouchRotate
local lastTouchRotation = nil
local function TouchRotate(touchPositions, rotation, velocity, state)
if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
local difference = rotation - lastTouchRotation
cameraRotation = cameraRotation + Vector2.new(-difference,0)*math.rad(cameraTouchRotateSpeed*cameraRotateSpeed)
		UpdateCamera()
	end
lastTouchRotation = rotation
end

-- ====================
-- CAMERA ZOOM
-- ====================
-- Fired by UserInputService.TouchPinch
local lastTouchScale = nil
local function TouchZoom(touchPositions, scale, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = scale - lastTouchScale
		cameraZoom = cameraZoom * (1 + difference)
		if cameraZoomBounds ~= nil then
			cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
		else
			cameraZoom = math.max(cameraZoom, 0)
end
		UpdateCamera()
	end
	lastTouchScale = scale
end

local function Input()
	UpdateCamera()
end
-- ========================================





-- ========================================
-- NON-MOBILE CAMERA EVENTS
-- ========================================

local function Input(inputObject)
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		if inputObject.UserInputState == Enum.UserInputState.Begin then						
			-- ====================
			-- CAMERA ZOOM
			-- ====================
			-- (I) Zoom In
			if inputObject.KeyCode == Enum.KeyCode.I then
			 	cameraZoom = cameraZoom - 15
			elseif inputObject.KeyCode == Enum.KeyCode.O then
				cameraZoom = cameraZoom + 15
			end
		
			-- (O) Zoom Out
			if cameraZoomBounds ~= nil then
				cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
			else
				cameraZoom = math.max(cameraZoom, 0)
			end
			
			UpdateCamera()
		end
	end
	
	-- ====================
	-- CAMERA ROTATE
	-- ====================
	local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
	if pressed then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		local rotation = userInputService:GetMouseDelta()
		cameraRotation = cameraRotation + rotation*math.rad(cameraMouseRotateSpeed)
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end

-- ====================
-- CAMERA MOVE
-- ====================
local function PlayerChanged()
	local movement = torso.Position - playerPosition
	cameraPosition = cameraPosition + movement
	playerPosition = torso.Position
		
	UpdateCamera()
end
-- ========================================
-- ========================================






-- ========================================
-- DEVICE CHECK
-- ========================================
-- Determine whether the user is on a mobile device

if UserInputService.TouchEnabled then
	-- The user is on a mobile device, use Touch events
UserInputService.TouchPan:Connect(TouchMove)
UserInputService.TouchRotate:Connect(TouchRotate)
UserInputService.TouchPinch:Connect(TouchZoom)
else
	
	-- The user is not on a mobile device use Input events
UserInputService.InputBegan:Connect(Input)
UserInputService.InputChanged:Connect(Input)
UserInputService.InputEnded:Connect(Input)

	-- Camera controlled by player movement
	wait(2)
	RunService:BindToRenderStep("PlayerChanged", Enum.RenderPriority.Camera.Value-1, PlayerChanged)
end	
-- ========================================
-- ========================================
```
 */
	UserInputType: Enum.UserInputType;
}

/** Used to insert assets from Roblox into the current game. */
interface InsertService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "InsertService";
	/** Returns an array of dictionaries, containing information about various Roblox approved sets. */
	GetBaseSets(): Array<SetInfo>;
	/** Returns the most recently uploaded models in the specified category.

## Code Samples

### InsertService:GetCollection

The format of the returned table is as follows:

```
undefined```

{ -- Array
   { -- Table
      AssetId = &lt;Integer&gt;, -- for use with InsertService::LoadAsset()
      AssetSetId = &lt;Integer&gt;, -- source set
      AssetVersionId = &lt;Integer&gt;, -- for use with InsertService::LoadAssetVersion()
      IsTrusted = &lt;Integer&gt;, -- &quot;trusted&quot; flag
      Name = &lt;String&gt;, -- model name
      CreatorName = &lt;String&gt; -- creator name
  }
}
```lua
local tab = game:GetService("InsertService"):GetCollection(catinfo.categoryId) 
for ndx,assetinfo in ipairs(tab) do 
     print(ndx) 
     for k,v in pairs(assetinfo) do 
          print(k, "=", v) 
     end 
end
```
 */
	GetCollection(categoryId: number): Array<CollectionInfo>;
	/** The GetFreeDecals function retrieves a list of Free `Decal`s from the Catalog. The return type for this method is very odd, as it returns a single table wrapped in a table.

The best way to explain it is to show a visual of the array returned:

```lua
[1] = {
	CurrentStartIndex = 1; -- This can vary depending on the page you input.
	TotalCount = 21; -- Always 21.
	Results = {
		-- All parameters here are psuedo. They can vary depending on the asset.
		[1] = {	
			Name = "Asset Name"; 
			AssetId = 0000000;
			AssetVersionId = 0000000;
			CreatorName = "Roblox";
		},
		-- [2], [3], and so on... up to [21]
	},
}
```


Yikes! That quite confusing. Unfortunately this method was added in the earlier days of Roblox, where easy to understand return-types weren't a priority.

Thankfully, an example for iterating over this list has been provided at the bottom of this page.

Additionally, if you want to insert `Models` instead, you can use the `GetFreeModels` function.

*Note:* The page argument starts at 0. So Page 1 = 0, Page 2 = 1, etc.

## Code Samples

### InsertService:GetFreeDecals


```lua

local insertService = game:GetService("InsertService")
local page = unpack(insertService:GetFreeDecals("Cats",0)) -- Search for "Cats" on Page 1.

for i = 1,page.TotalCount do
	local item = page.Results[i]
	print("Item #"..i)
	for key,value in pairs(item) do
		print(" " .. key .. ": " .. value)
	end
end

```

@param searchText String used to search for free decals in the Catalog
@param pageNum The page number in the Catalog to return
@returns A single table (of returned free decals) wrapped in a table */
	GetFreeDecals(searchText: string, pageNum: number): Array<FreeSearchResult>;
	/** The GetFreeModels function retrieves a list of Free `Models` from the Catalog. The return type for this method is very odd, as it returns a single table wrapped in a table.

The best way to explain it is to show a visual of the array returned:

```lua
[1] = {
	CurrentStartIndex = 1, -- This can vary depending on the page you input.
	TotalCount = 21, -- Always 21.
	Results = {
		-- All parameters here are psuedo. They can vary depending on the asset.
		[1] = {	
			Name = "Asset Name",
			AssetId = 0000000,
			AssetVersionId = 0000000,
			CreatorName = "Roblox",
    		}
    		-- [2], [3], and so on... up to [21]
    	}
}

An example for iterating over this list has been provided at the bottom of this page.

Additionally, if you would like to insert free `Decals`, you can use the `GetFreeDecals` function.

## Code Samples

### InsertService:GetFreeModels


```lua
local InsertService = game:GetService("InsertService")
local page = unpack(InsertService:GetFreeModels("Cats",0)) -- Search for "Cats" on Page 1.

for i = 1,page.TotalCount do
	local item = page.Results[i]
	print("Item #"..i)
	for key,value in pairs(item) do
		print(" " .. key .. ": " .. value)
	end
end
```

@param searchText String used to search for free decals in the Catalog
@param pageNum The page number in the Catalog to return
@returns A single table (of returned free models) wrapped in a table */
	GetFreeModels(searchText: string, pageNum: number): Array<FreeSearchResult>;
	/** Returns the latest AssetVersionId of an asset for assets created by the place creator.
Can be used in combination with [LoadAssetVersion](https://developer.roblox.com/api-reference/function/InsertService/LoadAssetVersion "LoadAssetVersion") to load the latest version of a model, even if it gets updated while the game is running. */
	GetLatestAssetVersionAsync(assetId: number): number;
	/** Returns an array of dictionaries, containing information about sets owned by the user.
This includes

* Sets the user is subscribed to.
* Sets that the user created.
* A single set containing the models created by the user.
* A single set containing the decals created by the user.Returns an array of dictionaries, containing information about sets owned by the user.

## Notes

* All values in the dictionaries are [strings](https://developer.roblox.com/articles/String "Strings"), even if they are a number.




**Dictionary Contents**

| Name | Description |
| Name | The name of the set. |
| Description | The description of the set. |
| ImageAssetId | An assetId for the icon of the set. |
| CreatorName | The creator of the set. |
| AssetSetId | The set's unique ID on the website. |
| CategoryId | Identical to AssetSetId |
| SetType | The type of set that this set is. | */
	GetUserSets(userId: number): Array<SetInfo>;
	/** The LoadAsset function returns a `model` inserted into `InsertService` containing the asset.

For instance, if you want to load a [Doge][1] `Model`, which has the asset Id ***257489726***, you would use the following statement:

    InsertService:LoadAsset("257489726")

This line would return an `Instance` of the Doge model within your game. Changing the asset Id passed as an argument changes the asset that is loaded into your game.

Interested in finding Free Models or `Decals` into your game? You can use the `GetFreeModels` and `GetFreeDecals` functions!

See another example below!

  [1]: https://www.roblox.com/library/257489726/Doge

## Code Samples

### InsertService:LoadAsset


```lua

local assetId = 82353
game:GetService("InsertService"):LoadAsset(assetId).Parent = game.Workspace

```

@param assetId The asset Id of the asset being loaded
@returns An instance of the loaded asset */
	LoadAsset(assetId: number): Model;
	/** Returns a model inserted into `InsertService` containing the asset with the given assetVersionId.

## Code Samples

### InsertService:LoadAssetVersion


```lua

local assetVersionId = 296050499
game:GetService("InsertService"):LoadAssetVersion(assetVersionId).Parent = game.Workspace

```
 */
	LoadAssetVersion(assetVersionId: number): Model;
}

interface RbxInternalJointInstance extends RbxInternalInstance {
	/** This property determines if the joint is currently active in the world. If true, the joint is active.

If the `JointInstance` is not in `Workspace` or `JointsService`, or one of its parts is not in Workspace the joint will be inactive.

Rigid joints like `Weld`, `Snap`, `WeldConstraint`, `Motor`, or `Motor6D` may also be disabled due to conflicts with other rigid joints, such as joints between the same two parts or indirect cycles in the weld graph. Joints disabled this way may be re-enabled later when another joint or part is added or removed. */
	readonly Active: boolean;
	/** C0 is the position aspect of the orientation between two parts in a weld. `Part0` and `Part0` move accordingly to this value, which denotes their respective positions. */
	C0: CFrame;
	/** Is subtracted from the `C0` property to create an offset point for `Part1`. */
	C1: CFrame;
	/** The first `BasePart` that the joint connects. */
	Part0: BasePart | undefined;
	/** The second `BasePart` that the joint connects. */
	Part1: BasePart | undefined;
}
/** JointInstance is the base class for joints, such as Connectors, Welds, and Snaps. */
type JointInstance = DynamicRotate | Glue | ManualSurfaceJointInstance | Motor | Rotate | Snap | VelocityMotor | Weld | Motor6D;

interface RbxInternalDynamicRotate extends RbxInternalJointInstance {
	/** The base angle of the DynamicRotate object, in radians. */
	BaseAngle: number;
}
/** The base class for classic motor joints. */
type DynamicRotate = RotateP | RotateV;

/** A RotateP object joins two parts together and allows rotation about a set axis. The joint will attempt to rotate the two parts until a desired rotational position is reached. This object is most commonly created by the SteppingMotor `SurfaceType`. If created through a script, a RotateP's behavoir is still governed by the SurfaceInput of `Part0`.

The three inputs of note are as follows:

* NoInput: The joint will not rotate under its own power. It can still be rotated by external forces (such as from a character pushing one of the parts).

* Constant: The joint will rotate based on the ParamB property of `Part0`. This rotation is measured in radians per physics frame (which is approximately 1/60th of a second).

* Sin: The joint will rotate based on the ParamA and ParamB properties of `Part0`. The rotation measured in radians per physics frame is calculated by the function: RotationRate = ParamA * sin(distributedGameTime * ParamB). distributedGameTime is the current time of the game measured in seconds. */
interface RotateP extends RbxInternalDynamicRotate {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RotateP";
}

/** A RotateV object joins two parts together and allows rotation about a set axis. This object is most commonly created by the Motor `SurfaceType`. If created through a script, a RotateV's behavior is still governed by the SurfaceInput of `Part0`.

The three inputs of note are as follows:

* NoInput: The joint will not rotate under its own power. It can still be rotated by external forces (such as from a character pushing one of the parts).

* Constant: The joint will rotate based on the ParamB property of `Part0`. This rotation is measured in radians per physics frame (which is approximately 1/60th of a second).

* Sin: The joint will rotate based on the ParamA and ParamB properties of `Part0`. The rotation measured in radians per physics frame is calculated by the function: RotationRate = ParamA * sin(distributedGameTime * ParamB). distributedGameTime is the current time of the game measured in seconds. */
interface RotateV extends RbxInternalDynamicRotate {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RotateV";
}

/** Glue is a type of joint that can break when enough force is applied. */
interface Glue extends RbxInternalJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Glue";
	/** F0 helps determining the Glue face of a `Glue`, which determines the amount of force needed to break the joint. */
	F0: Vector3;
	/** F1 helps determining the Glue face of a `Glue`, which determines the amount of force needed to break the joint. */
	F1: Vector3;
	/** F2 helps determining the Glue face of a `Glue`, which determines the amount of force needed to break the joint. */
	F2: Vector3;
	/** F3 helps determining the Glue face of a `Glue`, which determines the amount of force needed to break the joint. */
	F3: Vector3;
}

interface RbxInternalManualSurfaceJointInstance extends RbxInternalJointInstance {}
/** The ManualSurfaceJointInstance is the base class for `ManualGlue`. This instance (when created) also used to cause the server to crash, however this behaviour has since been fixed. */
type ManualSurfaceJointInstance = ManualGlue | ManualWeld;

/** **ManualGlue** is a joint created in a similar manner to the `ManualWeld` class. It functions identically to the `Glue` class. */
interface ManualGlue extends RbxInternalManualSurfaceJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ManualGlue";
}

/** A ManualWeld object holds two parts together. It is commonly created when the *Join Always* setting in Studio is turned on. ManualWeld functions identically to `Weld`. */
interface ManualWeld extends RbxInternalManualSurfaceJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ManualWeld";
}

interface RbxInternalDerivesFromMotor extends RbxInternalJointInstance {
	/** Displays the current rotation of the motor in radians.Displays the current rotation of the motor in radians.

Tags: NotReplicated */
	CurrentAngle: number;
	/** The desired angle to turn the motor to in radians. The motor will attempt to reach this angle (provided `MaxVelocity` is greater than 0. */
	DesiredAngle: number;
	/** The maximum velocity the motor can use to reach `DesiredAngle` measured in radians per physics frame (1/60th of a second). */
	MaxVelocity: number;
	/** Sets `DesiredAngle` of the motor. */
	SetDesiredAngle(value: number): void;
}
/** The Motor object is used to make movable `JointInstance` between two Parts. */
interface Motor extends RbxInternalDerivesFromMotor {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Motor";
}


/** The Motor6D object is used to make movable joints between two Parts. This is the motor Player characters use by default to move. */
interface Motor6D extends RbxInternalDerivesFromMotor {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Motor6D";
	/** The internal CFrame that is manipulated by Animations when a Motor6D is being animated. It is recommended to use this property for custom animations rather than `C0` and `C1`.

Transform is the transformation between the "parent" `part` and the "child" part. The "parent" part will always be the part that is more directly connected to the JointInstance.C0. This is not affected by which part is assigned to `Part0` and which is `Part1`. If the side the root part is on changes the interpretation of Transform will be inverted.

Similar to a `WeldJoint`, an active Motor6D will rigidly hold its two parts such that: 
`PartParent.CFrame * CParent * Transform == PartChild.CFrame * Child`The internal CFrame that is manipulated by Animations when a Motor6D is being animated. It is recommended to use this property for custom animations rather than `C0` and `C1`.

Transform is the transformation between the "parent" `part` and the "child" part. The "parent" part will always be the part that is more directly connected to the JointInstance.C0. This is not affected by which part is assigned to `Part0` and which is `Part1`. If the side the root part is on changes the interpretation of Transform will be inverted.

Similar to a `WeldJoint`, an active Motor6D will rigidly hold its two parts such that: 
`PartParent.CFrame * CParent * Transform == PartChild.CFrame * Child`

Tags: Hidden, NotReplicated */
	Transform: CFrame;
}

/** The Rotate object is used to allow rotation between two parts. Most commonly created through the Hinge SurfaceType on a `BasePart`. If created like this, the rotation will be about the normal vector from the face of the part the hinge is placed on. If created through a script the axis and point of rotation can be defined arbitrarily. */
interface Rotate extends RbxInternalJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Rotate";
}

/** A Snap object holds two objects rigidly together. Most commonly created when `MakeJoints` is called on parts where Inlet and Stud `SurfaceType` are touching. Functionally identical to `Weld`. */
interface Snap extends RbxInternalJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Snap";
}

/** The VelocityMotor is a special type of joint that works similarly to a `Motor`, but it uses a `MotorFeature` and a `Hole` to create the connection.

In order for this object to work correctly:

* The VelocityMotor must be parented inside of a `MotorFeature`

* The `MotorFeature` needs to be parented inside of a `BasePart`

* A `Hole` needs to be parented inside of another `BasePart`

* The VelocityMotor's `Hole` property should be assigned to the hole you parented inside of the other part. */
interface VelocityMotor extends RbxInternalJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VelocityMotor";
	/** Displays the angle that the motor is at in radians. */
	CurrentAngle: number;
	/** The desired angle to be reached. The motor will attempt to reach this angle. */
	DesiredAngle: number;
	/** The `Hole` linked to this VelocityMotor. */
	Hole?: Hole;
	/** The maximum amount of velocity able to be reached. */
	MaxVelocity: number;
}

/** The Weld object is used to hold two objects together in a relative position. They don't need to be touching.

## See also
 - `Weld Joints`, for more information on how to use `Welds` in your game.
 - `WeldConstraint`, for a newer alternative using the `constraints` system that does not require `C0` or `C1` properties to be manually set

## Code Samples

### Weld1

When instanced via a script, `/JointInstance/Part0` of the weld moves to match `/JointInstance/Part1`. The determination of JointInstance/Part0's `/BasePart/CFrame` can be described by the following equation:
```lua
weld.Part0.CFrame * weld.C0 = weld.Part1.CFrame * weld.C1
```
 */
interface Weld extends RbxInternalJointInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Weld";
}

/** The JointsService is a service that stores joints created by surface connections. It also has API available for visualizing surface to surface contact, and joining surfaces together. */
interface JointsService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "JointsService";
	/** Will remove any 'create joints' that were made visible via the `ShowPermissibleJoints` method. */
	ClearJoinAfterMoveJoints(): void;
	/** Updates all visible joints for the parts assigned by the `SetJoinAfterMoveTarget` and `SetJoinAfterMoveInstance` methods.
@returns No return. */
	CreateJoinAfterMoveJoints(): void;
	/** Sets the PVInstance that will be connected with the target PVInstance specified by [SetJoinAfterMoveTarget](https://developer.roblox.com/api-reference/function/JointsService/SetJoinAfterMoveTarget "SetJoinAfterMoveTarget")
. */
	SetJoinAfterMoveInstance(joinInstance: PVInstance): void;
	/** Sets the PVInstance that will be connected with the PVInstance specified by [SetJoinAfterMoveInstance](https://developer.roblox.com/api-reference/function/JointsService/SetJoinAfterMoveInstance "SetJoinAfterMoveInstance")
. */
	SetJoinAfterMoveTarget(joinTarget: PVInstance): void;
	/** When used it will visibly display a potential surface connection between the two `BasePart`, which were set with `SetJoinAfterMoveTarget` and `SetJoinAfterMoveInstance`. */
	ShowPermissibleJoints(): void;
}

interface KeyboardService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "KeyboardService";
}

/** A Keyframe holds the `Pose`s applied to joints in a `Model` at a given point of time in an animation. `Keyframe`s are interpolated between during animation playback.

Note, in most cases developers do not need to manipulate `KeyframeSequence`s as the animation editor covers most animation functionality. However, in some cases a developer may wish to generate an animation from a `Script` or build their own plugin.

**Structure**

Keyframes are held within a `KeyframeSequence` and contain `Pose` objects. The poses are named in accordance with the `BasePart`s they correspond to and are structured in terms of joint hierarchy. This means each `Pose` is parented to the `Pose` corresponding to the part it is attached to. See below for a visual example.

![][1]

Note, as `Pose`s are named in accordance with the `BasePart`s they correspond to, animations require distinct part names to play correctly. 


**Interpolation**

During animation playback the poses in different keyframes are interpolated between. This allows a smooth animation to be created without needing to define every frame. Note, the style of interpolation is determined in the `Pose` object. The Keyframe object merely holds the `Pose`s at a defined point of time in the animation (`Time`).

## Code Samples

### Keyframe Generate Poses

This sample includes a function that will generate a 'blank' keyframe containing blank poses for all of the model's connected parts in the correct hierarchical order.
```lua
    local function generateKeyframe(model)
    	if not model.PrimaryPart then
    		warn("No primary part set")
    		return
    	end
    	
    	local rootPart = model.PrimaryPart:GetRootPart()
    
    	if not rootPart then
    		warn("Root part not found")
    		return
    	end
    
    	local partsAdded = {}
    	partsAdded[rootPart] = true
    
    	local function addPoses(part, parentPose)
    		-- get all of the joints attached to the part 
    		for _, joint in pairs(part:GetJoints()) do
    			-- we're only interested in Motor6Ds
    			if joint:IsA("Motor6D") then
    				-- find the connected part
    				local connectedPart = nil
    				if joint.Part0 == part then 
    					connectedPart = joint.Part1
    				elseif joint.Part1 == part then 
    					connectedPart = joint.Part0
    				end	
    				if connectedPart then 	
    					-- make sure we haven't already added this part
    					if not partsAdded[connectedPart] then
    						partsAdded[connectedPart] = true
    						-- create a pose
    						local pose = Instance.new("Pose")
    						pose.Name = connectedPart.Name
    						parentPose:AddSubPose(pose)
    						-- recurse
    						addPoses(connectedPart, pose)
    					end
    				end			
    			end
    		end
    	end
    
    	local keyframe = Instance.new("Keyframe")
    
    	-- populate the keyframe
    	local rootPose = Instance.new("Pose")
    	rootPose.Name = rootPart.Name 
    	addPoses(rootPart, rootPose)
    	keyframe:AddPose(rootPose)
    
    	return keyframe
    end
```
 */
interface Keyframe extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Keyframe";
	/** This property gives the `Keyframe`'s time position (in seconds) in an animation. This determines the time at which the `Pose`s inside the keyframe will be shown.

Note the `Keyframe` with the highest time value in a `KeyframeSequence` is used to determine the length of the animation.

## Code Samples

### Get KeyframeSequence Length

This sample contains a simple function that will get the length of a KeyframeSequence by finding the Keyframe with the highest Keyframe.Time value.
```lua
local function getSequenceLength(keyframeSequence)
	local length = 0
	for _, keyframe in pairs(keyframeSequence:GetKeyframes()) do 
		if keyframe.Time > length then 
			length = keyframe.Time 
		end
	end
	return length
end
```
 */
	Time: number;
	/** This function adds a `KeyframeMarker` to the `Keyframe` by parenting it to the keyframe. It is functionally identical to setting the marker’s `Parent` to the Keyframe.

Note, this function will not error when an instance other than a KeyframeMarker is given as the parameter and will parent it successfully.

## More about Keyframes
`Keyframe` names do not need to be unique. For example, if an Animation has three keyframes named "Particles" the connected event returned by `GetMarkerReachedSignal` will fire each time one of these keyframes is reached.

`Keyframe` names can be set in the Roblox Animation Editor when creating or editing an animation. They cannot however be set by a `Script` on an existing animation prior to playing it.

## See also
 - `RemoveMarker`
 - `GetMarkers`
 - `GetMarkerReachedSignal`

## Code Samples

### Add Marker/Remove Marker

This example demonstrates the `AddMarker` and `RemoveMarker` functions. Note these are functionally equivalent to `parenting` and un-parenting the markers.
```lua
local keyframe = Instance.new("Keyframe", workspace)
local marker = Instance.new("KeyframeMarker")
marker.Name = "FootStep"
marker.Value = 100

keyframe:AddMarker(marker) --marker.Parent = keyframe

wait(2)

keyframe:RemoveMarker(marker) --marker.Parent = nil
```

@param marker The `KeyframeMarker` being parented to the `Keyframe`
@returns No return */
	AddMarker(marker: KeyframeMarker): void;
	/** This function adds a `Pose` to the `Keyframe` by parenting it to the keyframe. It is functionally identical to setting the pose's `Parent` to the keyframe.

Note, this function will not error when an instance other than a `Pose` is given as the pose parameter and will parent it successfully.

## Code Samples

### Keyframe Add/Remove Pose

This sample demonstrates quickly the Keyframe.AddPose, Keyframe.RemovePose and Pose.AddSubPose and Pose.RemoveSubPose functions. Note these are functionally equivalent to parenting and un-parenting the poses.
```lua
local keyframe = Instance.new("Keyframe", workspace)

local pose = Instance.new("Pose")
pose.EasingStyle = Enum.PoseEasingStyle.Cubic
pose.EasingDirection = Enum.PoseEasingDirection.Out
local pose2 = Instance.new("Pose")
pose2.EasingStyle = Enum.PoseEasingStyle.Cubic
pose2.EasingDirection = Enum.PoseEasingDirection.Out

keyframe:AddPose(pose) -- pose.Parent = keyframe

wait(2)

keyframe:RemovePose(pose) -- pose.Parent = nil 

wait(2)

keyframe:AddPose(pose) -- pose.Parent = keyframe

wait(2)

pose:AddSubPose(pose2) -- pose2.Parent = pose

wait(2)

pose:RemoveSubPose(pose2) -- pose2.Parent = nil
```

### Keyframe Generate Poses

This sample includes a function that will generate a 'blank' keyframe containing blank poses for all of the model's connected parts in the correct hierarchical order.
```lua
    local function generateKeyframe(model)
    	if not model.PrimaryPart then
    		warn("No primary part set")
    		return
    	end
    	
    	local rootPart = model.PrimaryPart:GetRootPart()
    
    	if not rootPart then
    		warn("Root part not found")
    		return
    	end
    
    	local partsAdded = {}
    	partsAdded[rootPart] = true
    
    	local function addPoses(part, parentPose)
    		-- get all of the joints attached to the part 
    		for _, joint in pairs(part:GetJoints()) do
    			-- we're only interested in Motor6Ds
    			if joint:IsA("Motor6D") then
    				-- find the connected part
    				local connectedPart = nil
    				if joint.Part0 == part then 
    					connectedPart = joint.Part1
    				elseif joint.Part1 == part then 
    					connectedPart = joint.Part0
    				end	
    				if connectedPart then 	
    					-- make sure we haven't already added this part
    					if not partsAdded[connectedPart] then
    						partsAdded[connectedPart] = true
    						-- create a pose
    						local pose = Instance.new("Pose")
    						pose.Name = connectedPart.Name
    						parentPose:AddSubPose(pose)
    						-- recurse
    						addPoses(connectedPart, pose)
    					end
    				end			
    			end
    		end
    	end
    
    	local keyframe = Instance.new("Keyframe")
    
    	-- populate the keyframe
    	local rootPose = Instance.new("Pose")
    	rootPose.Name = rootPart.Name 
    	addPoses(rootPart, rootPose)
    	keyframe:AddPose(rootPose)
    
    	return keyframe
    end
```

@param pose The `Pose` to be added. */
	AddPose(pose: Pose): void;

	GetMarkers(): Array<Instance>;
	/** This function returns an array containing all `Poses` that have been added to a `Keyframe`.

## Code Samples

### Keyframe Reset Poses

This code sample includes a function to reset the CFrame of the Poses in a Keyframe.
```lua
    local function resetPoses(parent)
    	-- both functions are equivalent to GetChildren
    	local poses = parent:IsA("Keyframe") and parent:GetPoses() 
    		or parent:IsA("Pose") and parent:GetSubPoses()
    
    	for _, pose in pairs(poses) do 
    		if pose:IsA("Pose") then
    			pose.CFrame = CFrame.new()
    			-- recurse
    			resetPoses(pose)
    		end
    	end
    end
```

@returns An array of `Pose`s. */
	GetPoses(): Array<Pose>;

	RemoveMarker(marker: KeyframeMarker): void;
	/** This function removes a `Pose` from the `Keyframe` by setting its `Parent` to nil. 

The `Pose`'s `Parent` is set to nil, but it is not destroyed. This means, provided the pose is referenced it can be re-parented later.

Note, this function will not error when an instance other than a `Pose` is given as the pose parameter.

## Code Samples

### Keyframe Add/Remove Pose

This sample demonstrates quickly the Keyframe.AddPose, Keyframe.RemovePose and Pose.AddSubPose and Pose.RemoveSubPose functions. Note these are functionally equivalent to parenting and un-parenting the poses.
```lua
local keyframe = Instance.new("Keyframe", workspace)

local pose = Instance.new("Pose")
pose.EasingStyle = Enum.PoseEasingStyle.Cubic
pose.EasingDirection = Enum.PoseEasingDirection.Out
local pose2 = Instance.new("Pose")
pose2.EasingStyle = Enum.PoseEasingStyle.Cubic
pose2.EasingDirection = Enum.PoseEasingDirection.Out

keyframe:AddPose(pose) -- pose.Parent = keyframe

wait(2)

keyframe:RemovePose(pose) -- pose.Parent = nil 

wait(2)

keyframe:AddPose(pose) -- pose.Parent = keyframe

wait(2)

pose:AddSubPose(pose2) -- pose2.Parent = pose

wait(2)

pose:RemoveSubPose(pose2) -- pose2.Parent = nil
```

@param pose The `Pose` to be removed. */
	RemovePose(pose: Pose): void;
}

/** A KeyframeMarker is an instance meant to represent an event that will eventually be fired when a `Keyframe` is hit. 

## Using a KeyframeMarker
KeyframeMarkers should always be parented to a Keyframe via setting the parent directly or using the `AddMarker` function of Keyframe. KeyframeMarkers can also be removed directly or using the `RemoveMarker` function, and polled to check which markers are attached to a specific Keyframe using `GetMarkers`.

Whenever a Keyframe is detected as an animation is running, there will be an event fired for each KeyframeMarker that is parented to the Keyframe. These events are identifiable by the name of the KeyframeMarker. You can retrieve and listen to these events using the `GetKeyframeMarkerReached` function. Optionally, you may set the `Value` property of the KeyframeMarker in order to pass along a value with the event being fired. 

It inherits the `Keyframe.Name` property from `Instance` and behaves identically. Names are used for identification and no not need to be unique. When multiple KeyFrameMarkers with the same name are attached to a KeyFrame, events such as the one returned by `GetMarkerReachedSignal` will fire for every marker.

## See also
 - `Keyframe`,  holds the `Poses` applied to joints in a `Model` at a given point of time in an animation
 - `AnimationTrack`, controls the playback of an animation on a `Humanoid` or `AnimationController`
 - `Animation`, holds a reference to animation data required to play custom animations on characters or other models using the Roblox animation system

## Code Samples

### Get Keyframe Markers Attached to a Keyframe

This example demonstrates the `AddMarker` and `GetMarkers` functions. After adding two markers, *marker1* and *marker2* to the keyframe, this example gets and prints the names of the added markers.
```lua
local keyframe = Instance.new("Keyframe", workspace)

local marker1 = Instance.new("KeyframeMarker")
marker1.Name = "FootStep"
marker1.Value = 100

local marker2 = Instance.new("KeyframeMarker")
marker2.Name = "Wave"
marker3.Value = 100

keyframe:AddMarker(marker1) --marker.Parent = keyframe
keyframe:AddMarker(marker2) --marker.Parent = keyframe

local markers = keyframe:GetMarkets()
for _, marker in pairs (markers) do
	print(marker.Name)
end
```

### Listening to KeyFrameMarkers

The following example plays an animation on the local `character` and prints a value whenever a `Keyframe` that has a `KeyframeMarker` named *“FootStep”* gets hit in the `animation`. 

The example listens to when the KeyFrame is hit by connecting the function *markerReached* to the event returned by `GetKeyframeReachedSignal`, which fires whenever the KeyFrameMarker named *"FootStep"* gets hit.

In order for this to work as expected, it should be placed in a `LocalScript` in `StarterGui`.
```lua
local player = game.Players:GetChildren()[1]
local character = game.Workspace:WaitForChild(player.Name)
local humanoid = character:WaitForChild("Humanoid")
 
local anim = Instance.new("Animation")
anim.AnimationId = "rbxassetid://437855404"
local animTrack = humanoid:LoadAnimation(anim)
 
animTrack:GetKeyframeReachedSignal("FootStep"):Connect(function(value)
    print(value)
end)
animTrack:Play()
```
 */
interface KeyframeMarker extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "KeyframeMarker";
	/** A value that is specified for a `KeyframeMarker`. Whenever the signal created from `GetMarkerReachedSignal` gets fired, this value will be passed into the connected function.

## See also
 - `Keyframe`,  holds the `Poses` applied to joints in a `Model` at a given point of time in an animation
 - `AnimationTrack`, controls the playback of an animation on a `Humanoid` or `AnimationController`

## Code Samples

### Get Keyframe Markers Attached to a Keyframe

This example demonstrates the `AddMarker` and `GetMarkers` functions. After adding two markers, *marker1* and *marker2* to the keyframe, this example gets and prints the names of the added markers.
```lua
local keyframe = Instance.new("Keyframe", workspace)

local marker1 = Instance.new("KeyframeMarker")
marker1.Name = "FootStep"
marker1.Value = 100

local marker2 = Instance.new("KeyframeMarker")
marker2.Name = "Wave"
marker3.Value = 100

keyframe:AddMarker(marker1) --marker.Parent = keyframe
keyframe:AddMarker(marker2) --marker.Parent = keyframe

local markers = keyframe:GetMarkets()
for _, marker in pairs (markers) do
	print(marker.Name)
end
```

### Add Marker/Remove Marker

This example demonstrates the `AddMarker` and `RemoveMarker` functions. Note these are functionally equivalent to `parenting` and un-parenting the markers.
```lua
local keyframe = Instance.new("Keyframe", workspace)
local marker = Instance.new("KeyframeMarker")
marker.Name = "FootStep"
marker.Value = 100

keyframe:AddMarker(marker) --marker.Parent = keyframe

wait(2)

keyframe:RemoveMarker(marker) --marker.Parent = nil
```
 */
	Value: string;
}

/** This object stores all the `Keyframe`s for an animation, determines if the animation is looped, and determines its priority against other animations. 

## What is a Keyframe Sequence?

The animation data Roblox uses in the playback of an animation, referenced by the `AnimationId` property, is constructed from a KeyframeSequence. Every animation has a KeyframeSequence associated with it. KeyframeSequences are usually created by the Roblox Animation Editor but can be created through other plugins or even manually. Once uploaded to Roblox, their Content ID is used for the `AnimationId` property.

Note, in most cases developers do not need to manipulate KeyframeSequences as the animation editor covers most animation functionality. However, in some cases a developer may wish to generate an animation from a `Script` or build their own plugin.

## KeyframeSequence Properties

The priority and looped animation settings are set by `Priority` and `Loop`. Note these can be eventually overwritten by the `AnimationTrack` properties.

The length of an animation is determined by the last `Keyframe` in the sequence, meaning the `Keyframe` with the highest `Time` property.

## KeyframeSequence Structure

KeyframeSequences are a container that hold `Keyframe`s. Keyframes represent a 'key' frame in the animation, that are interpolated between during playback.

Keyframes contain `Pose`s. `Pose`s are specific to each `BasePart` being animated and contain the `CFrame` applied to the `Motor6D` connecting to the part. Poses are named according to the `BasePart` they correspond with. For this reason, animations require distinct part names to play correctly. 


Poses are structured based on joint hierarchy. Each `Pose` is parented to the `Pose` corresponding to the part it is attached to. In practice, this means the poses branch out from the root part. See below for a visual example.

![][1]

## Using KeyframeSequences when making animations

KeyframeSequences must be first uploaded to Roblox before they can be played. This can be done by right clicking on the KeyframeSequence and clicking 'Save to Roblox'. Alternatively, `SaveSelectedToRoblox` can be used. This will bring up the animation upload window.

In some cases, a developer may want to preview an Animation before uploading it to the Roblox site. This can be achieved by generating a temporary id using `RegisterKeyframeSequence`. This will generate a hash id that can be used for localized animation testing.

## Obtaining KeyframeSequences

In some cases the developer may wish to download the KeyframeSequence corresponding to an existing uploaded Animation. This can be done so using `GetKeyframeSequenceAsync`.

## Code Samples

### KeyframeSequence Instantiation

This sample demonstrates how a basic KeyframeSequence can be created.
```lua
-- create the keyframesequence
local keyframeSequence = Instance.new("KeyframeSequence")
keyframeSequence.Loop = false
keyframeSequence.Priority = Enum.AnimationPriority.Action

--  create a keyframe
local keyframe = Instance.new("Keyframe")
keyframe.Time = 0

-- create sample poses
local rootPose = Instance.new("Pose")
rootPose.Name = "HumanoidRootPart"
rootPose.Weight = 0

local lowerTorsoPose = Instance.new("Pose")
lowerTorsoPose.Name = "LowerTorso"
lowerTorsoPose.Weight = 1

-- set the sequence hierarchy
rootPose:AddSubPose(lowerTorsoPose) -- lowerTorsoPose.Parent = rootPose
keyframe:AddPose(rootPose) -- rootPose.Parent = keyframe
keyframeSequence:AddKeyframe(keyframe) -- keyframe.Parent = keyframeSequence

-- parent the sequence 
keyframeSequence.Parent = workspace

```

### Create temporary animation

This code sample contains a simple function to generate an Animation with a generated hash ID to preview a KeyframeSequence locally.
```lua
    local KeyframeSequenceProvider = game:GetService("KeyframeSequenceProvider")
    
    local function createPreviewAnimation(keyframeSequence)
    	local hashId = KeyframeSequenceProvider:RegisterKeyframeSequence(keyframeSequence) 
    	if hashId then 
    		local Animation = Instance.new("Animation")
    		Animation.AnimationId = hashId
    		return Animation
    	end
    end
```

### Get KeyframeSequence Length

This sample contains a simple function that will get the length of a KeyframeSequence by finding the Keyframe with the highest Keyframe.Time value.
```lua
local function getSequenceLength(keyframeSequence)
	local length = 0
	for _, keyframe in pairs(keyframeSequence:GetKeyframes()) do 
		if keyframe.Time > length then 
			length = keyframe.Time 
		end
	end
	return length
end
```
 */
interface KeyframeSequence extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "KeyframeSequence";
	/** Determines whether the animation created from the `KeyframeSequence` will be looped. When set to true the animation will continuously repeat each time the animation finishes.

When an `AnimationTrack` has been created from an `Animation`, its `Looped` property will default to the original `KeyframeSequence` value. Note this value can be overwritten.

## Code Samples

### KeyframeSequence Instantiation

This sample demonstrates how a basic KeyframeSequence can be created.
```lua
-- create the keyframesequence
local keyframeSequence = Instance.new("KeyframeSequence")
keyframeSequence.Loop = false
keyframeSequence.Priority = Enum.AnimationPriority.Action

--  create a keyframe
local keyframe = Instance.new("Keyframe")
keyframe.Time = 0

-- create sample poses
local rootPose = Instance.new("Pose")
rootPose.Name = "HumanoidRootPart"
rootPose.Weight = 0

local lowerTorsoPose = Instance.new("Pose")
lowerTorsoPose.Name = "LowerTorso"
lowerTorsoPose.Weight = 1

-- set the sequence hierarchy
rootPose:AddSubPose(lowerTorsoPose) -- lowerTorsoPose.Parent = rootPose
keyframe:AddPose(rootPose) -- rootPose.Parent = keyframe
keyframeSequence:AddKeyframe(keyframe) -- keyframe.Parent = keyframeSequence

-- parent the sequence 
keyframeSequence.Parent = workspace

```
 */
	Loop: boolean;
	/** Determines the default priority of an animation created from the `KeyframeSequence`. Depending on what this is set to, playing multiple animations at once will look to this property to figure out which `Keyframe` `Poses` should be played over one another.

When an `AnimationTrack` has been created from an `Animation`, its `Priority` property will default to the original `KeyframeSequence` value. Note this value can be overwritten.

## Code Samples

### KeyframeSequence Instantiation

This sample demonstrates how a basic KeyframeSequence can be created.
```lua
-- create the keyframesequence
local keyframeSequence = Instance.new("KeyframeSequence")
keyframeSequence.Loop = false
keyframeSequence.Priority = Enum.AnimationPriority.Action

--  create a keyframe
local keyframe = Instance.new("Keyframe")
keyframe.Time = 0

-- create sample poses
local rootPose = Instance.new("Pose")
rootPose.Name = "HumanoidRootPart"
rootPose.Weight = 0

local lowerTorsoPose = Instance.new("Pose")
lowerTorsoPose.Name = "LowerTorso"
lowerTorsoPose.Weight = 1

-- set the sequence hierarchy
rootPose:AddSubPose(lowerTorsoPose) -- lowerTorsoPose.Parent = rootPose
keyframe:AddPose(rootPose) -- rootPose.Parent = keyframe
keyframeSequence:AddKeyframe(keyframe) -- keyframe.Parent = keyframeSequence

-- parent the sequence 
keyframeSequence.Parent = workspace

```
 */
	Priority: Enum.AnimationPriority;
	/** This function adds a `Keyframe` to the `KeyframeSequence` by parenting it to the `KeyframeSequence`. It is functionally identical to setting the `Keyframe`'s `Parent` to the `KeyframeSequence`.

Note, this function will not error when an instance other than a `Keyframe` is given as the keyframe parameter and will parent it successfully.

## Code Samples

### KeyframeSequence Instantiation

This sample demonstrates how a basic KeyframeSequence can be created.
```lua
-- create the keyframesequence
local keyframeSequence = Instance.new("KeyframeSequence")
keyframeSequence.Loop = false
keyframeSequence.Priority = Enum.AnimationPriority.Action

--  create a keyframe
local keyframe = Instance.new("Keyframe")
keyframe.Time = 0

-- create sample poses
local rootPose = Instance.new("Pose")
rootPose.Name = "HumanoidRootPart"
rootPose.Weight = 0

local lowerTorsoPose = Instance.new("Pose")
lowerTorsoPose.Name = "LowerTorso"
lowerTorsoPose.Weight = 1

-- set the sequence hierarchy
rootPose:AddSubPose(lowerTorsoPose) -- lowerTorsoPose.Parent = rootPose
keyframe:AddPose(rootPose) -- rootPose.Parent = keyframe
keyframeSequence:AddKeyframe(keyframe) -- keyframe.Parent = keyframeSequence

-- parent the sequence 
keyframeSequence.Parent = workspace

```

@param keyframe The `Keyframe` to be added. */
	AddKeyframe(keyframe: Keyframe): void;
	/** This function returns an array containing all `Keyframe`s that have been added to a `KeyframeSequence`. This is functionally the same as using the `GetChildren` function on the `KeyframeSequence`.

Note, this function will return all children of the `KeyframeSequence`, including non `Keyframe`s if any are present.

## Code Samples

### Get KeyframeSequence Length

This sample contains a simple function that will get the length of a KeyframeSequence by finding the Keyframe with the highest Keyframe.Time value.
```lua
local function getSequenceLength(keyframeSequence)
	local length = 0
	for _, keyframe in pairs(keyframeSequence:GetKeyframes()) do 
		if keyframe.Time > length then 
			length = keyframe.Time 
		end
	end
	return length
end
```

@returns An array of `Keyframe`s */
	GetKeyframes(): Array<Keyframe>;
	/** This function removes a `Keyframe` from the `KeyframeSequence` by setting its parent to nil. It is functionally identical to setting the keyframe's parent to nil

The `Keyframe`'s parent is set to nil, but it is not destroyed. This means, provided the keyframe is referenced it can be re-parented later.

Note, this function will not error when an `Instance` other than a `Keyframe` is given as the keyframe parameter.

## Code Samples

### KeyframeSequence RemoveKeyframe

This sample adds a Keyframe to a KeyframeSequence before removing it and adding it again. Note that once a Keyframe is removed it is not destroyed, meaning it can be re-added later.
```lua
-- create the keyframesequence
local keyframeSequence = Instance.new("KeyframeSequence")
keyframeSequence.Parent = workspace 

-- create a keyframe
local keyframe = Instance.new("Keyframe")

-- add the keyframe 
keyframeSequence:AddKeyframe(keyframe)

wait(2)

-- remove the keyframe 
keyframeSequence:AddKeyframe(keyframe)


```

@param keyframe The `Keyframe` to be removed. */
	RemoveKeyframe(keyframe: Keyframe): void;
}

/** The KeyframeSequenceProvider is a service that is used to load and preview `KeyframeSequence`s. It includes a number of functions that are useful when working with `Animation`s.

## What is a KeyframeSequence?

The animation data Roblox uses in the playback of an animation, referenced by the `AnimationId` property, is constructed from a `KeyframeSequence`. Every animation has a `KeyframeSequence` associated with it. `KeyframeSequence`s are usually created by the Roblox Animation Editor but can be created through other plugins or even manually.

For more information, see the `KeyframeSequence` page.

## What does the KeyframeSequenceProvider do?

The KeyframeSequenceProvider has a number of uses. 

 - Download the `KeyframeSequence` associated with an animation content ID from the Roblox website
 - Generate a temporary id to locally preview an animation
 - Fetch the content IDs of animations owned by a particular user.

## Code Samples

### Create temporary animation

This code sample contains a simple function to generate an Animation with a generated hash ID to preview a KeyframeSequence locally.
```lua
    local KeyframeSequenceProvider = game:GetService("KeyframeSequenceProvider")
    
    local function createPreviewAnimation(keyframeSequence)
    	local hashId = KeyframeSequenceProvider:RegisterKeyframeSequence(keyframeSequence) 
    	if hashId then 
    		local Animation = Instance.new("Animation")
    		Animation.AnimationId = hashId
    		return Animation
    	end
    end
```
 */
interface KeyframeSequenceProvider extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "KeyframeSequenceProvider";
	/** Generates a temporary asset ID from a `KeyframeSequence` that can be used for localized testing of an animation.

This function performs the same function to `RegisterKeyframeSequence` however this function generates an *active:/ URL instead of a hash.

The ID generated can be used in an `Animation`'s `AnimationId` property for testing.

The asset ID generated by this function is temporary and cannot be used outside of Studio. Developers wishing to generate an asset ID that can be used online should upload the `KeyframeSequence` to Roblox.

## Code Samples

### Create temporary animation

This code sample contains a simple function to generate an Animation with a generated hash ID to preview a KeyframeSequence locally.
```lua
    local KeyframeSequenceProvider = game:GetService("KeyframeSequenceProvider")
    
    local function createPreviewAnimation(keyframeSequence)
    	local hashId = KeyframeSequenceProvider:RegisterKeyframeSequence(keyframeSequence) 
    	if hashId then 
    		local Animation = Instance.new("Animation")
    		Animation.AnimationId = hashId
    		return Animation
    	end
    end
```

@param keyframeSequence The `KeyframeSequence` to be used.
@returns A temporary asset ID generated for localized animation playback. */
	RegisterActiveKeyframeSequence(keyframeSequence: KeyframeSequence): string;
	/** Generates a temporary asset ID from a `KeyframeSequence` that can be used for localized testing of an animation.

This function performs the same function to `RegisterActiveKeyframeSequence` however this function generates a hash instead of an *active:/ URL.

The ID generated can be used for the `AnimationId` property to test animations.

The asset ID generated by this function is temporary and cannot be used outside of Studio. Developers wishing to generate an asset ID that can be used online should upload the `KeyframeSequence` to Roblox.

## Code Samples

### KeyframeSequenceProvider:RegisterKeyframeSequence


```lua

local asset = game:GetService("KeyframeSequenceProvider"):RegisterKeyframeSequence(workspace.KeyframeSequence)
local animation = Instance.new("Animation",workspace)
animation.Name = "TestAnimation"
animation.AnimationId = asset

```

@param keyframeSequence The `KeyframeSequence` to be used.
@returns A temporary asset ID generated for localized animation playback. */
	RegisterKeyframeSequence(keyframeSequence: KeyframeSequence): string;
	/** This function returns an `InventoryPages` object which can be used to iterate over animations owned by a specific user.

This function has a number of potential uses, such as allowing users to browse and import animations into a custom animation plugin.

## Code Samples

### KeyframeSequenceProvider GetAnimations

This code sample includes a demonstration of how the content IDs of animations belonging to a player can be downloaded using `GetAnimations`. To run this code be sure to change the *USER_ID* variable to the ID of the user whose animations you want to download.
```lua
local KeyframeSequenceProvider = game:GetService("KeyframeSequenceProvider")

local USER_ID = 0 -- Insert your UserId here

local function extractPages(pagesObject)
    local array = {}
    while true do 
        local thisPage = pagesObject:GetCurrentPage()
        for _, v in pairs(thisPage) do 
            table.insert(array, v)
        end
        if pagesObject.IsFinished then
            break 
        end 
        pagesObject:AdvanceToNextPageAsync()
    end
    return array
end

local inventoryPages = KeyframeSequenceProvider:GetAnimations(USER_ID)

local animationIds = extractPages(inventoryPages)

for _, id in pairs(animationIds) do 
    print(id)
end
print("total: ", #animationIds)
```

@param userId The user ID of the user.
@returns An `InventoryPages` of animations. */
	GetAnimations(userId: number): InventoryPages;
	/** GetKeyframeSequenceAsync returns a `KeyframeSequence` based on the specified assetId. The assetId must correspond to an animation. The function will yield until the `KeyframeSequence` is loaded from the website. Because this is a webcall it should wrapped in a pcall.

## Code Samples

### KeyframeSequenceProvider:GetKeyframeSequenceAsync


```lua

local KeyframeSequence = game:GetService("KeyframeSequenceProvider")
local animation = "rbxassetid://507771019"
local keyframes = {}
local success = pcall(function()
	keyframes = KeyframeSequence:GetKeyframeSequenceAsync(animation)
end)
if success then
	local keyframeTable = keyframes:GetKeyframes()
	for key,value in ipairs(keyframeTable) do
		print("The time of keyframe number",key,"is",value.Time)
	end
else
	print("error getting KeyframeSequence")
end
```

@param assetId The content ID of the animation.
@returns The `KeyframeSequence` found. */
	GetKeyframeSequenceAsync(assetId: string): KeyframeSequence;
}

interface RbxInternalLight extends RbxInternalInstance {
	/** Sets how bright the emitted light is, defaults to 1. */
	Brightness: number;
	/** The color of the emitted light. */
	Color: Color3;
	/** If set to true, light will be emitted from the source object. */
	Enabled: boolean;
	/** If set to true, will project shadows if light is blocked by an obstacle. */
	Shadows: boolean;
}
/** Light is a root class for dynamic lighting related objects. */
type Light = PointLight | SpotLight | SurfaceLight;

/** A PointLight is a light source that emits illumination from a single point. Light is emitted spherically based on the `Range` of the PointLight.

In order for a PointLight to provide illumination, it must be the direct child of a `BasePart` or `Attachment` (the part or attachment itself must be a descendant of the `Workspace`).

If a PointLight is parented to a part, then the light will emanate from the part’s `Position`. If a PointLight is parented to an attachment, then the light will emanate from the attachment’s `WorldPosition`.

For more light types, see the **see also** section.

See Also
----------

 - `SurfaceLight`
 - `SpotLight`

## Code Samples

### Creating a New Point Light

This example creates a new anchored `BasePart` named *Part* at the position `{0, 0, 0}`.

It then creates a new point light with `brightness` of 1, `Color3` `color` of `{255/255, 255/255, 255/255}` (white) and `range` of 16 studs. The point light's parent is set to the BasePart we created. To view the light, navigate to the part at `{0, 0, 0}` or move the *Part* created to a location visible to the player.

Please note that the properties of the created point light can easily be changed by modifying the property values in the code sample below. Additionally, if you have an existing point light, you can also create a similar script that modifies that light instead of creating a new BasePart and light.
```lua
-- Create a new BasePart
local part = Instance.new("Part")
part.Parent = game.Workspace
part.Anchored = true
part.Position = Vector3.new(0,0,0)

-- Create a new PointLight
local light = Instance.new("PointLight")
light.Color = Color3.new(255/255, 255/255, 255/255)
light.Brightness = 1
light.Range = 16
light.Parent = part
```
 */
interface PointLight extends RbxInternalLight {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PointLight";
	/** The size of the area that the PointLight will illuminate. */
	Range: number;
}

/** A SpotLight is a light source that emits illumination of a specified `Color` and `Brightness`. It is emitted from a `Face` in the shape of a spherical cone with an apex `Angle`, and a radius `Range`.

In order for a spotlight to provide illumination, it must be the direct child of a `BasePart` or `Attachment` (the part or attachment itself must be a descendant of the Workspace). If a spotlight is parented to a part, then the light will emanate from the part’s `Position`. 

The face of the spotlight will cause the light to emanate from the corresponding face on the part. If a spotlight is parented to an attachment, then the light will emanate from the attachment’s `WorldPosition`. Even though attachments don’t have faces, the face property of the spotlight will cause light to emanate along the x corresponding axis of the attachment (`-z` is front, `+x` is right, `+y` is top, etc).

This shows the dimensions of the ice cream cone-shaped spotlight:


For more light types, see the **see also** section.

See Also
----------

 - `SurfaceLight`
 - `PointLight` */
interface SpotLight extends RbxInternalLight {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SpotLight";
	/** The angle of which the light is shone from the SpotLight. */
	Angle: number;
	/** Sets the side of the parent that the SpotLight comes from. */
	Face: Enum.NormalId;
	/** The size of the area that the SpotLight will illuminate. */
	Range: number;
}

/** A SurfaceLight is a light source that emits illumination of a specified `Color` and `Brightness` from a `Face` for a specified `Range`. 

In order for a SurfaceLight to provide illumination, it must be the direct child of a `BasePart` or `Attachment` (the part or attachment itself must be a descendant of the Workspace). If a SurfaceLight is parented to a part, then the light will emanate from the part’s selected face(s). If parented to an attachment SurfaceLight is equivalent to a `SpotLight`. 



For more light types, please see the **see also** section.

See Also
----------

 - `PointLight`
 - `SpotLight` */
interface SurfaceLight extends RbxInternalLight {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SurfaceLight";
	/** The angle of which the light is shone from the SurfaceLight. */
	Angle: number;
	/** Sets the side of the parent that the SurfaceLight comes from. */
	Face: Enum.NormalId;
	/** The distance from the SurfaceLight's face that will illuminate. */
	Range: number;
}

/** The Lighting service controls the environmental lighting in a game. It includes a range of adjustable properties that can be used to change how lighting appears and interacts with other objects.

Developers can change the color and appearance of lighting in their place using properties such as `Ambient` and `OutdoorAmbient`.

In addition to controlling environmental lighting, the Lighting service also configures any fog in the game using the `FogColor`, `FogStart` and `FogEnd` properties.

Lighting, along with `CurrentCamera`, is one of the two places where `PostEffect`s such as the `SunRaysEffect` and `BlurEffect` are displayed once parented to.

## Notes

 - Lighting only controls environmental lighting and not dynamic light objects such as the `PointLight`
 - Prior to the introduction of `ServerStorage` and `ReplicatedStorage` lighting was used for storage. This behavior is not supported and should not be used in new work

## Code Samples

### Day/Night Cycle

This code sample includes a simple day/night cycle script. The speed time goes at and the initial time can be changed using the TIME_SPEED and START_TIME parameters.
```lua
local Lighting = game:GetService("Lighting")

-- constants
local TIME_SPEED = 60 -- 1 min = 1 hour
local START_TIME = 9 -- 9am
--

local minutesAfterMidnight = START_TIME * 60
local waitTime = 60 / TIME_SPEED

while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	Lighting:SetMinutesAfterMidnight(minutesAfterMidnight)

	wait(waitTime)
end


```
 */
interface Lighting extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Lighting";
	/** The lighting hue applied to areas that are occluded from the sky, such as indoor areas.

This property defaults to 0, 0, 0 (black).

As long as the red, green and blue channels of this property do not exceed the corresponding channels in `OutdoorAmbient` the change in hue will be reserved for areas occluded from the sun/moon. The effective `OutdoorAmbient` value is clamped to be greater than or equal to Ambient in all channels. This means, if a channel of Ambient exceeds its corresponding `OutdoorAmbient` channel then the hue will begin to apply to outdoor areas. For a visual demonstration of this, please see the images below.

![enter image description here](https://developer.roblox.com/assets/blt6e6c67086eab8c57/Ambient.png)

Note, when `GlobalShadows` is disabled there is no distinction between areas occluded and areas that are not. In this case `OutdoorAmbient` will be ignored and the hue from the Ambient property will be applied everywhere.

For more properties that influence the color of lighting, please see `ColorShift_Bottom` and `ColorShift_Top`. */
	Ambient: Color3;
	/** The intensity of illumination in the place.

Changing this value will influence the impact of the light source (sun or moon) on the map's lighting. When brightness is set to 0, there will be no effect due to `ColorShift_Top` or `ColorShift_Bottom` as the light source is having no effect. Note, it will not influence the shadows created by the `GlobalShadows` property.

Whilst this property is not clamped, the effect is clamped between 0 and 2. Meaning setting Brightness to 10 will be no different to setting it to 2.

Note, `Ambient` and `OutdoorAmbient` can also be used to influence how bright a place appears. For example, setting `OutdoorAmbient` to 255, 255, 255 will make the place appear brighter than its default value of 127, 127, 127 (as it is more white). */
	Brightness: number;
	/** A numerical representation (in hours) of the current time of day used by `Lighting`.

Note, this property does not correspond with the actual time of day and will not change during the game unless it has been changed by a script.

For a measure of `Lighting`'s time formatted as a 24 hour string use `CurrentTime`. Changing `CurrentTime` or using `SetMinutesAfterMidnight` will also change this property.

Using ClockTime requires the time to be normalized:
```lua
minutesAfterMidnight = 0
while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	local minutesNormalised = minutesAfterMidnight % (60 * 24)
	local hours = minutesNormalised / 60

	Lighting.ClockTime = hours

	wait()
end
```


Using `TimeOfDay` requires the time to be normalized and a string formatted:
```lua
minutesAfterMidnight = 0
while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	local minutesNormalised = minutesAfterMidnight % (60 * 24)
	local seconds = minutesNormalised * 60
	local hours = string.format("%02.f", math.floor(seconds/3600))
	local mins = string.format("%02.f", math.floor(seconds/60 - (hours*60)))
	local secs = string.format("%02.f", math.floor(seconds - hours*3600 - mins *60))
	local timeString = hours..":"..mins..":"..secs

	Lighting.TimeOfDay = timeString

	wait()
end
```


Using `SetMinutesAfterMidnight` requires no extra processing:
```lua
minutesAfterMidnight = 0
while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	Lighting:SetMinutesAfterMidnight(minutesAfterMidnight)

	wait()
end
```A numerical representation (in hours) of the current time of day used by `Lighting`.

Note, this property does not correspond with the actual time of day and will not change during the game unless it has been changed by a script.

For a measure of `Lighting`'s time formatted as a 24 hour string use `CurrentTime`. Changing `CurrentTime` or using `SetMinutesAfterMidnight` will also change this property.

Using ClockTime requires the time to be normalized:
```lua
minutesAfterMidnight = 0
while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	local minutesNormalised = minutesAfterMidnight % (60 * 24)
	local hours = minutesNormalised / 60

	Lighting.ClockTime = hours

	wait()
end
```


Using `TimeOfDay` requires the time to be normalized and a string formatted:
```lua
minutesAfterMidnight = 0
while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	local minutesNormalised = minutesAfterMidnight % (60 * 24)
	local seconds = minutesNormalised * 60
	local hours = string.format("%02.f", math.floor(seconds/3600))
	local mins = string.format("%02.f", math.floor(seconds/60 - (hours*60)))
	local secs = string.format("%02.f", math.floor(seconds - hours*3600 - mins *60))
	local timeString = hours..":"..mins..":"..secs

	Lighting.TimeOfDay = timeString

	wait()
end
```


Using `SetMinutesAfterMidnight` requires no extra processing:
```lua
minutesAfterMidnight = 0
while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	Lighting:SetMinutesAfterMidnight(minutesAfterMidnight)

	wait()
end
```

Tags: NotReplicated */
	ClockTime: number;
	/** The hue represented in light reflected in the opposite surfaces to those facing the sun or moon.

The surfaces of a `BasePart` influenced by ColorShift_Bottom depends on the position and orientation of the `BasePart` relative to the sun or moon's position. Where the sun is directly overhead a `BasePart`, the shift in color will only apply to the bottom surface.

This effect can be increased or reduced by altering `Brightness`.

ColorShift_Bottom influences the opposite surfaces to `ColorShift_Top`. For a visual demonstration of this, please see the image below.

![enter image description here](https://developer.roblox.com/assets/blt6316b01e497fa7aa/ColorShift.png)

Note, `ColorShift_Top` and ColorShift_Bottom will interact with the `Ambient` and `OutdoorAmbient` properties if they are greater than 0, 0, 0. Also, the influence of ColorShift_Bottom can be very hard to identify when `GlobalShadows` is enabled (as it is by default). */
	ColorShift_Bottom: Color3;
	/** The hue represented in light reflected from surfaces facing the sun or moon.

The surfaces of a `BasePart` influenced by ColorShift_Top depends on the position and orientation of the `BasePart` relative to the sun or moon's position. Where the sun is directly overhead a `BasePart`, the shift in color will only apply to the top surface.

This effect can be increased or reduced by altering `Brightness`.

Whilst ColorShift_Top influences surfaces exposed to light, `ColorShift_Bottom` influences surfaces sheltered from light. For a visual demonstration of this, please see the image below.

![enter image description here](https://developer.roblox.com/assets/blt6316b01e497fa7aa/ColorShift.png)

Note, ColorShift_Top and `ColorShift_Bottom` will interact with the `Ambient` and `OutdoorAmbient` properties if they are greater than 0, 0, 0. */
	ColorShift_Top: Color3;
	/** This property determines the exposure compensation amount which applies a bias to the exposure level of the scene prior to the tonemap step. Defaults to 0.


  - A value of +1 indicates twice as much exposure and -1 means half as much exposure.
  - A value of 0 indicates no exposure compensation will be done.
  - Range: -5 to 5

This property is replicated and can be set from scripts or `Studio`.

```lua
lua
local Lighting = game:GetService(“Lighting”)
Lighting.ExposureCompensation = 5
```


You can use this property to adjust the exposure amount prior to the tonemap step to show more detail either in lighter or darker areas. This is needed as we move to a HDR pipeline.

When `Technology` is set to `Legacy`, this property has no effect.

```lua
lua
local Lighting = game:GetService(“Lighting”)

-- ExposureCompensation has no effect because Lighting’s Technology is Legacy
Lighting.Technology = Enum.Technology.Legacy
Lighting.ExposureCompensation = 5
``` */
	ExposureCompensation: number;
	/** A `Color3` value giving the hue of `Lighting`'s fog.

## How does fog work?
Fog in Roblox is displayed in a plane perpendicular to the `CurrentCamera`s direction. It fades between the `FogStart` property where it is not visible, to the `FogEnd` property where it is fully opaque. The effect of fog is it blends color with the FogColor.

At distances greater than `FogEnd`, color will be determined entirely by the FogColor. However at distances between `FogStart` and `FogEnd` the degree to which the color is blended depends on the position.

Roblox's fog uses linear interpolation between `FogStart` and `FogEnd`. This means if `FogStart` is 10 and `FogEnd` is 20, at a distance of 15 studs the fog will be at 50%. That means the color of a pixel at 15 studs will be 50% its normal color blended with 50% of the fog color.

```lua
local Lighting = game:GetService("Lighting")
-- fog will fade between 25 and 200 studs
Lighting.FogStart = 25
Lighting.FogEnd = 200
```


Note, fog does not obscure the skybox.

For more information about fog please see this [blog post][1].


  [1]: https://blog.roblox.com/2011/12/roblox-secrets-revealed-fog-blog/ */
	FogColor: Color3;
	/** The depth from the `CurrentCamera`, in studs, at which fog will be completely opaque.

## How does fog work?
Fog in Roblox is displayed in a plane perpendicular to the `CurrentCamera`s look direction. It fades between the `FogStart` property where it is not visible, to the FogEnd property where it is fully opaque. The effect of fog is it blends color with the `FogColor`.

At distances greater than FogEnd, color will be determined entirely by the `FogColor`. However at distances between `FogStart` and FogEnd the degree to which the color is blended depends on the position.

Roblox's fog uses linear interpolation between `FogStart` and FogEnd. This means if `FogStart` is 10 and FogEnd is 20, at a distance of 15 studs the fog will be at 50%. That means the color of a pixel at 15 studs will be 50% its normal color blended with 50% of the fog color.

```lua
local Lighting = game:GetService("Lighting")
-- fog will fade between 25 and 200 studs
Lighting.FogStart = 25
Lighting.FogEnd = 200
```


The color of the fog can be adjusted using `FogColor`.

Note, fog does not obscure the skybox.

For more information about fog please see this [blog post][1].


  [1]: https://blog.roblox.com/2011/12/roblox-secrets-revealed-fog-blog/ */
	FogEnd: number;
	/** The depth from the `CurrentCamera`, in studs, at which fog begins to show.

## How does fog work?
Fog in Roblox is displayed in a plane perpendicular to the `CurrentCamera`s look direction. It fades between the FogStart property where it is not visible, to the `FogEnd` property where it is fully opaque. The effect of fog is it blends  color with the `FogColor`.

At distances greater than `FogEnd`, color will be determined entirely by the `FogColor`. However at distances between FogStart and `FogEnd` the degree to which the color is blended depends on the position.

Roblox's fog uses linear interpolation between FogStart and `FogEnd`. This means if FogStart is 10 and `FogEnd` is 20, at a distance of 15 studs the fog will be at 50%. That means the color of a pixel at 15 studs will be 50% its normal color blended with 50% of the fog color.

```lua
local Lighting = game:GetService("Lighting")
-- fog will fade between 25 and 200 studs
Lighting.FogStart = 25
Lighting.FogEnd = 200
```


The color of the fog can be adjusted using `FogColor`.

Note, fog does not obscure the skybox.

For more information about fog please see this [blog post][1].


  [1]: https://blog.roblox.com/2011/12/roblox-secrets-revealed-fog-blog/ */
	FogStart: number;
	/** The geographic latitude, in degrees, of the scene, influencing the result of `Lighting`s time on the position of the sun and moon.

When calculating the position of the sun, the earth's tilt is also taken into account.

Changing GeographicLatitude will alter the position of the sun at every `TimeOfDay`. Developers looking to obtain the sun or moon's position should use `GetSunDirection` or `GetMoonDirection`.

## Code Samples

### Sun direction

The following code sample is an example of the how the direction of the sun is calculated. This is the calculation that `GetSunDirection` uses.
```lua
local lighting = game:GetService("Lighting")
 
local unitZ = Vector3.new(0,0,1)
local earthTilt = math.rad(23.5) -- The Earth's tilt in radians.
local halfSolarYear = 182.6282 -- Half the length of an average solar year
 
local function getSunDirection()
	local gameTime = lighting:GetMinutesAfterMidnight()
	local geoLatitude = lighting.GeographicLatitude
 
	local dayTime = gameTime/1440
	local sourceAngle = 2 * math.pi * dayTime
 
	local sunPosition = Vector3.new(math.sin(sourceAngle), -math.cos(sourceAngle), 0)
	local latRad = math.rad(geoLatitude)
 
	local sunOffset = -earthTilt * math.cos(math.pi * (dayTime - halfSolarYear) / halfSolarYear) - latRad
	local sunRotation = CFrame.fromAxisAngle(unitZ:Cross(sunPosition), sunOffset)
 
	local sunDirection = sunRotation * sunPosition
	return sunDirection
end
```
 */
	GeographicLatitude: number;
	/** Toggles voxel-based dynamic lighting in the game

## What does GlobalShadows do?

When set to true, shadows are rendered in sheltered areas depending on the position of the sun and moon. The lighting hue applied to these areas is determined by the `Ambient` property. The lighting hue in all other areas is determined by the `OutdoorAmbient` property.

When disabled, shadows are not drawn and no distinction is made between indoor and outdoor areas. As a result, the `Ambient` property determines the lighting hue and `OutdoorAmbient` will do nothing.

Shadows are calculated using a voxel system, and each lighting voxel is 4x4x4 studs. This means objects need to be larger than 4x4x4 studs to display a realistic shadow. Shadows are also recalculated when `BasePart`s are moving.

Note, this property is unrelated to shadows from characters which are displayed regardless of what GlobalShadows is set to.

For more information about Roblox's dynamic lighting, please see this [blog post][1].

## Toggling GlobalShadows

Developers toggling the GlobalShadows setting will notice that disabling it makes the place considerably darker. This is because when GlobalShadows is disabled `Ambient` is used to calculate the lighting hue in both indoor and ourdoor spaces. This darkness can be resolved by setting `Ambient` to a higher value such as `OutdoorAmbient`'s default value of 127, 127, 127.

In most cases developers are recommended to leave GlobalShadows enabled due to the superior visual appearance. See the image below for a comparison.

![enter image description here](https://developer.roblox.com/assets/blt23745970e2437872/GlobalShadows.png)


  [1]: https://blog.roblox.com/2013/02/dynamic-lighting-and-shadows-the-voxel-solution/ */
	GlobalShadows: boolean;
	/** The lighting hue applied to outdoor areas.

This property defaults to 127, 127, 127.

As long as the red, green and blue channels of `Ambient` do not exceed the corresponding channels in this property, the hue of the lighting in outdoor areas will be determined by this property. The effective OutdoorAmbient value is clamped to be greater than or equal to `Ambient` in all channels. This means, if a channel of `Ambient` exceeds its corresponding OutdoorAmbient channel then the hue of `Ambient` will begin to apply to outdoor areas. For a visual demonstration of this, please see the images below.

![enter image description here](https://developer.roblox.com/assets/blt6e6c67086eab8c57/Ambient.png)

Note, when `GlobalShadows` is disabled there is no distinction between areas occluded from the sky and areas that are not. In this case OutdoorAmbient will be ignored and the hue from the `Ambient` property will be applied everywhere.

For more properties that influence the color of lighting, please see `ColorShift_Bottom` and `ColorShift_Top`. */
	OutdoorAmbient: Color3;
	/** Determines whether outlines are enabled or disabled in a place.

Outlines can be disabled on a global basis, using this `Lighting` property, or alternatively on a surface-by-surface basis for `BasePart`s using `SurfaceType`.

Although this property can be set by scripts, it recommended this property is set in Roblox Studio prior to publishing the place.

Note, although outlines are not deprecated they are not the default and may no longer be supported in the future. 

For more information on changing outlines, please see this [blog post][1].


  [1]: https://blog.roblox.com/2013/08/you-can-now-toggle-outlines/ */
	Outlines: boolean;
	/** This property controls how blurry the shadows are. */
	ShadowSoftness: number;
	/** A 24 hour string representation of the current time of day used by `Lighting`.

Note, this property does not correspond with the actual time of day and will not change during the game unless it has been changed by a script.

For a numeric measure of `Lighting`'s time use `ClockTime`. Changing `ClockTime` or using `SetMinutesAfterMidnight` will also change this property.

Using TimeOfDay requires the time to be normalized and a string formatted:
```lua
minutesAfterMidnight = 0
while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	local minutesNormalised = minutesAfterMidnight % (60 * 24)
	local seconds = minutesNormalised * 60
	local hours = string.format("%02.f", math.floor(seconds/3600))
	local mins = string.format("%02.f", math.floor(seconds/60 - (hours*60)))
	local secs = string.format("%02.f", math.floor(seconds - hours*3600 - mins *60))
	local timeString = hours..":"..mins..":"..secs

	Lighting.TimeOfDay = timeString

	wait()
end
```


Using `ClockTime` requires the time to be normalized:
```lua
minutesAfterMidnight = 0
while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	local minutesNormalised = minutesAfterMidnight % (60 * 24)
	local hours = minutesNormalised / 60

	Lighting.ClockTime = hours

	wait()
end
```


Using `SetMinutesAfterMidnight` requires no extra processing:
```lua
minutesAfterMidnight = 0
while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	Lighting:SetMinutesAfterMidnight(minutesAfterMidnight)

	wait()
end
``` */
	TimeOfDay: string;
	/** Returns the number of minutes that have passed after midnight for the purposes of lighting.

This number will be nearly identical to `ClockTime` multiplied by 60.

This number will not always be equal to the value given in `SetMinutesAfterMidnight` as it returns minutes after midnight in the current day.

For `Lighting`s time formatted as a string, see `TimeOfDay`.

## Code Samples

### Lighting:GetMinutesAfterMidnight


```lua
game.Lighting.TimeOfDay = "14:00:00"
print(game.Lighting:GetMinutesAfterMidnight())
```

@returns The number of minutes after midnight. */
	GetMinutesAfterMidnight(): number;
	/** Returns a `Vector3` representing the direction of the moon from the position 0, 0, 0.

Note, when the moon has 'set' and is no longer visible, the `Vector3` returned by this function will continue to point towards the moon below the map.

Developers looking to change the positioning of the moon should use the `ClockTime` or `GeographicLatitude` properties.

A variant of this function exists for obtaining the direction of the sun, `GetSunDirection`.

## Code Samples

### Lighting:GetMoonDirection


```lua
game.Lighting.TimeOfDay = "14:00:00"
print(game.Lighting:GetMoonDirection())
```

@returns `DataType/Vector3` representing the direction of the moon from the position 0, 0, 0. */
	GetMoonDirection(): Vector3;
	/** Returns the moon's current phase. There is no way to change the moon's phase so this will always return 0.75 */
	GetMoonPhase(): number;
	/** Returns a `Vector3` representing the direction of the sun from the position 0, 0, 0.

Note, when the sun has set and is no longer visible, the `Vector3` returned by this function will continue to point towards the sun below the map.

Developers looking to change the positioning of the sun should use the `ClockTime` or `GeographicLatitude` properties.

A variant of this function exists for obtaining the direction of the moon, `GetMoonDirection`.

## Code Samples

### Lighting:GetSunDirection

This example shows how this function can be used:
```lua
game.Lighting.TimeOfDay = "14:00:00"
game.Lighting.GeographicLatitude = 41.73
print(game.Lighting:GetSunDirection())
```

@returns `DataType/Vector3` representing the direction of the sun from the position 0, 0, 0. */
	GetSunDirection(): Vector3;
	/** Sets `TimeOfDay` and `ClockTime` to the given number of minutes after midnight.


## How can I make a day / night script?
SetMinutesAfterMidnight allows a numerical value to be used, for example in a day/night cycle `Script`, without the need to convert to a string in the format required by `TimeOfDay`. It also allows values greater than 24 hours to be given that correspond to times in the next day. See the code snippets below for an example.

Using `TimeOfDay` requires the time to be normalized and a string formatted:
```lua
minutesAfterMidnight = 0
while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	local minutesNormalised = minutesAfterMidnight % (60 * 24)
	local seconds = minutesNormalised * 60
	local hours = string.format("%02.f", math.floor(seconds/3600))
	local mins = string.format("%02.f", math.floor(seconds/60 - (hours*60)))
	local secs = string.format("%02.f", math.floor(seconds - hours*3600 - mins *60))
	local timeString = hours..":"..mins..":"..secs

	Lighting.TimeOfDay = timeString

	wait()
end
```


Using `ClockTime` requires the time to be normalized:
```lua
minutesAfterMidnight = 0
while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	local minutesNormalised = minutesAfterMidnight % (60 * 24)
	local hours = minutesNormalised / 60

	Lighting.ClockTime = hours

	wait()
end
```


Using `SetMinutesAfterMidnight` requires no extra processing:
```lua
minutesAfterMidnight = 0
while true do
	minutesAfterMidnight = minutesAfterMidnight + 1

	Lighting:SetMinutesAfterMidnight(minutesAfterMidnight)

	wait()
end
```

## Code Samples

### Setting Lighting Time

The following code would set the time to be 14:00:00. This is because 840/60 is equal to 14.
```lua
game.Lighting:SetMinutesAfterMidnight( 840 )
```

@param minutes The number of minutes after midnight. */
	SetMinutesAfterMidnight(minutes: number): void;
	/** This event fires when a `Lighting` property is changed or a `Sky` is added or removed from `Lighting`.

Although this event fires when most properties of `Lighting` are changed, developers should be aware of the few exceptions:

 - Changing `GlobalShadows` will not fire this event
 - The fog properties, `FogColor`, `FogStart` and `FogEnd` will not fire this event

In cases where this behavior is not desired, the `Changed` event or `GetPropertyChangedSignal` function can be used.

## Code Samples

### Lighting.LightingChanged

The following code would print Skybox has changed whenever you changed the Lighting's SkyBox. The opposite will be printed when the adverse is true.
```lua

game.Lighting.LightingChanged:Connect(function(skyboxChanged)
    if skyboxChanged then
       print("Skybox has changed")
    else
       print("The skybox did not change.")
    end
end)

```
 */
	readonly LightingChanged: RBXScriptSignal<(skyboxChanged: boolean) => void>;
}

interface RbxInternalLocalStorageService extends RbxInternalInstance {}
type LocalStorageService = AppStorageService | UserStorageService;

interface AppStorageService extends RbxInternalLocalStorageService {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AppStorageService";
}

interface UserStorageService extends RbxInternalLocalStorageService {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UserStorageService";
}

/** LocalizationService is the service responsible for handling automated translation.

It is used as a storage for `LocalizationTable` objects used by automatic text replacement. 

LocalizationService will only use its child LocalizationTables for automatic text replacement unless `RootLocalizationTable` is specified on a GUI object or its ancestors. */
interface LocalizationService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LocalizationService";
	/** This property shows the locale id that the local player has set for their Roblox account.
This will return a string with the two letter code (for example, "en-us") for the locale. */
	readonly RobloxLocaleId: string;
	/** This property shows the locale id that the local player has set for their operating system.
This will return a string with the two letter code (for example, "en-us") for the locale. */
	readonly SystemLocaleId: string;
	/** Returns a list of `LocalizationTable` objects that are parented to the LocalizationService. */
	GetCorescriptLocalizations(): Array<Instance>;

	GetTableEntries(instance?: Instance): unknown;
	/** This function takes a player an argument and yields until the cloud localization data for that `player's` locale has been loaded, and then returns a `Translator` object which can be used to perform translations for that locale if any are available.

## See also
  - `GetTranslatorForPlayerAsync`, same functionality as this function except that it yields until the translator has been loaded
  - `GetTranslatorForLocaleAsync`, returns a Translator to be used for translations using the locale data loaded

## Code Samples

### Getting and Using a Translator for a Player

This code sample attempts to retrieve a `Translator` object for the locale “fr” - France. 

`GetTranslatorForPlayerAsync` is wrapped in a pcall because it may error. If it does not error and returns a Translator, prints “Hello in French:“ followed by the French translation of “Hello World!”. If the function errors, it prints “GetTranslatorForLocaleAsync failed:“ followed by the error message.

`GetTranslatorForPlayer` can also be used if you'd like to get the player's translator without yielding until the function returns.
```lua
local LocalizationService = game:GetService('LocalizationService')

local res,trans = pcall(function()
	LocalizationService:GetTranslatorForPlayerAsync("fr")
end)                                                                                                                                                                                                 
	
if res then
	local ctx = game.Workspace.Sign.SurfaceGui.Frame.TextLabel
	local res = trans:Translate(ctx, "Hello World!")
	print('Hello in French: ' .. res)
else
	print('GetTranslatorForPlayerAsync failed: ' .. trans)
end
```

@param player The `Player` that you are getting the `Translator` for
@returns The `Translator` instance for the specified locale */
	GetTranslatorForPlayer(player: Player): Translator;
	/** This function takes a language code as an argument and yields until the cloud localization data for that locale has been loaded, and then returns a `Translator` object which can be used to perform translations for that locale if any are available.

This function can error and thus should be wrapped in a `Built-in Functions & Variables — pcall`.

## See also
  - `GetTranslatorForPlayer`, same functionality as this function except that it does not yield
  - `GetTranslatorForPlayerAsync`, same functionality as this function except that it yields until the translator has been loaded

## Code Samples

### Getting and Using a Translator for a Locale

This code sample attempts to retrieve a `Translator` object for the locale “fr” - French. 

`GetTranslatorForLocaleAsync` is wrapped in a pcall because it may error. If it does not error and returns a Translator, prints “Hello in French:“ followed by the French translation of “Hello World!”. If the function errors, it prints “GetTranslatorForLocaleAsync failed:“ followed by the error message.
```lua
local LS = game:GetService('LocalizationService')

local res,trans = pcall(function()
	return LS:GetTranslatorForLocaleAsync("fr")
end)
	
if res then
	local ctx = game.Workspace.Sign.SurfaceGui.Frame.TextLabel
	local res = trans:Translate(ctx, "Hello World!")
	print('Hello in French: ' .. res)
else
	print('GetTranslatorForLocaleAsync failed: ' .. trans)
end
```

@param locale A Roblox supported language code. The currently supported language codes are “en” (English), “fr” (French), “de” (German), “ko” (Korean), “pt” (Portuguese), “es” (Spanish)
@returns The `Translator` instance for the specified locale */
	GetTranslatorForLocaleAsync(locale: string): Translator;
	/** This function takes a player an argument and yields until the cloud localization data for that player's locale has been loaded, and then returns a `Translator` object which can be used to perform translations for that locale if any are available.

This function can error and thus should be wrapped in a pcall.

## See also
  - `GetTranslatorForPlayer`, same functionality as this function except that it does not yield
  - `GetTranslatorForLocaleAsync`, returns a Translator to be used for translations using the locale data loaded

## Code Samples

### Getting and Using a Translator for a Player

This code sample attempts to retrieve a `Translator` object for the locale “fr” - France. 

`GetTranslatorForPlayerAsync` is wrapped in a pcall because it may error. If it does not error and returns a Translator, prints “Hello in French:“ followed by the French translation of “Hello World!”. If the function errors, it prints “GetTranslatorForLocaleAsync failed:“ followed by the error message.

`GetTranslatorForPlayer` can also be used if you'd like to get the player's translator without yielding until the function returns.
```lua
local LocalizationService = game:GetService('LocalizationService')

local res,trans = pcall(function()
	LocalizationService:GetTranslatorForPlayerAsync("fr")
end)                                                                                                                                                                                                 
	
if res then
	local ctx = game.Workspace.Sign.SurfaceGui.Frame.TextLabel
	local res = trans:Translate(ctx, "Hello World!")
	print('Hello in French: ' .. res)
else
	print('GetTranslatorForPlayerAsync failed: ' .. trans)
end
```

@param player The `Player` that you are getting the `Translator` for
@returns The `Translator` instance for the specified locale */
	GetTranslatorForPlayerAsync(player: Player): Translator;
}

/** A LocalizationTable is a database of translations. It contains source strings and translations for various languages. It is used with `Translator` and the `LocalizationService` auto-translator system to control text translations in the game.


LocalizationTables are designed to be treated as resources, like a texture or a script. They are not optimized to be modified at runtime. Changing a the contents of a table will cause the entire contents of the table to be replicated to all players.



## LocalizationTable Entries

Each LocalizationTable contains a set of entries. Each entry contains the translations of the text, along with some special fields:



* **Key** is an optional unique key for fast hash lookups in code. If it is non-empty it must be unique in the table.
* **Source** is the orignal text in the source language that will be used by the `LocalizationService` automatic text replacement system to match GUI text and render a translation instead. The Source field can be filled by the text capture tools, or can be set manually. For key-based lookups the Source value can be used as a translation for `SourceLocaleId` if the entry doesn't have a translation for that locale. If Source is empty then the entry will not be used by the automatic replacement system.
* **Context** is the full Instance name for the object that the text appeared on. Context is used for disambiguation by the automatic text replacement system. When multiple matches for the Source are found, the system will pick the best match by matching backwards from the end of the Context string. There are other more robust ways to handle disambiguation available as well, like using multiple tables with `RootLocalizationTable`.
* **Example** is whatever you want it to be. If the text capture tool guessed some parameters for a string the Example field will contain an example of them used in context.


All of these fields are optional, but at least either Key or Source must be non-empty. No two entries can have the same Key, Source, and Context.


The **Source**
 field and all translation strings must be valid [LocalizationService format strings](https://developer.roblox.com/articles/Format-Strings)
.

## Code Samples

### LocalizationTable


```lua
local LocalizationService = game:GetService("LocalizationService")
local HttpService = game:GetService("HttpService")

local function createLocalizationTable(contents)
	local localTable = Instance.new("LocalizationTable")
	localTable.DevelopmentLanguage = LocalizationService.SystemLocaleId
	localTable.Contents = HttpService:JSONEncode(contents)
	return localTable
end

local helloWorldTable = createLocalizationTable({
	[1] =
	{
		key = "Hello_World"; -- The 'expressionKey' to be used with GetString
		values = 
		{	-- A dictionary of keys corresponding to IETF language tags, and their translations.
			["ru"] = " !";			-- Russian
			["fr"] = "Bonjour le monde!";	-- French
			["de"] = "Hallo Welt!";			-- German
			["en-US"] = "Hello world!";		-- English
			["it"] = "Ciao mondo!";			-- Italian
			["pt-BR"] = "Ol Mundo!";		-- Portuguese
			["ja"] = ""; 		-- Japanese
			["es"] = "Hola Mundo!";			-- Spanish
		}
	}
})

print(helloWorldTable:GetString("en-US","Hello_World"))
```
 */
interface LocalizationTable extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LocalizationTable";
	/** The language that the source material of this LocalizationTable was based on, as a locale-id. */
	SourceLocaleId: string;
	/** The GetEntries function returns an array of dictionaries contained in a given `/LocalizationTable`, where each dictionary represents an entry of localization data.

To set the entries of a LocalizationTable, you can use `SetEntries`.

Each dictionary in the array contains the following fields:
| Index   | Type                            | Description                                                                                                                                                                                                                    |
|---------|---------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Key     | `String`             | A lookup key for this specific entry in the LocalizationTable.                                                                                                                                                                 |
| Source  | `String`             | The string used to format the localized string. Used as a lookup if a *Key* is not provided.                                                                                                                                   |
| Context | `String`             | A `GetFullName` path to the object that was used to generate the LocalizationTable. Used as a lookup if a *Key* is not provided.                                                                                      |
| Example | `String`             | The string used to format the localization. Optional.                                                                                                                                                                          |
| Values  | dictionary&lt;`String`&gt; | A dictionary of language translations for this localization entry. The keys of this dictionary are locale ids, and the values are strings that are used to apply localization for the language corresponding to the locale id. |

## Code Samples

### LocalizationTable:GetEntries

The following code sample creates a `LocalizationTable`, sets its entries, then gets and displays its entries. In order for this example to work, a LocalizationTable instance must be located inside the `LocalizationService` service.

The *entries* variable is a table of dictionaries, each with the format required to create a LocalizationTable with `SetEntries`.

The *get_results* variable is a table of dictionaries - the same table that we created with the *entries* variable. We then loop through each of the tables in this dictionary to display its *Valuesstrings.
```lua
local LocalizationTable = game:GetService("LocalizationService"):FindFirstChild("LocalizationTable")

local entries = {
	{["Key"] = "0001", ["Source"] = "en-us", ["Values"] = {
		["0001"] = "Hello Muddah, hello Fadduh.",
		["0002"] = "Here I am at Camp Granada.",
		["0003"] = "Camp is very entertaining.",
		["0004"] = "And they say we'll have some fun if it stops raining."}
	},
}

LocalizationTable:SetEntries(entries)
local get_results = LocalizationTable:GetEntries()

-- === Display dictionary contents ===
for index, table in pairs (get_results) do	-- Loop through each table in the dictionary, our dictionary only has 1 table
	for key, value in pairs (dict["Values"]) do	-- Loop through every key, value pair in the dictionary to print our strings
		print(value)
	end
end
```

@returns An array of dictionaries, where each dictionary represents an entry of localization data. */
	GetEntries(): Array<LocalizationEntry>;
	/** Returns a `Translator` for keys in this LocalizationTable, in the specified language. */
	GetTranslator(localeId: string): Translator;
	/** Removes an entry from the LocalizationTable, using the specified _key_, _source_, and _context_
 to narrow down the specific entry to be removed. */
	RemoveEntry(key: string, source: string, context: string): void;
	/** Removes a single language translation from the LocalizationTable, using the provided _key_, _source_, _context_, and _localeId_
 to narrow down the specific entry to be removed. */
	RemoveEntryValue(key: string, source: string, context: string, localeId: string): void;
	/** Removes all translations from the LocalizationTable with the specified localeId. */
	RemoveTargetLocale(localeId: string): void;
	/** Sets the contents of the LocalizationTable.
The entries parameter should be an array of dictionaries in the same format as the one returned from the `GetEntries` function. */
	SetEntries(entries?: any): void;
	/** Sets the **Context**
 field of a LocalizationTable entry to _newContext_, using the specified _key_, _source_, and _context_
 to narrow down the entry that will have this change applied. */
	SetEntryContext(key: string, source: string, context: string, newContext: string): void;
	/** Sets the **Example**
 field of a LocalizationTable entry to _example_, using the specified _key_, _source_, and _context_
 to narrow down the entry that will have this change applied. */
	SetEntryExample(key: string, source: string, context: string, example: string): void;
	/** Sets the **Key**
 field of a LocalizationTable entry to _newKey_, using the specified _key_, _source_, and _context_
 to narrow down the entry that will have this change applied. */
	SetEntryKey(key: string, source: string, context: string, newKey: string): void;
	/** Sets the **Source**
 field of a LocalizationTable entry to _newSource_, using the specified _key_, _source_, and _context_
 to narrow down the entry that will have this change applied. */
	SetEntrySource(key: string, source: string, context: string, newSource: string): void;
	/** Sets the text of the specified localeId in a LocalizationTable entry, using the specified _key_, _source_, and _context_
 to narrow down the entry that will have this change applied. */
	SetEntryValue(key: string, source: string, context: string, localeId: string, text: string): void;
}

/** A service that allows you to read outputted text. */
interface LogService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LogService";
	/** Returns a table of tables, each of which corresponds to something which has been displayed in the output.. */
	GetLogHistory(): Array<LogInfo>;
	/** Fired when text is added to the output.

## Code Samples

### LogService.MessageOut

Code and output
```lua
local msg = Instance.new("Message", workspace)
Game:GetService("LogService").MessageOut:Connect(function(Message, Type)
    msg.Text = "The message was "..Message.." and the type was "..tostring(Type)
end)

print("Hello, World!")
```
 */
	readonly MessageOut: RBXScriptSignal<(message: string, messageType: Enum.MessageType) => void>;
}

/** An unfinished service which apparently would have allowed a user to login from within a place. */
interface LoginService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LoginService";
}

/** The LuaSettings allows you to change certain properties, in regards to how Roblox handles Lua.
It is labeled as **Lua**
 in the Roblox Studio Settings menu. */
interface LuaSettings extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LuaSettings";
	/** Toggles whether or not script starts are logged in the output.
If set to true, the output will print blue text indicating what scripts are running, and their origin point in the DataModel. */
	AreScriptStartsReported: boolean;
	/** How long a call to `wait()` with no arguments will yield. */
	DefaultWaitTime: number;
	/** How many heartbeats there are between manual GC steps in Lua. */
	GcFrequency: number;
	/** The ideal limit above which Roblox triggers aggressive garbage collection, in average KB per `GcFrequency`. */
	GcLimit: number;
	/** Sets the size of pauses between successive garbage collections in Lua. */
	GcPause: number;
	/** Sets the value of Lua's garbage collection step multiplier, which controls the 'granularity' of Lua's garbage collector. */
	GcStepMul: number;
	/** Sets the maximum percent of Roblox's duty cycle that can be used to resume waiting Lua threads.
This defaults to 0.1 (or 10%) */
	WaitingThreadsBudget: number;
}

interface RbxInternalLuaSourceContainer extends RbxInternalInstance {}
/** The base class for all objects which contain Lua code. `Script`, `LocalScript`, `ModuleScript` and `CoreScript` all inherit from LuaSourceContainer. */
type LuaSourceContainer = BaseScript | ModuleScript;

interface RbxInternalBaseScript extends RbxInternalLuaSourceContainer {
	/** Determines whether a `BaseScript` will run or not.

`Script`s and `LocalScript`s, when parented to a valid parent, will run when Disabled is false.

If Disabled is set to true whilst a script is running, the current thread will be terminated.

If Disabled is set to true from false, the script will run again. This means the Disabled property can be toggled to restart a script:

```lua
scriptObject.Disabled = false
scriptObject.Disabled = true
```


Note, the above code snippet cannot be used within the script itself. This is because once the script is disabled the thread will terminate. */
	Disabled: boolean;
	/** The content ID of an uploaded script. When set binds the uploaded code to the script's `Source`. 

By default, this property is set to *'[Embedded]'*. This means the source of the script is not linked to an upload script and is instead written in the script. 

```lua
script.LinkedSource = "http://www.roblox.com/asset/?id=1014476" -- link source
```


Developers should remove a linked source via the properties window, rather than setting the property to *'[Embedded]'*.

For the LinkedSource property for `ModuleScript`s, please see `LinkedSource`.

Developers can find more information on using the LinkedSource property in `Linked this tutorial`. */
	LinkedSource: string;
}
/** The base class for all script objects which run automatically. */
type BaseScript = CoreScript | Script | LocalScript;

/** A CoreScript is a special type of script, that cannot be edited or ran by normal users. They are used by Roblox to handle integrated user interfaces found in the `CoreGui` among other things.



CoreScripts are special, because they can use API that is under the RobloxScriptSecurity security level.

You can find Roblox's built-in CoreScripts in their [github repository](https://github.com/ROBLOX/Core-Scripts/tree/master/CoreScriptsRoot)
.
They can also be found and modified from Roblox Studio's content folder (which is located in the directory folder of Roblox Studio's executable) via `scripts`
. */
interface CoreScript extends RbxInternalBaseScript {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CoreScript";
}

interface RbxInternalDerivesFromScript extends RbxInternalBaseScript {}
/** A Script is a type of Lua code container that will run its contents on the server. By default, Scripts have ```lua
print("Hello, world")
```
 as their contents. The instant that the following conditions are met, a Script's Lua code is run in a new thread:

 - Disabled property is false
 - The Script object is a descendant of the Workspace or
   ServerScriptService

The Script will continue to run until the above conditions are not met, it terminates or it raises an error (unless that error is raised by a function connected to some event that is firing). Additionally, the thread will be stopped if the Script or one of its ancestors is destroyed.  A script will continue to run even if the Parent property is set to nil (and the Script is not destroyed).

It has access to server-side objects, properties and events. For example, Scripts can award badges to players using BadgeService, while a LocalScript on the client cannot. Actions taken by LocalScripts that are not replicated (due to FilteringEnabled) will not be visible to Scripts.

## Code Samples

### Hello World

A Lua example of the classic [hello world program][1]. When run, it displays the simple message to the Output in Roblox Studio. By default, Script and LocalScript objects contain this code when they are first created.


  [1]: https://en.wikipedia.org/wiki/%22Hello,_World!%22_program
```lua
print("Hello, world")
```
 */
interface Script extends RbxInternalDerivesFromScript {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Script";
}


/** A LocalScript is a Lua source container that runs Lua code on a client connected to a Roblox server. They are used to access client-only objects, such as the player's `Camera`. For code run through LocalScripts, the LocalPlayer property of the `Players` service will return the player whose client is running the script.

A LocalScript will **only** run Lua code if it is a descendant of one of the following objects:

* A Player's `Backpack`, such as a child of a `Tool`
* A Player's `character` model
* A Player's `PlayerGui`
* A Player's `PlayerScripts`.
* The `ReplicatedFirst` service

## Code Samples

### CurrentCamera Position

This code prints to the Output the current position of the workspace's CurrentCamera. This code can only be run in a LocalScript - try putting it in a LocalScript inside StarterPlayerScripts to test it.
```lua
print(game.Workspace.CurrentCamera.CFrame.p)
```
 */
interface LocalScript extends RbxInternalDerivesFromScript {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LocalScript";
}

/** A ModuleScript is a type of Lua source container that runs once and must return exactly one value. This value is then returned by a call to `require` given the ModuleScript as the only argument. ModuleScripts run once and only once per Lua environment and return the exact same value for subsequent calls to `require`. 

ModuleScripts are essential objects for adhering to the don't-repeat-yourself (DRY) principle. When you write a function, write it only once and use it everywhere. Having multiple copies of a function is disastrous when you need to change that behavior. So, you should define functions or groups of functions in ModuleScripts and have your Scripts and LocalScripts call `require` on your ModuleScripts. Keep your code organized!

It's important to know that return values from ModuleScripts are independent with regards to LocalScripts and Scripts, and other environments like the Command Bar. Using `require` on a ModuleScript in a LocalScript will run the code on the client, even if a Script did so already on the server. Similarly, in Roblox Studio, using `require` on a ModuleScript in the hierarchy with the Command Bar will give a similar behavior. So, be careful if you are using a ModuleScript on the client and server at the same time, or debugging it within Studio.

Note that the first call to `require` on a ModuleScript will not yield (halt) unless the ModuleScript yields (e.g. calls `wait`). The current thread that called `require` will yield until a ModuleScript returns a value. A run time error is generated if this doesn't happen. If a ModuleScript is attempting to `require` another ModuleScript that in turn tries to `require`s it, the **thread will hang and never halt (cyclic `require` calls do not generate errors).** Be mindful of your module dependencies in large projects!

If a ModuleScript object is has its Name property set to 'MainModule' and is uploaded to Roblox as a model to your account, Scripts can use `require` with the uploaded model's AssetId instead. This allows you to create private modules on your Roblox account!

## Code Samples

### Simple ModuleScript Usage

This code sample shows how to use the require function on a ModuleScript, then use the value that it returned. See the "Simple ModuleScript Example" for the code to go with this sample.
```lua
    -- The require function is provided a ModuleScript, then runs
    -- the code, waiting until it returns a singular value.
    local my_functions = require(script.Parent.MyFunctions)

    -- These are some dummy functions defined in another code sample
    my_functions.foo()
    my_functions.bar()
```

### Simple ModuleScript Example

The code sample starts by creating a local variable holding an empty table. It then fills the table with two placeholder functions, and then finally returns the table. Using this code in a ModuleScript would make the `my_functions` table (and thus any functions, tables or other values within it) available to any Script, LocalScript or other ModuleScript.
```lua
    -- Tables are store multiple values in one variable
    local my_functions = {}
    
    -- Add a few functions to the table
    function my_functions.foo()
    	print("Foo!")
    end
    
    function functions.bar()
    	print("Bar!")
    end
    
    -- ModuleScripts must return exactly one value
    return my_functions
```
 */
interface ModuleScript extends RbxInternalLuaSourceContainer {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ModuleScript";
	/** Used to store a URL that points to an online script source. Binds the online code to the script's `Source`. */
	LinkedSource: string;
}

/** An internal service, which is responsible for retrieving HTTP data from websites. Used by a range of services, including `MarketplaceService`, `InsertService` and `HttpService`. Its functions cannot be accessed by developers. */
interface LuaWebService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "LuaWebService";
}

/** MarketplaceService is the game service that is responsible for in-game transactions. 

The most notable functions are `PromptProductPurchase` and `PromptPurchase`, as well as the callback `ProcessReceipt` which must be well defined so that transactions do not fail. 

MarketplaceService also has functions that fetch information about developer products (`GetProductInfo` and `GetDeveloperProductsAsync`), game passes (`UserOwnsGamePassAsync`), and other assets (`PlayerOwnsAsset`).

## Monetization

Learning to use MarketplaceService is the first step towards learning to monetize a game on Roblox. Be extra mindful when using these features, as failed sales and sale-related bugs can be incredibly frustrating to deal with. Another important game service regarding monetization is `DataStoreService` which is responsible for saving and loading data like that of purchases. When processing purchases, it is often a good idea to check using data stores that a player hasn't already been granted a product. Remember: all of the current financial rules of Roblox apply to in-game sales. At the moment, members of Builders Club will earn 70% of the total cost of the transaction and 10% for affiliate gear sales. If you are not a Builders Club member, you instead earn 10% of the total cost of the transaction.

## Purchase Prompt

Below is an example of an in-game developer product purchase prompt for a product called "XP Boost", with a price of R$ 25. The player is presented with the choice "Buy Now" or "Cancel". Upon confirming the purchase, the `ProcessReceipt` callback will be invoked with information about the purchase so the game may grant the product (in this case, the XP Boost). In studio, purchases will not charge the developer account and will be marked as such in the prompt.
![A screenshot of the in-game purchase prompt asking "Want to buy the product XP Boost for R$ 25? This is a test purchase. Your account will not be charged "][PromptProductPurchase]

## Sale Processing

Processing the sales of developer products is done by setting the `ProcessReceipt` callback once. This callback should grant the bonus associated with a developer product and return `Enum.ProductPurchaseDecision.PurchaseGranted`.

  [PromptProductPurchase]: /assets/5b61f4394bf5bf624023e72b/PromptProductPurchase.png

## Code Samples

### Handling Gamepass Purchase Finished

Below is a screenshot of a game pass purchase prompt. The function in the code sample runs immediately after the player presses "Cancel" or after the player buys the game pass then presses "OK". Should there be an issue with the purchase, the event also fires.

![A game pass purchase prompt](https://developer.roblox.com/assets/5c3f8ccaa8796cdd7e718524/PromptProductPurchase-prompt.png)
```lua
local MarketplaceService = game:GetService("MarketplaceService")

local function gamepassPurchaseFinished(...)
	-- Print all the details of the prompt, for example:
	-- PromptGamePassPurchaseFinished PlayerName 123456 false
	print("PromptGamePassPurchaseFinished", ...)
end

MarketplaceService.PromptGamePassPurchaseFinished:Connect(gamepassPurchaseFinished)
```
 */
interface MarketplaceService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "MarketplaceService";
	/** Used to prompt a user to purchase a game pass with the given assetId. */
	PromptGamePassPurchase(player: Player, gamePassId: number): void;
	/** Used to prompt a user to purchase a product with the given product id.

## Code Samples

### MarketplaceService:PromptProductPurchase

The below example would prompt all new players to buy a developer product with an ID of 123456.
```lua

local productId = 123456
game.Players.PlayerAdded:Connect(function(player)
	Game:GetService("MarketplaceService"):PromptProductPurchase(player, productId)
end)

```
 */
	PromptProductPurchase(
		player: Player,
		productId: number,
		equipIfPurchased?: boolean,
		currencyType?: CastsToEnum<Enum.CurrencyType>,
	): void;
	/** Used to prompt a user to purchase an item with the given assetId.

For game passes, use `PromptGamePassPurchase`.

## Code Samples

### MarketplaceService:PromptPurchase

The below example would prompt all new players to buy Beautiful Hair for Beautiful People.
```lua

game.Players.PlayerAdded:Connect(function(player)
	game:GetService("MarketplaceService"):PromptPurchase(player, 16630147)
end)

```
 */
	PromptPurchase(
		player: Player,
		assetId: number,
		equipIfPurchased?: boolean,
		currencyType?: CastsToEnum<Enum.CurrencyType>,
	): void;
	/** Returns a `Pages` object which contains information for all of the current game's developer products.

## Code Samples

### MarketplaceService:GetDeveloperProductsAsync

The below example would print the name, price, ID, description and icon AssetId for all of the developer products which belong to the current game. It will not work in solo mode unless you set the place's PlaceId using `/DataModel/SetPlaceIdSetPlaceId` in the command bar.
```lua
local developerProducts = game:GetService("MarketplaceService"):GetDeveloperProductsAsync():GetCurrentPage()

for _, developerProduct in pairs(developerProducts) do
    for field, value in pairs(developerProduct) do
        print(field .. ": " .. value)
    end
    print(" ")
end
```
 */
	GetDeveloperProductsAsync(): Pages;
	/** This function provides information about an asset, developer product or game pass given its **assetId** and the `InfoType` (Asset, Product or GamePass respectively).

Information about the queried item is provided in a dictionary with the following keys. Note that not all information is provided or necessarily relevant for the kind of object you are querying.

| Name | Type | Description |
| --- | --- | --- |
| `Name` | string | The name shown on the asset's page |
| `Description` | string | The description as shown on the asset's page; can be nil if blank |
| `PriceInRobux` | number | The cost of purchasing the asset using Robux |
| `Created` | timestamp | Timestamp of when the asset was created, e.g. `2018-08-01T17:55:11.98Z` |
| `Updated` | timestamp | Timestamp of when the asset was last updated by its creator, e.g. `2018-08-01T17:55:11.98Z` |
| `ContentRatingTypeId` | number | Indicates whether the item is marked as 13+ in catalog |
| `MinimumMembershipLevel` | number | The minimum Builder's Club subscription necessary to purchase the item |
| `IsPublicDomain` | boolean | Describes whether the asset can be taken for free |
| **Creator Information** |
| `Creator` | Dictionary | A table of information describing the creator of the asset (see following lines) |
| `Creator.CreatorType` | string | Either `User` or `Group` |
| `Creator.CreatorTargetId` | number | The ID of the creator user or group |
| `Creator.Name` | string | The name/username of the creator |
| `Creator.Id` | number | (Use CreatorTargetId instead) |
| **Assets** |
| `AssetId` | number | If InfoType was Asset, this is the ID of the given asset. |
| `AssetTypeId` | number | The type of asset (e.g. place, model, shirt) [*](#assettypes) |
| `IsForSale` | boolean | Describes whether the asset is purchasable |
| `IsLimited` | boolean | Describes whether the asset is a "limited item" that is no longer (if ever) sold |
| `IsLimitedUnique` | boolean | Describes whether the asset is a "limited unique" ("Limited U") item that only has a fixed number sold |
| `IsNew` | boolean | Describes whether the asset is marked as "new" in the catalog |
| `Remaining` | number | The remaining number of items a limited unique item may be sold |
| `Sales` | number | The number of items the asset has been sold |
| **Developer Products** |
| `ProductId` | number | If the InfoType was Product, this is the product ID |
| `IconImageAssetId` | number | For developer products, this is the asset ID of the product's icon (or 0 if the product does not have one) |


\* See `Asset Asset Types` for the asset type ID numbers.
 †Timestamps are formatted using [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)

## Developer Product Example
The following example loads information about a developer product.

```lua
local PRODUCT_ID = 336755544

local MarketplaceService = game:GetService("MarketplaceService")

local productInfo = MarketplaceService:GetProductInfo(PRODUCT_ID, Enum.InfoType.Product)

print("Product ID " .. PRODUCT_ID .. " name: " .. productInfo.Name) 

if productInfo.Description then
	print("Description: " .. productInfo.Description)
else
	print("No description!")
end

if productInfo.IsForSale then
	print("It is on sale for " .. productInfo.PriceInRobux .. " Robux.")
end

print("The image icon is: rbxassetid://" .. productInfo.IconImageAssetId)
```


## Use in Studio Plugins
This method is often used by plugins to detect old versions and notify the user to manually update a plugin. The plugin author uploads a dummy asset, such as a decal or model, then puts the present version of the plugin in that asset's description. The plugin then calls this method and checks an internal version number for a newer version.

## Possible Errors
If no such item exists with the given ID, this function will throw an error:

 - For developer products, the error is: 

> *MarketplaceService:getProductInfo() failed because rawProductInfo was empty*

 - For game passes and assets, the error is: 

> *MarketplaceService:getProductInfo() failed because HTTP 0 (HTTP 400 (HTTP/1.1 400 BadRequest))*

## Code Samples

### Getting Product Info

The below example will print the name and description of the asset with an ID of 125378389. In this case it will print:  *"Mr. Fancy Top Hat :: So fancy that even his top hat's top hat has a top hat."*
```lua
local Asset = game:GetService("MarketplaceService"):GetProductInfo(125378389)
print(Asset.Name .. " :: " .. Asset.Description)
```

@param assetId The assetId of the specified product
@param infoType An `Enum/InfoType` enum value specifying the type of information being retrieved
@returns A dictionary containing information about the queried item (described in the table above). Note that not all information is provided or necessarily relevant for the kind of object you are querying */
	GetProductInfo(assetId: number, infoType: CastsToEnum<Enum.InfoType.Asset>): AssetProductInfo;
	GetProductInfo(assetId: number, infoType: CastsToEnum<Enum.InfoType.Product>): DeveloperProductInfo;
	GetProductInfo(assetId: number, infoType: CastsToEnum<Enum.InfoType.GamePass>): AssetProductInfo;
	/** Returns whether the inventory of given `Player` contains an asset, given the ID. This method can query for hats, models, sounds, etc. This function takes a small amount of time to send a request the Roblox website.

In the case that a query fails, this function will throw an error. Therefore, it is recommended to wrap calls to this function in `pcall`.

* This method should not be used for **game passes**, since they use a separate ID system. Legacy game passes that still depend on an asset ID should use `PlayerHasPass` instead of this method.
* This method cannot be used to check for **developer products** since they can be purchased multiple times but not owned themselves. Use a `GlobalDataStore` to save when a developer has bought a developer product instead.

## Code Samples

### Check for Item Ownership

This code sample demonstrates how to check if a player owns a certain item. Here, we're checking for the item [Midnight Shades](https://www.roblox.com/catalog/30331986/Midnight-Shades), a hat that costs R$ 250. As a player enters the game, their account is checked for the ownership of that item and a message is printed.

Notice how the call to PlayerOwnsAsset is wrapped in `pcall` - this prevents the code from throwing an error in case the player's inventory can't be checked for some reason. Should such an error occur, the `success` variable would be false.
```lua
-- The item we're checking for: https://www.roblox.com/catalog/30331986/Midnight-Shades
local ASSET_ID = 30331986
local ASSET_NAME = "Midnight Shades"

local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")
local PlayerOwnsAsset = MarketplaceService.PlayerOwnsAsset

Players.PlayerAdded:Connect(function (player)
	local success, doesPlayerOwnAsset = pcall(PlayerOwnsAsset, MarketplaceService, player, ASSET_ID)
	if doesPlayerOwnAsset then
		print(player.Name .. " owns " .. ASSET_NAME)
	else
		print(player.Name .. " doesn't own " .. ASSET_NAME)
	end
end)
```

@param player A Player object whose inventory shall be tested for the ownership of the given asset
@param assetId The ID of an asset for which the given player's inventory shall be tested
@returns Indicates whether the given Player's inventory contains the given asset */
	PlayerOwnsAsset(player: Player, assetId: number): boolean;
	/** UserOwnsGamePassAsync returns true if the `Player` with the given `UserId` owns the game pass with the given **game pass ID** (not to be confused with asset ID).

## Caching Behavior

Results of this function are remembered so that repeated calls will return quicker. This function will always return true if the player owns the game pass upon first entering a server after having purchased the game pass. If the game pass is purchased in-game (through `PromptGamePassPurchase`), this function may return false due to the caching behavior. Conversely, should the player delete the game pass from their inventory, this function may return true despite the player not owning the game pass.

## History

Previously, querying player ownership of game passes required the use of the now-deprecated `PlayerHasPass` function. This was changed in April 2018 when [game passes received their own ID system](https://devforum.roblox.com/t/live-changes-to-game-passes/116918).

On [Release 350](/resources/release-note/Release-Note-for-350) (August 2018), this function was changed so that the result is cached. Previously, it made a request every time it was called.
@param userId The `Player/UserId|UserId` of the `Player` whose inventory shall be queried
@param gamePassId The game pass ID of the game pass to be checked, not to be confused with asset ID */
	UserOwnsGamePassAsync(userId: number, gamePassId: number): boolean;
	/** This event fires when a purchase dialogue of a game pass is closed. This fires right as the dialogue closes when the player presses "Cancel" at the prompt, or "OK" at the success/error message.

 - For **developer product** purchase prompts, connect to
   `PromptProductPurchaseFinished`. In order to
   process such purchases you need to set the
   `ProcessReceipt` callback in a
   single script.
   
 - For **affiliate gear sales** or other assets, use   
   `PromptPurchaseFinished`.

## Code Samples

### Handling Gamepass Purchase Finished

Below is a screenshot of a game pass purchase prompt. The function in the code sample runs immediately after the player presses "Cancel" or after the player buys the game pass then presses "OK". Should there be an issue with the purchase, the event also fires.

![A game pass purchase prompt](https://developer.roblox.com/assets/5c3f8ccaa8796cdd7e718524/PromptProductPurchase-prompt.png)
```lua
local MarketplaceService = game:GetService("MarketplaceService")

local function gamepassPurchaseFinished(...)
	-- Print all the details of the prompt, for example:
	-- PromptGamePassPurchaseFinished PlayerName 123456 false
	print("PromptGamePassPurchaseFinished", ...)
end

MarketplaceService.PromptGamePassPurchaseFinished:Connect(gamepassPurchaseFinished)
```
 */
	readonly PromptGamePassPurchaseFinished: RBXScriptSignal<
		(player: Player, gamePassId: number, wasPurchased: boolean) => void
	>;
	/** PromptPurchaseFinished fires when a purchase dialogue of an affiliate gear sale or other asset is closed. This fires right as the dialogue closes when the player presses "Cancel" at the prompt, or "OK" at the success/error message.

* For **game passes**, use `PromptGamePassPurchaseFinished`.
* For **developer product** purchase prompts, connect to `PromptProductPurchaseFinished`. In order to process such purchases you need to set the `ProcessReceipt` callback in a single script.

## Example
Below is a screenshot of an affiliate gear sale prompt. The function in the code sample runs immediately after the player presses "Cancel" or after the user buys the item then presses "OK". Should there be an issue with the purchase, the event also fires.
![A product purchase prompt for an affiliate gear sale](https://developer.roblox.com/assets/5c3f7bb9aae307c07f2f485f/PromptProductPurchase-confirm.png)

```lua
local MarketplaceService = game:GetService("MarketplaceService")

MarketplaceService.PromptPurchaseFinished:connect(function (...)
	-- Print all the details of the prompt, for example:
	-- PromptPurchaseFinished PlayerName 11377306 true
	print("PromptPurchaseFinished", ...)
end)
```

## Code Samples

### MarketplaceService.PromptPurchaseFinished

The below example would print 'Telamon bought an item with AssetID: 1111' to the output, if he were to complete a transaction in (your) game with an item that had an AssetID of 1111. Alternatively, it would print 'Telamon didn't buy an item with AssetID: 1111' if the opposite was true.
```lua

local MarketplaceService = game:GetService("MarketplaceService")

MarketplaceService.PromptPurchaseFinished:Connect(function(player, assetId, isPurchased)
	if isPurchased then
		print(player.Name .. " bought an item with AssetID: " .. assetId)
	else
		print(player.Name .. " didn't buy an item with AssetID: " .. assetId)
	end
end)

```
 */
	readonly PromptPurchaseFinished: RBXScriptSignal<(player: Player, assetId: number, isPurchased: boolean) => void>;
	/** After a player makes a purchase through a `PromptProductPurchase()` dialog, this callback is called multiple times until it returns `Enum.ProductPurchaseDecision.PurchaseGranted`. For example, the function is called again for a product when the player joins the game&nbsp;&mdash; or even after they have bought something else&nbsp;&mdash; **unless** you return `Enum.ProductPurchaseDecision.PurchaseGranted`.

It's important to carefully examine the information passed to the callback via the **receipt info table** and properly process the receipt. See the code sample below for a model of how to create a receipt handling callback.

Care and caution are highly recommended in implementing this callback as small mistakes run the risk of failed sales.

As with all callbacks, this function should be set **once and only once** by a single `Script`. If you're selling multiple products in your game, this callback must handle receipts for all of them.


## Receipt Info Table

The receipt info table passed to this callback will contain the following data:

| Key | Type | Description |
| --- | --- | --- |
| `PurchaseId` | string | A unique identifier for the specific purchase. |
| `PlayerId` | number | The ID of the player who made the purchase. |
| `ProductId` | number | The ID of the purchased product. |
| `CurrencySpent` | number | The amount of currency spent in the purchase. |
| `CurrencyType` | `CurrencyType` | The type of currency spent in the purchase; always `Enum.CurrencyType.Robux`. |
| `PlaceIdWherePurchased` | number | The ID of the place where the product was purchased (not necessarily the same as the current place's ID). |

## Code Samples

### ProcessReceipt Callback

This code sample illustrates a `ProcessReceipt` callback function for a game to handle purchasing of two `Developer Products In Game developer products`
 (more can be added as needed). It properly checks for and records purchases using a `GlobalDataStore` called "PurchaseHistory."

Most importantly, it properly returns `Enum.ProductPurchaseDecision.PurchaseGranted` when the transaction is successfully completed **or** if it's detected that the purchase has already been granted using the "PurchaseHistory" data store.
```lua
local MarketplaceService = game:GetService("MarketplaceService")
local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")

-- Data store for tracking purchases that were successfully processed
local purchaseHistoryStore = DataStoreService:GetDataStore("PurchaseHistory")

-- Table setup containing product IDs and functions for handling purchases
local productFunctions = {}
-- ProductId 123123 for a full heal
productFunctions[123123] = function(receipt, player)
	-- Logic/code for player buying a full heal (may vary)
	if player.Character and player.Character:FindFirstChild("Humanoid") then
		-- Heal the player to full health
		player.Character.Humanoid.Health = player.Character.Humanoid.MaxHealth
		-- Indicate a successful purchase
		return true
	end
end
-- ProductId 456456 for 100 gold
productFunctions[456456] = function(receipt, player)
	-- Logic/code for player buying 100 gold (may vary)
	local stats = player:FindFirstChild("leaderstats")
	local gold = stats and stats:FindFirstChild("Gold")
	if gold then
		gold.Value = gold.Value + 100
		-- Indicate a successful purchase
		return true
	end
end

-- The core 'ProcessReceipt' callback function
local function processReceipt(receiptInfo)

	-- Determine if the product was already granted by checking the data store  
	local playerProductKey = receiptInfo.PlayerId .. "_" .. receiptInfo.PurchaseId
	local purchased = false
	local success, errorMessage = pcall(function()
		purchased = purchaseHistoryStore:GetAsync(playerProductKey)
	end)
	-- If purchase was recorded, the product was already granted
	if success and purchased then
		return Enum.ProductPurchaseDecision.PurchaseGranted
	else
		error("Data store error:" .. errorMessage)
	end

	-- Find the player who made the purchase in the server
	local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)
	if not player then
		-- The player probably left the game
		-- If they come back, the callback will be called again
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end
	
	-- Look up handler function from 'productFunctions' table above
	local handler = productFunctions[receiptInfo.ProductId]

	-- Call the handler function and catch any errors
	local success, result = pcall(handler, receiptInfo, player)
	if not success or not result then
		warn("Error occurred while processing a product purchase")
		print("\nProductId:", receiptInfo.ProductId)
		print("\nPlayer:", player)
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	-- Record transaction in data store so it isn't granted again
	local success, errorMessage = pcall(function()
		purchaseHistoryStore:SetAsync(playerProductKey, true)
	end)
	if not success then
		error("Cannot save purchase data: " .. errorMessage)
	end

	-- IMPORTANT: Tell Roblox that the game successfully handled the purchase
	return Enum.ProductPurchaseDecision.PurchaseGranted
end

-- Set the callback; this can only be done once by one script on the server! 
MarketplaceService.ProcessReceipt = processReceipt
```
 */
	ProcessReceipt: (receiptInfo: ReceiptInfo) => Enum.ProductPurchaseDecision;
}

interface RbxInternalDerivesFromMessage extends RbxInternalInstance {
	/** Sets the text of a `Message` or `Hint`.

A `Message` will be invisible if its `Text` property is blank, however the black bar of a `Hint` will remain visible. */
	Text: string;
}
/** Fills the entire screen with a semi-transparent grey background, with centered text in the middle of the screen. With the introduction of Roblox's GUI features it has been deprecated and `TextLabel`s should be used instead for new work.

Messages will not display if the `Text` field is empty. */
interface Message extends RbxInternalDerivesFromMessage {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Message";
}


/** A Hint is an object that creates a small black bar at the very top of the screen with text. Its appearance cannot be customized in any way. With the introduction of Roblox's GUI features it has been deprecated and `TextLabel`s should be used instead for new work.

Notes:
* When a Hint is placed in the `Workspace`, it will be visible to everyone
* When placed under a `Player`'s `PlayerGui`, it will be visible only to that player
* Hints will render if placed in the `CoreGui` */
interface Hint extends RbxInternalDerivesFromMessage {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Hint";
}

/** **Beta**


This feature is in beta and may have unexpected or unreliable behavior.


The MessagingService allows game servers in the same game to communicate with each other in real time (< 1 second) using topics. Topics are developer defined strings (1-80 characters) that game servers can send and receive messages.

Delivery is best effort and not guaranteed. Make sure to architect your game so delivery failures are not critical.

## Limitations
Note: these limits are subject to change at any time.

| Limit | Maximum |
| --- | --- |
| Messages per game server per minute | 150 + 60 * number of players |
| Subscriptions per game server | 5 + 2 * number of players |


## Availability
When released as a beta feature, this was available in live servers but not in Studio. */
interface MessagingService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "MessagingService";
	/** **Beta**


This feature is in beta and may have unexpected or unreliable behavior.


This function invokes the supplied callback whenever a message is pushed to the topic.

Yields until the message is received by the backend.

## See also
  - `SubscribeAsync`, begins listening to the given topic
@param topic Determines where the message is sent
@param message The data to include in the message
@returns No return */
	PublishAsync(topic: string, message?: any): void;
	/** **Beta**


This feature is in beta and may have unexpected or unreliable behavior.


This function registers a callback to begin listening to the given topic. The callback is invoked when a topic receives a message. It can be called multiple times for the same topic.

## Callback
The callback is invoked with two arguments:
| Field | Summary |
| --- | --- |
| Data | Developer supplied payload |
| Sent | Unix time in seconds at which the message was sent |


It yields until the subscription is properly registered and returns a connection object.

To unsubscribe, call `:Disconnect()` on the returned object. Once Disconnect() is called, the callback should never be invoked. Killing the script containing the connections also causes the underlying connect to be unsubscribed.

## See also
  - `PublishAsync`, invokes the supplied callback whenever a message is pushed to the topic

## Code Samples

### Subscribing to Cross Server Messages

This example demonstrates how to use `SubscribeAsync` to listen to a topic for cross-server chat within a game universe.

When a player joins, the example subscribes to the topic *player-*. When a message is sent with this topic, the connected callback executes and prints *Received message for *. It also disconnects the connection when the player’s `ancestry changes`.

In order for this to work as expected it must be placed in a server `Script`.
```lua
local messagingService = game:getService("MessagingService")
local players = game:GetService("Players")
 
players.PlayerAdded:connect(function(player)
    --subscribe to the topic
    local topic = "player-" .. player.UserId
    local connection = messagingService:SubscribeAsync(topic, function(message)
        print("Received message for " .. player.Name)
    end)
 
    player.AncestryChanged:connect(function()
        -- unsubscribe from the topic
        connection:Disconnect()
    end)
end)
```

@param topic Determines where to listen for messages
@param callback Function to be invoked whenever a message is received
@returns Connection that can be used to unsubscribe from the topic */
	SubscribeAsync(topic: string, callback: (Data: any, Sent: number) => void): RBXScriptConnection;
}

interface RbxInternalMouse extends RbxInternalInstance {
	/** This property indicates `CFrame` of the mouse's position in 3D space. Note that `TargetFilter` and its descendants will be ignored.

Developers can get obtain the position of Hit like so:

```lua
local position = mouse.Hit.p
```


Hit is often used by `Tool`s to fire a weapon towards the mouse in third person. 

Developers looking for the `BasePart` the mouse is pointing at should use `Target`.

## How is Mouse.Hit calculated?
The position of the Hit CFrame is calculated as the point of intersection between the mouse's internal `Ray` (an extended version of `UnitRay`) and an object in 3D space (such as a part).

The orientation of the Hit CFrame corresponds with the direction of the `UnitRay`. 

```lua
local unitRayDirection = mouse.UnitRay.Direction
local mouseHitDirection = mouse.Hit.lookVector
-- unitRayDirection ≈ mouseHitDirection
-- the vectors are approximately equal
```


Note, the roll of the `CurrentCamera` is not used when calculating the orientation of the Hit `CFrame`.

The mouse's internal ray extends for 1000 studs. If the mouse is not pointing at an object in 3D space (for example when pointing at the sky), this property will be 1000 studs away from the `CurrentCamera`.

## Code Samples

### Mouse.Hit Laser Beam

The code in this sample, when placed inside a `LocalScript` within `StarterPlayerScripts` will draw a red laser beam between the character's head and `Hit` at all times.

Note, this beam will pass directly through obstructions in third person as the `Mouse`'s raycasting is done from the `CurrentCamera` not the head.
```lua
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- grab local player
local localPlayer = Players.LocalPlayer

-- create beam
local beam = Instance.new("Beam")
beam.Segments = 1
beam.Width0 = 0.2
beam.Width1 = 0.2
beam.Color = ColorSequence.new(Color3.new(1, 0, 0))
beam.FaceCamera = true

-- create attachments
local attachment0 = Instance.new("Attachment")
local attachment1 = Instance.new("Attachment")
beam.Attachment0 = attachment0
beam.Attachment1 = attachment1

-- parent attachments to Terrain 
beam.Parent = workspace.Terrain
attachment0.Parent = workspace.Terrain
attachment1.Parent = workspace.Terrain

-- grab the mouse
local mouse = localPlayer:GetMouse()

-- connect to RenderStepped (update every frame)
RunService.RenderStepped:Connect(function()

	-- make sure the character exists
	local character = localPlayer.Character
	if not character then
		-- disable the beam
		beam.Enabled = false
		return
	end

	-- make sure the head exists
	local head = character:FindFirstChild("Head")
	if not head then
		-- disable the beam
		beam.Enabled = false
		return
	end

	-- enable the beam
	beam.Enabled = true

	-- define origin and finish
	local origin = head.Position
	local finish = mouse.Hit.p

	-- move the attachments 
	attachment0.Position = origin
	attachment1.Position = finish
end)



```

### Mouse Origin vs Mouse Hit vs CurrentCamera Position

The code below visualizes the difference between `Hit` and `Origin`. In order to do this, the code uses the `Vector3` positions of the hit and origin `CFrame` values using `.p`.

The difference is that the origin is "where the mouse came from" (its origin) and the hit is the position where the mouse hits (is when the player presses their mouse). 

This example also visualizes that the mouse origin is very similar to the position of the `CurrentCamera` by printing the magnitude (distance) between the two positions.
```lua
local mouse = game.Players.LocalPlayer:GetMouse()
local camPos = game.Workspace.CurrentCamera.CoordinateFrame.p

print("-------------------------------------------------")
print("Mouse.Hit:\t|",  mouse.hit.p)
print("camPos:\t|", camPos)
print("Mouse.Origin:\t|", mouse.Origin.p)
print("-------------------------------------------------")
print("Magnitude:\t|",(mouse.Origin.p - camPos).magnitude)
print("-------------------------------------------------")
```
This property indicates `CFrame` of the mouse's position in 3D space. Note that `TargetFilter` and its descendants will be ignored.

Developers can get obtain the position of Hit like so:

```lua
local position = mouse.Hit.p
```


Hit is often used by `Tool`s to fire a weapon towards the mouse in third person. 

Developers looking for the `BasePart` the mouse is pointing at should use `Target`.

## How is Mouse.Hit calculated?
The position of the Hit CFrame is calculated as the point of intersection between the mouse's internal `Ray` (an extended version of `UnitRay`) and an object in 3D space (such as a part).

The orientation of the Hit CFrame corresponds with the direction of the `UnitRay`. 

```lua
local unitRayDirection = mouse.UnitRay.Direction
local mouseHitDirection = mouse.Hit.lookVector
-- unitRayDirection ≈ mouseHitDirection
-- the vectors are approximately equal
```


Note, the roll of the `CurrentCamera` is not used when calculating the orientation of the Hit `CFrame`.

The mouse's internal ray extends for 1000 studs. If the mouse is not pointing at an object in 3D space (for example when pointing at the sky), this property will be 1000 studs away from the `CurrentCamera`.

## Code Samples

### Mouse.Hit Laser Beam

The code in this sample, when placed inside a `LocalScript` within `StarterPlayerScripts` will draw a red laser beam between the character's head and `Hit` at all times.

Note, this beam will pass directly through obstructions in third person as the `Mouse`'s raycasting is done from the `CurrentCamera` not the head.
```lua
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- grab local player
local localPlayer = Players.LocalPlayer

-- create beam
local beam = Instance.new("Beam")
beam.Segments = 1
beam.Width0 = 0.2
beam.Width1 = 0.2
beam.Color = ColorSequence.new(Color3.new(1, 0, 0))
beam.FaceCamera = true

-- create attachments
local attachment0 = Instance.new("Attachment")
local attachment1 = Instance.new("Attachment")
beam.Attachment0 = attachment0
beam.Attachment1 = attachment1

-- parent attachments to Terrain 
beam.Parent = workspace.Terrain
attachment0.Parent = workspace.Terrain
attachment1.Parent = workspace.Terrain

-- grab the mouse
local mouse = localPlayer:GetMouse()

-- connect to RenderStepped (update every frame)
RunService.RenderStepped:Connect(function()

	-- make sure the character exists
	local character = localPlayer.Character
	if not character then
		-- disable the beam
		beam.Enabled = false
		return
	end

	-- make sure the head exists
	local head = character:FindFirstChild("Head")
	if not head then
		-- disable the beam
		beam.Enabled = false
		return
	end

	-- enable the beam
	beam.Enabled = true

	-- define origin and finish
	local origin = head.Position
	local finish = mouse.Hit.p

	-- move the attachments 
	attachment0.Position = origin
	attachment1.Position = finish
end)



```

### Mouse Origin vs Mouse Hit vs CurrentCamera Position

The code below visualizes the difference between `Hit` and `Origin`. In order to do this, the code uses the `Vector3` positions of the hit and origin `CFrame` values using `.p`.

The difference is that the origin is "where the mouse came from" (its origin) and the hit is the position where the mouse hits (is when the player presses their mouse). 

This example also visualizes that the mouse origin is very similar to the position of the `CurrentCamera` by printing the magnitude (distance) between the two positions.
```lua
local mouse = game.Players.LocalPlayer:GetMouse()
local camPos = game.Workspace.CurrentCamera.CoordinateFrame.p

print("-------------------------------------------------")
print("Mouse.Hit:\t|",  mouse.hit.p)
print("camPos:\t|", camPos)
print("Mouse.Origin:\t|", mouse.Origin.p)
print("-------------------------------------------------")
print("Magnitude:\t|",(mouse.Origin.p - camPos).magnitude)
print("-------------------------------------------------")
```


Tags: ReadOnly, NotReplicated */
	readonly Hit: CFrame;
	/** The content ID of the image used as the `Mouse`'s icon.

The size of the mouse's icon is dependent on the dimensions of the image used, and the center of the image should be the mouse's tip. The default mouse image is 64x64 pixels, with the mouse taking up 17x24 pixels of space. Developers can consult the default images which are stored in the following directory:

*AppData/Local/Roblox/Versions/[version]/content/textures*


Although the icon can be set to a transparent image to hide the mouse, the preferred method of doing this is using `MouseIconEnabled`.

Note, this property is overridden when the mouse is hovering over a `GuiButton`.

For more information on how to change the mouse's icon, please see `Mouse Icon this tutorial`.

## Code Samples

### 

This example changes the `LocalPlayer` mouse icon to look like the dragon image shown below.

![Dragon mouse icon](https://developer.roblox.com/assets/5b72217a7246caab436d9fef/DragonIcon.png)
```lua
local mouse = game.Players.LocalPlayer:GetMouse()
mouse.Icon = "http://www.roblox.com/asset?id=163023520"
```
 */
	Icon: string;
	/** A `CFrame` positioned at the `CurrentCamera` and oriented toward the `Mouse`'s 3D position.

`UnitRay` starts at the same position as Origin, and extends for a stud in the same direction.

```lua
local unitRay = mouse.UnitRay
local origin = mouse.Origin
-- unitRay.Direction = origin.p
-- unitRay.Direction ≈ origin.lookVector
```

For the position of the `Mouse` in 3D space, see `Hit`.A `CFrame` positioned at the `CurrentCamera` and oriented toward the `Mouse`'s 3D position.

`UnitRay` starts at the same position as Origin, and extends for a stud in the same direction.

```lua
local unitRay = mouse.UnitRay
local origin = mouse.Origin
-- unitRay.Direction = origin.p
-- unitRay.Direction ≈ origin.lookVector
```

For the position of the `Mouse` in 3D space, see `Hit`.

Tags: ReadOnly, NotReplicated */
	readonly Origin: CFrame;
	/** The object in 3D space the `mouse` is pointing to.

## Notes
 - If `TargetFilter` has been set, the target filter and its descendants will be ignored.
 - When the mouse is not pointing at a `BasePart`, for example when it is pointing at the sky, Target will be nil.
 - Developers looking for the position of the mouse in 3D space should use `Hit`.

## Code Samples

### Color Randomizer Tool

The following code sample, when placed in `StarterPlayerScripts` will create a tool in the player's backpack that, once equipped, will change the `BrickColor` of every `BasePart` the player clicks on.
```lua
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer
local backpack = localPlayer:WaitForChild("Backpack")

local tool = Instance.new("Tool")
tool.RequiresHandle = false
tool.CanBeDropped = false 
tool.Parent = backpack

tool.Equipped:Connect(function(mouse)
	mouse.Button1Down:Connect(function()
		if mouse.Target and mouse.Target.Parent then
			mouse.Target.BrickColor = BrickColor.Random()
		end
	end)
end)
```
The object in 3D space the `mouse` is pointing to.

## Notes
 - If `TargetFilter` has been set, the target filter and its descendants will be ignored.
 - When the mouse is not pointing at a `BasePart`, for example when it is pointing at the sky, Target will be nil.
 - Developers looking for the position of the mouse in 3D space should use `Hit`.

## Code Samples

### Color Randomizer Tool

The following code sample, when placed in `StarterPlayerScripts` will create a tool in the player's backpack that, once equipped, will change the `BrickColor` of every `BasePart` the player clicks on.
```lua
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer
local backpack = localPlayer:WaitForChild("Backpack")

local tool = Instance.new("Tool")
tool.RequiresHandle = false
tool.CanBeDropped = false 
tool.Parent = backpack

tool.Equipped:Connect(function(mouse)
	mouse.Button1Down:Connect(function()
		if mouse.Target and mouse.Target.Parent then
			mouse.Target.BrickColor = BrickColor.Random()
		end
	end)
end)
```


Tags: ReadOnly, NotReplicated */
	readonly Target?: BasePart;
	/** This property determines an object to be ignored by the mouse when calculating `Hit` and `Target`. The descendants of the object are also ignored, so it is possible to ignore multiple objects so long as they are a descendant of the object to which this property is set. This property is useful when filtering models containing special effects or decorations that should not affect `Hit` or `Target`.

This property can be set to any `Instance` or nil, for example:
```lua
local Players = game:GetService("Players")
local player = Players.LocalPlayer 
local mouse = player:GetMouse()
mouse.TargetFilter = workspace.Model
 
-- Now, when the player hovers the cursor over the model, mouse.Target will be some object
-- behind workspace.Model, if there is one.
```


This property is essentially a single-object blacklist for mouse raycasting. For more in-depth control on raycasting, see the following functions of `Workspace`: `FindPartOnRay`, `FindPartOnRayWithWhitelist` and `FindPartOnRayWithIgnoreList`.

The `Character` of the `LocalPlayer` is ignored by the mouse automatically. */
	TargetFilter?: Instance;
	/** This property indicates the `NormalId` of the `BasePart` surface at which the mouse is pointing. This property is derived from the world position of mouse (`Hit`) and the part toward which the mouse is pointing (`Target`).

This property isn't meaningful when the mouse is not pointing at a part, for example when the mouse is pointing at the sky. At the moment, this property is set to 'Right' under these circumstances. Before using this property, check that the mouse's target is not nil.

```lua
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local mouse = player:GetMouse()
-- Check that there exists a part at which the mouse is pointing
if mouse.Target then
	print("The mouse is pointing to the " .. mouse.TargetSurface.Name .. " side of " .. mouse.Target.Name)
else
	print("The mouse is not pointing at anything.")
end
```

## Code Samples

### Surface Randomizer

The code in this sample, when placed in a `LocalScript` inside `StarterPlayerScripts` will set the surface of any `BasePart` clicked on to a random surface.
```lua
local Players = game:GetService("Players")

-- grab the mouse
local localPlayer = Players.LocalPlayer
local mouse = localPlayer:GetMouse()

-- define surface types 
local surfaceTypes = {
	Enum.SurfaceType.Smooth,
	Enum.SurfaceType.Glue,
	Enum.SurfaceType.Weld,
	Enum.SurfaceType.Studs,
	Enum.SurfaceType.Inlet,
	Enum.SurfaceType.Universal,
	Enum.SurfaceType.Hinge,
	Enum.SurfaceType.Motor
}

-- listen for mouse clicks
mouse.Button1Down:Connect(function()
	-- make sure the mouse is pointing at a part
	local target = mouse.Target
	if not target then
		return
	end

	-- pick a random surface type
	local surfaceType = surfaceTypes[math.random(1, #surfaceTypes)]

	-- find the correct surface
	local surface = mouse.TargetSurface 
	local propertyName = surface.Name.."Surface"

	-- set the surface type
	mouse.Target[propertyName] = surfaceType
end)


```
This property indicates the `NormalId` of the `BasePart` surface at which the mouse is pointing. This property is derived from the world position of mouse (`Hit`) and the part toward which the mouse is pointing (`Target`).

This property isn't meaningful when the mouse is not pointing at a part, for example when the mouse is pointing at the sky. At the moment, this property is set to 'Right' under these circumstances. Before using this property, check that the mouse's target is not nil.

```lua
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local mouse = player:GetMouse()
-- Check that there exists a part at which the mouse is pointing
if mouse.Target then
	print("The mouse is pointing to the " .. mouse.TargetSurface.Name .. " side of " .. mouse.Target.Name)
else
	print("The mouse is not pointing at anything.")
end
```

## Code Samples

### Surface Randomizer

The code in this sample, when placed in a `LocalScript` inside `StarterPlayerScripts` will set the surface of any `BasePart` clicked on to a random surface.
```lua
local Players = game:GetService("Players")

-- grab the mouse
local localPlayer = Players.LocalPlayer
local mouse = localPlayer:GetMouse()

-- define surface types 
local surfaceTypes = {
	Enum.SurfaceType.Smooth,
	Enum.SurfaceType.Glue,
	Enum.SurfaceType.Weld,
	Enum.SurfaceType.Studs,
	Enum.SurfaceType.Inlet,
	Enum.SurfaceType.Universal,
	Enum.SurfaceType.Hinge,
	Enum.SurfaceType.Motor
}

-- listen for mouse clicks
mouse.Button1Down:Connect(function()
	-- make sure the mouse is pointing at a part
	local target = mouse.Target
	if not target then
		return
	end

	-- pick a random surface type
	local surfaceType = surfaceTypes[math.random(1, #surfaceTypes)]

	-- find the correct surface
	local surface = mouse.TargetSurface 
	local propertyName = surface.Name.."Surface"

	-- set the surface type
	mouse.Target[propertyName] = surfaceType
end)


```


Tags: ReadOnly, NotReplicated */
	readonly TargetSurface: Enum.NormalId;
	/** The UnitRay property is a `Ray` directed toward the `Mouse`'s position in 3D space (described by `Hit`). It originates from the `CFrame` of the `CurrentCamera`. Like all unit rays, it has a distance of 1.

```lua
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local mouse = player:GetMouse()
print(mouse.UnitRay.Direction.magnitude) -- Always 1
```The UnitRay property is a `Ray` directed toward the `Mouse`'s position in 3D space (described by `Hit`). It originates from the `CFrame` of the `CurrentCamera`. Like all unit rays, it has a distance of 1.

```lua
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local mouse = player:GetMouse()
print(mouse.UnitRay.Direction.magnitude) -- Always 1
```

Tags: ReadOnly, NotReplicated */
	readonly UnitRay: Ray;
	/** The ViewSizeX property describes the horizontal component of the game window's size in pixels.

## Code Samples

### Normalized Mouse Position

This code sample shows how you can create a `Vector2` representing the `Mouse` object's position on screen (`X` and `Y`) and the size of the screen itself (`ViewSizeX` and `ViewSizeY`). Using these, you can normalize the position of the mouse on-screen such that the top-left just under the topbar maps to (0, 0) and the bottom-right maps to (1, 1). This normalized position is calculated and printed as the mouse moves using the `Move` event.
```lua
-- Note: You should use ContextActionService or UserInputService instead of 
-- the Mouse object for accomplishing this task.
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()

local function onMouseMove()
	-- Construct Vector2 objects for the mouse's position and screen size
	local position = Vector2.new(mouse.X, mouse.Y)
	local size = Vector2.new(mouse.ViewSizeX, mouse.ViewSizeY)
	-- A normalized position will map the top left (just under the topbar)
	-- to (0, 0) the bottom right to (1, 1), and the center to (0.5, 0.5).
	-- This is calculated by dividing the position by the total size.
	local normalizedPosition = position / size
	print(normalizedPosition)
end
mouse.Move:Connect(onMouseMove)
```
The ViewSizeX property describes the horizontal component of the game window's size in pixels.

## Code Samples

### Normalized Mouse Position

This code sample shows how you can create a `Vector2` representing the `Mouse` object's position on screen (`X` and `Y`) and the size of the screen itself (`ViewSizeX` and `ViewSizeY`). Using these, you can normalize the position of the mouse on-screen such that the top-left just under the topbar maps to (0, 0) and the bottom-right maps to (1, 1). This normalized position is calculated and printed as the mouse moves using the `Move` event.
```lua
-- Note: You should use ContextActionService or UserInputService instead of 
-- the Mouse object for accomplishing this task.
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()

local function onMouseMove()
	-- Construct Vector2 objects for the mouse's position and screen size
	local position = Vector2.new(mouse.X, mouse.Y)
	local size = Vector2.new(mouse.ViewSizeX, mouse.ViewSizeY)
	-- A normalized position will map the top left (just under the topbar)
	-- to (0, 0) the bottom right to (1, 1), and the center to (0.5, 0.5).
	-- This is calculated by dividing the position by the total size.
	local normalizedPosition = position / size
	print(normalizedPosition)
end
mouse.Move:Connect(onMouseMove)
```


Tags: ReadOnly, NotReplicated */
	readonly ViewSizeX: number;
	/** The ViewSizeY property describes the vertical component of the game window's size in pixels. This length includes the space used by the topbar.

## Code Samples

### Normalized Mouse Position

This code sample shows how you can create a `Vector2` representing the `Mouse` object's position on screen (`X` and `Y`) and the size of the screen itself (`ViewSizeX` and `ViewSizeY`). Using these, you can normalize the position of the mouse on-screen such that the top-left just under the topbar maps to (0, 0) and the bottom-right maps to (1, 1). This normalized position is calculated and printed as the mouse moves using the `Move` event.
```lua
-- Note: You should use ContextActionService or UserInputService instead of 
-- the Mouse object for accomplishing this task.
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()

local function onMouseMove()
	-- Construct Vector2 objects for the mouse's position and screen size
	local position = Vector2.new(mouse.X, mouse.Y)
	local size = Vector2.new(mouse.ViewSizeX, mouse.ViewSizeY)
	-- A normalized position will map the top left (just under the topbar)
	-- to (0, 0) the bottom right to (1, 1), and the center to (0.5, 0.5).
	-- This is calculated by dividing the position by the total size.
	local normalizedPosition = position / size
	print(normalizedPosition)
end
mouse.Move:Connect(onMouseMove)
```
The ViewSizeY property describes the vertical component of the game window's size in pixels. This length includes the space used by the topbar.

## Code Samples

### Normalized Mouse Position

This code sample shows how you can create a `Vector2` representing the `Mouse` object's position on screen (`X` and `Y`) and the size of the screen itself (`ViewSizeX` and `ViewSizeY`). Using these, you can normalize the position of the mouse on-screen such that the top-left just under the topbar maps to (0, 0) and the bottom-right maps to (1, 1). This normalized position is calculated and printed as the mouse moves using the `Move` event.
```lua
-- Note: You should use ContextActionService or UserInputService instead of 
-- the Mouse object for accomplishing this task.
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()

local function onMouseMove()
	-- Construct Vector2 objects for the mouse's position and screen size
	local position = Vector2.new(mouse.X, mouse.Y)
	local size = Vector2.new(mouse.ViewSizeX, mouse.ViewSizeY)
	-- A normalized position will map the top left (just under the topbar)
	-- to (0, 0) the bottom right to (1, 1), and the center to (0.5, 0.5).
	-- This is calculated by dividing the position by the total size.
	local normalizedPosition = position / size
	print(normalizedPosition)
end
mouse.Move:Connect(onMouseMove)
```


Tags: ReadOnly, NotReplicated */
	readonly ViewSizeY: number;
	/** When detecting changes in the mouse's position on-screen, it is recommended that you use `BindAction` with `Enum.UserInputType.MouseMovement` or `InputChanged`, which both describe the position of the mouse using the `Position` (a `Vector3`) of an `InputObject`,  instead of using this and related properties.


The X property describes the horizontal component of the mouse's position on the screen. The position is measured in pixels relative to the top left corner, under the topbar. This property can be used in conjunction with `Y` to produce a `Vector2` representing the mouse's position:
```lua
local position = Vector2.new(mouse.X, mouse.Y)
```

This property does not fire `Changed` or the signal returned from `GetPropertyChangedSignal`. Use the `Move` event instead.

## Code Samples

### Normalized Mouse Position

This code sample shows how you can create a `Vector2` representing the `Mouse` object's position on screen (`X` and `Y`) and the size of the screen itself (`ViewSizeX` and `ViewSizeY`). Using these, you can normalize the position of the mouse on-screen such that the top-left just under the topbar maps to (0, 0) and the bottom-right maps to (1, 1). This normalized position is calculated and printed as the mouse moves using the `Move` event.
```lua
-- Note: You should use ContextActionService or UserInputService instead of 
-- the Mouse object for accomplishing this task.
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()

local function onMouseMove()
	-- Construct Vector2 objects for the mouse's position and screen size
	local position = Vector2.new(mouse.X, mouse.Y)
	local size = Vector2.new(mouse.ViewSizeX, mouse.ViewSizeY)
	-- A normalized position will map the top left (just under the topbar)
	-- to (0, 0) the bottom right to (1, 1), and the center to (0.5, 0.5).
	-- This is calculated by dividing the position by the total size.
	local normalizedPosition = position / size
	print(normalizedPosition)
end
mouse.Move:Connect(onMouseMove)
```
When detecting changes in the mouse's position on-screen, it is recommended that you use `BindAction` with `Enum.UserInputType.MouseMovement` or `InputChanged`, which both describe the position of the mouse using the `Position` (a `Vector3`) of an `InputObject`,  instead of using this and related properties.


The X property describes the horizontal component of the mouse's position on the screen. The position is measured in pixels relative to the top left corner, under the topbar. This property can be used in conjunction with `Y` to produce a `Vector2` representing the mouse's position:
```lua
local position = Vector2.new(mouse.X, mouse.Y)
```

This property does not fire `Changed` or the signal returned from `GetPropertyChangedSignal`. Use the `Move` event instead.

## Code Samples

### Normalized Mouse Position

This code sample shows how you can create a `Vector2` representing the `Mouse` object's position on screen (`X` and `Y`) and the size of the screen itself (`ViewSizeX` and `ViewSizeY`). Using these, you can normalize the position of the mouse on-screen such that the top-left just under the topbar maps to (0, 0) and the bottom-right maps to (1, 1). This normalized position is calculated and printed as the mouse moves using the `Move` event.
```lua
-- Note: You should use ContextActionService or UserInputService instead of 
-- the Mouse object for accomplishing this task.
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()

local function onMouseMove()
	-- Construct Vector2 objects for the mouse's position and screen size
	local position = Vector2.new(mouse.X, mouse.Y)
	local size = Vector2.new(mouse.ViewSizeX, mouse.ViewSizeY)
	-- A normalized position will map the top left (just under the topbar)
	-- to (0, 0) the bottom right to (1, 1), and the center to (0.5, 0.5).
	-- This is calculated by dividing the position by the total size.
	local normalizedPosition = position / size
	print(normalizedPosition)
end
mouse.Move:Connect(onMouseMove)
```


Tags: ReadOnly, NotReplicated */
	readonly X: number;
	/** When detecting changes in the mouse's position on-screen, it is recommended that you use `BindAction` with `Enum.UserInputType.MouseMovement` or `InputChanged`, which both describe the position of the mouse using the `Position` (a `Vector3`) of an `InputObject`,  instead of using this and related properties.


The Y property describes the vertical component of the mouse's position on the screen. The position is measured in pixels relative to the top left corner, under the topbar. This property can be used in conjunction with `X` to produce a `Vector2` representing the mouse's position:
```lua
local position = Vector2.new(mouse.X, mouse.Y)
```

This property does not fire `Changed` or the signal returned from `GetPropertyChangedSignal`. Use the `Move` event instead.

## Code Samples

### Normalized Mouse Position

This code sample shows how you can create a `Vector2` representing the `Mouse` object's position on screen (`X` and `Y`) and the size of the screen itself (`ViewSizeX` and `ViewSizeY`). Using these, you can normalize the position of the mouse on-screen such that the top-left just under the topbar maps to (0, 0) and the bottom-right maps to (1, 1). This normalized position is calculated and printed as the mouse moves using the `Move` event.
```lua
-- Note: You should use ContextActionService or UserInputService instead of 
-- the Mouse object for accomplishing this task.
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()

local function onMouseMove()
	-- Construct Vector2 objects for the mouse's position and screen size
	local position = Vector2.new(mouse.X, mouse.Y)
	local size = Vector2.new(mouse.ViewSizeX, mouse.ViewSizeY)
	-- A normalized position will map the top left (just under the topbar)
	-- to (0, 0) the bottom right to (1, 1), and the center to (0.5, 0.5).
	-- This is calculated by dividing the position by the total size.
	local normalizedPosition = position / size
	print(normalizedPosition)
end
mouse.Move:Connect(onMouseMove)
```
When detecting changes in the mouse's position on-screen, it is recommended that you use `BindAction` with `Enum.UserInputType.MouseMovement` or `InputChanged`, which both describe the position of the mouse using the `Position` (a `Vector3`) of an `InputObject`,  instead of using this and related properties.


The Y property describes the vertical component of the mouse's position on the screen. The position is measured in pixels relative to the top left corner, under the topbar. This property can be used in conjunction with `X` to produce a `Vector2` representing the mouse's position:
```lua
local position = Vector2.new(mouse.X, mouse.Y)
```

This property does not fire `Changed` or the signal returned from `GetPropertyChangedSignal`. Use the `Move` event instead.

## Code Samples

### Normalized Mouse Position

This code sample shows how you can create a `Vector2` representing the `Mouse` object's position on screen (`X` and `Y`) and the size of the screen itself (`ViewSizeX` and `ViewSizeY`). Using these, you can normalize the position of the mouse on-screen such that the top-left just under the topbar maps to (0, 0) and the bottom-right maps to (1, 1). This normalized position is calculated and printed as the mouse moves using the `Move` event.
```lua
-- Note: You should use ContextActionService or UserInputService instead of 
-- the Mouse object for accomplishing this task.
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()

local function onMouseMove()
	-- Construct Vector2 objects for the mouse's position and screen size
	local position = Vector2.new(mouse.X, mouse.Y)
	local size = Vector2.new(mouse.ViewSizeX, mouse.ViewSizeY)
	-- A normalized position will map the top left (just under the topbar)
	-- to (0, 0) the bottom right to (1, 1), and the center to (0.5, 0.5).
	-- This is calculated by dividing the position by the total size.
	local normalizedPosition = position / size
	print(normalizedPosition)
end
mouse.Move:Connect(onMouseMove)
```


Tags: ReadOnly, NotReplicated */
	readonly Y: number;
	/** The Button1Down even fires when the the player presses their left mouse button.

This can also be accessed from a `Tool`. For example, when placed in a `LocalScript`, the code below prints Button1Down whenever the left mouse button is pressed:

```lua
local Tool = script.Parent --make sure this is a Tool object

Tool.Equipped:Connect(function(Mouse)
	Mouse.Button1Down:Connect(function()
		print("Button1Down")
	end)
end).
```

Developers can find out the position of the mouse in world-space, and if it is pointing at any `BasePart`, using the `Hit` and `Target` properties. 

For information on how to obtain the mouse object, please see the `Mouse` page.

Note, developers are recommended to use `UserInputService` instead of the `Mouse` object in new work.

## Code Samples

### Color Randomizer Tool

The following code sample, when placed in `StarterPlayerScripts` will create a tool in the player's backpack that, once equipped, will change the `BrickColor` of every `BasePart` the player clicks on.
```lua
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer
local backpack = localPlayer:WaitForChild("Backpack")

local tool = Instance.new("Tool")
tool.RequiresHandle = false
tool.CanBeDropped = false 
tool.Parent = backpack

tool.Equipped:Connect(function(mouse)
	mouse.Button1Down:Connect(function()
		if mouse.Target and mouse.Target.Parent then
			mouse.Target.BrickColor = BrickColor.Random()
		end
	end)
end)
```
 */
	readonly Button1Down: RBXScriptSignal<() => void>;
	/** Fires when the left mouse button is released.

For information on how to obtain the `Mouse` object, please see the `Mouse` page.

Developers can find out the position of the mouse in world-space, and if it is pointing at any `BasePart` using the `Hit` and `Target` properties.

Note, developers are recommended to use `UserInputService` instead of the `Mouse` object in new work.

## Code Samples

### Color Randomizer Tool (Button1Up)

The follow example changes the `BrickColor` of every `BasePart` the player clicks and releases their mouse on. 

In order for a part to change color, the player's mouse must be over the part both when the player presses their left mouse button down and when the player releases their left mouse button.
```lua
local mouse = game.Players.LocalPlayer:GetMouse()
local target = nil

mouse.Button1Down:Connect(function()
	target = mouse.Target
end)

mouse.Button1Up:Connect(function()
	if target == mouse.Target then
		target.BrickColor = BrickColor.Random()
	end
end)
```
 */
	readonly Button1Up: RBXScriptSignal<() => void>;
	/** The Button2Down even fires when the the player presses their right mouse button.

This can also be accessed from a `Tool`. For example, when placed in a `LocalScript`, the code below prints Button2Down whenever the right mouse button is pressed:

```lua
local Tool = script.Parent --make sure this is a Tool object

Tool.Equipped:Connect(function(Mouse)
	Mouse.Button2Down:Connect(function()
		print("Button2Down")
	end)
end).
```

Developers can find out the position of the mouse in world-space, and if it is pointing at any `BasePart`, using the `Hit` and `Target` properties. 

For information on how to obtain the mouse object, please see the `Mouse` page.

Note, developers are recommended to use `UserInputService` instead of the `Mouse` object in new work.

## Code Samples

### Color Randomizer Tool

The following code sample, when placed in `StarterPlayerScripts` will create a tool in the player's backpack that, once equipped, will change the `BrickColor` of every `BasePart` the player clicks on.
```lua
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer
local backpack = localPlayer:WaitForChild("Backpack")

local tool = Instance.new("Tool")
tool.RequiresHandle = false
tool.CanBeDropped = false 
tool.Parent = backpack

tool.Equipped:Connect(function(mouse)
	mouse.Button2Down:Connect(function()
		if mouse.Target and mouse.Target.Parent then
			mouse.Target.BrickColor = BrickColor.Random()
		end
	end)
end)
```
 */
	readonly Button2Down: RBXScriptSignal<() => void>;
	/** Fired when the right mouse button is released.

```lua
mouse.Button2Up:Connect(function()
print("button 2 up!")
end
```


For information on how to obtain the `Mouse` object, please see the `Mouse` page.

Developers can find out the position of the mouse in world-space, and if it is pointing at any `BasePart` using the `Hit` and `Target` properties.

Note, developers are recommended to use `UserInputService` instead of the `Mouse` object in new work. */
	readonly Button2Up: RBXScriptSignal<() => void>;
	/** Fired during every heartbeat that the mouse isn't being passed to another mouse event.

Note, this event should not be used to determine when the mouse is still. As it fires every heartbeat it will fire between `Move` events.

For information on how to obtain the `Mouse` object, please see the `Mouse` page.

Developers can find out the position of the mouse in world-space, and if it is pointing at any `BasePart` using the `Hit` and `Target` properties.

Note, developers are recommended to use `UserInputService` instead of the `Mouse` object in new work.

## Code Samples

### Mouse.Idle

This example demonstrates how mouse events are passed during each frame
```lua

local mouse = game.Players.LocalPlayer:GetMouse()
local rs = game:GetService("RunService")
local events = {"Button1Down","Button1Up","Button2Down","Button2Up","Idle","Move","WheelBackward","WheelForward","KeyDown","KeyUp"}
local currentEvent
local frame = 0

for _,event in pairs(events) do
	mouse[event]:Connect(function ()
		currentEvent = event
	end)
end

local function processInput()
	frame = frame + 1
	print("Frame",frame,"- mouse event was passed to",currentEvent)
end

rs:BindToRenderStep("ProcessInput",Enum.RenderPriority.Input.Value,processInput)

```
 */
	readonly Idle: RBXScriptSignal<() => void>;
	/** Fired when the mouse is moved.

Note, this event is fired when the mouse's position is updated, therefore it will fire repeatedly whilst being moved.

For information on how to obtain the `Mouse` object, please see the `Mouse` page.

Developers can find out the position of the mouse in world-space, and if it is pointing at any `BasePart` using the `Hit` and `Target` properties.

```lua
mouse.Move:Connect(function()
	local position = mouse.Hit.p
	local target = mouse.Target
	print(target, position)
end)
```


Note, developers are recommended to use `UserInputService` instead of the `Mouse` object in new work. */
	readonly Move: RBXScriptSignal<() => void>;
	/** Fires when the mouse wheel is scrolled backwards.

See `WheelForward` for the scrolling forward event. 

For information on how to obtain the `Mouse` object, please see the `Mouse` page.

Note, developers are recommended to use `UserInputService` instead of the `Mouse` object in new work.

## Code Samples

### Mouse.WheelBackward

The below example assumes that you have already got the player's mouse (and set it as a variable named 'mouse'), whether by use of a `/Tool`, `/HopperBin` or the `/Player/GetMouse` method. It will print "Wheel went backwards!" when the player scrolls backwards.
```lua

mouse.WheelBackward:Connect(function()
    print("Wheel went backwards!")
end)

```
 */
	readonly WheelBackward: RBXScriptSignal<() => void>;
	/** Fires when the mouse wheel is scrolled forwards.

See `WheelBackward` for the scrolling backwards event.

For information on how to obtain the `Mouse` object, please see the `Mouse` page.

Note, developers are recommended to use `UserInputService` instead of the `Mouse` object in new work.

## Code Samples

### Mouse.WheelForward

The below example assumes that you have already got the player's mouse (and set it as a variable named 'mouse'), whether by use of a `Tool`, `HopperBin` or the `/Player/GetMouse` method. It will print "Wheel went forward!" when the player scrolls forwards.
```lua

mouse.WheelForward:Connect(function()
    print("Wheel went forward!")
end)

```
 */
	readonly WheelForward: RBXScriptSignal<() => void>;
}
/** The Mouse object is the code interface for the computer mouse.

## How to get the Mouse?
A Mouse object is not createable, but can be obtained using the `GetMouse`, `Equipped`. The `PluginMouse` object, which inherits from Mouse can be created using the `Plugin` `GetMouse` function.

```lua
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer -- from a LocalScript
local mouse = Player:GetMouse()
```


```lua
Tool.Equipped:Connect(function(mouse)
	-- got mouse
end)
```


## Mouse alternatives

There is a degree of overlap between the functionality offered by `ContextActionService`, `UserInputService` and the Mouse object.

Mouse, by and large, has been superseded by `UserInputService` which offers wider additional functionality for interacting with the mouse as well as other input types. For example:

 - `UserInputService` supports other inputs such as key presses and mobile inputs whereas `Mouse` does not
 - `UserInputService` includes additional mouse features such as `MouseBehavior` and `MouseDeltaSensitivity`

In most cases developers are advised to use the new `UserInputService`. However the Mouse object remains supported for a number of reasons.

 - Mouse existed long before `UserInputService` and a large number of places and gear items are dependent on it
 - The `PluginMouse` object is still used by plugins accessing the mouse
 - The mouse object is embedded into `Tool`s and is easier to pick up for new developers */
type Mouse = PlayerMouse | PluginMouse;

/** The PlayerMouse behaves identically to the `Mouse` object that is obtained using `Equipped`. It can be accessed from `LocalScript`s using the local player's `GetMouse` method.

The only difference between the PlayerMouse and the `Mouse` object is the PlayerMouse can be obtained using the `GetMouse` method.

In most cases developers are advised to use the new `UserInputService`. However the PlayerMouse and Mouse objects remain supported for a number of reasons.

For more information on how to use the mouse object, see the `Mouse` page.

## Code Samples

### PlayerMouse

This code sample includes a simple example of how the local player's `PlayerMouse` can be retrieved using the `GetMouse` function in a `LocalScript`. This code should be placed in a `LocalScript` in `StarterPlayerScripts`.
```lua
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer
local mouse = localPlayer:GetMouse()
    
mouse.Move:Connect(function()
	print("mouse screen position: ", mouse.X, mouse.Y)
end)
```
 */
interface PlayerMouse extends RbxInternalMouse {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PlayerMouse";
}

/** The PluginMouse object gives `Plugin`s access to the mouse. It works like the `Mouse` object and can be obtained using the plugin `GetMouse` method.

Note the PluginMouse can only be used when the plugin has been activated using `Activate`.

In addition to the functions from the `Mouse` object, the PluginMouse includes the `DragEnter` function which keeps track of items being selected whilst the mouse is dragging.

For more information on how to use mouse objects, see the `Mouse` page.

## Code Samples

### PluginMouse Get

The code below demonstrates how the PluginMouse object can be obtained and used in a plugin. To use this code, paste it into a `Script` save that script to the local Plugins Folder using right click, save to file. The plugins folder can be found in the Plugins tab in the Roblox Studio toolbar.
```lua
    plugin:Activate(false) -- gain non exclusive access to the mouse 
    local mouse = plugin:GetMouse() -- get the PluginMouse 
    mouse.Button1Down:Connect(function()
    	print("Left mouse click")
    end)


```
 */
interface PluginMouse extends RbxInternalMouse {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginMouse";
}

interface MouseService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "MouseService";
}

/** The NetworkMarker is used to tell the client when the server has finished loading the world for the client. */
interface NetworkMarker extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NetworkMarker";
	/** Fired when the server has finished replicating the world to the client. */
	readonly Received: RBXScriptSignal<() => void>;
}

interface RbxInternalNetworkPeer extends RbxInternalInstance {}
/** The NetworkPeer object is the most basic class of the network objects. */
type NetworkPeer = NetworkClient | NetworkServer;

/** This service is responsible for connecting a client to a server. */
interface NetworkClient extends RbxInternalNetworkPeer {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NetworkClient";
	/** The client's authorization ticket. This is only used when connecting to non-local Roblox servers. */
	Ticket: string;
	/** Fired when the client successfully connects to a server. Returns a string showing the server's IP and Port, and the client's `ClientReplicator`. */
	readonly ConnectionAccepted: RBXScriptSignal<(peer: string, replicator: ClientReplicator) => void>;
	/** Fired if the client fails to connect to the server. */
	readonly ConnectionFailed: RBXScriptSignal<(peer: string, code: number, reason: string) => void>;
	/** Fires if the client tries to connect to a server, but the request to join was rejected. 
This usually occurs when the client isn't on the right version of Roblox. */
	readonly ConnectionRejected: RBXScriptSignal<(peer: string) => void>;
}

/** The NetworkServer stores all the `NetworkReplicator` in the game and handles all connections. `SetOutgoingKBPSLimit` can be used to imitate latency while using _Start Server_
. */
interface NetworkServer extends RbxInternalNetworkPeer {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NetworkServer";
	/** The port that the NetworkServer uses.The port that the NetworkServer uses.

Tags: ReadOnly, NotReplicated */
	readonly Port: number;
}

interface RbxInternalNetworkReplicator extends RbxInternalInstance {
	/** Returns the player that is connected to the NetworkReplicator. */
	GetPlayer(): Player;
}
/** An object which handles the replication of other objects either from the server to the client, or from the client to the server. */
type NetworkReplicator = ClientReplicator | ServerReplicator;

/** The ClientReplicator is in charge of replicating changes from the server over to the client. It represents the client's connection to a server. */
interface ClientReplicator extends RbxInternalNetworkReplicator {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ClientReplicator";
}

/** The ServerReplicator's job is to replicate changes from other clients and the server over to a certain client. */
interface ServerReplicator extends RbxInternalNetworkReplicator {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ServerReplicator";
}

/** NetworkSettings is a settings class that allow you to debug a lot of features with Roblox's server/client networking.


It can be found in Roblox Studio's settings, under the **Network**
 tab. */
interface NetworkSettings extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NetworkSettings";
	/** When set to true, a debug message will be printed to the output in cases where the physics receiver rejects a request that it received.

Note that this property is intended for Roblox engineers who are debugging network replication. This documentation may become outdated in the future, as Roblox's network code is always changing behind the scenes.

---

Incorrect Root Primitive
-

If a part receiving physics changes is not the root primitive of the assembly it belongs to, the following debug message is printed: 

`!isAssemblyRootPrimitive {PartName}`
(Where `{PartName}` is the name of the part.)

---

Grounded Part 
-

If the part receiving physics changes is grounded (see: `IsGrounded`), then the following debug message is printed:

`computeIsGrounded {PartName}`
(Where `{PartName}` is the name of the part.) */
	ArePhysicsRejectionsReported: boolean;
	/** ClientPhysicsSendRate specifies how many times physics changes can be submitted from the client to the server, per second.
This defaults to 20. */
	ClientPhysicsSendRate: number;
	/** DataGCRate specifies how frequently old replication data is garbage collected, per second. */
	DataGCRate: number;
	/** DataMtuAdjust is a property that is added to the *maximum transmission unit* size of all replication data packets.
The value of this property is constrained to [-1000,0), and defaults to -200. */
	DataMtuAdjust: number;
	/** DataSendPriority controls the send priority of regular packets in Roblox's underlying Raknet replication layer.
It can be set to the following values:

| Name | Description |
| IMMEDIATE_PRIORITY | The highest possible priority. These packets are sent immediately, and are generally not buffered or aggregated into a single datagram. |
| HIGH_PRIORITY | For every 2 IMMEDIATE_PRIORITY packets, 1 HIGH_PRIORITY packet will be sent. |
| MEDIUM_PRIORITY | For every 2 HIGH_PRIORITY packets, 1 MEDIUM_PRIORITY packet will be sent. |
| LOW_PRIORITY | For every 2 MEDIUM_PRIORITY packets, 1 LOW_PRIORITY packet will be sent. |


The value of this currently defaults to MEDIUM_PRIORITY. Changing it requires you to use the command bar.
For example, this will set the DataSendPriority to HIGH_PRIORITY:
`settings().Network.DataSendPriority = Enum.DataSendPriority.HIGH_PRIORITY`DataSendPriority controls the send priority of regular packets in Roblox's underlying Raknet replication layer.
It can be set to the following values:

| Name | Description |
| IMMEDIATE_PRIORITY | The highest possible priority. These packets are sent immediately, and are generally not buffered or aggregated into a single datagram. |
| HIGH_PRIORITY | For every 2 IMMEDIATE_PRIORITY packets, 1 HIGH_PRIORITY packet will be sent. |
| MEDIUM_PRIORITY | For every 2 HIGH_PRIORITY packets, 1 MEDIUM_PRIORITY packet will be sent. |
| LOW_PRIORITY | For every 2 MEDIUM_PRIORITY packets, 1 LOW_PRIORITY packet will be sent. |


The value of this currently defaults to MEDIUM_PRIORITY. Changing it requires you to use the command bar.
For example, this will set the DataSendPriority to HIGH_PRIORITY:
`settings().Network.DataSendPriority = Enum.DataSendPriority.HIGH_PRIORITY`

Tags: Hidden, NotReplicated */
	DataSendPriority: Enum.PacketPriority;
	/** DataSendRate specifies how frequently data packets are sent back and forth between the server and client, per second. */
	DataSendRate: number;
	/** IncommingReplicationLag is a property that allows you to simulate high-latency situations. It adds a delay time between when packets are actually sent and received. The property is measured in seconds, and defaults to 0. */
	IncommingReplicationLag: number;
	/** .The purpose of this property is unknown, as it does not appear to be used anywhere in the engine. */
	IsQueueErrorComputed: boolean;
	/** NetworkOwnerRate specifies how frequently the network owner of a `/BasePart` can be automatically changed by the server, per second. It currently defaults to 10 times per second. */
	NetworkOwnerRate: number;
	/** PhysicsMtuAdjust is a property that is added to the *maximum transmission unit* size of all physics data packets.
The value of this property is constrained to [-1000,0), and defaults to -200. */
	PhysicsMtuAdjust: number;
	/** PhysicsSendPriority controls the send priority of physics packets in Roblox's underlying RakNet replication layer.
It can be set to the following values:

| Name | Description |
| IMMEDIATE_PRIORITY | The highest possible priority. These packets are sent immediately, and are generally not buffered or aggregated into a single datagram. |
| HIGH_PRIORITY | For every 2 IMMEDIATE_PRIORITY packets, 1 HIGH_PRIORITY packet will be sent. |
| MEDIUM_PRIORITY | For every 2 HIGH_PRIORITY packets, 1 MEDIUM_PRIORITY packet will be sent. |
| LOW_PRIORITY | For every 2 MEDIUM_PRIORITY packets, 1 LOW_PRIORITY packet will be sent. |


The value of this currently defaults to HIGH_PRIORITY. Changing it requires you to use the command bar.
For example, this will set the PhysicsSendPriority to MEDIUM_PRIORITY:
`settings().Network.PhysicsSendPriority = Enum.DataSendPriority.MEDIUM_PRIORITY`PhysicsSendPriority controls the send priority of physics packets in Roblox's underlying RakNet replication layer.
It can be set to the following values:

| Name | Description |
| IMMEDIATE_PRIORITY | The highest possible priority. These packets are sent immediately, and are generally not buffered or aggregated into a single datagram. |
| HIGH_PRIORITY | For every 2 IMMEDIATE_PRIORITY packets, 1 HIGH_PRIORITY packet will be sent. |
| MEDIUM_PRIORITY | For every 2 HIGH_PRIORITY packets, 1 MEDIUM_PRIORITY packet will be sent. |
| LOW_PRIORITY | For every 2 MEDIUM_PRIORITY packets, 1 LOW_PRIORITY packet will be sent. |


The value of this currently defaults to HIGH_PRIORITY. Changing it requires you to use the command bar.
For example, this will set the PhysicsSendPriority to MEDIUM_PRIORITY:
`settings().Network.PhysicsSendPriority = Enum.DataSendPriority.MEDIUM_PRIORITY`

Tags: Hidden, NotReplicated */
	PhysicsSendPriority: Enum.PacketPriority;
	/** PhysicsSendRate specifies how frequently physics packets are sent back and forth between the server and client, per second. */
	PhysicsSendRate: number;
	/** PreferredClientPort specifies the preferred port to be used by the client when connecting to a local server.
Note that the port should be a value between 0-65535. Any value outside this range will make the client fail to connect to the server. */
	PreferredClientPort: number;
	/** PrintBits is a diagnostics property that no longer appears to be in use. It would likely print information about bits being streamed between the server and client. */
	PrintBits: boolean;
	/** PrintEvents is a diagnostics property that no longer appears to be in use. It would have likely printed information about events being replicated across the server/client boundary. */
	PrintEvents: boolean;
	/** PrintFilters is a diagnostics property that allows developers to see what changes are being filtered while `FilteringEnabled` is set to true. It's important to note that this property will only work while in a local server.

When set to true, there are several conditions where warnings will be printed into the output, as listed below:

----------

Instance Replication
-

If the client creates an instance and parents it into another instance that is visible to the server, the following warning is printed:
"**Filtering is enabled. New Instance `{1}` will not be replicated.**"
•  `{1}` — The hierarchical location of the hew instance in the `DataModel`.

----------

Property Replication
-

If the client changes the property of an instance that is visible to the server, the following warning is printed:

"**Filtering is enabled. Property `{1}` change for instance `{2}` will not be replicated.**"
• `{1}` — The name of the property.
• `{2}` — The hierarchical location of the instance in the `DataModel`.

----------

Event Replication
-

If an instance's event is fired by the client and it's normally able to replicate to the server, the following warning is printed:

"**Filtering is enabled. Event `{1}` for instance `{2}` will not be replicated.**"
• `{1}` — The name of the event.
• `{2}` — The hierarchical location of the instance in the `DataModel`.

----------

Terrain Voxel Replication
-

If the client changes a `Terrain` cell, the following warning is printed:
"**Filtering is enabled, terrain cell change will not be replicated.**"

---------- */
	PrintFilters: boolean;
	/** PrintInstances is an internal property that prints debug information about instance replication across the server/client boundary. 
There are several debug outputs that are made available when this property is set to true, as listed below.

Note that this property is intended for Roblox engineers who are debugging network replication. 
This documentation may become outdated in the future, as Roblox's network code is always changing behind the scenes.

---

Instance Creation
-

**When a new Instance is replicated, the following debug message is printed:**
`Replication NewInstance::write from cache: {1}:{2}:{3} &gt;&gt; {4}, {5} bits`

**The numbers in curly braces are substituted, and can be described as:**
• `{1}` – The `ClassName` of the new Instance.
• `{2}` – The GUID string of the new Instance (which can be retrieved via `GetDebugId`).
• `{3}` – The `Name` of the new Instance.
• `{4}` – The IP address of the peer creating the Instance.
• `{5}` – The number of bits that were written to create the Instance.

---

Instance Removal
---

**When the removal of an Instance is requested, the following debug message is printed:**
`Replication: ~{1}:{2} &lt;&lt; {3}`

**The numbers in curly braces are substituted, and can be described as:**
• `{1}`  – The `ClassName` of the new Instance.
• `{2}` – The GUID string of the new Instance (which can be retrieved via `GetDebugId`).
• `{3}` – The IP address of the peer requesting the removal of the Instance.

--- */
	PrintInstances: boolean;
	/** When set to true, debug messages will be printed into the output, pertaining to physics replication errors. There are several debug outputs that are made available when this property is set to true, as listed below.

Note that this property is intended for Roblox engineers who are debugging network replication. This documentation may become outdated in the future, as Roblox’s network code is always changing behind the scenes.

---

Outdated Physics Packet
-

This following debug message is printed if the PhysicsReceiver receives a mechanism update packet for a part that has been updated ahead of the packet's submission time:
`Physics-in old packet`

This happens if the packet is received late, and a newer packet has already been processed.

---

Unknown Part
-

This following debug message is printed if the PhysicsReceiver cannot find the part that is trying to be updated, because the provided Instance identifier was invalid:

`Physics-in of unidentified {GUID}`
(Where `{GUID}` is the unknown `GetDebugId` identifier that is supposed to be targeting the part)

This typically happens if a part is removed before the physics update packet is received.

---

Invalid Part 
-

This following debug message is printed if the PhysicsReceiver receives a request to update the physics of a part that is not a descendant of the Workspace:

`Physics-in of part not in workspace {GUID}`
(Where `{GUID}` is the `GetDebugId` identifier of the target part)

This usually happens if the part was just moved out of the Workspace, and was previously being simulated.

--- */
	PrintPhysicsErrors: boolean;
	/** A diagnostics property that no longer appears to be in use. Would likely print information about property changes being streamed between the server and client. */
	PrintProperties: boolean;
	/** When set to true, debug information is printed regarding messages that have been split up into multiple packets.

Note that this property is intended for Roblox engineers who are debugging network replication. This documentation may become outdated in the future, as Roblox’s network code is always changing behind the scenes.

---

Debug Output Format
-
The debug outputs are formatted as such:
`split message, id {1}, size {2}, split count {3}`

**The numbers in curly braces are substituted, and can be described as:**
• `{1}` – The id of the split packet.
• `{2}` – The number of bits being transmitted in each payload.
• `{3}` – The total number of split packets that should be received.

--- */
	PrintSplitMessage: boolean;
	/** When set to true, debug information is printed to the output regarding the replication of instances when `StreamingEnabled` is set to true. There are several debug outputs that are made available when this property is set to true, as listed below.

Note that this property is intended for Roblox engineers who are debugging network replication. This documentation may become outdated in the future, as Roblox’s network code is always changing behind the scenes.

---

Streaming Capacity Update
-

When the client's streaming capacity is updated, the following debug message will be printed:
`clientInstanceQuota {1}, packet in queue {2}, predictedTotalInstanceProcessTime {3}, avgStreamDataReadTime {4}, avgInstancesPerStreamData {5}`

**The numbers in curly braces are substituted, and can be described as:**
• `{1}` – The id of the client instance quota.
• `{2}` – The current number of incoming packets that have been queued.
• `{3}` – A prediction for how long it will take to update the quota. 
• `{4}` – The current average time it takes to read the stream data.
• `{5}` – The average number of instances in the stream data.

---

Instance Quota Update
-

When the client receives an instance quota update, the following debug message will be printed:
`Received new client instance quota: {1}, max region radius: {2}`

**The numbers in curly braces are substituted, and can be described as:**
• `{1}` – The id of the client instance quota.
• `{2}` – The maximum radius of space around the client's `ReplicationFocus` that can have physical instances streamed in. 

--- */
	PrintStreamInstanceQuota: boolean;
	/** When set to true, a debug message will be printed to the output, when a physics `Touched` event is replicated. This includes the `Touched` event, and the `TouchEnded` event.

Note that this property is intended for Roblox engineers who are debugging network replication. This documentation may become outdated in the future, as Roblox’s network code is always changing behind the scenes.

---

Sending 'Contact Start'
-

When the replicator is sending that contact between two parts has started, the following debug message will be printed:

`Replication: Touch:{1}-&gt;{2} &gt;&gt; {3}, bytes: {4}`

**The numbers in curly braces are substituted, and can be described as:**
• `{1}` – The name of the 1st part.
• `{2}` – The name of the 2nd part.
• `{3}` – The IP of the peer sending the change.
• `{4}` – The number of bytes that were sent to send the change.

---

Sending 'Contact End'
-

When the replicator is sending that contact between two parts has ended, the following debug message will be printed:

`Replication: Untouch:{1}-&gt;{2} &gt;&gt; {3}, bytes: {4}`

**The numbers in curly braces are substituted, and can be described as:**
• `{1}` – The name of the 1st part.
• `{2}` – The name of the 2nd part.
• `{3}` – The IP of the peer sending the change.
• `{4}` – The number of bytes that were sent to send the change.

---

Receiving 'Contact Start' 
-

When the replicator is receiving that contact between two parts has started, the following debug message will be printed:

`Replication: Touch:{1}-&gt;{2} &lt;&lt; {3}`

**The numbers in curly braces are substituted, and can be described as:**
• `{1}` – The name of the 1st part.
• `{2}` – The name of the 2nd part.
• `{3}` – The IP of the peer receiving the change.

---

Receiving 'Contact End'
-

When the replicator is receiving that contact between two parts has ended, the following debug message will be printed:

`Replication: Untouch:{1}-&gt;{2} &lt;&lt; {3}`

**The numbers in curly braces are substituted, and can be described as:**
• `{1}` – The name of the 1st part.
• `{2}` – The name of the 2nd part.
• `{3}` – The IP of the peer receiving the change.

--- */
	PrintTouches: boolean;
	/** [LACKS DOCUMENTATION] */
	ProxyEnabled: boolean;
	/** [LACKS DOCUMENTATION] */
	ProxyURL: string;
	/** ReceiveRate controls the maximum rate per second at which the network replicator is willing to receive packets. */
	ReceiveRate: number;
	/** ![RenderStreamedRegions in action!](https://developer.roblox.com/assets/blte3c189bb8bdbf8e3/ShowStreamedRegions.png)

When set to true, regions of space that are being streamed to the client will be outlined in red.
This will only be shown if `StreamingEnabled` is set to true. */
	RenderStreamedRegions: boolean;
	/** When set to true, a label will be shown above each `Player`'s head, showing the current animation being played by the Player's `Humanoid`, if any. */
	ShowActiveAnimationAsset: boolean;
	/** TouchSendRate describes the rate per second in which `Touched` events are replicated back and forth between the server and the client. This includes both the `Touched` event, and the `TouchEnded` event. */
	TouchSendRate: number;
	/** TrackDataTypes is a diagnostics property that, when set to true, tells the replicator stats to sample data about packets that are being sent. */
	TrackDataTypes: boolean;
	/** TrackPhysicsDetails is a diagnostics property that, when set to true, tells the replicator stats to sample replication physics details. */
	TrackPhysicsDetails: boolean;
	/** UsePhysicsPacketCache is a property that, when set to true, will make the `PhysicsPacketCache` service be created alongside the `NetworkServer` when a server is being initialized.

Roblox will always set the value of this property to true when initializing a server, so this property is technically obsolete. */
	UsePhysicsPacketCache: boolean;
}

/** An unfinished service that would allow you to schedule notifications.
Currently goes unimplemented, and cannot be enabled. */
interface NotificationService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NotificationService";
}

interface RbxInternalPVInstance extends RbxInternalInstance {}
/** A PVInstance is an abstract class that cannot be created. It is the base for all objects that have a physical location in the world, specifically `BasePart` and `Model`. The PV in PVInstance stands for _Position-Velocity_
. This class has existed since 2005, and while the class itself no longer has any functionality, it is used for adornable objects that can be connected to both BaseParts and Models. */
type PVInstance = BasePart | Model | Status | Workspace;

interface RbxInternalBasePart extends RbxInternalPVInstance {
	/** The Anchored property determines whether the part will be **immovable** by physics. When enabled, a part will never change position due to gravity, other parts collisions, overlapping other parts, or any other physics-related causes. A part that is not anchored is called **unanchored**. As a result, two anchored parts will never fire the `/BasePart/Touched` event on each other. An anchored part may still be moved by changing its `/BasePart/CFrame` or `/BasePart/Position`, and it still may have a nonzero `/BasePart/Velocity` and `/BasePart/RotVelocity`. Finally, if an unanchored part is joined with an anchored part through an object like a `/Weld`, it too will act anchored. If such a joint breaks the part may be affected by physics again.

It's a good idea to anchor parts that are part of your game's environment (and therefore shouldn't move). In fact, if you don't have a good reason to keep a part unanchored, you should anchor it. Unanchored parts can cause performance issues if there are many. In Roblox Studio, you can anchor/unanchor an entire model using the Anchor tool. Be sure to keep static environment models anchored, like in-world buttons, signs, and trees.

Network ownership cannot be set on anchored parts. If a part's anchored status changes on the server, the network ownership of that part will be affected.

## Code Samples

### Part Anchored Toggle

This code sample will allow a part to be clicked to toggle its anchored property. When toggled, the visual appearance of the part is updated (red means anchored, yellow means free).
```lua
local part = script.Parent

-- Create a ClickDetector so we can tell when the part is clicked 
local cd = Instance.new("ClickDetector", part)

-- This function updates how the part looks based on its Anchored state
local function updateVisuals()
	if part.Anchored then
		-- When the part is anchored...
		part.BrickColor = BrickColor.new("Bright red")
		part.Material = Enum.Material.DiamondPlate
	else
		-- When the part is unanchored...
		part.BrickColor = BrickColor.new("Bright yellow")
		part.Material = Enum.Material.Wood
	end
end

local function onToggle()
	-- Toggle the anchored property
	part.Anchored = not part.Anchored
	
	-- Update visual state of the brick
	updateVisuals()
end

-- Update, then start listening for clicks
updateVisuals()
cd.MouseClick:connect(onToggle)

```
 */
	Anchored: boolean;
	/** The BackParamA property is relevant when a part's `/BasePart/BackSurface` is set to Motor or SteppingMotor and `/BasePart/BackSurfaceInput` is set to Sin. It determines the **amplitude** of the motor's rotational velocity, using the following formula:

`MotorVelocity = ParamA * math.sin(workspace.DistributedGameTime * ParamB)`

There are no other usages for this property.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	BackParamA: number;
	/** The BackParamB property is relevant when a part's `/BasePart/BackSurface` is set to Motor or SteppingMotor and `/BasePart/BackSurfaceInput` is set to Constant or Sin. For Constant, it determines the constant rotational velocity of the motor. For Sin, it determines the **frequency** of the motor's rotational velocity, using the following formula:

`MotorVelocity = ParamB * math.sin(workspace.DistributedGameTime * ParamB)`

In no other cases is this property used.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	BackParamB: number;
	/** The BackSurface property determines the type of surface used for the +Z direction of a part. When two parts' faces are placed next to each other, they may create a joint between them depending on the SurfaceType used on the touching faces. If set to Motor, the `/BasePart/BackSurfaceInput` determines how a motor joint should behave.

Most SurfaceTypes render a texture on the part face if the `/BasePart/Material` is set to Plastic. Some SurfaceTypes - Hinge, Motor and SteppingMotor - will render a 3D adornment instead. If this property is selected in the Properties window, it will be highlighted in the game world similar to that of a `/SurfaceSelection`.

## Code Samples

### Show All SurfaceTypes

This code sample shows what each SurfaceType looks like on a part. In addition, it creates a BillboardGui label on the part with a TextLabel that reflects the name of the current SurfaceType.
```lua
local part = script.Parent

-- Create a billboard gui to display what the current surface type is
local bbgui = Instance.new("BillboardGui")
bbgui.AlwaysOnTop = true
bbgui.Size = UDim2.new(0, 200, 0, 50)
bbgui.Adornee = part
local tl = Instance.new("TextLabel")
tl.Size = UDim2.new(0, 200, 0, 50)
tl.BackgroundTransparency = 1
tl.TextStrokeTransparency = 0
tl.TextColor3 = Color3.new(1, 1, 1) -- White
tl.Parent = bbgui
bbgui.Parent = part

local function setAllSurfaces(part, surfaceType)
	part.TopSurface = surfaceType
	part.BottomSurface = surfaceType
	part.LeftSurface = surfaceType
	part.RightSurface = surfaceType
	part.FrontSurface = surfaceType
	part.BackSurface = surfaceType
end

while true do
	-- Iterate through the different SurfaceTypes
	for _, enum in pairs(Enum.SurfaceType:GetEnumItems()) do
		tl.Text = enum.Name
		setAllSurfaces(part, enum)
		wait(1)
	end
end

```
 */
	BackSurface: Enum.SurfaceType;
	/** The BackSurfaceInput property determines the kind of input provided to a part's `/BasePart/BackSurface`. This is only relevant for Motor or SteppingMotor SurfaceTypes. This property determines how `/BasePart/BackParamA` and `/BasePart/BackParamB` are used. For brevity, these properties will be referred to as ParamA and ParamB, respectively.

  - By default, this is set to NoInput. This stops the motor altogether,
  - For Constant, the motor rotates at a constant velocity equal to `ParamB`.
  - For Sin, the motor rotates at a velocity equal to `ParamA * math.sin(workspace.DistributedGameTime * ParamB)`. See `/Workspace/DistributedGameTime`.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	BackSurfaceInput: Enum.InputType;
	/** The BottomParamA property is relevant when a part's `/BasePart/BottomSurface` is set to Motor or SteppingMotor and `/BasePart/BottomSurfaceInput` is set to Sin. It determines the **amplitude** of the motor's rotational velocity, using the following formula:

`MotorVelocity = ParamA * math.sin(workspace.DistributedGameTime * ParamB)`

There are no other usages for this property.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	BottomParamA: number;
	/** The BottomParamB property is relevant when a part's `/BasePart/BottomSurface` is set to Motor or SteppingMotor and `/BasePart/BottomSurfaceInput` is set to Constant or Sin. For Constant, it determines the constant rotational velocity of the motor. For Sin, it determines the **frequency** of the motor's rotational velocity, using the following formula:

`MotorVelocity = ParamB * math.sin(workspace.DistributedGameTime * ParamB)`

In no other cases is this property used.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	BottomParamB: number;
	/** The BottomSurface property determines the type of surface used for the -Y direction of a part. When two parts' faces are placed next to each other, they may create a joint between them depending on the SurfaceType used on the touching faces. If set to Motor, the `/BasePart/BottomSurfaceInput` determines how a motor joint should behave.

Most SurfaceTypes render a texture on the part face if the `/BasePart/Material` is set to Plastic. Some SurfaceTypes - Hinge, Motor and SteppingMotor - will render a 3D adornment instead. If this property is selected in the Properties window, it will be highlighted in the game world similar to that of a `/SurfaceSelection`.

## Code Samples

### Show All SurfaceTypes

This code sample shows what each SurfaceType looks like on a part. In addition, it creates a BillboardGui label on the part with a TextLabel that reflects the name of the current SurfaceType.
```lua
local part = script.Parent

-- Create a billboard gui to display what the current surface type is
local bbgui = Instance.new("BillboardGui")
bbgui.AlwaysOnTop = true
bbgui.Size = UDim2.new(0, 200, 0, 50)
bbgui.Adornee = part
local tl = Instance.new("TextLabel")
tl.Size = UDim2.new(0, 200, 0, 50)
tl.BackgroundTransparency = 1
tl.TextStrokeTransparency = 0
tl.TextColor3 = Color3.new(1, 1, 1) -- White
tl.Parent = bbgui
bbgui.Parent = part

local function setAllSurfaces(part, surfaceType)
	part.TopSurface = surfaceType
	part.BottomSurface = surfaceType
	part.LeftSurface = surfaceType
	part.RightSurface = surfaceType
	part.FrontSurface = surfaceType
	part.BackSurface = surfaceType
end

while true do
	-- Iterate through the different SurfaceTypes
	for _, enum in pairs(Enum.SurfaceType:GetEnumItems()) do
		tl.Text = enum.Name
		setAllSurfaces(part, enum)
		wait(1)
	end
end

```
 */
	BottomSurface: Enum.SurfaceType;
	/** The BottomSurfaceInput property determines the kind of input provided to a part's `/BasePart/BottomSurface`. This is only relevant for Motor or SteppingMotor SurfaceTypes. This property determines how `/BasePart/BottomParamA` and `/BasePart/BottomParamB` are used. For brevity, these properties will be referred to as ParamA and ParamB, respectively.

  - By default, this is set to NoInput. This stops the motor altogether,
  - For Constant, the motor rotates at a constant velocity equal to `ParamB`.
  - For Sin, the motor rotates at a velocity equal to `ParamA * math.sin(workspace.DistributedGameTime * ParamB)`. See `/Workspace/DistributedGameTime`.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	BottomSurfaceInput: Enum.InputType;
	/** The BrickColor property determines the color of a part. If the part has a `/BasePart/Material`, this also determines the color used when rendering the material texture. For more control over the color, the `/BasePart/Color` property can be used (it is a Color3 variant of this property). If Color set, this property will use the closest BrickColor.

Other visual properties of a part are determined by `/BasePart/Transparency` and `/BasePart/Reflectance`.

## Code Samples

### Part Anchored Toggle

This code sample will allow a part to be clicked to toggle its anchored property. When toggled, the visual appearance of the part is updated (red means anchored, yellow means free).
```lua
local part = script.Parent

-- Create a ClickDetector so we can tell when the part is clicked 
local cd = Instance.new("ClickDetector", part)

-- This function updates how the part looks based on its Anchored state
local function updateVisuals()
	if part.Anchored then
		-- When the part is anchored...
		part.BrickColor = BrickColor.new("Bright red")
		part.Material = Enum.Material.DiamondPlate
	else
		-- When the part is unanchored...
		part.BrickColor = BrickColor.new("Bright yellow")
		part.Material = Enum.Material.Wood
	end
end

local function onToggle()
	-- Toggle the anchored property
	part.Anchored = not part.Anchored
	
	-- Update visual state of the brick
	updateVisuals()
end

-- Update, then start listening for clicks
updateVisuals()
cd.MouseClick:connect(onToggle)

```
 */
	BrickColor: BrickColor;
	/** The CFrame property determines both the position and orientation of a part relative to the world. The part is rendered such that the CFrame is the center of the rendered 3D model (with one exception outlined below). For keeping track of positions relative to a part's CFrame, an `/Attachment` is useful. Most visual flair objects (such as particles and lights) will render at a part's CFrame.

When setting CFrame, other joined parts are also moved relative to the part whose CFrame was set. This could be used for teleporting a player's character, however it is recommended to use `/Model/SetPrimaryPartCFrame` instead if you want to move an entire model. Unlike `/BasePart/Position`, setting CFrame will always move the part to the exact given CFrame; in other words: **no overlap checking is done when setting CFrame.** If two collidable parts happen to overlap and one is not `/BasePart/Anchored`, the physics solver will attempt to resolve the overlap.

In online sessions, a part may be rendered differently than its CFrame may suggest (e.g., for tweening the different CFrames received from the server). Use `/BasePart/GetRenderCFrame` to get the apparent CFrame.

## Code Samples

### Setting Part CFrame

This code sample demonstrates setting a part's CFrame in many different ways. It showcases how to create and compose CFrame values. It references a sibling part called "OtherPart" for demonstrating relative positioning.
```lua
local part = script.Parent

-- Reset the part's CFrame to (0, 0, 0) with no rotation.
-- This is sometimes called the "identity" CFrame
part.CFrame = CFrame.new()

-- Set to a specific position (X, Y, Z)
part.CFrame = CFrame.new(0, 25, 10)

-- Same as above, but use a Vector3 instead
local point = Vector3.new(0, 25, 10)
part.CFrame = CFrame.new(point)

-- Set the part's CFrame to be at one point, looking at another
local lookAtPoint = Vector3.new(0, 20, 15)
part.CFrame = CFrame.new(point, lookAtPoint)

-- Rotate the part's CFrame by pi/2 radians on local X axis
part.CFrame = part.CFrame * CFrame.Angles(math.pi / 2, 0, 0)
-- Rotate the part's CFrame by 45 degrees on local Y axis
part.CFrame = part.CFrame * CFrame.Angles(0, math.rad(45), 0)
-- Rotate the part's CFrame by 180 degrees on global Z axis (note the order!)
part.CFrame = CFrame.Angles(0, 0, math.pi) * part.CFrame -- Pi radians is equal to 180 degrees

-- Composing two CFrames is done using * (the multiplication operator)
part.CFrame = CFrame.new(2, 3, 4) * CFrame.new(4, 5, 6) --> equal to CFrame.new(6, 8, 10)

-- Unlike algebraic multiplication, CFrame composition is NOT communitative: a * b is not necessarily b * a!
-- Imagine * as an ORDERED series of actions. For example, the following lines produce different CFrames:
-- 1) Slide the part 5 units on X.
-- 2) Rotate the part 45 degrees around its Y axis.
part.CFrame = CFrame.new(5, 0, 0) * CFrame.Angles(0, math.rad(45), 0)
-- 1) Rotate the part 45 degrees around its Y axis.
-- 2) Slide the part 5 units on X.
part.CFrame = CFrame.Angles(0, math.rad(45), 0) * CFrame.new(5, 0, 0)

-- There is no "CFrame division", but instead simply "doing the inverse operation".
part.CFrame = CFrame.new(4, 5, 6) * CFrame.new(4, 5, 6):inverse() --> is equal to CFrame.new(0, 0, 0)
part.CFrame = CFrame.Angles(0, 0, math.pi) * CFrame.Angles(0, 0, math.pi):inverse() --> equal to CFrame.Angles(0, 0, 0)

-- A reference to some other part
local otherPart = part.Parent.OtherPart

-- Position a part relative to another (in this case, put our part on top of otherPart)
part.CFrame = otherPart.CFrame * CFrame.new(0, part.Size.Y/2 + otherPart.Size.Y/2, 0)

-- All of this information applies to SetPrimaryPartCFrame, since that's all tht method
local model = part.Parent.Model
model:SetPrimaryPartCFrame(CFrame.new(0, 25, 0))

```
 */
	CFrame: CFrame;
	/** The CanCollide property determines whether a part will physically interact with other parts. When disabled, other parts can pass through the brick uninterrupted. Parts used for **decoration** usually have CanCollide disabled, as they need not be considered by the physics engine.

If a part is not `/BasePart/Anchored` and has CanCollide disabled, it may fall out of the world to be eventually destroyed by `/Workspace/FallenPartsDestroyHeight`. Therefore, it is usually desirable to anchor such parts or join them to another part that is anchored so that they don't fall out of the level. You can also use an object like `/BodyPosition` or `/BodyForce` to prevent falling out of the level entirely.

Even when CanCollide is disabled, parts may still fire the `/BasePart/Touched` event (as well the other parts touching them). In addition, a part allow other parts to pass through even if CanCollide is enabled if their collision groups are not set to collide with each other. Part collision groups are managed by `/PhysicsService`.

## Code Samples

### Fade Door

This code sample shows how a part can fade away when touched by a Humanoid then reappear a moment after to create a passable door.
```lua
-- Paste into a Script inside a tall part
local part = script.Parent

local OPEN_TIME = 1

-- Can the door be opened at the moment?
local debounce = false

local function open()
	part.CanCollide = false
	part.Transparency = 0.7
	part.BrickColor = BrickColor.new("Black")
end

local function close()
	part.CanCollide = true
	part.Transparency = 0
	part.BrickColor = BrickColor.new("Bright blue")
end

local function onTouch(part)
	-- If the door was already open, do nothing
	if debounce then print("D") return end
	
	-- Check if touched by a Humanoid
	local human = part.Parent:FindFirstChildOfClass("Humanoid")
	if not human then print("not human") return end

	-- Perform the door opening sequence	
	debounce = true
	open()
	wait(OPEN_TIME)
	close()
	debounce = false	
end

part.Touched:Connect(onTouch)
close()

```
 */
	CanCollide: boolean;
	/** Determines whether or not a part casts a shadow. It allows you to disable shadows for a part without having to make that part `transparent`. */
	CastShadow: boolean;
	/** The CenterOfMass property describes the position in which a `part`'s [center of mass][1] is located. Should a force be applied to the part toward this point, the part would not rotate as a result of this force. **CenterOfMass is currently not enabled.**

  [1]: https://en.wikipedia.org/wiki/Center_of_mass */
	readonly CenterOfMass: Vector3;
	/** The CollisionGroupId property describes the ID number of the part's collision group. Parts start off in the Default group whose ID is 0. Although this property can be directly changed, it is recommended to instead manipulate the collision group of a part using the **name** of the group with the `/PhysicsService/SetPartCollisionGroup` function. You can find the ID of a collision group by using `/PhysicsService/GetCollisionGroupId`.

This value cannot be negative, and cannot exceed `/PhysicsService/GetMaxCollisionGroups`. Invalid IDs are clamped.

## Code Samples

### PhysicsService:GetCollisionGroupId1


```lua
local physicsService = game:GetService("PhysicsService")

-- returns a valid group id (int) or nil
function getGroupId(name)
	-- GetCollisionGroupId will throw if it does not exist
	local ok, groupId = pcall(physicsService.GetCollisionGroupId, physicsService, name)
	return ok and groupId or nil
end

-- returns a valid group id (int) or nil
function getOrCreateGroupId(name)
	local ok, groupId = pcall(physicsService.GetCollisionGroupId, physicsService, name)
	if not ok then
		-- Create may fail if we have hit the maximum of 32 different groups
		ok, groupId = pcall(physicsService.CreateCollisionGroup, physicsService, name)
	end
	return ok and groupId or nil
end
	
print(getGroupId("Test")) -- prints nil
print(getOrCreateGroupId("Test")) -- prints 1
print(getGroupId("Test")) -- prints 1
```
 */
	CollisionGroupId: number;
	/** The Color property determines the color of a part. If the part has a `/BasePart/Material`, this also determines the color used when rendering the material texture. If this property is set, `/BasePart/BrickColor` will use the closest BrickColor to the Color3 value.

Other visual properties of a part are determined by `/BasePart/Transparency` and `/BasePart/Reflectance`.

## Code Samples

### Character Health Body Color

This code sample colors a player's entire character based on how much health they have. It generates a color based on their max health, then sets the color properties of objects within their character, removing any extra objects.
```lua
-- Paste into a Script within StarterCharacterScripts 
-- Then play the game, and fiddle with your character's health
local char = script.Parent
local human = char.Humanoid

local colorHealthy = Color3.new(.4, 1, .2)
local colorUnhealthy = Color3.new(1, .4, .2)

-- Set the color of the humanoid, removing any extra objects
local function setColor(color)
	for _, child in pairs(char:GetChildren()) do
		if child:IsA("BasePart") then
			-- Set the color of any parts
			child.Color = color
			-- Remove decals
			while child:FindFirstChildOfClass("Decal") do
				child:FindFirstChildOfClass("Decal"):Destroy()
			end
		elseif child:IsA("Accessory") then
			-- Set the color of any accessories
			child.Handle.Color = color
			local mesh = child.Handle:FindFirstChildOfClass("SpecialMesh")
			if mesh then mesh.TextureId = "" end
		elseif child:IsA("Shirt") or child:IsA("Pants") then
			-- Remove shirt/pant textures
			child:Destroy()
		end
	end
end

local function update()
	-- Calculate the percentage health the human has
	local perc = human.Health / human.MaxHealth
	
	-- Create a color by tweening based on the percentage of your healthy
	-- The color goes from colorHealthy (100%) ----- > colorUnhealthy (0%)
	local color = Color3.new(
		colorHealthy.r * perc + colorUnhealthy.r * (1 - perc),
		colorHealthy.g * perc + colorUnhealthy.g * (1 - perc),
		colorHealthy.b * perc + colorUnhealthy.b * (1 - perc)
	)
	setColor(color)
end

update()
human.HealthChanged:Connect(update)

```
 */
	Color: Color3;
	/** CustomPhysicalProperties lets you customize various physical aspects of a `part`, such as its's density, friction, and elasticity. 

If enabled, this property let’s you configure these physical properties. If disabled, these physical properties are determined by the `Material` of the part. The page for `Material` contains list of the various part materials.

## Code Samples

### Set CustomPhysicalProperties

This code sample demonstrates how to set the CustomPhysicalProperties property of a part.
```lua
local part = script.Parent

-- The properties to set
-- This will make the part light and bouncy!
local density = .3
local friction = .1
local elasticity = 1
local frictionWeight = 1
local elasticityWeight = 1

-- Construct new PhysicalProperties and set
local physProperties = PhysicalProperties.new(density, friction, elasticity, frictionWeight, elasticityWeight)
part.CustomPhysicalProperties = physProperties
```
 */
	CustomPhysicalProperties: PhysicalProperties;
	/** The FrontParamA property is relevant when a part's `/BasePart/FrontSurface` is set to Motor or SteppingMotor and `/BasePart/FrontSurfaceInput` is set to Sin. It determines the **amplitude** of the motor's rotational velocity, using the following formula:

`MotorVelocity = ParamA * math.sin(workspace.DistributedGameTime * ParamB)`

In no other cases is this property used.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	FrontParamA: number;
	/** The FrontParamB property is relevant when a part's `/BasePart/FrontSurface` is set to Motor or SteppingMotor and `/BasePart/FrontSurfaceInput` is set to Constant or Sin. For Constant, it determines the constant rotational velocity of the motor. For Sin, it determines the **frequency** of the motor's rotational velocity, using the following formula:

`MotorVelocity = ParamB * math.sin(workspace.DistributedGameTime * ParamB)`

In no other cases is this property used.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	FrontParamB: number;
	/** The FrontSurface property determines the type of surface used for the -Z direction of a part. When two parts' faces are placed next to each other, they may create a joint between them depending on the SurfaceType used on the touching faces. If set to Motor, the `/BasePart/FrontSurfaceInput` determines how a motor joint should behave.

Most SurfaceTypes render a texture on the part face if the `/BasePart/Material` is set to Plastic. Some SurfaceTypes - Hinge, Motor and SteppingMotor - will render a 3D adornment instead. If this property is selected in the Properties window, it will be highlighted in the game world similar to that of a `/SurfaceSelection`.

## Code Samples

### Show All SurfaceTypes

This code sample shows what each SurfaceType looks like on a part. In addition, it creates a BillboardGui label on the part with a TextLabel that reflects the name of the current SurfaceType.
```lua
local part = script.Parent

-- Create a billboard gui to display what the current surface type is
local bbgui = Instance.new("BillboardGui")
bbgui.AlwaysOnTop = true
bbgui.Size = UDim2.new(0, 200, 0, 50)
bbgui.Adornee = part
local tl = Instance.new("TextLabel")
tl.Size = UDim2.new(0, 200, 0, 50)
tl.BackgroundTransparency = 1
tl.TextStrokeTransparency = 0
tl.TextColor3 = Color3.new(1, 1, 1) -- White
tl.Parent = bbgui
bbgui.Parent = part

local function setAllSurfaces(part, surfaceType)
	part.TopSurface = surfaceType
	part.BottomSurface = surfaceType
	part.LeftSurface = surfaceType
	part.RightSurface = surfaceType
	part.FrontSurface = surfaceType
	part.BackSurface = surfaceType
end

while true do
	-- Iterate through the different SurfaceTypes
	for _, enum in pairs(Enum.SurfaceType:GetEnumItems()) do
		tl.Text = enum.Name
		setAllSurfaces(part, enum)
		wait(1)
	end
end

```
 */
	FrontSurface: Enum.SurfaceType;
	/** The FrontSurfaceInput property determines the kind of input provided to a part's `/BasePart/FrontSurface`. This is only relevant for Motor or SteppingMotor SurfaceTypes. This property determines how `/BasePart/FrontParamA` and `/BasePart/FrontParamB` are used. For brevity, these properties will be referred to as ParamA and ParamB, respectively.

  - By default, this is set to NoInput. This stops the motor altogether,
  - For Constant, the motor rotates at a constant velocity equal to `ParamB`.
  - For Sin, the motor rotates at a velocity equal to `ParamA * math.sin(workspace.DistributedGameTime * ParamB)`. See `/Workspace/DistributedGameTime`.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	FrontSurfaceInput: Enum.InputType;
	/** The LeftParamA property is relevant when a part's `/BasePart/LeftSurface` is set to Motor or SteppingMotor and `/BasePart/LeftSurfaceInput` is set to Sin. It determines the **amplitude** of the motor's rotational velocity, using the following formula:

`MotorVelocity = ParamA * math.sin(workspace.DistributedGameTime * ParamB)`

In no other cases is this property used.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	LeftParamA: number;
	/** The LeftParamB property is relevant when a part's `/BasePart/LeftSurface` is set to Motor or SteppingMotor and `/BasePart/LeftSurfaceInput` is set to Constant or Sin. For Constant, it determines the constant rotational velocity of the motor. For Sin, it determines the **frequency** of the motor's rotational velocity, using the following formula:

`MotorVelocity = ParamB * math.sin(workspace.DistributedGameTime * ParamB)`

In no other cases is this property used.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	LeftParamB: number;
	/** The LeftSurface property determines the type of surface used for the -X direction of a part. When two parts' faces are placed next to each other, they may create a joint between them depending on the SurfaceType used on the touching faces. If set to Motor, the `/BasePart/LeftSurfaceInput` determines how a motor joint should behave.

Most SurfaceTypes render a texture on the part face if the `/BasePart/Material` is set to Plastic. Some SurfaceTypes - Hinge, Motor and SteppingMotor - will render a 3D adornment instead. If this property is selected in the Properties window, it will be highlighted in the game world similar to that of a `/SurfaceSelection`.

## Code Samples

### Show All SurfaceTypes

This code sample shows what each SurfaceType looks like on a part. In addition, it creates a BillboardGui label on the part with a TextLabel that reflects the name of the current SurfaceType.
```lua
local part = script.Parent

-- Create a billboard gui to display what the current surface type is
local bbgui = Instance.new("BillboardGui")
bbgui.AlwaysOnTop = true
bbgui.Size = UDim2.new(0, 200, 0, 50)
bbgui.Adornee = part
local tl = Instance.new("TextLabel")
tl.Size = UDim2.new(0, 200, 0, 50)
tl.BackgroundTransparency = 1
tl.TextStrokeTransparency = 0
tl.TextColor3 = Color3.new(1, 1, 1) -- White
tl.Parent = bbgui
bbgui.Parent = part

local function setAllSurfaces(part, surfaceType)
	part.TopSurface = surfaceType
	part.BottomSurface = surfaceType
	part.LeftSurface = surfaceType
	part.RightSurface = surfaceType
	part.FrontSurface = surfaceType
	part.BackSurface = surfaceType
end

while true do
	-- Iterate through the different SurfaceTypes
	for _, enum in pairs(Enum.SurfaceType:GetEnumItems()) do
		tl.Text = enum.Name
		setAllSurfaces(part, enum)
		wait(1)
	end
end

```
 */
	LeftSurface: Enum.SurfaceType;
	/** The LeftSurfaceInput property determines the kind of input provided to a part's `/BasePart/LeftSurface`. This is only relevant for Motor or SteppingMotor SurfaceTypes. This property determines how `/BasePart/LeftParamA` and `/BasePart/LeftParamB` are used. For brevity, these properties will be referred to as ParamA and ParamB, respectively.

  - By default, this is set to NoInput. This stops the motor altogether,
  - For Constant, the motor rotates at a constant velocity equal to `ParamB`.
  - For Sin, the motor rotates at a velocity equal to `ParamA * math.sin(workspace.DistributedGameTime * ParamB)`. See `/Workspace/DistributedGameTime`.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	LeftSurfaceInput: Enum.InputType;
	/** The LocalTransparencyModifier property is a multiplier to `Transparency` that is only visible to the local client. It does not replicate from client to server. It is useful for when a part should not render for a specific client, such as how the player does not see their character’s body parts when they zoom into first person mode.

The property modifies the local part’s transparency increases a part’s transparency on a scale from 0 to 1 using the following formula:

```lua
lua
	-- Calculate the part’s client-side transparency. Values greater than 1 round down to 1.
	local clientTransparency = part.Transparency + (1 * part.localTransparencyModifier)
```


Take a look at the table below for an example of how this property affect’s a part’s client-side transparency:

| Transparency | LocalTransparencyModifier | Server-Side Transparency | Client-Side Transparency | Description                                                                                                                                                                              |
|--------------|---------------------------|--------------------------|--------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0.5          | 0                         | 0.5                      | 0.5                      | A modifier value of 0.5 means that the part's client-side transparency is affected as follows: 0.5 + 1*0 = 0.5. The part's client-side transparency equals its server-side transparency. |
| 0.5          | 0.5                       | 0.5                      | 0.75                     | A modifier value of 0.5 means that the part's client-side transparency is affected as follows: 0.5 + 1*0.5 = 0.75                                                                        |
| 0.5          | 1                         | 0.5                      | 1                        | A modifier value of 1 means that the part's client-side transparency is affected as follows: 0.5 + 1*1 = >1. The client does not render the part.                                        |

## Code Samples

### X-Ray Vision

This code sample gives the local client X-ray vision using LocalTransparencyModifier. It allows the player to see through all parts in the Workspace, which are found using recursion.
```lua
-- X-ray vision: see through everything!

local function makeXRayPart(part)
	-- LocalTransparencyModifier will make parts see-through but only for the local
	-- client, and it won't replicate to the server
	part.LocalTransparencyModifier = .5 
end

-- This function uses recursion to search for parts in the game
local function recurseForParts(object)
	-- Did we find a part that isn't 
	if object:IsA("BasePart") then
		makeXRayPart(object)
	end
	
	-- Stop if this object has a Humanoid - we don't want to see-through players! 
	if object:FindFirstChildOfClass("Humanoid") then return end
	
	-- Check the object's children for more parts
	for _, child in pairs(object:GetChildren()) do
		recurseForParts(child)
	end
end

recurseForParts(workspace)

```
 */
	LocalTransparencyModifier: number;
	/** The Locked property determines whether a `part` (or a `model` it is contained within) may be selected in Roblox Studio by clicking on it. This property is most often enabled on parts within environment models that aren't being edited at the moment. Roblox Studio has a Lock/Unlock All tool that can toggle the Locked state of every part descendant in a model at once.

## Code Samples

### Recursive Unlock

This code sample uses the concept of recursion to unlock all parts that are a descendant of a model.
```lua
-- Paste into a Script within a Model you want to unlock
local model = script.Parent

-- This function recurses through a model's heirarchy and unlocks
-- every part that it encounters. 
local function recursiveUnlock(object)
	if object:IsA("BasePart") then
		object.Locked = false
	end
	
	-- Call the same function on the children of the object
	-- Note: The recursive process stops if an object has no children
	for _, child in pairs(object:GetChildren()) do
		recursiveUnlock(child)
	end
end

recursiveUnlock(model)
-- You could unlock every part in the workspace by calling
-- the function with the workspace, like this:
--recursiveUnlock(workspace)

```
 */
	Locked: boolean;
	/** If this property is enabled, the `part` will not contribute to the total mass or inertia of its rigid body as long as it is `welded` to another part that has mass.



If the part is its own root part according to `GetRootPart` then this will be ignored for that part, and it will still contribute mass and inertia to its rigid body like a normal part. Parts that are massless should never become an assembly root part unless all other parts in the assembly are also massless.

This might be useful for things like optional accessories on vehicles that you don’t want to affect the handling of the car or a massless render mesh welded to a simpler collision mesh. For instance, to create a massless `MeshPart`, you would use the follow code:

```lua
local mesh = Instance.new("MeshPart")
mesh.Parent = game.Workspace
mesh.MeshId = "insert meshId here"
mesh.Massless = true
```


## See also
- `understanding root Understanding Root Parts`, an article documenting what root parts are and how to use them */
	Massless: boolean;
	/** The Material property allows a builder to set a part's texture and default physical properties (in the case that `/BasePart/CustomPhysicalProperties` is unset). The default Plastic material has a very light texture, and the SmoothPlastic material has no texture at all. Some material textures like DiamondPlate and Granite have very visible textures. Each material's texture reflects sunlight differently, especially Foil.

Setting this property then enabling `/BasePart/CustomPhysicalProperties` will use the default physical properties of a material. For instance, DiamondPlate is a very dense material while Wood is very light. A part's density determines whether it will float in terrain water.

The Glass material changes rendering behavior on moderate graphics settings. It applies a bit of reflectiveness (similar to `/BasePart/Reflectance`) and perspective distortion. The effect is especially pronounced on sphere-shaped parts (set `/BasePart/Shape` to Ball). Semitransparent objects and Glass parts behind Glass are not visible.

## Code Samples

### Part Anchored Toggle

This code sample will allow a part to be clicked to toggle its anchored property. When toggled, the visual appearance of the part is updated (red means anchored, yellow means free).
```lua
local part = script.Parent

-- Create a ClickDetector so we can tell when the part is clicked 
local cd = Instance.new("ClickDetector", part)

-- This function updates how the part looks based on its Anchored state
local function updateVisuals()
	if part.Anchored then
		-- When the part is anchored...
		part.BrickColor = BrickColor.new("Bright red")
		part.Material = Enum.Material.DiamondPlate
	else
		-- When the part is unanchored...
		part.BrickColor = BrickColor.new("Bright yellow")
		part.Material = Enum.Material.Wood
	end
end

local function onToggle()
	-- Toggle the anchored property
	part.Anchored = not part.Anchored
	
	-- Update visual state of the brick
	updateVisuals()
end

-- Update, then start listening for clicks
updateVisuals()
cd.MouseClick:connect(onToggle)

```
 */
	Material: Enum.Material;
	/** The Orientation property describes the part's rotation in degrees around the X, Y and Z axes using a Vector3. The rotations are applied in Y → X → Z order. This differs from proper [Euler angles][1], and is instead [Tait–Bryan angles][2] which describe **yaw, pitch and roll**. It is also worth noting how this property differs from the `CFrame.Angles()` constructor, which applies rotations in a different order (Z → Y → X). For better control over the rotation of a part, it is recommended that `/BasePart/CFrame` is set instead.

  [1]: https://en.wikipedia.org/wiki/Euler_angles
  [2]: https://en.wikipedia.org/wiki/Euler_angles#Tait-Bryan_angles

## Code Samples

### Part Spinner

This code sample rotates a part continually on the Y axis.
```lua
local part = script.Parent

local incr = 360/20

-- Rotate the part continually
while true do
	for deg = 0, 360, incr do
		-- Set only the Y axis rotation
		part.Rotation = Vector3.new(0, deg, 0)
		-- A better way to do this would be setting CFrame
		--part.CFrame = CFrame.new(part.Position) * CFrame.Angles(0, math.rad(deg), 0)
		wait()
	end
end

```
 */
	Orientation: Vector3;
	/** The Position property describes the coordinates of a `part` using a `Vector3`. It reflects the position of the part's `/BasePart/CFrame`, however it can also be set. 

When setting Position, **overlap checking takes place**: if moving the part would cause it to overlap with another part, the destination position shall be just high enough so no overlap occurs. To avoid this, set the part's CFrame instead.

## Code Samples

### Position Overlap Checking

This code sample demonstrates the overlap checking behavior of the Position property by creating two parts, PartA and PartB. It attempts to place them at the same Position.
```lua
-- Create two parts, PartA and PartB
local partA = Instance.new("Part", workspace)
partA.Name = "PartA"
partA.BrickColor = BrickColor.new("Really red")
partA.Anchored = true
local partB = Instance.new("Part", workspace)
partB.Name = "PartB"
partB.BrickColor = BrickColor.new("Really blue")
partB.Anchored = true

-- Demonstrate overlap
partA.Position = Vector3.new(0, 50, 0)
partB.Position = Vector3.new(0, 50, 0) -- This would cause an overlap!
print(partB.Position == Vector3.new(0, 50, 0)) --> false
print(partB.Position) --> Very close to (0, 51.2, 0)

```
 */
	Position: Vector3;
	/** This returns the time in seconds since the part's physics got last updated on the local client (or the server). Returns 0 when the part has no physics (Anchored) */
	readonly ReceiveAge: number;
	/** The Reflectance property determines how much a `part` reflects the skybox.  A value of 0 indicates the part is not reflective at all, and a value of 1 indicates the part should fully reflect. 

Reflectance is not affected by `/BasePart/Transparency`, unless the part is fully transparent, in which case reflectance will not render at all. Reflectance may or may not be ignored depending on the `/BasePart/Material` of the part.

## Code Samples

### Touch Blink

This code sample causes a part to blink its Reflectance and a PointLight every time it is touched. It uses a pattern that prevents multiple concurrent function calls from fighting with each other.
```lua
local part = script.Parent

-- Add a light
local pointLight = Instance.new("PointLight", part)
pointLight.Brightness = 0
pointLight.Range = 12

local touchNo = 0
local function blink()
	-- Advance touchNo to tell other blink() calls to stop early
	touchNo = touchNo + 1
	-- Save touchNo locally so we can tell when it changes globally
	local myTouchNo = touchNo
	for i = 1, 0, -.1 do
		-- Stop early if another blink started
		if touchNo ~= myTouchNo then break end
		-- Update the blink animation
		part.Reflectance = i
		pointLight.Brightness = i * 2
		wait(0.05)
	end
end

part.Touched:Connect(blink)

```
 */
	Reflectance: number;
	/** The ResizeIncrement property is a read-only property that describes the smallest change in size allowable by the `/BasePart/Resize` method. It differs between implementations of the `/BasePart` abstract class. For instance, `/Part` has this set to 1 and `/TrussPart` has this set to 2 (since individual truss sections are 2x2x2 in size).

## Code Samples

### Resize Handles

This code sample creates a Handles object and shows how to set the Faces property of the object. It also references ResizeableFaces of a part. Try placing this script in multiple kinds of parts to see how ResizeableFaces varies.
```lua
-- Put this Script in several kinds of BasePart, like
-- Part, TrussPart, WedgePart, CornerWedgePart, etc.
local part = script.Parent

-- Create a handles object for this part
local handles = Instance.new("Handles")
handles.Adornee = part
handles.Parent = part

-- Manually specify the faces applicable for this handle
handles.Faces = Faces.new(Enum.NormalId.Top, Enum.NormalId.Front, Enum.NormalId.Left)

-- Alternatively, use the faces on which the part can be resized.
-- If part is a TrussPart with only two Size dimensions
-- of length 2, then ResizeableFaces will only have two
-- enabled faces. For other parts, all faces will be enabled. 
handles.Faces = part.ResizeableFaces

```
 */
	readonly ResizeIncrement: number;
	/** The ResizeableFaces property (with an **e**, not ResizableFaces) describes using a Faces object the different faces on which a part may be resized. For most implementations of `/BasePart`, such as `/Part` and `/WedgePart`, this property includes all faces. However, `/TrussPart` will set its ResizeableFaces set to only two faces since those kinds of parts must have two `/BasePart/Size` dimensions of length 2. This property is most commonly used with tools used for building and manipulating parts and has little use outside of that context. The `/Handles` class, which has the `/Handles/Faces` property, can be used in conjunction with this property to display only the handles on faces that can be resized on a part.

## Code Samples

### Resize Handles

This code sample creates a Handles object and shows how to set the Faces property of the object. It also references ResizeableFaces of a part. Try placing this script in multiple kinds of parts to see how ResizeableFaces varies.
```lua
-- Put this Script in several kinds of BasePart, like
-- Part, TrussPart, WedgePart, CornerWedgePart, etc.
local part = script.Parent

-- Create a handles object for this part
local handles = Instance.new("Handles")
handles.Adornee = part
handles.Parent = part

-- Manually specify the faces applicable for this handle
handles.Faces = Faces.new(Enum.NormalId.Top, Enum.NormalId.Front, Enum.NormalId.Left)

-- Alternatively, use the faces on which the part can be resized.
-- If part is a TrussPart with only two Size dimensions
-- of length 2, then ResizeableFaces will only have two
-- enabled faces. For other parts, all faces will be enabled. 
handles.Faces = part.ResizeableFaces

```
 */
	readonly ResizeableFaces: Faces;
	/** The RightParamA property is relevant when a part's `/BasePart/RightSurface` is set to Motor or SteppingMotor and `/BasePart/RightSurfaceInput` is set to Sin. It determines the **amplitude** of the motor's rotational velocity, using the following formula:

`MotorVelocity = ParamA * math.sin(workspace.DistributedGameTime * ParamB)`

In no other cases is this property used.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	RightParamA: number;
	/** The RightParamB property is relevant when a part's `/BasePart/RightSurface` is set to Motor or SteppingMotor and `/BasePart/RightSurfaceInput` is set to Constant or Sin. For Constant, it determines the constant rotational velocity of the motor. For Sin, it determines the **frequency** of the motor's rotational velocity, using the following formula:

`MotorVelocity = ParamB * math.sin(workspace.DistributedGameTime * ParamB)`

In no other cases is this property used.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	RightParamB: number;
	/** The RightSurface property determines the type of surface used for the +X direction of a part. When two parts' faces are placed next to each other, they may create a joint between them depending on the SurfaceType used on the touching faces. If set to Motor, the `/BasePart/RightSurfaceInput` determines how a motor joint should behave.

Most SurfaceTypes render a texture on the part face if the `/BasePart/Material` is set to Plastic. Some SurfaceTypes - Hinge, Motor and SteppingMotor - will render a 3D adornment instead. If this property is selected in the Properties window, it will be highlighted in the game world similar to that of a `/SurfaceSelection`.

## Code Samples

### Show All SurfaceTypes

This code sample shows what each SurfaceType looks like on a part. In addition, it creates a BillboardGui label on the part with a TextLabel that reflects the name of the current SurfaceType.
```lua
local part = script.Parent

-- Create a billboard gui to display what the current surface type is
local bbgui = Instance.new("BillboardGui")
bbgui.AlwaysOnTop = true
bbgui.Size = UDim2.new(0, 200, 0, 50)
bbgui.Adornee = part
local tl = Instance.new("TextLabel")
tl.Size = UDim2.new(0, 200, 0, 50)
tl.BackgroundTransparency = 1
tl.TextStrokeTransparency = 0
tl.TextColor3 = Color3.new(1, 1, 1) -- White
tl.Parent = bbgui
bbgui.Parent = part

local function setAllSurfaces(part, surfaceType)
	part.TopSurface = surfaceType
	part.BottomSurface = surfaceType
	part.LeftSurface = surfaceType
	part.RightSurface = surfaceType
	part.FrontSurface = surfaceType
	part.BackSurface = surfaceType
end

while true do
	-- Iterate through the different SurfaceTypes
	for _, enum in pairs(Enum.SurfaceType:GetEnumItems()) do
		tl.Text = enum.Name
		setAllSurfaces(part, enum)
		wait(1)
	end
end

```
 */
	RightSurface: Enum.SurfaceType;
	/** The RightSurfaceInput property determines the kind of input provided to a part's `/BasePart/RightSurface`. This is only relevant for Motor or SteppingMotor SurfaceTypes. This property determines how `/BasePart/RightParamA` and `/BasePart/RightParamB` are used. For brevity, these properties will be referred to as ParamA and ParamB, respectively.

  - By default, this is set to NoInput. This stops the motor altogether,
  - For Constant, the motor rotates at a constant velocity equal to `ParamB`.
  - For Sin, the motor rotates at a velocity equal to `ParamA * math.sin(workspace.DistributedGameTime * ParamB)`. See `/Workspace/DistributedGameTime`.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	RightSurfaceInput: Enum.InputType;
	/** This property is the main rule in determining the root part of an assembly. It is an integer between -127 and 127 that takes precedence over all other rules for root part sort (including the weird rules based on part `size`). A part with a higher RootPriority will take priority over other `unanchored` parts with equal `Massless` values and a lower RootPriority.



Use this to control which part of an assembly is the root part and keep the root part stable if size changes.

## See also
- `understanding root Understanding Root Parts`, an article documenting what root parts are and how to use them */
	RootPriority: number;
	/** The RotVelocity of a `part` describes how its `Orientation` is presently changing. In other words, this property describes how the fast part is rotating. The part only rotates if it is not anchored.

 The unit of this property is **degrees per second**.

Using this in conjunction with `AlignOrientation` allows for aligned parts to have matching RotVelocity and Orientation values. */
	RotVelocity: Vector3;
	/** The rotation of the part in degrees for the three axes. */
	Rotation: Vector3;
	/** The Size property determines the dimensions of a part. The individual dimensions can go as low as 0.05 and as high as 2048 (or 2^11). The size of the part is used in determining its mass, which is given by `/BasePart/GetMass`. The `/BasePart/Shape` of a part can apply some restrictions on Size - namely, a Ball must have the same 3 dimensions. A part's Size is used by a variety of other objects:

  - `/ParticleEmitter` uses Size to determine the area from which particles are spawned.
  - `/BlockMesh` uses Size to partially determine the rendered rectangular prism.
  - `/SpecialMesh` uses Size for some certain `/SpecialMesh/MeshType`s to determine the size of the rendered mesh.
  - `/SurfaceLight` uses Size to determine the space to illuminate.

## Code Samples

### Pyramid Builder

This code sample constructs a pyramid by stacking parts that get progressively smaller. It also colors the parts so they blend between a start color and end color.
```lua
-- Configuration of the tower
local pos = Vector3.new(50, 50, 50)
local towerBaseSize = 30

-- Decide on two colors that are different in hue
local hue = math.random()
local color0 = Color3.fromHSV(hue, 1, 1)
local color1 = Color3.fromHSV((hue + .35) % 1, 1, 1)

-- Create a model to hold tower parts
local model = Instance.new("Model")
model.Name = "Tower"
for i = towerBaseSize, 1, -2 do
	-- Create a part
	local part = Instance.new("Part")
	part.Parent = model
	part.Size = Vector3.new(i, 2, i)
	part.Position = pos
	part.Anchored = true
	-- Tween from color0 and color1
	local perc = i / towerBaseSize 
	part.Color = Color3.new(
		color0.r * perc + color1.r * (1 - perc),
		color0.g * perc + color1.g * (1 - perc),
		color0.b * perc + color1.b * (1 - perc)
	)
	-- Move up
	pos = pos + Vector3.new(0, part.Size.Y, 0)
end
model.Parent = workspace

```
 */
	Size: Vector3;
	/** The TopParamA property is relevant when a part's `/BasePart/TopSurface` is set to Motor or SteppingMotor and `/BasePart/TopSurfaceInput` is set to Sin. It determines the **amplitude** of the motor's rotational velocity, using the following formula:

`MotorVelocity = ParamA * math.sin(workspace.DistributedGameTime * ParamB)`

In no other cases is this property used.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	TopParamA: number;
	/** The TopParamB property is relevant when a part's `/BasePart/TopSurface` is set to Motor or SteppingMotor and `/BasePart/TopSurfaceInput` is set to Constant or Sin. For Constant, it determines the constant rotational velocity of the motor. For Sin, it determines the **frequency** of the motor's rotational velocity, using the following formula:

`MotorVelocity = ParamB * math.sin(workspace.DistributedGameTime * ParamB)`

In no other cases is this property used.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	TopParamB: number;
	/** The TopSurface property determines the type of surface used for the +Y direction of a part. When two parts' faces are placed next to each other, they may create a joint between them depending on the SurfaceType used on the touching faces. If set to Motor, the `/BasePart/TopSurfaceInput` determines how a motor joint should behave.

Most SurfaceTypes render a texture on the part face if the `/BasePart/Material` is set to Plastic. Some SurfaceTypes - Hinge, Motor and SteppingMotor - will render a 3D adornment instead. If this property is selected in the Properties window, it will be highlighted in the game world similar to that of a `/SurfaceSelection`.

## Code Samples

### Show All SurfaceTypes

This code sample shows what each SurfaceType looks like on a part. In addition, it creates a BillboardGui label on the part with a TextLabel that reflects the name of the current SurfaceType.
```lua
local part = script.Parent

-- Create a billboard gui to display what the current surface type is
local bbgui = Instance.new("BillboardGui")
bbgui.AlwaysOnTop = true
bbgui.Size = UDim2.new(0, 200, 0, 50)
bbgui.Adornee = part
local tl = Instance.new("TextLabel")
tl.Size = UDim2.new(0, 200, 0, 50)
tl.BackgroundTransparency = 1
tl.TextStrokeTransparency = 0
tl.TextColor3 = Color3.new(1, 1, 1) -- White
tl.Parent = bbgui
bbgui.Parent = part

local function setAllSurfaces(part, surfaceType)
	part.TopSurface = surfaceType
	part.BottomSurface = surfaceType
	part.LeftSurface = surfaceType
	part.RightSurface = surfaceType
	part.FrontSurface = surfaceType
	part.BackSurface = surfaceType
end

while true do
	-- Iterate through the different SurfaceTypes
	for _, enum in pairs(Enum.SurfaceType:GetEnumItems()) do
		tl.Text = enum.Name
		setAllSurfaces(part, enum)
		wait(1)
	end
end

```
 */
	TopSurface: Enum.SurfaceType;
	/** The TopSurfaceInput property determines the kind of input provided to a part's `/BasePart/TopSurface`. This is only relevant for Motor or SteppingMotor SurfaceTypes. This property determines how `/BasePart/TopParamA` and `/BasePart/TopParamB` are used. For brevity, these properties will be referred to as ParamA and ParamB, respectively.

  - By default, this is set to NoInput. This stops the motor altogether,
  - For Constant, the motor rotates at a constant velocity equal to `ParamB`.
  - For Sin, the motor rotates at a velocity equal to `ParamA * math.sin(workspace.DistributedGameTime * ParamB)`. See `/Workspace/DistributedGameTime`.

## Code Samples

### Motor Control

This code sample demonstrates how surface properties can be set using only a NormalId (Top, Front, etc). It switches a motor's -SurfaceInput from NoInput, Constant and Sin to show how each work using -ParamA and -ParamB properties.
```lua
-- Paste this into a Script inside a part with a Motor SurfaceType
local partMotor = script.Parent
-- Place a brick called "MovingPart" so it is touching the Motor surface
local partMoving = partMotor.Parent.MovingPart

-- For this example, we use TopSurface, TopSurfaceInput, TopParamA and TopParamB
-- However, this will work for all faces (NormalId): Top, Bottom, Left, Right, Front and Back

-- A function to quickly set all surface properties at once 
local function setFaceSurfaceInputParams(normalId, surfaceType, inputType, paramA, paramB)
	local surfaceName = normalId.Name -- e.g. "Top", "Bottom", etc

	-- Syntax Note: in Lua, part.Something is the same as part["Something"]
	-- The difference is that the latter allows us to use a string ("Something"), while
	-- the former requires use of an identifier (.Something). Below, we build of each the surface
	-- properties below by concatenating the surface name with the property postfix.
	
	-- Set "___Surface", eg "TopSurface"
	partMotor[surfaceName .. "Surface"] = surfaceType
	-- Set "___SurfaceInput", eg "TopSurfaceInput"
	partMotor[surfaceName .. "SurfaceInput"] = inputType
	-- Set "___ParamA", eg "TopParamA"
	partMotor[surfaceName .. "ParamA"] = paramA
	-- Set "___ParamB", eg "TopParamB"
	partMotor[surfaceName .. "ParamB"] = paramB
end

local normalId = Enum.NormalId.Top

while true do
	-- Set to NoInput, where the motor will not operate at all
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.NoInput, 0, 0)
	wait(1)
	-- Set to Constant, where motor rotational velocity = paramB
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Constant, 0, .25)
	wait(2)
	-- Set to Sin, where motor rotational velocity = paramA * math.sin(time * paramB)
	-- Since we're using pi (~3.14), the frequency of rotation is 1 second (per definition of sine function)
	setFaceSurfaceInputParams(normalId, Enum.SurfaceType.Motor, Enum.InputType.Sin, .25, math.pi)
	wait(3)
end

```
 */
	TopSurfaceInput: Enum.InputType;
	/** The Transparency property controls the visibility of a part on a scale of 0 to 1, where 0 is completely visible (opaque), and a value of 1 is completely invisible (not rendered at all). 

`Reflectance` can reduce the overall transparency of a brick if set to a value close to 1.

While fully transparent parts are not rendered at all, partially transparent objects have some significant rendering costs. Having many translucent parts may slow down the game’s performance.

When transparent parts overlap, render order can act unpredictable - try to keep semi-transparent parts from overlapping to avoid this.

The `LocalTransparencyModifier` is a multiplier to Transparency that is only visible to the local client.

## Code Samples

### Fade Door

This code sample shows how a part can fade away when touched by a Humanoid then reappear a moment after to create a passable door.
```lua
-- Paste into a Script inside a tall part
local part = script.Parent

local OPEN_TIME = 1

-- Can the door be opened at the moment?
local debounce = false

local function open()
	part.CanCollide = false
	part.Transparency = 0.7
	part.BrickColor = BrickColor.new("Black")
end

local function close()
	part.CanCollide = true
	part.Transparency = 0
	part.BrickColor = BrickColor.new("Bright blue")
end

local function onTouch(part)
	-- If the door was already open, do nothing
	if debounce then print("D") return end
	
	-- Check if touched by a Humanoid
	local human = part.Parent:FindFirstChildOfClass("Humanoid")
	if not human then print("not human") return end

	-- Perform the door opening sequence	
	debounce = true
	open()
	wait(OPEN_TIME)
	close()
	debounce = false	
end

part.Touched:Connect(onTouch)
close()

```

### X-Ray Vision

This code sample gives the local client X-ray vision using LocalTransparencyModifier. It allows the player to see through all parts in the Workspace, which are found using recursion.
```lua
-- X-ray vision: see through everything!

local function makeXRayPart(part)
	-- LocalTransparencyModifier will make parts see-through but only for the local
	-- client, and it won't replicate to the server
	part.LocalTransparencyModifier = .5 
end

-- This function uses recursion to search for parts in the game
local function recurseForParts(object)
	-- Did we find a part that isn't 
	if object:IsA("BasePart") then
		makeXRayPart(object)
	end
	
	-- Stop if this object has a Humanoid - we don't want to see-through players! 
	if object:FindFirstChildOfClass("Humanoid") then return end
	
	-- Check the object's children for more parts
	for _, child in pairs(object:GetChildren()) do
		recurseForParts(child)
	end
end

recurseForParts(workspace)

```
 */
	Transparency: number;
	/** The Velocity of a part describes how its `/BasePart/Position` is presently changing. The unit of this property is **studs per second**. For reference, the default Roblox character moves at 16 studs per second via `/Humanoid/WalkSpeed`. The acceleration due to gravity is found in `/Workspace/Gravity` (by default, -196.2 studs per second).

Setting the Velocity of an part that is `/BasePart/Anchored` will cause it to act like a conveyor belt. Any object that touches the part will begin to move in accordance with the Velocity.

Some `/BodyMover` objects will apply forces and thus change the Velocity of a part over time. The simplest of these is a `/BodyForce` which can be used to counteract the acceleration due to gravity on a single part (set the +Y axis of the `/BodyForce/Force` to the product of the mass (`/BasePart/GetMass`) and the gravity constant).

## Code Samples

### Projectile Firing

This code sample fires a part from one position toward another. It calculates the velocity needed to reach the destination in time, and applies an anti-gravity effect using a BodyForce. In addition, it adds a Trail to better visualize the path of the projectile as it arcs through the air.
```lua
-- Put this Script in a Part, preferably bullet-shaped :)
local part = script.Parent
part.Shape = Enum.PartType.Ball
part.Size = Vector3.new(2, 2, 2)
part.BrickColor = BrickColor.new("Really black")
part.CanCollide = false

-- Settings for the projectile's path!
local startPoint = Vector3.new(0, 50, 0)
local targetPoint = Vector3.new(50, 100, 0)
local travelTime = 1
local antiGravity = .5

-- Anti-gravity effect: add a BodyForce to counter gravity
local bf = Instance.new("BodyForce")
bf.Force = Vector3.new(0, workspace.Gravity * part:GetMass() * antiGravity, 0)
bf.Parent = part

-- Add a trail to two attachments
local a0 = Instance.new("Attachment", part)
a0.Position = Vector3.new(1, 0, 0)
local a1 = Instance.new("Attachment", part)
a1.Position = Vector3.new(-1, 0, 0)
local trail = Instance.new("Trail", part)
trail.Attachment0 = a0
trail.Attachment1 = a1
trail.FaceCamera = true
trail.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0),
	NumberSequenceKeypoint.new(1, 1)
})
trail.Lifetime = .35

local function fire(startPoint, targetPoint)	
	-- Calculate how far we have to travel
	local distance = (targetPoint - startPoint).magnitude
	-- Since speed = displacement / time, our speed is:
	local speed = distance / travelTime
	-- Position our part at the start, pointing to the target
	part.CFrame = CFrame.new(startPoint, targetPoint)
	-- Shoot the part
	part.Velocity = part.CFrame.lookVector * speed
end

-- Repeatedly fire the projectile
while true do
	fire(startPoint, targetPoint)
	wait(travelTime)
end
```
 */
	Velocity: Vector3;
	/** Breaks any surface connection with any adjacent part, including `Weld` and other `JointInstance`.
@returns No return */
	BreakJoints(): void;
	/** Returns whether the parts can collide with each other or not. This function takes into account the collision groups of the two parts.
This function will error if the specified part is not a BasePart.Returns whether the parts can collide with each other.
@param part The specified part being checked for collidability
@returns Whether the parts can collide with each other */
	CanCollideWith(part: BasePart): boolean;
	/** The CanSetNetworkOwnership function checks whether you can set a `part's` network ownership.

The function’s return value verifies whether or not you can call `SetNetworkOwner` or `SetNetworkOwnershipAuto` without encountering an error. It returns true if you can modify/read the network ownership, or returns false and the reason you can't, as a string.

##See Also
 * [Network ownership][1]

  [1]: /articles/Network-Ownership

## Code Samples

### Check if a Part's Network Ownership Can Be Set

This example checks whether or not the network ownership of the first `BasePart` named *Part* in the `Workspace` can be set.
```lua
local part = workspace:FindFirstChild("Part")

if part and part:IsA("BasePart") then
	local canSet,errorReason = part:CanSetNetworkOwnership()
	if canSet then
		print(part:GetFullName().."'s Network Ownership can be changed!")
	else
		warn("Cannot change the Network Ownership of "..part:GetFullName().." because: "..errorReason)
	end
end
```

@returns Whether you can modify/read the network ownership, as well as a reason if you cannot */
	CanSetNetworkOwnership(): LuaTuple<[boolean, string | undefined]>;
	/** Returns a table of parts connected to the the object by any kind of rigid joint.
If _recursive_ is true this function will return all of the parts in the assembly rigidly connected to the BasePart. 


## Rigid Joints

When a joint connects two parts together `(Part0 &#x2192; Part1)`, a joint is **rigid** if the physics of `Part1` are completely locked down by `Part0`
.
This only applies to the following joint types: * `Weld`
* `Snap`
* `ManualWeld`
* `Motor`
* `Motor6D`
* `WeldConstraint`
@param recursive A table of parts connected to the the object by any kind of `JointInstance|joint` */
	GetConnectedParts(recursive?: boolean): Array<BasePart>;
	/** Return all Joints or Constraints that is connected to this Part.
@returns An array of all Joints or Constraints connected to the Part. */
	GetJoints(): Array<Constraint | JointInstance>;
	/** The GetMass function returns the `part's` mass. 

This can vary depending on the part's `material` and the size. The ` material enum` page contains a table of all materials and their densities. Parts made of materials with greater densities have more mass than equally sized parts made of materials with lesser densities.

Note that a part’s density differs from the densities listed on the [material][1] page if the part’s `CustomPhysicalProperties` property is set.

You can also determine location of the part's center of mass via the `CenterOfMass` property.

  [1]: http://wiki.roblox.com/index.php?title=API:Enum/Material

## Code Samples

### Finding a Part's Mass

This example creates a new part, myPart, in the game's Workspace, with dimensions 4x6x4 studs. The part is also anchored.

Then, myMass is set to equal the mass of the new part. The mass of the part is printed at the end of the print statement:

> My part's mass is ...
```lua
local myPart = Instance.new("Part")
myPart.Parent = game.Workspace
myPart.Size = Vector3.new(4, 6, 4)
myPart.Anchored = true
 
local myMass = myPart:GetMass()
 
print("My part's mass is " .. myMass)
```

@returns The part's mass */
	GetMass(): number;
	/** Returns the current player who is the network owner of this part, or nil in case of the server.
@returns The current player who is the network owner of this part, or nil in case of the server */
	GetNetworkOwner(): Player | undefined;
	/** Returns true if the game engine automatically decides the network owner for this part.
@returns Whether the game engine automatically decides the network owner for this part */
	GetNetworkOwnershipAuto(): boolean;
	/** Returns the base part of an assembly (a collection of parts connected together). When moving an assembly of parts using a [CFrame](https://developer.roblox.com/api-reference/datatype/CFrame "CFrame")
 it is important to move this base part (this will move all other parts connected to it accordingly.
@returns The base part of an assembly (a collection of parts connected together) */
	GetRootPart(): BasePart;
	/** Returns a table of all parts that are physically interacting with this part. If the part itself has CanCollide set to false, then this function will return an empty table UNLESS it has a `TouchInterest` (AKA: Something is connected to its Touched event). Parts that are adjacent but not intersecting are not considered touching.
@returns A table of all parts that intersect and can collide with this part */
	GetTouchingParts(): Array<BasePart>;
	/** Returns true if the object is connected to a part that will hold it in place (eg an `Anchored` part), otherwise returns false.
@returns Whether the object is connected to a part that will hold it in place */
	IsGrounded(): boolean;
	/** Creates a joint on any side of the object that has a surface ID that can make a joint.
@returns No return */
	MakeJoints(): void;
	/** Changes the size of an object just like using the Studio resize tool.
@param normalId The side to resize
@param deltaAmount How much to grow/shrink on the specified side
@returns Whether the part is resized */
	Resize(normalId: CastsToEnum<Enum.NormalId>, deltaAmount: number): boolean;
	/** Sets the given player as network owner for this and all connected parts.
When playerInstance is nil, the server will be the owner instead of a player.Sets the given player as network owner for this and all connected parts.




## See Also

* [NetworkOwnership](https://developer.roblox.com/articles/Network-Ownership "NetworkOwnership")
@param playerInstance The player being given network ownership of the part
@returns No return */
	SetNetworkOwner(playerInstance?: Player): void;
	/** Lets the game engine dynamically decide who will handle the part's physics (one of the clients or the server).
@returns No return */
	SetNetworkOwnershipAuto(): void;
	/** This is a server-only function that uses `3D Modeling with CSG` to subtract the geometry of a table of `BaseParts` from the calling BasePart.

The following properties from the calling part will be applied to the resulting part:

* Color
* Material
* Reflectance
* Transparency

* Anchored
* CanCollide
* Density
* Friction

* Elasticity
* FrictionWeight
* ElasticityWeight

The resulting union instance will have a null parent and will be named "Union". If the resulting union's `UsePartColor` is false, it is rendered with face colors. Face colors of the result come from colors of its constituent parts. Its `UsePartColor` property defaults to false and its `CollisionFidelity` matches the provided enum.

The original parts remain in the same state and location in the game's tree as before operation.

The code snippet below demonstrates how to perform the operation as described above:

```lua
local part = workspace.Part1
local otherParts = {workspace.Part2, workspace.Part3, workspace.Part4}

-- Perform union operation
local newUnion = part:SubtractAsync(otherParts)
```

The image below visualizes parts before and after the operation. The red negated parts are subtracted from the grey part.

![SubtractAsync Visualization](https://developer.roblox.com/assets/5cad5e7d23c3e3b178f1fb2f/SubtractAsync.jpg)

The original parts remain unchanged following a successful subtract operation. In most cases, you should destroy all of the original parts and parent the returned `UnionOperation` to the same place as the calling `BasePart`.

## Potential Errors

* There is a limit to how many parts can be generated. If a union operation would result in a part with more than 5000 triangles, it will fail and Studio will alert you to the error in the Output window.
* A part made with solid modeling can only use **one** color and material. If you union two parts with different colors/materials, the result will use the characteristics of just one of the parts.
* A unioned or negated part can only be scaled uniformly (all of the dimensions must be scaled at the same proportion). If you need to change the size of just one part in a solid model construction, it may be easier to un-union that part, resize it, and then redo the union process.
* This function can only be called from the server. It cannot be called by the client.
* All parts must be supported by CSG. Only `BaseParts` are supported, not `Terrain` or meshes. If A union operation involving any non-supported part will fail and Studio will alert you to the error in the Output window.
* The resulting union cannot be empty due to subtractions. If a union operation would result in an empty part, it will fail and Studio will alert you to the error in the Output window.

## Solid-Modeling Playground
Now that you understand basic in-game solid modeling, experience it within a sample place!

#### Rotating Windows

Blast pieces out of rotating windows or fuse new material onto them. Includes a helper module script that rebuilds mechanisms with constraints and attachments!



## See also
  - `In Game Solid Modeling`, create custom plugins for solid modeling techniques like unions, negations, and separations
  - `3D Modeling with Parts`, how to combine and subtract parts to create complex solid shapes
  - `Making an Arch`, make an arch for your environment using the Negate tool

## Code Samples

### Basic In-Game Subtract Operation

This example assumes there are three parts named **Part1**, **Part2**, and **Part3** in the `Workspace`. It creates a union by subtracting **Part2** and **Part3** from **Part1**, destroys the original parts, and inserts the resulting `UnionOperation`.
```lua
local part = workspace.Part1
local otherParts = {workspace.Part2, workspace.Part3}

-- Perform subtract operation
local newUnion = part:SubtractAsync(otherParts)

-- Destroy source parts
part:Destroy()
for _, otherPart in pairs(otherParts) do
	otherPart:Destroy()
end

-- Insert new union into workspace
newUnion.Parent = workspace
```

### CSG Operations - Subtraction

Let’s test out in-game solid modeling with a quick demo script! You can copy and paste this into a `Script` within `ServerScriptService`, or wherever is most convenient.

In this example, a basic order of operations occurs:

1. A red glass window is created in the center of the place (lines 2-10) .
2. A smaller block is created in the center of the window part (lines 13-19) .
3. After 2 seconds, `SubtractAsync()` is called on the window, using the smaller block as the part to subtract.

There are a few reasons why an in-game solid modeling operation may fail (see the API docs). Because of this, you should always use `pcall()` to catch any unexpected errors.

4. If successful, the resulting part is returned with a name of **Union**. This instance will **not** be parented to the workspace, so it's your job to parent it back into the game world.

The original parts remain in the game, including both the instance that the operation is called on (`window`) and the parts that are added to or subtracted from it (`subBlock`). As a result, these parts are explicitly destroyed following a successful modeling operation (lines 33-34)
.
```lua
-- Create a basic window part
local window = Instance.new("Part")
window.Size = Vector3.new(10, 16, 0.5)
window.Material = "Glass"
window.BrickColor = BrickColor.new("Persimmon")
window.Reflectance = 0.2
window.Transparency = 0.5
window.Position = Vector3.new(0, 8, 0)
window.Anchored = true
window.Parent = game.Workspace
 
-- Create a part to subtract from window
local subBlock = Instance.new("Part")
subBlock.Size = Vector3.new(4, 4, 4)
subBlock.Material = "SmoothPlastic"
subBlock.CanCollide = false
subBlock.Position = Vector3.new(0, 8, 0)
subBlock.Anchored = true
subBlock.Parent = game.Workspace
 
wait(2)
 
-- Subtract smaller block from window
local success, newUnion = pcall(function()
	return window:SubtractAsync({subBlock})
end)
 
if success and newUnion then
	newUnion.Position = window.Position
	newUnion.Anchored = true
	newUnion.Parent = game.Workspace
	-- Remove original parts
	window:Destroy()
	subBlock:Destroy()
end
```

@param parts The objects taking part in the subtraction
@returns The resulting union from the subtraction operation */
	/** @rbxts server */
	SubtractAsync(parts: Array<BasePart>, collisionfidelity?: CastsToEnum<Enum.CollisionFidelity>): UnionOperation;
	/** This is a server-only function that uses `3D Modeling with CSG` to combine the geometry of the calling `BasePart` with a table of other BaseParts. The following properties from the calling part will be applied to the resulting part:

* Color
* Material
* Reflectance
* Transparency

* Anchored
* CanCollide
* Density
* Friction

* Elasticity
* FrictionWeight
* ElasticityWeight

The resulting union instance will have a null parent and will be named "Union". If the resulting union's `UsePartColor` is false, it is rendered with face colors. Face colors of the result come from colors of its constituent parts. Its `UsePartColor` property defaults to false and its `CollisionFidelity` matches the provided enum.

The original parts remain in the same state and location in the game's tree as before operation.

The code snippet below demonstrates how to perform the operation as described above:

```lua
local part = workspace.Part1
local otherParts = {workspace.Part2, workspace.Part3, workspace.Part4}

-- Perform union operation
local newUnion = part:UnionAsync(otherParts)
```

The image below visualizes parts before and after the operation. The green parts are combined with the grey part.

![Union Visualization](https://developer.roblox.com/assets/5cad525c4a3a4aa802c91f88/UnionAsync.jpg)

Note that if a `NegateOperation` is provided, it will also be unioned additively. For subtraction, use `SubtractAsync()`.

The original parts remain unchanged following a successful union operation. In most cases, you should destroy all of the original parts and parent the returned `UnionOperation` to the same place as the calling `BasePart`.

## Potential Errors

* There is a limit to how many parts can be generated. If a union operation would result in a part with more than 5000 triangles, it will fail and Studio will alert you to the error in the Output window.
* A part made with solid modeling can only use **one** color and material. If you union two parts with different colors/materials, the result will use the characteristics of just one of the parts.
* A unioned or negated part can only be scaled uniformly (all of the dimensions must be scaled at the same proportion). If you need to change the size of just one part in a solid model construction, it may be easier to un-union that part, resize it, and then redo the union process.
* This function can only be called from the server. It cannot be called by the client.
* All parts must be supported by CSG. Only `BaseParts` are supported, not `Terrain` or meshes. If A union operation involving any non-supported part will fail and Studio will alert you to the error in the Output window.
* The resulting union cannot be empty due to subtractions. If a union operation would result in an empty part, it will fail and Studio will alert you to the error in the Output window.

## Solid-Modeling Playground
Now that you understand basic in-game solid modeling, experience it within a sample place!

#### Rotating Windows

Blast pieces out of rotating windows or fuse new material onto them. Includes a helper module script that rebuilds mechanisms with constraints and attachments!


## See also
  - `In Game Solid Modeling`, create custom plugins for solid modeling techniques like unions, negations, and separations
  - `3D Modeling with Parts`, how to combine and subtract parts to create complex solid shapes
  - `Making an Arch`, make an arch for your environment using the Negate tool

## Code Samples

### Basic In-Game Union Operation

This example assumes there are three parts named **Part1**, **Part2**, and **Part3** in the `Workspace`. It creates a union, destroys the original parts, then inserts the resulting `UnionOperation`.
```lua
local part = workspace.Part1
local otherParts = {workspace.Part2, workspace.Part3}

-- Perform union operation
local newUnion = part:UnionAsync(otherParts)

-- Destroy source parts
part:Destroy()
for _, otherPart in pairs(otherParts)
	otherPart:Destroy()
end

-- Insert new union into workspace
newUnion.Parent = workspace
```

@param parts List of `Part|Parts` that are unioned with the calling part
@param collisionfidelity Optional `enum/CollisionFidelity|enum` argument that specifies how similar the collision model of this solid model is, compared to the actual geometry of the solid model. Defaults to Enum.CollisionFidelity.Default
 - Default - detailed geometry based on convex decomp representation
 - Hull - convex hull of the result
 - Box - bounding box
@param renderFidelity Optional `enum/RenderFidelity|enum` argument that specifies the level of detail that solid-modeled parts will be shown in
 - Automatic - Dynamically control a solid-modeled part’s level of detail depending on its distance from the camera (see table above)
 - Precise - Specifically set a solid-modeled part’s level of detail regardless of its distance from the camera (lowest, medium, or highest)
@returns Resulting `UnionOperation` with default name “Union” */
	/** @rbxts server */
	UnionAsync(parts: Array<BasePart>, collisionfidelity?: CastsToEnum<Enum.CollisionFidelity>): UnionOperation;
	/** Fired when a `part` stops touching another part. This event fires under similar conditions to those of `/BasePart/Touched`.

## Code Samples

### Touching Parts Count

This code sample creates a BillboardGui on a part that displays the number of parts presently touching it.
```lua
local part = script.Parent

-- Create a BillboardGui
local bbgui = Instance.new("BillboardGui", part)
bbgui.Size = UDim2.new(0, 200, 0, 50)
bbgui.Adornee = part
bbgui.AlwaysOnTop = true
local tl = Instance.new("TextLabel", bbgui)
tl.Size = UDim2.new(1, 0, 1, 0)
tl.BackgroundTransparency = 1

local numTouchingParts = 0

local function onTouch(part)
	print("Touch started: " .. part.Name)
	numTouchingParts = numTouchingParts + 1
	tl.Text = numTouchingParts
end

local function onTouchEnded(part)
	print("Touch ended: " .. part.Name)
	numTouchingParts = numTouchingParts - 1
	tl.Text = numTouchingParts
end

part.Touched:Connect(onTouch)
part.TouchEnded:Connect(onTouchEnded)

```
 */
	readonly TouchEnded: RBXScriptSignal<(otherPart: BasePart) => void>;
	/** The Touched event fires when a part comes in contact with another part. For instance, if PartA bumps into PartB, then PartA.Touched fires with PartB, and PartB fires with PartA.

This event only fires as a result of physics movement, so it will not fire if the CFrame property was changed such that the part overlaps another part. This also means that at least one of the parts involved must not be `/BasePart/Anchored` at the time of the collision.

Many types of parts are removed or destroyed as soon as they hit another part. This means that it is possible for the other part's `/Instance/Parent` to be nil. Be sure to check that `otherPart.Parent` is not nil before using it, such as calling `/Instance/FindFirstChild`.

## Code Samples

### Touch Blink

This code sample causes a part to blink its Reflectance and a PointLight every time it is touched. It uses a pattern that prevents multiple concurrent function calls from fighting with each other.
```lua
local part = script.Parent

-- Add a light
local pointLight = Instance.new("PointLight", part)
pointLight.Brightness = 0
pointLight.Range = 12

local touchNo = 0
local function blink()
	-- Advance touchNo to tell other blink() calls to stop early
	touchNo = touchNo + 1
	-- Save touchNo locally so we can tell when it changes globally
	local myTouchNo = touchNo
	for i = 1, 0, -.1 do
		-- Stop early if another blink started
		if touchNo ~= myTouchNo then break end
		-- Update the blink animation
		part.Reflectance = i
		pointLight.Brightness = i * 2
		wait(0.05)
	end
end

part.Touched:Connect(blink)

```

### Touching Parts Count

This code sample creates a BillboardGui on a part that displays the number of parts presently touching it.
```lua
local part = script.Parent

-- Create a BillboardGui
local bbgui = Instance.new("BillboardGui", part)
bbgui.Size = UDim2.new(0, 200, 0, 50)
bbgui.Adornee = part
bbgui.AlwaysOnTop = true
local tl = Instance.new("TextLabel", bbgui)
tl.Size = UDim2.new(1, 0, 1, 0)
tl.BackgroundTransparency = 1

local numTouchingParts = 0

local function onTouch(part)
	print("Touch started: " .. part.Name)
	numTouchingParts = numTouchingParts + 1
	tl.Text = numTouchingParts
end

local function onTouchEnded(part)
	print("Touch ended: " .. part.Name)
	numTouchingParts = numTouchingParts - 1
	tl.Text = numTouchingParts
end

part.Touched:Connect(onTouch)
part.TouchEnded:Connect(onTouchEnded)

```

### Model Touched

This code sample demonstrates how to connect the Touched event of multiple parts in a Model to one function.
```lua
local model = script.Parent

local function onModelTouched(part)
	-- Filter any instances of the model coming in contact with itself
	if part:IsDescendantOf(model) then return end
	print(model:GetFullName() .. " was touched by " .. part:GetFullName())
end

for _, child in pairs(model:GetChildren()) do
	if child:IsA("BasePart") then
		child.Touched:Connect(onModelTouched)
	end
end

```
 */
	readonly Touched: RBXScriptSignal<(otherPart: BasePart) => void>;
}
/** BasePart is an abstract base class for in-world objects that render and are physically simulated while in the `Workspace`. There are several implementations of BasePart, the most common is `Part`, a simple 6-face rectangular prism. Others include `SpawnLocation`, `WedgePart` and the singleton `Terrain` object within the `Workspace`. Most of the time, when documentation refers to a part, most BasePart implementations will work and not just `Part`.

There are **many** different objects that interact with BasePart:

  - They may be grouped within a `Model`, which allows several BasePart to be moved at the same time using `SetPrimaryPartCFrame`.
  - A `Decal` applies a stretched image texture to the faces of a part, though the exact mapping depends on the type of part.
  - A `Texture` applies a tiled image texture to the faces of a part much like a `Decal`.
  - A `SurfaceGui` renders `GuiObjects` on the face of a part.
  - An `Attachment` can be added to specify a CFrames relative to a parent BasePart. These are often used by physics `Constraint` objects, such as `RopeConstraint` and `HingeConstraint`.
  - `ParticleEmitter` emit particles uniformly in the volume of the BasePart to which they are parented.
  - Light objects like `PointLight` emit light from the center of a BasePart.
  - When `played`, a `Sound` parented to a BasePart will be physically located at the part's position.
  - `BodyMover` objects like `BodyVelocity` exert forces on the BasePart to which they are parented.
  - As a sibling of a `Humanoid`, they can be used as limbs of a character and also animated when joined using `Motor6D`. If not a sibling of a `Humanoid`, BasePart can still be animated using an `AnimationController`.
  - In Studio, you can use most implementations of BaseParts with solid modelling.
  - If parented to a `Tool` and given the name "Handle", a BasePart can be held by characters.
  - You can make BasePart interactive by adding a `ClickDetector`
  - You can a mesh like a `BlockMesh` or `SpecialMesh` to change how a BasePart looks without change how it physically behaves. */
type BasePart = CornerWedgePart | FormFactorPart | Terrain | TriangleMeshPart | TrussPart | VehicleSeat;

/** This is a corner piece which has the same properties as a `Part`. */
interface CornerWedgePart extends RbxInternalBasePart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CornerWedgePart";
}

interface RbxInternalFormFactorPart extends RbxInternalBasePart {}
/** The FormFactorPart class is an abstract class. It inherits from the `BasePart` class and adds the `FormFactor` property to classes that inherit from it.

The FormFactor property has been deprecated, so this class has been deprecated as well. */
type FormFactorPart = Part | WedgePart | FlagStand | Platform | Seat | SkateboardPlatform | SpawnLocation;

interface RbxInternalDerivesFromPart extends RbxInternalFormFactorPart {
	/** The Shape property sets the type of shape the object has.

The `PartType` enum controls the shape value, and has three possible shapes:
| Shape/Value | Description                           |
|-------------|---------------------------------------|
| Ball        | A spherical shape, like a basketball. |
| Cylinder    | A rod-like shape, like a tin can.     |
| Block       | The default, brick shape.             |

To obtain custom part shapes, you can use a `MeshPart` instead of a `Part`.

## Code Samples

### Create a Part in a Script

The script below spawns a new `Part` instance and sets several of the part's properties. 

Most notably, the script sets the `Shape` property to `Enum.PartType.Ball`. It also names the part *JurrasicPart* (hehe), anchors it, makes it a child of *Workspace*, and sets its color to white.
```lua
local part = Instance.new("Part")		-- Create a new part

part.Name = "JurrasicPart"			-- Name the part... hehe
part.Anchored = true				-- Anchor the part
part.Parent = game.Workspace		-- Put the part into the Workspace
part.Shape = Enum.PartType.Ball		-- Give the part a ball shape
part.Color = Color3.new(1, 1, 1)		-- Set the color to black
```
The Shape property sets the type of shape the object has.

The `PartType` enum controls the shape value, and has three possible shapes:
| Shape/Value | Description                           |
|-------------|---------------------------------------|
| Ball        | A spherical shape, like a basketball. |
| Cylinder    | A rod-like shape, like a tin can.     |
| Block       | The default, brick shape.             |

To obtain custom part shapes, you can use a `MeshPart` instead of a `Part`.

## Code Samples

### Create a Part in a Script

The script below spawns a new `Part` instance and sets several of the part's properties. 

Most notably, the script sets the `Shape` property to `Enum.PartType.Ball`. It also names the part *JurrasicPart* (hehe), anchors it, makes it a child of *Workspace*, and sets its color to white.
```lua
local part = Instance.new("Part")		-- Create a new part

part.Name = "JurrasicPart"			-- Name the part... hehe
part.Anchored = true				-- Anchor the part
part.Parent = game.Workspace		-- Put the part into the Workspace
part.Shape = Enum.PartType.Ball		-- Give the part a ball shape
part.Color = Color3.new(1, 1, 1)		-- Set the color to black
```


Tags: NotReplicated */
	Shape: Enum.PartType;
}
/** ## What is a Part
The Part object is a physical object. When it is in the `Workspace`, it will move and interact with other Parts. It can have bonds formed with other Parts, so that the two Parts stay in the same relative position.

Parts are the basic building blocks of any Roblox place. Commonly known as **bricks**, you'll see these the most often of any other objects as almost every place is built out of these. It is possible to stretch a Part to very large sizes and use them for baseplates, or make them very small and use them to create cool looking `Tool`.

## How can I edit a Part
The Part object can be edited using the various studio tools. It is available via either the insert menu, or the *Object Insert menu*. It can also be created using the function:
```lua
lua
Instance.new("Part")
```


## How do I create different shaped Parts
Using the Mesh objects, such as `SpecialMesh`, `BlockMesh`, or `CylinderMesh` objects you can change the shape of them. Using the `Decal` or `Texture` objects, you can place pictures on top of the bricks.

## Changing Parts using scripts
There are many scripting opportunities using the Part object. Many of the other scripting objects, such as `BodyForce` objects operate inside of a Part or other physics based objects. Editing the Part's properties through a script can result in a lot of fun opportunities.

## Code Samples

### Create a Part in a Script

The script below spawns a new `Part` instance and sets several of the part's properties. 

Most notably, the script sets the `Shape` property to `Enum.PartType.Ball`. It also names the part *JurrasicPart* (hehe), anchors it, makes it a child of *Workspace*, and sets its color to white.
```lua
local part = Instance.new("Part")		-- Create a new part

part.Name = "JurrasicPart"			-- Name the part... hehe
part.Anchored = true				-- Anchor the part
part.Parent = game.Workspace		-- Put the part into the Workspace
part.Shape = Enum.PartType.Ball		-- Give the part a ball shape
part.Color = Color3.new(1, 1, 1)		-- Set the color to black
```
 */
interface Part extends RbxInternalDerivesFromPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Part";
}


/** The `Flag` and `FlagStand` objects were created to allow developers to make 'Capture the Flag' style games quickly. However they have been deprecated and developers are advised to design their own systems which will be more flexible and reliable. 

To get started with this, developers can use the 'Capture The Flag' template place provided by Roblox which has a fully functioning system developers can take and use in their own games. A link to the place, which is free to edit, is [here][1].


  [1]: https://www.roblox.com/games/92721754/Capture-The-Flag#!/about */
interface FlagStand extends RbxInternalDerivesFromPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FlagStand";
	/** The Team that owns the `FlagStand`. Corresponds with the TeamColors in the `Teams` service.

The `Flag` and `FlagStand` objects were created to allow developers to make 'Capture the Flag' style games quickly. However they have been deprecated and developers are advised to design their own systems which will be more flexible and reliable. 

To get started with this, developers can use the 'Capture The Flag' template place provided by Roblox which has a fully functioning system developers can take and use in their own games. A link to the place, which is free to edit, is [here][1].


  [1]: https://www.roblox.com/games/92721754/Capture-The-Flag#!/about */
	TeamColor: BrickColor;
	/** This event fires when a player bearing an opposing flag, and having the same `TeamColor` as the stand, touches the `FlagStand`.

The `Flag` and `FlagStand` objects were created to allow developers to make 'Capture the Flag' style games quickly. However they have been deprecated and developers are advised to design their own systems which will be more flexible and reliable. 

To get started with this, developers can use the 'Capture The Flag' template place provided by Roblox which has a fully functioning system developers can take and use in their own games. A link to the place, which is free to edit, is [here][1].


  [1]: https://www.roblox.com/games/92721754/Capture-The-Flag#!/about */
	readonly FlagCaptured: RBXScriptSignal<(player: Player) => void>;
}

/** The Platform object creates a brick that when touched by a `Player` will anchor their torso to the brick. This allows for the creation of vehicles that players can stand in and not be flung about the cabin/deck of the vehicle.

The Platform is almost identical to the `Seat` object, except that instead of sitting down the player will be standing while locked in place. Good for ships.

The Platform object is very useful for making people's characters staying in one spot while they move around, such as a ship or truck. When a player touches the Platform a `Weld` constraint is created, so they are 'attached' to the Platform and can't move until that weld is broken. It can be removed by hitting the spacebar, when the player jumps to exit the Platform. */
interface Platform extends RbxInternalDerivesFromPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Platform";
}

/** A type of `BasePart` that a player character can 'sit' in. When a character touches an enabled Seat object, it will be attached to the part by a `Weld` and the default character scripts will play a sitting animation.  

## How do Seats work?

When a model containing a `Humanoid` and a `BasePart` called 'HumanoidRootPart' (generally a player character) touches a seat, a `Weld` is created between the seat and the part. The `C0` and `C1` properties are configured so that the character is welded 2 studs above the seat. This weld is named 'SeatWeld' and parented to the seat. 

When sitting the `Occupant` property is set to the `Humanoid` that is 'sitting' in the seat. Furthermore the `SeatPart` property of the humanoid is set to the seat.

A character can also be forced to sit in a seat using the `Sit` function.

There are two ways for a character to get out of a seat. When a player jumps, they are removed from the seat. However this can also be done manually by destroying the seat weld, for example:

    seat:FindFirstChild("SeatWeld"):Destroy()

Note seats have a cooldown (currently 3 seconds) that is on a per-character per-seat basis. This means once a character has gotten out of a seat they cannot sit back on the same seat for 3 seconds. This cooldown behavior may change and should not be relied upon by developers.

## What can Seats be used for?

Seats have a diverse range of uses, ranging from the obvious to the more unconventional.

 - Creating chairs or benches without the need for any programming
 - Allowing characters to 'sit' in moving objects such as vehicles without getting flung around
 - Creating interfaces that are controlled by the character in the seat using the `Occupant` property

## Code Samples

### Detecting Seat Occupant

This code sample includes a demonstration of how the `Occupant` property can be used to track which player is sitting in a seat and when they sit down or sit up.
```lua
    local Players = game:GetService("Players")
    
    local seat = Instance.new("Seat")
    seat.Anchored = true 
    seat.Position = Vector3.new(0, 1, 0)
    seat.Parent = workspace 
    
    local currentPlayer = nil
    
    seat:GetPropertyChangedSignal("Occupant"):Connect(function()
    	local humanoid = seat.Occupant 
    	if humanoid then 
    		local character = humanoid.Parent
    		local player = Players:GetPlayerFromCharacter(character)
    		if player then 
    			print(player.Name.." has sat down")
    			currentPlayer = player
    			return
    		end	
    	end
    	if currentPlayer then 
    		print(currentPlayer.Name.." has got up")
    		currentPlayer = nil
    	end
    end)
```
 */
interface Seat extends RbxInternalDerivesFromPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Seat";
	/** Whether or not the seat is usable. If set to true, the seat will act as a normal part. */
	Disabled: boolean;
	/** The humanoid that is sitting in the seat */
	readonly Occupant?: Humanoid;
	/** Forces the character with the specified [Humanoid](https://developer.roblox.com/api-reference/class/Humanoid "Humanoid")
 to sit in the Seat. */
	Sit(humanoid: Humanoid): void;
}

/** A SkateboardPlatform can be used to create a skateboard. When characters get on a skateboard, they are stuck to it until they press the escape key. Until then, the character uses skateboard animations and travels faster than a walking character. */
interface SkateboardPlatform extends RbxInternalDerivesFromPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SkateboardPlatform";
	/** The SkateboardPlatform's active SkateboardController. */
	readonly Controller?: SkateboardController;
	/** The `/Humanoid` that is controlling the SkateboardPlatform. */
	readonly ControllingHumanoid?: Humanoid;
	/** The direction of movement, tied to the keys A and D. Must be 1 (right), 0 (straight), or -1 (left). Will refresh back to 0 unless constantly set. */
	Steer: number;
	/** If true, wheels won't roll without user input. */
	StickyWheels: boolean;
	/** The direction of movement, tied to the keys W and S. Must be an integer 1 (forward), 0 (null), or -1 (reverse). Will refresh back to 0 unless constantly set. */
	Throttle: number;
	/** Adds ''impulseWorld'' to the SkateboardPlatform's `/BasePart/Velocity`. */
	ApplySpecificImpulse(impulseWorld: Vector3): void;
	/** Fired when the skateboard is equipped. */
	readonly Equipped: RBXScriptSignal<(humanoid: Humanoid, skateboardController: SkateboardController) => void>;
	/** Fired when the SkateboardPlatform's `/SkateboardPlatform/ControllingHumanoid` changes the force being used on the SkateboardPlatform. */
	readonly MoveStateChanged: RBXScriptSignal<(newState: Enum.MoveState, oldState: Enum.MoveState) => void>;
	/** Fired whenever the skateboard is unequipped. */
	readonly Unequipped: RBXScriptSignal<(humanoid: Humanoid) => void>;
}

/** SpawnLocations, or "spawns" determine where a `Player` respawns when they die. They can be configured to allow only certain players to use each spawn, using `Teams`. They also control how `ForceFields` are set up for newly-spawned players.

SpawnLocations can be used as checkpoints, such as in an obstacle course, using the `AllowTeamChangeOnTouch` property, so that when a player touches it, they will change teams to the SpawnLocation's team. In this case, only the first `Team` should have `AutoAssignable` set to true, else players will not start at the first checkpoint.

Note if a SpawnLocation is added to the `Workspace` in Studio with `Neutral` set to false a Team will be created corresponding to `TeamColor` if it does not already exist. This behavior does not occur when spawns are created in-game using a `Script` or if the properties of the SpawnLocation are changed after already being added. It is recommended that developers always set up their teams manually and not rely on this behavior. 

**Spawning Rules**

 - When `Neutral` is set to false only `Players` with `TeamColor` matching `TeamColor` will respawn above it
 - When `Neutral` is set to true any Player can spawn above it regardless of `TeamColor`
 - If multiple eligible spawns are available to a `Player`, a random one will be chosen
 - Players will spawn at different points on top of a SpawnLocation, but currently, they may still spawn on top of each other if they spawn right after one and other

## Code Samples

### SpawnLocation Checkpoints

This sample demonstrates how SpawnLocations can be used to make a checkpoint system. Typically this would be done Studio and not in Lua, but this example serves as a comprehensive example of what Team and SpawnLocation properties need to be used to achieve this setup.
```lua
local Teams = game:GetService("Teams")

-- create start team (AutoAssignable = true)
local startTeam = Instance.new("Team", Teams)
startTeam.Name = "Start"
startTeam.AutoAssignable = true
startTeam.TeamColor = BrickColor.new("White")

-- create checkpoint teams (Autoassignable = false), ensuring all TeamColors are unique
local team1 = Instance.new("Team", Teams)
team1.Name = "Checkpoint 1"
team1.AutoAssignable = false
team1.TeamColor = BrickColor.new("Bright blue")

local team2 = Instance.new("Team", Teams)
team2.Name = "Checkpoint 2"
team2.AutoAssignable = false
team2.TeamColor = BrickColor.new("Bright green")

local team3 = Instance.new("Team", Teams)
team3.Name = "Checkpoint 2"
team3.AutoAssignable = false
team3.TeamColor = BrickColor.new("Bright red")

-- create spawns 
local startSpawn = Instance.new("SpawnLocation", game.Workspace)
startSpawn.Anchored = true
startSpawn.Size = Vector3.new(5, 1, 5)
startSpawn.Neutral = false
startSpawn.AllowTeamChangeOnTouch = false
startSpawn.TeamColor = startTeam.TeamColor
startSpawn.BrickColor = startTeam.TeamColor

local team1Spawn = Instance.new("SpawnLocation", game.Workspace)
team1Spawn.Anchored = true
team1Spawn.Size = Vector3.new(5, 1, 5)
team1Spawn.Neutral = false
team1Spawn.AllowTeamChangeOnTouch = true
team1Spawn.TeamColor = team1.TeamColor
team1Spawn.BrickColor = team1.TeamColor

local team2Spawn = Instance.new("SpawnLocation", game.Workspace)
team2Spawn.Anchored = true
team2Spawn.Size = Vector3.new(5, 1, 5)
team2Spawn.Neutral = false
team2Spawn.AllowTeamChangeOnTouch = true
team2Spawn.TeamColor = team2.TeamColor
team2Spawn.BrickColor = team2.TeamColor

local team3Spawn = Instance.new("SpawnLocation", game.Workspace)
team3Spawn.Anchored = true
team3Spawn.Size = Vector3.new(5, 1, 5)
team3Spawn.Neutral = false
team3Spawn.AllowTeamChangeOnTouch = true
team3Spawn.TeamColor = team3.TeamColor
team3Spawn.BrickColor = team3.TeamColor

-- position spawns
startSpawn.CFrame = CFrame.new(0, 0.5, 0)
team1Spawn.CFrame = CFrame.new(10, 0.5, 0)
team2Spawn.CFrame = CFrame.new(20, 0.5, 0)
team3Spawn.CFrame = CFrame.new(30, 0.5, 0)
```
 */
interface SpawnLocation extends RbxInternalDerivesFromPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SpawnLocation";
	/** Allows a `Player` to join the team by touching the `SpawnLocation`. When set to true, if a `Player` character comes into contact with the `SpawnLocation`, the player's `TeamColor` will be set to `TeamColor`. `Neutral` will also be set to `Neutral` upon contact, meaning a player can also become neutral by touching a spawn location.

This will not function when `Enabled` is set to false.


## Making Checkpoints

This feature is often used to make checkpoints in obstacle courses or similar games. See `How to use Spawn Objects with Roblox Using Player Spawns` for details.

## Code Samples

### SpawnLocation Checkpoints

This sample demonstrates how SpawnLocations can be used to make a checkpoint system. Typically this would be done Studio and not in Lua, but this example serves as a comprehensive example of what Team and SpawnLocation properties need to be used to achieve this setup.
```lua
local Teams = game:GetService("Teams")

-- create start team (AutoAssignable = true)
local startTeam = Instance.new("Team", Teams)
startTeam.Name = "Start"
startTeam.AutoAssignable = true
startTeam.TeamColor = BrickColor.new("White")

-- create checkpoint teams (Autoassignable = false), ensuring all TeamColors are unique
local team1 = Instance.new("Team", Teams)
team1.Name = "Checkpoint 1"
team1.AutoAssignable = false
team1.TeamColor = BrickColor.new("Bright blue")

local team2 = Instance.new("Team", Teams)
team2.Name = "Checkpoint 2"
team2.AutoAssignable = false
team2.TeamColor = BrickColor.new("Bright green")

local team3 = Instance.new("Team", Teams)
team3.Name = "Checkpoint 2"
team3.AutoAssignable = false
team3.TeamColor = BrickColor.new("Bright red")

-- create spawns 
local startSpawn = Instance.new("SpawnLocation", game.Workspace)
startSpawn.Anchored = true
startSpawn.Size = Vector3.new(5, 1, 5)
startSpawn.Neutral = false
startSpawn.AllowTeamChangeOnTouch = false
startSpawn.TeamColor = startTeam.TeamColor
startSpawn.BrickColor = startTeam.TeamColor

local team1Spawn = Instance.new("SpawnLocation", game.Workspace)
team1Spawn.Anchored = true
team1Spawn.Size = Vector3.new(5, 1, 5)
team1Spawn.Neutral = false
team1Spawn.AllowTeamChangeOnTouch = true
team1Spawn.TeamColor = team1.TeamColor
team1Spawn.BrickColor = team1.TeamColor

local team2Spawn = Instance.new("SpawnLocation", game.Workspace)
team2Spawn.Anchored = true
team2Spawn.Size = Vector3.new(5, 1, 5)
team2Spawn.Neutral = false
team2Spawn.AllowTeamChangeOnTouch = true
team2Spawn.TeamColor = team2.TeamColor
team2Spawn.BrickColor = team2.TeamColor

local team3Spawn = Instance.new("SpawnLocation", game.Workspace)
team3Spawn.Anchored = true
team3Spawn.Size = Vector3.new(5, 1, 5)
team3Spawn.Neutral = false
team3Spawn.AllowTeamChangeOnTouch = true
team3Spawn.TeamColor = team3.TeamColor
team3Spawn.BrickColor = team3.TeamColor

-- position spawns
startSpawn.CFrame = CFrame.new(0, 0.5, 0)
team1Spawn.CFrame = CFrame.new(10, 0.5, 0)
team2Spawn.CFrame = CFrame.new(20, 0.5, 0)
team3Spawn.CFrame = CFrame.new(30, 0.5, 0)
```
 */
	AllowTeamChangeOnTouch: boolean;
	/** The length of time, in seconds, that a `ForceField` will be applied to a `Player` character spawning at this `SpawnLocation`. If Duration is zero, the `ForceField` is never created, and it will not trigger the `DescendantAdded` or `ChildAdded` events.

This default value of this property is 10 seconds.

The duration feature allows developers to easily give `Player`s protection from 'spawn killing' which can be a frustrating experience for players. Note, `ForceField`s will only protect users from `Explosion`s and Weapons that use `TakeDamage` to deal damage or otherwise check for a `ForceField`.

## Code Samples

### SpawnLocation ForceField

This sample will create a neutral SpawnLocation in the Workspace that'll give players spawning a ForceField for 20 seconds.
```lua
local spawnLocation = Instance.new("SpawnLocation", game.Workspace)
spawnLocation.Anchored = true
spawnLocation.Size = Vector3.new(5, 1, 5)
spawnLocation.Neutral = true -- anyone can spawn here
spawnLocation.Duration = 20 -- ForceField duration 20s
```
 */
	Duration: number;
	/** Sets whether or not the `SpawnLocation` is enabled. When disabled players cannot spawn at the `SpawnLocation` and the `AllowTeamChangeOnTouch` functionality is disabled.

This property provides the most convenient way of preventing `Player`s from spawning at a spawn.

Note, although team changing on touch using `AllowTeamChangeOnTouch` is disabled when Enabled is set to false, other touched events using `BasePart.Touched` will still fire.

## Code Samples

### SpawnLocation Enabled

The following sample will create a SpawnLocation in the Workspace that will become semi-transparent when it is disabled.
```lua
local spawnLocation = Instance.new("SpawnLocation", game.Workspace)
spawnLocation.Anchored = true
spawnLocation.Size = Vector3.new(5, 1, 5)
spawnLocation.Neutral = true -- anyone can spawn here
spawnLocation.Enabled = true

spawnLocation:GetPropertyChangedSignal("Enabled"):Connect(function()
	spawnLocation.Transparency = spawnLocation.Enabled and 0 or 0.5
end)

wait(5)
spawnLocation.Enabled = false -- transparency = 0.5
```
 */
	Enabled: boolean;
	/** Whether or not a spawn is affiliated with a specific team. This means that any `Player`, of any `Team`, can spawn on it if this property is set to true. 

If Neutral is set to false, only players whose `TeamColor` is equal to `TeamColor` can use the `SpawnLocation`.

If `AllowTeamChangeOnTouch` is true `Neutral` will be set to this property upon contact with the spawn.

## Code Samples

### SpawnLocation Checkpoints

This sample demonstrates how SpawnLocations can be used to make a checkpoint system. Typically this would be done Studio and not in Lua, but this example serves as a comprehensive example of what Team and SpawnLocation properties need to be used to achieve this setup.
```lua
local Teams = game:GetService("Teams")

-- create start team (AutoAssignable = true)
local startTeam = Instance.new("Team", Teams)
startTeam.Name = "Start"
startTeam.AutoAssignable = true
startTeam.TeamColor = BrickColor.new("White")

-- create checkpoint teams (Autoassignable = false), ensuring all TeamColors are unique
local team1 = Instance.new("Team", Teams)
team1.Name = "Checkpoint 1"
team1.AutoAssignable = false
team1.TeamColor = BrickColor.new("Bright blue")

local team2 = Instance.new("Team", Teams)
team2.Name = "Checkpoint 2"
team2.AutoAssignable = false
team2.TeamColor = BrickColor.new("Bright green")

local team3 = Instance.new("Team", Teams)
team3.Name = "Checkpoint 2"
team3.AutoAssignable = false
team3.TeamColor = BrickColor.new("Bright red")

-- create spawns 
local startSpawn = Instance.new("SpawnLocation", game.Workspace)
startSpawn.Anchored = true
startSpawn.Size = Vector3.new(5, 1, 5)
startSpawn.Neutral = false
startSpawn.AllowTeamChangeOnTouch = false
startSpawn.TeamColor = startTeam.TeamColor
startSpawn.BrickColor = startTeam.TeamColor

local team1Spawn = Instance.new("SpawnLocation", game.Workspace)
team1Spawn.Anchored = true
team1Spawn.Size = Vector3.new(5, 1, 5)
team1Spawn.Neutral = false
team1Spawn.AllowTeamChangeOnTouch = true
team1Spawn.TeamColor = team1.TeamColor
team1Spawn.BrickColor = team1.TeamColor

local team2Spawn = Instance.new("SpawnLocation", game.Workspace)
team2Spawn.Anchored = true
team2Spawn.Size = Vector3.new(5, 1, 5)
team2Spawn.Neutral = false
team2Spawn.AllowTeamChangeOnTouch = true
team2Spawn.TeamColor = team2.TeamColor
team2Spawn.BrickColor = team2.TeamColor

local team3Spawn = Instance.new("SpawnLocation", game.Workspace)
team3Spawn.Anchored = true
team3Spawn.Size = Vector3.new(5, 1, 5)
team3Spawn.Neutral = false
team3Spawn.AllowTeamChangeOnTouch = true
team3Spawn.TeamColor = team3.TeamColor
team3Spawn.BrickColor = team3.TeamColor

-- position spawns
startSpawn.CFrame = CFrame.new(0, 0.5, 0)
team1Spawn.CFrame = CFrame.new(10, 0.5, 0)
team2Spawn.CFrame = CFrame.new(20, 0.5, 0)
team3Spawn.CFrame = CFrame.new(30, 0.5, 0)
```
 */
	Neutral: boolean;
	/** The TeamColor property sets what team the `SpawnLocation` is affiliated to. If `Neutral` property is false, only `Player`s with the same `TeamColor` as the spawn's TeamColor will be able to spawn there. 

If `AllowTeamChangeOnTouch` is true `Neutral` will be set to this property upon contact with the spawn.

## Code Samples

### SpawnLocation Checkpoints

This sample demonstrates how SpawnLocations can be used to make a checkpoint system. Typically this would be done Studio and not in Lua, but this example serves as a comprehensive example of what Team and SpawnLocation properties need to be used to achieve this setup.
```lua
local Teams = game:GetService("Teams")

-- create start team (AutoAssignable = true)
local startTeam = Instance.new("Team", Teams)
startTeam.Name = "Start"
startTeam.AutoAssignable = true
startTeam.TeamColor = BrickColor.new("White")

-- create checkpoint teams (Autoassignable = false), ensuring all TeamColors are unique
local team1 = Instance.new("Team", Teams)
team1.Name = "Checkpoint 1"
team1.AutoAssignable = false
team1.TeamColor = BrickColor.new("Bright blue")

local team2 = Instance.new("Team", Teams)
team2.Name = "Checkpoint 2"
team2.AutoAssignable = false
team2.TeamColor = BrickColor.new("Bright green")

local team3 = Instance.new("Team", Teams)
team3.Name = "Checkpoint 2"
team3.AutoAssignable = false
team3.TeamColor = BrickColor.new("Bright red")

-- create spawns 
local startSpawn = Instance.new("SpawnLocation", game.Workspace)
startSpawn.Anchored = true
startSpawn.Size = Vector3.new(5, 1, 5)
startSpawn.Neutral = false
startSpawn.AllowTeamChangeOnTouch = false
startSpawn.TeamColor = startTeam.TeamColor
startSpawn.BrickColor = startTeam.TeamColor

local team1Spawn = Instance.new("SpawnLocation", game.Workspace)
team1Spawn.Anchored = true
team1Spawn.Size = Vector3.new(5, 1, 5)
team1Spawn.Neutral = false
team1Spawn.AllowTeamChangeOnTouch = true
team1Spawn.TeamColor = team1.TeamColor
team1Spawn.BrickColor = team1.TeamColor

local team2Spawn = Instance.new("SpawnLocation", game.Workspace)
team2Spawn.Anchored = true
team2Spawn.Size = Vector3.new(5, 1, 5)
team2Spawn.Neutral = false
team2Spawn.AllowTeamChangeOnTouch = true
team2Spawn.TeamColor = team2.TeamColor
team2Spawn.BrickColor = team2.TeamColor

local team3Spawn = Instance.new("SpawnLocation", game.Workspace)
team3Spawn.Anchored = true
team3Spawn.Size = Vector3.new(5, 1, 5)
team3Spawn.Neutral = false
team3Spawn.AllowTeamChangeOnTouch = true
team3Spawn.TeamColor = team3.TeamColor
team3Spawn.BrickColor = team3.TeamColor

-- position spawns
startSpawn.CFrame = CFrame.new(0, 0.5, 0)
team1Spawn.CFrame = CFrame.new(10, 0.5, 0)
team2Spawn.CFrame = CFrame.new(20, 0.5, 0)
team3Spawn.CFrame = CFrame.new(30, 0.5, 0)
```
 */
	TeamColor: BrickColor;
}

/** WedgeParts are great for building slopes because of their slanted surface. They can even be rotated onto their slant so that they can be used at an angle to make a triangular ramp. Due to their collision, WedgeParts can be good for quickly rotating bricks to a certain angle within Roblox Studio, making them a quick solution to using scripting methods such as CFrame to perform the same function. WedgeParts can be adjusted to any size a regular brick can so that they can be aligned with the rest of your building work. WedgeParts, when used next to each other at different angles, can also make great curved ramps without the need for CFrame too */
interface WedgePart extends RbxInternalFormFactorPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "WedgePart";
}

/** Terrain is a feature that allows players to create dynamically morphable environments, with little to no lag. Terrain is currently based on a 4x4x4 grid of cells, where each cell has a number between 0 and 1 representing how much the geometry should occupy the cell, and the material of the cell. The occupancy determines how the cell will morph together with surrounding cells, and the result is the illusion of having no grid constraint. Terrain provides a practically unlimited amount of space to work with. */
interface Terrain extends RbxInternalBasePart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Terrain";
	/** Displays the boundaries of the largest possible editable region. */
	readonly MaxExtents: Region3int16;
	/** The tint of the Terrain water. */
	WaterColor: Color3;
	/** Controls how opaque the Terrain's water reflections are. */
	WaterReflectance: number;
	/** The transparency of the Terrain water. */
	WaterTransparency: number;
	/** Sets the maximum height of the Terrain water waves in studs. This is currently constrained to between 0 and 1. */
	WaterWaveSize: number;
	/** Sets how many times the Terrain water waves will move up and down per minute. This is currently constrained to between 0 and 100. */
	WaterWaveSpeed: number;
	/** Returns the world position of the center of the terrain cell (x, y, z). */
	CellCenterToWorld(x: number, y: number, z: number): Vector3;
	/** Returns the position of the lower-left-forward corner of the grid cell (x, y, z). */
	CellCornerToWorld(x: number, y: number, z: number): Vector3;
	/** Clears the terrain. */
	Clear(): void;
	/** Stores a chunk of terrain into a `TerrainRegion` object so it can be loaded back later.  Note: `TerrainRegion` data does not replicate between server and client.

## Code Samples

### Terrain:CopyRegion

The following code will copy the whole Terrain and clear it.
After 5 seconds it will paste the terrain back.
```lua
local terrainRegion = workspace.Terrain:CopyRegion(workspace.Terrain.MaxExtents)
workspace.Terrain:Clear()
wait(5)
workspace.Terrain:PasteRegion(terrainRegion, workspace.Terrain.MaxExtents.Min, true)
```
 */
	CopyRegion(region: Region3int16): TerrainRegion;
	/** Returns the number of non-empty cells in the Terrain. */
	CountCells(): number;
	/** Fills a ball of smooth terrain in a given space.

## Code Samples

### Terrain:FillBall

The below would set a ball of Grass at 0,0,0(World Space) with a radius of 5.
```lua
workspace.Terrain:FillBall(Vector3.new(0,0,0),5,Enum.Material.Grass)

```
 */
	FillBall(center: Vector3, radius: number, material: CastsToEnum<Enum.Material>): void;
	/** Fills a block of smooth terrain with a given location, rotation, size, and material. */
	FillBlock(cframe: CFrame, size: Vector3, material: CastsToEnum<Enum.Material>): void;
	/** Fills a [Region3](https://developer.roblox.com/api-reference/datatype/Region3 "Region3")
 space with smooth terrain. */
	FillRegion(region: Region3, resolution: number, material: CastsToEnum<Enum.Material>): void;
	/** Returns the current terrain material color for the specified terrain material. */
	GetMaterialColor(material: CastsToEnum<Enum.Material>): Color3;
	/** Applies a chunk of terrain to the Terrain object. Note: `TerrainRegion` data does not replicate between server and client.

## Code Samples

### Terrain:PasteRegion

The following code will copy the whole Terrain and clear it. After 5 seconds it will paste the terrain back.
```lua
local terrainRegion = workspace.Terrain:CopyRegion(workspace.Terrain.MaxExtents)
workspace.Terrain:Clear()
wait(5)
local corner = Vector3int16.new(-32000, -32000, -32000)
local pasteEmptyRegion = false
workspace.Terrain:PasteRegion(terrainRegion, corner, pasteEmptyRegion)
```
 */
	PasteRegion(region: TerrainRegion, corner: Vector3int16, pasteEmptyCells: boolean): void;
	/** Returns a certain region of [smooth terrain](https://developer.roblox.com/articles/Intro-To-Terrain "Smooth terrain") in [table format](https://developer.roblox.com/articles/Intro-To-Terrain#Reading_and_writing_voxels "Smooth terrain") . Both of the return arrays have an additional `.Size` property, a [Vector3](https://developer.roblox.com/api-reference/datatype/Vector3 "Vector3")
. */
	ReadVoxels(
		region: Region3,
		resolution: number,
	): LuaTuple<[ReadVoxelsArray<Enum.Material>, ReadVoxelsArray<number>]>;
	/** Sets current terrain material color for specified terrain material. Terrain material will shift its base color toward specified color. */
	SetMaterialColor(material: CastsToEnum<Enum.Material>, value: Color3): void;
	/** Returns the grid cell location that contains the point **position**
. */
	WorldToCell(position: Vector3): Vector3;
	/** Returns the grid cell location that contains the point position, preferring empty grid cells when position is on a grid edge. */
	WorldToCellPreferEmpty(position: Vector3): Vector3;
	/** Returns the grid cell location that contains the point position, preferring non-empty grid cells when position is on a grid edge. */
	WorldToCellPreferSolid(position: Vector3): Vector3;
	/** Sets a certain region of [smooth terrain](https://developer.roblox.com/articles/Intro-To-Terrain "Smooth terrain") using the [table format](https://developer.roblox.com/articles/Intro-To-Terrain#Reading_and_writing_voxels "Smooth terrain") */
	WriteVoxels(
		region: Region3,
		resolution: number,
		materials: Array<Array<Array<CastsToEnum<Enum.Material>>>>,
		occupancy: Array<Array<Array<number>>>,
	): void;
}

interface RbxInternalTriangleMeshPart extends RbxInternalBasePart {}
type TriangleMeshPart = MeshPart | PartOperation | NegateOperation | UnionOperation;

/** MeshParts are a form of `BasePart` that includes a physically simulated custom mesh. Unlike with other mesh classes, such as `SpecialMesh` and `BlockMesh`, they are not parented to a `BasePart` but rather behave as a `BasePart` in their own right.

## How do I use MeshParts
The mesh and texture of a MeshPart are determined by the `MeshId` and `TextureID` properties. For more information on how to use MeshParts please see `Mesh here`.

## SpecialMesh or MeshPart?

There are currently two ways of using a developer created mesh. They are using a `SpecialMesh` with the `FileType` set to 'FileMesh', or by using a MeshPart. Although, on the whole, the MeshPart object has superseded the SpecialMesh there are some differences developers should be aware of.

 - `Material` displays correctly on the mesh when using a MeshPart and not when using a `SpecialMesh`
 - MeshParts include the `CollisionFidelity` property, meaning the collision model of a MeshPart can be set to resemble the geometry of the mesh. The `SpecialMesh` object by contrast, uses the parent `BasePart`s collision model
 - The mesh of a MeshPart scales on all axis depending on the `Size` property of the MeshPart, the mesh of a `SpecialMesh` does not
 - The `SpecialMesh` object includes the `Offset` and `Scale` properties whereas MeshParts do not
 - The `MeshId` property of a `SpecialMesh` can be changed by a `Script` or `LocalScript` during runtime. The `MeshId` property of a MeshPart can not

In most, but not all cases, using a MeshPart is more suitable. As MeshParts are a relatively new feature however, developers should expect some of the above behaviour to change.

  [1]: /articles/Mesh-Parts */
interface MeshPart extends RbxInternalTriangleMeshPart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "MeshPart";
	/** The **MeshId** is the content ID of the mesh that is to be displayed on the `MeshPart`.

Note that this property currently cannot be changed by scripts as the collision model of the mesh cannot be recomputed during runtime. Developers should not rely on this behavior as it may change in the future. Those looking for a custom mesh object that can be updated during runtime should use `SpecialMesh`. */
	readonly MeshId: string;
	/** [LACKS DOCUMENTATION] */
	readonly RenderFidelity: Enum.RenderFidelity;
	/** The texture applied to the `MeshPart`. When this property is set to an empty string, no texture will be applied to the mesh.

```lua
MeshPart.TextureID = "" -- no texture
```


Note, although the `MeshId` property cannot be changed during runtime, the texture can.

## How can I change the texture of a mesh?

Using the TextureId property, the texture of a mesh can be changed without having to reupload the mesh. To do this, a new image will need to be uploaded to Roblox with the desired texture. The original texture image file can be obtained by exporting the mesh using the 'Export Selection' option in Roblox Studio. The image file will be saved alongside the exported .obj file.

The new texture can then be re-uploaded to Roblox as a Decal and its content ID can be applied to the mesh using the TextureId property.

## How can I make a textured mesh?

A mesh can only be textured if the mesh has been UV mapped. UV mapping refers to the practice of projecting a texture map onto a mesh. This cannot be done using Roblox Studio and has to be done using an external 3D modelling application such as [Blender][1].

  [1]: https://www.blender.org/ */
	TextureID: string;
}

interface RbxInternalDerivesFromPartOperation extends RbxInternalTriangleMeshPart {
	/** [LACKS DOCUMENTATION] */
	readonly RenderFidelity: Enum.RenderFidelity;
	/** The number of polygons in this solid model. This value will always be &lt;= 5000.The number of polygons in this solid model. This value will always be &lt;= 5000.

Tags: ReadOnly, NotReplicated */
	readonly TriangleCount: number;
	/** Sets whether the PartOperation can be recolored using the BrickColor property. When true, the entire Union will be colored as per `BrickColor`. When false, the parts in the Union will maintain their original colors before the Union operation was performed. */
	UsePartColor: boolean;
}
/** An abstract class that all [solid modeling](https://developer.roblox.com/articles/3D-Modeling-with-Parts)
 based parts inherit from. */
interface PartOperation extends RbxInternalDerivesFromPartOperation {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PartOperation";
}


/** A CSG part created by the "Negate" option in studio ([Solid modeling](https://developer.roblox.com/articles/3D-Modeling-with-Parts)
).
Union this with another part, to cut this part out of the second one. */
interface NegateOperation extends RbxInternalDerivesFromPartOperation {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NegateOperation";
}

/** A CSG part created by the "Union" option in studio ([Solid modeling](https://developer.roblox.com/articles/3D-Modeling-with-Parts "Solid modeling")
).
It is two (or more) parts merged into each other, which can be separated again. */
interface UnionOperation extends RbxInternalDerivesFromPartOperation {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UnionOperation";
}

/** Truss parts are the same as Parts, except that they have a different visual style, resize differently and characters are able to climb them. */
interface TrussPart extends RbxInternalBasePart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TrussPart";
	/** Sets what the truss looks like. There are currently three different styles.Sets what the truss looks like. There are currently three different styles.

Tags: NotReplicated */
	Style: Enum.Style;
}

/** The VehicleSeat objects welds a player to the seat when the player touches the seat. It then forwards the movement keys to any connected motor joints, allowing control of a vehicle.

While VehicleSeats are great for making simple vehicles they do have some limitations. Movement control will only detect motors connected directly to the vehicle seat, or through another rigid connection. This means that if you have a wheel connected to a beam which is then welded to the seat it will work fine, however if you have the wheel connected to a part, which is connected by a hinge to the rest of the car, it will not work. */
interface VehicleSeat extends RbxInternalBasePart {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VehicleSeat";
	/** Displays how many hinges are detected by the VehicleSeat. Useful for debugging vehicle designs. */
	readonly AreHingesDetected: number;
	/** Toggles whether the `VehicleSeat` is active or not.
If the seat is disabled then it will not automatically weld a character to it on collision and will not allow a character to control the connected vehicle.Toggles whether the `VehicleSeat` is active or not. */
	Disabled: boolean;
	/** If true, a fancy speed bar will be displayed speed on screen that tells you what speed the Vehicle is moving at. */
	HeadsUpDisplay: boolean;
	/** The maximum speed that can be attained. */
	MaxSpeed: number;
	/** The humanoid that is sitting in the seat */
	readonly Occupant?: Humanoid;
	/** The direction of movement, tied to the keys A and D. Must be one of 1 (right), 0 (straight), or -1 (left). Will refresh back to 0 unless constantly set. */
	Steer: number;
	/** Functions identically to `Steer`, but the value is not an integer. */
	SteerFloat: number;
	/** The direction of movement, tied to the keys W and S. Must be an integer 1 (forward) 0 (null) or -1 (reverse). Will refresh back to 0 unless constantly set. */
	Throttle: number;
	/** Functions identically to `Throttle`, but the value is not an integer. */
	ThrottleFloat: number;
	/** How fast the vehicles will be able to attain `MaxSpeed`. The greater the number, the faster it will reach the maximum speed. */
	Torque: number;
	/** The speed at which the vehicle will turn. Higher numbers can cause problems and are not necessarily better. */
	TurnSpeed: number;
	/** Forces the character with the specified [Humanoid](https://developer.roblox.com/api-reference/class/Humanoid "Humanoid")
 to sit in the VehicleSeat. */
	Sit(humanoid: Humanoid): void;
}

interface RbxInternalDerivesFromModel extends RbxInternalPVInstance {
	/** Points to the `Model`'s primary part. The part is the `BasePart` that is used as a basis when positioning the model using the `MoveTo` and `SetPrimaryPartCFrame` functions.

Note when assigning the PrimaryPart that the part must be a `BasePart` that is descendant of the Model. If this is not the case, the PrimaryPart will be set to nil in Roblox studio, or produce an error if done so by a Script.

When dealing with models full of unanchored parts connected with joints such as `Weld`s or `Motor6D`s it is best practice to set the PrimaryPart to the root part of the assembly. Giving the example of a Player Character, this is the HumanoidRootPart.

## Code Samples

### SetPrimaryPartCFrame

In this code sample a Model is created with a simple arrangement of Parts. The PrimaryPart of this Model is then set, meaning Model:SetPrimaryPartCFrame can then be used.

To demonstrate SetPrimaryPartCFrame, a simple loop is then run which switches the model between two CFrames every second.
```lua
-- define two CFrames
local startCFrame = CFrame.new(0, 10, 0)
local endCFrame = CFrame.new(0, 15, 0) * CFrame.Angles(0, math.rad(90), 0)

-- create a simple model
local model = Instance.new("Model", game.Workspace)

local part = Instance.new("Part", model)
part.Size = Vector3.new(5, 1, 5)
part.Anchored = true
part.CFrame = startCFrame
part.BrickColor = BrickColor.new("Bright green")

local part2 = Instance.new("Part", model)
part2.Size = Vector3.new(5, 1, 1)
part2.Anchored = true
part2.CFrame = startCFrame * CFrame.new(0, 1, 0) * CFrame.Angles(0, math.rad(90), 0)
part2.BrickColor = BrickColor.new("Bright red")

-- set the model's PrimaryPart
model.PrimaryPart = part 

-- loop between the two CFrames
while true do
	wait(1)
	model:SetPrimaryPartCFrame(startCFrame)
	wait(1)
	model:SetPrimaryPartCFrame(endCFrame)
end


```
 */
	PrimaryPart?: BasePart;
	/** Breaks connections between `BaseParts`, including surface connections with any adjacent parts, `WeldConstraint`s, and all `Weld`s and other `JointInstance`s.

When BreakJoints is used on a Player character `Model`, the character's `Humanoid` will die as it relies on the Neck joint.

Note that although joints produced by surface connections with adjacent Parts can technically be recreated using `MakeJoints`, this will only recreate joints produced by surfaces. Developers should not rely on this as following the joints being broken parts may no longer be in contact with each other.

## Code Samples

### Manual Joint Creation

This code sample demonstrates manual creation of joints on two parts that are siblings of the script (PartA and PartB). It creates a joints on two touching parts with compatible surface types (Studs and Inlet).
```lua
local partA = script.Parent.PartA
local partB = script.Parent.PartB

local function join(part0, part1, jointClass, parent)
    local newJoint = Instance.new(jointClass or "ManualWeld")
    newJoint.Part0 = part0
    newJoint.Part1 = part1
    newJoint.C0 = CFrame.new()
    newJoint.C1 = part1.CFrame:toObjectSpace(part0.CFrame)
    newJoint.Parent = parent or part0
 
    return newJoint
end

-- Create some joints and break them
join(partA, partB)
partA:BreakJoints()
-- Glue joints are wobbly
join(partA, partB, "Glue")
partA:BreakJoints()
-- Most of the time, joints ought to be put in JointsService
join(partA, partB, "Weld", game:GetService("JointsService"))
```

### Break Character Joints

In this sample the joints in every Player character Model added will be broken 3 seconds after spawning. Breaking these joints will cause the Humanoid to die.
```lua
local Players = game:GetService("Players")

Players.PlayerAdded:Connect(function(newPlayer)
	newPlayer.CharacterAdded:Connect(function(characterModel)
		wait(3)
		characterModel:BreakJoints()
	end)
end)
```
 */
	BreakJoints(): void;

	GetBoundingBox(): LuaTuple<[CFrame, Vector3]>;
	/** Returns the size of the smallest bounding box that contains all of the `BasePart`s in the `Model`. If `PrimaryPart` exists then the bounding box will be aligned to that part. If a primary part has not been set then the function will chose a part in the model to align the bounding box to. As the the selection of this part is not deterministic it is recommended to set a `PrimaryPart` to get consistent results with this function.

Note this function only returns the size of the smallest bounding box, and the developer must employ their own method to obtain the position of the bounding box.

## Code Samples

### Model GetExtentsSize

The code sample below demonstrates how Model.GetExtentsSize can be used to get the size of the bounding box containing the parts.
```lua
local model = Instance.new('Model', Workspace) -- Create a model.
 
for i = 1, 5 do
	-- Fill the model with randomly positioned parts.
	local part = Instance.new('Part', model)
	part.Anchored = true
	part.Size = Vector3.new(math.random(5), math.random(5), math.random(5))
end
 
print(model:GetExtentsSize())
```

@returns The `DataType/Vector3` extents size of the `Model`. */
	GetExtentsSize(): Vector3;
	/** Returns the `CFrame` of the `Model`'s `PrimaryPart`. 

This function is equivalent to the following.

    Model.PrimaryPart.CFrame

Note this function will throw an error if no primary part exists for the `Model`. If this behavior is not desired developers can do the following, which will be equal to nil if there is no primary part.

    local cFrame = Model.PrimaryPart and Model.PrimaryPart.CFrame

## Code Samples

### Rotating a Model

The following code demonstrates how GetPrimaryPartCFrame and SetPrimaryPartCFrame can be used to rotate a model.

A simple model is created in the Workspace and a loop is started that will rotate the model 10 degrees around the Y axis every 0.2 seconds.
```lua
local startPosition = Vector3.new(0, 10, 0)

-- create a simple rotated model at the startPosition
local model = Instance.new("Model", game.Workspace)

local part1 = Instance.new("Part")
part1.Size = Vector3.new(4, 4, 4)
part1.CFrame = CFrame.new(startPosition)
part1.Anchored = true
part1.BrickColor = BrickColor.new("Bright yellow")
part1.Parent = model

local part2 = Instance.new("Part")
part2.Size = Vector3.new(2, 2, 2)
part2.CFrame = part1.CFrame * CFrame.new(0, 3, 0)
part2.Anchored = true
part2.BrickColor = BrickColor.new("Bright blue")
part2.Parent = model

-- set the primary part
model.PrimaryPart = part1
model.Parent = game.Workspace

while true do
	local primaryPartCFrame = model:GetPrimaryPartCFrame()
	local newCFrame = primaryPartCFrame * CFrame.Angles(0, math.rad(10), 0)
	model:SetPrimaryPartCFrame(newCFrame)
	wait(.2)
end
```
 */
	GetPrimaryPartCFrame(): CFrame;
	/** Goes through all `BasePart`s in the `Model`. If any part's side has a SurfaceType that can make a joint it will create a joint with any adjacent parts.

This function will not work if the `Model` is not a descendant of `Workspace`. Therefore developers must first ensure the `Model` is parented to `Workspace` before using MakeJoints.

Joints are broken if enough force is applied to them due to an `Explosion`, unless a `ForceField` object is parented to the model. For this reason, they are often used to make simple destructible buildings and other models.

## Code Samples

### Simple Joint Creation

This code sample demonstrates creation of joints on two parts that are siblings of the script (PartA and PartB). It uses MakeJoints on two touching parts with compatible surface types (Studs and Inlet).
```lua
local partA = script.Parent.PartA
local partB = script.Parent.PartB

-- Move PartB on top of PartA
partB.CFrame = partA.CFrame * CFrame.new(0, partB.Size.Y / 2 + partA.Size.Y / 2, 0)
-- Studs and Inlet will make joints
partA.TopSurface = Enum.SurfaceType.Studs
partB.BottomSurface = Enum.SurfaceType.Inlet
-- Automatically create a joint between PartA and PartB
partA:MakeJoints()
```

### Model MakeJoints

This code sample demonstrates how joints can be made using the Model:MakeJoints function.

A model is instanced, with two parts on top of each other. The top part is anchored and the bottom part is not. Normally, when parented to the Workspace the bottom part would fall to the Baseplate.

However, as TopSurface property of the bottom part is set to Enum.SurfaceType.Weld, this means that when Model:MakeJoints is ran a connection is made between them.

Therefore the bottom part does not drop until the joints in the model are broken. This is often done using Model:BreakJoints, but in this example the connection is broken using an explosion.
```lua
local model = Instance.new("Model")

-- create one part on top of another
local topPart = Instance.new("Part", model)
topPart.Size = Vector3.new(5, 1, 5)
topPart.Position = Vector3.new(0, 10, 0)
topPart.BrickColor = BrickColor.new("Bright green")
topPart.Anchored = true -- anchor the top part

local bottomPart = Instance.new("Part", model)
bottomPart.Size = Vector3.new(8, 1, 8)
bottomPart.Position = Vector3.new(0, 9, 0)
bottomPart.BrickColor = BrickColor.new("Bright green")
bottomPart.Anchored = false -- leave bottom unanchored

-- set the part's surfaces
topPart.BottomSurface = Enum.SurfaceType.Smooth -- 'Weld' to create a joint
topPart.TopSurface = Enum.SurfaceType.Smooth
bottomPart.BottomSurface = Enum.SurfaceType.Smooth
bottomPart.TopSurface = Enum.SurfaceType.Weld -- 'Weld' to create a joint

-- parent the model to the workspace
model.Parent = game.Workspace

-- make the joints
model:MakeJoints()

wait(2)
-- unanchor the bottom part - part does not fall
print("Unanchored!")
bottomPart.BrickColor = BrickColor.new("Bright red")
bottomPart.Anchored = false

wait(2)
-- break the joints using an explosion - part falls
local explosion = Instance.new("Explosion")
explosion.Position = bottomPart.Position
explosion.Parent = game.Workspace

```
 */
	MakeJoints(): void;
	/** Moves the `PrimaryPart` to the given position. If a primary part has not been specified then the root part of the model will be used. Because the root part is not deterministic, it is recommended to always set a `PrimaryPart` when using MoveTo.

If there are any obstructions where the model is to be moved to, such as `Terrain` or other `BasePart`s, then the model will be moved up in the Y direction until there is nothing in the way. If this behavior is not desired, `SetPrimaryPartCFrame` should be used instead.

Note that rotation is not preserved when moving a model with MoveTo. It is recommended to use either `TranslateBy` or `SetPrimaryPartCFrame` if the current rotation of the model needs to be preserved.

## Code Samples

### Model MoveTo

This sample demonstrates how Model:MoveTo avoids collisions.

A simple two part Model is created, and its PrimaryPart is set. An large obstruction part is placed next to it.

After 5 seconds Model:MoveTo is used to direct the model to move inside the obstruction part. However, as MoveTo will not move a model inside of an obstruction the Model is moved up on the Y axis and placed above the obstruction.
```lua
-- define two Positions
local startPosition = Vector3.new(-20, 10, 0)
local endPosition = Vector3.new(0, 10, 0)

-- create a simple model at the startPosition
local model = Instance.new("Model", game.Workspace)

local part1 = Instance.new("Part")
part1.Size = Vector3.new(4, 4, 4)
part1.Position = startPosition
part1.Anchored = true
part1.BrickColor = BrickColor.new("Bright yellow")
part1.Parent = model

local part2 = Instance.new("Part")
part2.Size = Vector3.new(2, 2, 2)
part2.Position = startPosition + Vector3.new(0, 3, 0)
part2.Anchored = true
part2.BrickColor = BrickColor.new("Bright blue")
part2.Parent = model

-- set the primary part
model.PrimaryPart = part1
model.Parent = game.Workspace

-- create an obstruction at the endPosition
local obstruction = Instance.new("Part")
obstruction.Name = "Obstruction"
obstruction.Size = Vector3.new(10, 10, 10)
obstruction.Position = Vector3.new(0, 10, 0)
obstruction.Anchored = true
obstruction.BrickColor = BrickColor.new("Bright green")
obstruction.Parent = game.Workspace

wait(3)
-- attempt to move the model to the obstructed endPosition
model:MoveTo(endPosition)
```

@param position The `DataType/Position` the `Model` is to be moved to. */
	MoveTo(position: Vector3): void;
	/** Sets the `CFrame` of the `Model`'s `PrimaryPart`. All other parts in the model will also be moved and will maintain their orientation and offset respective to the `PrimaryPart`. 

Note, this function will throw an error if no `PrimaryPart` exists for the model. This can cause issues if, for example, the primary part was never set or has been destroyed. Therefore, it is recommended the developer check the `PrimaryPart` exists before using this function. For example:

    if model.PrimaryPart then
    	model:SetPrimaryPartCFrame(cf)
    end

A common use for this is for the 'teleportation' of player characters to different positions.

## Code Samples

### Character SetPrimaryPartCFrame

In this sample every Player character Model added will be moved to 0, 500, 0 three seconds after spawning.
```lua
local Players = game:GetService("Players")

Players.PlayerAdded:Connect(function(newPlayer)
	newPlayer.CharacterAdded:Connect(function(characterModel)
		wait(3)
		characterModel:SetPrimaryPartCFrame(CFrame.new(0, 500, 0))
	end)
end)
```

### SetPrimaryPartCFrame

In this code sample a Model is created with a simple arrangement of Parts. The PrimaryPart of this Model is then set, meaning Model:SetPrimaryPartCFrame can then be used.

To demonstrate SetPrimaryPartCFrame, a simple loop is then run which switches the model between two CFrames every second.
```lua
-- define two CFrames
local startCFrame = CFrame.new(0, 10, 0)
local endCFrame = CFrame.new(0, 15, 0) * CFrame.Angles(0, math.rad(90), 0)

-- create a simple model
local model = Instance.new("Model", game.Workspace)

local part = Instance.new("Part", model)
part.Size = Vector3.new(5, 1, 5)
part.Anchored = true
part.CFrame = startCFrame
part.BrickColor = BrickColor.new("Bright green")

local part2 = Instance.new("Part", model)
part2.Size = Vector3.new(5, 1, 1)
part2.Anchored = true
part2.CFrame = startCFrame * CFrame.new(0, 1, 0) * CFrame.Angles(0, math.rad(90), 0)
part2.BrickColor = BrickColor.new("Bright red")

-- set the model's PrimaryPart
model.PrimaryPart = part 

-- loop between the two CFrames
while true do
	wait(1)
	model:SetPrimaryPartCFrame(startCFrame)
	wait(1)
	model:SetPrimaryPartCFrame(endCFrame)
end


```

@param cframe The `DataType/CFrame` to be set. */
	SetPrimaryPartCFrame(cframe: CFrame): void;
	/** Shifts a `Model` by the given `Vector3` offset, preserving the `Model`'s orientation. If another `BasePart` or `Terrain` already exists at the new position then the `Model` will overlap said object.

The translation is applied in world space rather than object space, meaning even if the model's parts are orientated differently it will still move along the standard axis.

## Code Samples

### Model TranslateBy

This sample demonstrates how Model:TranslateBy ignores collisions and respects the orientation of the model.

A simple two part Model is created, rotated 45 degrees on the Y axis, and its PrimaryPart is set. An large obstruction part is placed next to it.

After 5 seconds Model:TranslateBy is used to direct the model to move inside the obstruction part. The model will move inside of the obstruction and maintain it's current orientation.
```lua
-- define two Positions
local startPosition = Vector3.new(-20, 10, 0)
local endPosition = Vector3.new(0, 10, 0)

-- create a simple rotated model at the startPosition
local model = Instance.new("Model", game.Workspace)

local part1 = Instance.new("Part")
part1.Size = Vector3.new(4, 4, 4)
part1.CFrame = CFrame.new(startPosition) * CFrame.Angles(0, math.rad(45), 0)
part1.Anchored = true
part1.BrickColor = BrickColor.new("Bright yellow")
part1.Parent = model

local part2 = Instance.new("Part")
part2.Size = Vector3.new(2, 2, 2)
part2.CFrame = part1.CFrame * CFrame.new(0, 3, 0)
part2.Anchored = true
part2.BrickColor = BrickColor.new("Bright blue")
part2.Parent = model

-- set the primary part
model.PrimaryPart = part1
model.Parent = game.Workspace

-- create an obstruction at the endPosition
local obstruction = Instance.new("Part")
obstruction.Name = "Obstruction"
obstruction.Size = Vector3.new(10, 10, 10)
obstruction.Position = Vector3.new(0, 10, 0)
obstruction.Transparency = 0.5
obstruction.Anchored = true
obstruction.BrickColor = BrickColor.new("Bright green")
obstruction.Parent = game.Workspace

wait(3)
-- use TranslateBy to shift the model into the obstruction
model:TranslateBy(endPosition - startPosition)
```

@param delta The `DataType/Vector3` to translate the `Model` by, */
	TranslateBy(delta: Vector3): void;
}
/** Models are container objects, meaning they hold objects and group objects together. They are best used to hold collections of `BasePart`s and have a number of functions that extend their functionality. 

At their most basic level, Models allow developers to group selections of `BasePart`s together. This is particularly useful when building environments in Roblox Studio as it means the grouped parts can be moved and rotated together. When not storing collections of `BasePart`s it is recommended that developers use the `Folder` object, as they will not benefit from the additional functionality Models provide.

To access some of the extended functionality Models provide, the `PrimaryPart` property needs to be set. This property points to the `BasePart` within the Model that is to be used when moving or otherwise manipulating the model.

Models have a wide range of applications, including being used for Roblox Player Characters. They also have a number of unique behaviors that are important to keep in mind when using them:

* When a `Humanoid` and a `Part` named "Head" are parented under a model, a name-tag GUI will appear with the name of the model.

* If a `Part`'s position on the Y axis hits the `FallenPartsDestroyHeight` value, and it was the last object inside of a Model, the Model will be destroyed as well.

## Code Samples

### Basic Model Instantiation

The following sample includes a basic function that takes a table of objects and parents them into a new Model, returning that Model.
```lua
local function groupObjects(objectTable)
	local model = Instance.new("Model")
	for _, object in pairs(objectTable) do
		object.Parent = model
	end
	return model
end
```
 */
interface Model extends RbxInternalDerivesFromModel {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Model";
}


/** Used as a storage for custom Humanoid statuses. This object would've been officially used in the RbxStatus library, but remains unfinished. */
interface Status extends RbxInternalDerivesFromModel {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Status";
}

/** The Workspace is the service in which any objects that are to be rendered in the 3D world exist. Objects not descending from Workspace will not be rendered or physically interact with the world.

## What does the Workspace do?
The core job of the Workspace is to hold objects that exist in the 3D world, `BaseParts` and `Attachments`. Whilst such objects are descendant of Workspace, they will be active. For BaseParts this means they will be rendered, and physically interact with other parts and the world. For `Attachment`s this means objects adorned to them, such as `ParticleEmitters`, `Beams` and `BillboardGuis` will render.

Understanding this behavior is important, as it means objects can be removed from the Workspace when they are not needed. For example, map `Models` can be removed from the `Workspace` when a different map is being played on. Objects that are not immediately needed in the Workspace are generally stored in `ReplicatedStorage` or `ServerStorage`.

In its role as the holder of active 3D objects, Workspace includes a number of useful functions related to parts, their positions and joints between them. Commonly used are the Workspace's raycasting functions, such as `FindPartOnRay`.

## Accessing the Workspace
The Workspace can be accessed several ways, all of which are valid.
```lua
workspace -- a global variable
game.Workspace -- a property of the DataModel
game:GetService("Workspace") -- workspace is a service
```


## Notes
 - Objects that require adornment, such as `ParticleEmitter`s and `BillboardGui`s will be adorned to the *0, 0, 0* position when adorned to the Workspace (parented to it without an adornee otherwise being set)
 - The `MakeJoints` and `BreakJoints` functions inherited from the `Model` class are overridden by the Workspace's own `MakeJoints` and `BreakJoints` functions, which can only be used in plugins
 - It is impossible to delete the Workspace
 - The Workspace will also clean up `BasePart`s that fall beneath `FallenPartsDestroyHeight`
 - A client's current `Camera` object can be accessed using the `CurrentCamera` property
 - The `Terrain` object can be accessed using the `Terrain` property

## Code Samples

### ServerStorage Map Rotation

This is a very simple example of how a multiple map system can be made using ServerStorage.

It creates three dummy models (to take the place of maps), that are parented to ServerStorage. Then, it will load a random map (different to the previous map) and wait a specified duration on a loop.

Developers wishing to integrate something similar into their games should consider measures to ensure players respawn correctly, or go to a lobby during intermission periods.
```lua
    local ServerStorage = game:GetService("ServerStorage")
    
    local ROUND_TIME = 5
    
    local map1 = Instance.new("Model", ServerStorage)
    map1.Name = "Map1"
    local map2 = Instance.new("Model", ServerStorage)
    map2.Name = "Map2"
    local map3 = Instance.new("Model", ServerStorage)
    map3.Name = "Map3"
    
    local maps = {map1, map2, map3}
    local currentMap = nil
    local lastPick = nil
    
    while true do 
    	print("New map!")
    
    	-- remove current map 
    	if currentMap then 
    		currentMap:Destroy()
    	end
    
    	-- pick a map 
    	local randomPick = nil
    	if #maps > 1 then
    		repeat 
    			randomPick = math.random(1, #maps)
    		until randomPick ~= lastPick
    		lastPick = randomPick
    	end
    
    	-- fetch new map
    	local map = maps[randomPick]
    	currentMap = map:Clone()
    	currentMap.Parent = workspace
    
    	wait(ROUND_TIME)
    end
```
 */
interface Workspace extends RbxInternalDerivesFromModel {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Workspace";
	/** This `Workspace` property determines whether assets created by other uses can be sold in the game.

## What are third party sales?

When this value is false, as it is by default, only assets created by the place creator (be it a player or a group) and Roblox can be sold using `MarketplaceService`.

In most cases, games do not need to sell third party assets. However, some games such as trade hangouts require this feature and therefore it exists as an opt-in option.

## What third party products can I sell?

Note, `Developer Products – In-Game developer products` can only be sold in the game they are associated with, regardless of what AllowThirdPartySales is set to. This property will function for `Game Passes – Abilities and game passes` and `How to Make Shirts and Pants for Roblox clothing` however.


  [1]: /articles/Developer-Products-In-Game-Purchases
  [2]: /articles/Game-Passes-One-Time-Purchases
  [3]: /articles/How-to-Make-Shirts-and-Pants-for-Roblox-Characters */
	AllowThirdPartySales: boolean;
	/** The `Camera` object being used by the local player.

## How to use CurrentCamera
This property can be set. When it is set, all other `Camera` objects in the `Workspace` are destroyed, including the previous CurrentCamera. If this property is set to nil, or the CurrentCamera is otherwise destroyed, a new `Camera` will be created and assigned. Developers should avoid setting this property to nil or destroying the CurrentCamera however as it can have unintended consequences.

When looking for a client's `Camera` object, developers should use this property rather than looking for a child of `Workspace` named 'Camera'.

## What can be done with CurrentCamera
Accessing a client's current `Camera` object brings a range of uses.

 - Manipulating the viewport using the `Camera` functions
 - Bbjects parented to the `Camera` will not replicate to the server, regardless of what `FilteringEnabled` is set to. Prior to `FilteringEnabled`, this was the main way to render `BasePart`s on one client only.

Below is an example of how this property can be used to access the `Camera` object and increase its `FieldOfView`.
```lua
workspace.CurrentCamera.FieldOfView = 100
``` */
	CurrentCamera?: Camera;
	/** The amount of time, in seconds, that the game has been running.

Despite the title, this value is currently not 'Distributed' across the client and the server. Instead, on the server it represents how long the server has been running. On the client, it represents how long the client has been connected to the server. 

Developers should not rely on the above behavior, and it is possible this property will be synchronized across clients and the server in the future. 

Those looking for the time since the program started running should use the 'time' function instead. See below for a comparison between DistributedGameTime and its alternatives.

```lua
print(workspace.DistributedGameTime) --&gt; Time the game started running
print(os.time()) --&gt; Time since epoch (1 January 1970, 00:00:00) UTC
print(tick()) --&gt; Time since epoch (1 January 1970, 00:00:00) system time
print(time()) --&gt; Time the game started running
print(elapsedTime()) --&gt; Time since Roblox started running
``` */
	DistributedGameTime: number;
	/** This property determines the height at which falling `BaseParts` (and their ancestor `Models`) are destroyed.

![Parts being destroyed at the FallenPartsDestroyHeight](https://developer.roblox.com/assets/5b65c33eba048a343db86bf8/FallenPartsDestroyHeight.gif)

## What happens to falling parts?
For performance reasons, Roblox automatically destroys (using `Destroy`) parts that fall below this value. This is to prevent parts that have fallen off the map from continuing to fall forever.

If a part destroyed due to this behavior is the last part in a model, then that `model will also be destroyed. This applies to all model ancestors of the part.

This property can be read by scripts, but can only be set by plugins, the command bar or the properties window in Roblox Studio.

## Notes

 - Developers should also use the `Debris` service to clean up parts that are no longer needed, but have not fallen off the map
 - This property is clamped between -50,000 and 50,000. This is because `BasePart`s do not simulate or render properly at a great distance from the origin due to floating point inaccuracies */
	readonly FallenPartsDestroyHeight: number;
	/** **Warning!** Experimental Mode has been discontinued, meaning this property will no longer take effect.


Determines whether changes made from the client will replicate to the server or not. When this property is disabled, the game is in 'Experimental Mode'.

This property is not replicated, meaning it cannot be changed once the game has started. For this reason, developers should only set this property in Roblox Studio.

## What does FilteringEnabled do?

When FilteringEnabled is disabled, the place is in 'Experimental Mode'. In 'Experimental Mode', changes made to the game on the client replicate back to the server. For some, this makes games simpler to make, but means exploiters can change nearly anything in the game (such as deleting the baseplate).

When FilteringEnabled is enabled, everything continues to replicate from the server to the client (with a few exceptions such as `ServerStorage` and `ServerScriptStorage`). However, actions made by the client will no longer freely replicate to the server. Instead, `RemoteEvent`s and `RemoteFunction`s need to be used by the client to 'request' the server preforms certain actions on its behalf.

## What are the exceptions to FilteringEnabled?

Whilst FilteringEnabled prevents almost everything from replicating from the client to the server, there are some exceptions.

 - Some properties on the local `Humanoid`
 - `Sound` playback, when `RespectFilteringEnabled` is set to false
 - `ClickDetector` input events
 - `AnimationTrack` playback
 - Physics simulated on `BasePart`s which the client has `Network Ownership — Making physics smoother!|network ownership` of

## Is FilteringEnabled more secure?

Enabling FilteringEnabled is the best way of restricting exploiters from ruining your games. When it is enabled, with a few exceptions, changes made by clients will not replicate to the server (and therefore will not replicate to other clients). This means, if your game is properly designed, exploiters will find it much harder to operate in your game.

Enabling FilteringEnabled however, has implications on a game's design that developers must consider. Before using it, it is highly recommended developers familiarize themselves on the following topics:

 - `Experimental Experimental Mode` A brief introduction to the client-server model
 - `Building Games with Experimental Mode Building games with Experimental Mode off` How to approach building a game with FilteringEnabled
 - [Converting Experimental Mode games][4] Converting a game to use FilteringEnabled
 - [Game Security][5] How to use FilteringEnabled to improve the security of your game


  [1]: /articles/Network-Ownership
  [2]: /articles/Experimental-Mode
  [3]: /articles/Building-Games-with-Experimental-Mode-Off
  [4]: /articles/Converting-From-Experimental-Mode
  [5]: /articles/Game-Security */
	readonly FilteringEnabled: boolean;
	/** Determines the acceleration due to gravity applied to falling `BaseParts`. This value is measured in studs per second squared and by default is set to 196.2 studs/second2
. By changing this value, developers can simulate the effects of lower or higher gravity in game.

## Code Samples

### Low Gravity Button

This script creates a touch pad in the workspace that, when touched, will reduce the game's gravity. Activating the pad again will switch back to normal gravity.
```lua
-- Calculate the moon's gravity
local moonGravityRatio = 1.62 / 9.81
local defaultGravity = 196.2
local moonGravity = defaultGravity * moonGravityRatio

-- Create a touch pad
local pad = Instance.new("Part")
pad.Size = Vector3.new(5, 1, 5)
pad.Position = Vector3.new(0, 0.5, 0)
pad.Anchored = true
pad.BrickColor = BrickColor.new("Bright green")
pad.Parent = workspace

-- Listen for pad touch
local enabled = false
local debounce = false
pad.Touched:Connect(function(hit)
	if not debounce then
		debounce = true
		-- Toggle gravity between moon and default
		enabled = not enabled 
		workspace.Gravity = enabled and moonGravity or defaultGravity
		-- Change pad color 
		pad.BrickColor = enabled and BrickColor.new("Bright red") or BrickColor.new("Bright green")
		wait(1)
		debounce = false
	end
end)
```
 */
	Gravity: number;
	/** Whether network streaming is enabled for the place or not.

This property is not replicated, and therefore cannot be changed once the game has started. For this reason, it is advised it is set in Roblox Studio.

## What is network streaming?

Streaming is an opt-in feature builders can enable for their places. It'll allow places to have more `BasePart`s, faster join times, and allow more games to run on less powerful hardware. It does this by allowing games to be played whilst objects are still being downloaded, and removing objects that are no longer needed.

The downside of network streaming is it means the client can no longer rely on specific objects being available. Developers should not enable StreamingEnabled unless they understand its implications and have put processes in place to manage them. For example, `LocalScript`s may have to use `WaitForChild` in order to access parts of the game. */
	StreamingEnabled: boolean;
	/** This property is a reference to the `Terrain` object parented to the `Workspace`. 

![An example of Roblox terrain](https://developer.roblox.com/assets/5b65bf0c4bf5bf624023ee26/Terrain.png)

This property, like `CurrentCamera`, ensures that developers to not inadvertently index a descendant of `Workspace` named 'Terrain' when looking for a game's `Terrain` object. Without this property, developers would need to use the `FindFirstChildOfClass` function.

```lua
workspace.Terrain.WaterColor = Color3.new(0, 1, 0) -- make the water green
``` */
	Terrain: Terrain;
	/** FindPartOnRay uses [raycasting][1] to find the first `BasePart` intersecting with a given `Ray`. This function returns the position of intersection, the surface normal of the intersecting `BasePart` at the point of intersection, and the `BasePart`'s `Material`.

```lua
local character = game.Players.LocalPlayer.Character
-- Get the head
local head = character:FindFirstChild("Head")
-- Build a ray in the direction the head is facing
local origin = head.Position
local lookDirection = head.CFrame.lookVector
local ray = Ray.new(origin, lookDirection * 500)
-- Raycast, ignoring the player's character
local part, hitPosition = workspace:FindPartOnRay(ray, character)
if part then
	print("Hit part: " .. part:GetFullName())
else
	print("Did not hit part")
end
```


The `terrainCellsAreCubes` and `ignoreWater` parameters determine whether `Terrain` cells should be treated as cubes or not, and whether water should be ignored or not. 

If the `ignoreDescendantsInstance` parameter is provided, the raycasting calculation will ignore the given object and all of its descendants. It behaves similar to the `TargetFilter` property.

In order to white-list or ignore multiple objects and their descendants, use these variants: `FindPartOnRayWithWhitelist` and `FindPartOnRayWithIgnoreList`.

## Notes

 - Theoretically, a ray extends infinitely in one direction. However, the max length of the direction vector on Roblox is 5000 studs
 - The length of the direction vector is important - parts further away than its length will not be tested
 - If the ray does not intersect a part, the return values will be nil and the point at the end of the ray, respectively
 - Parts that are in a `collision group` that does not collide with the "Default" collision group are ignored implicitly

For more information on how raycasting works in Roblox, please see the articles on [raycasting basics][1] and [how to make raycasting guns][2].


  [1]: /articles/Raycasting
  [2]: /articles/Making-a-ray-casting-laser-gun-in-Roblox
@param ray The `DataType/Ray`.
@param ignoreDescendantsInstance An `Instance` to be ignored.
@param terrainCellsAreCubes True if terrain cells should be treated as cubes.
@param ignoreWater True if terrain water should be ignored.
@returns The `BasePart` (or `Terrain`) hit, the `DataType/Vector3` point of intersection, the `DataType/Vector3` surface normal at the point of intersection and the `Enum/Material` of the `BasePart` or terrain cell hit. */
	FindPartOnRay(
		ray: Ray,
		ignoreDescendantsInstance?: Instance,
		terrainCellsAreCubes?: boolean,
		ignoreWater?: boolean,
	): LuaTuple<[BasePart | undefined, Vector3, Vector3, Enum.Material]>;
	/** This function returns the first `BasePart` intersecting with the given `Ray` that isn't in, or a descendant of an object in, the given ignore list. It also returns the position of intersection, the surface normal of the intersecting part at the point of intersection, and the part's `Material`.

This function is a variant of `FindPartOnRay` with the addition of an ignore list. This allows the developer to ignore certain parts or `Model`s. 

Those looking to utilize a white list instead should use `FindPartOnRayWithWhitelist`.

For more information on how raycasting works in Roblox, please see the articles on [raycasting basics][1] and [how to make raycasting guns][2].

## Notes
 - Theoretically, a ray extends infinitely in one direction. However, the max length of the direction vector on Roblox is 5000 studs
 - The length of the direction vector is important - parts further away than its length will not be tested
 - If the ray does not intersect a part, the return values will be nil and the point at the end of the ray, respectively
 - Parts that are in a `collision group` that do not collide with the "Default" collision group are ignored implicitly. This is an unintended behavior that may change


  [1]: /articles/Raycasting
  [2]: /articles/Making-a-ray-casting-laser-gun-in-Roblox

## Code Samples

### Raycast IgnoreList

This code sample includes a relatively in-depth example of how `FindPartOnRayWithIgnoreList` works. It creates a rotating turret that shoots constantly surrounded by a mixture of parts. Some of these parts will be added to the ignore list, whereas some will not.
```lua
local Debris = game:GetService("Debris")

-- create a turret part
local turret = Instance.new("Part")
turret.Anchored = true
turret.Size = Vector3.new(1, 1, 1)
turret.BrickColor = BrickColor.new("Black")
turret.FrontSurface = Enum.SurfaceType.Hinge
turret.Position = Vector3.new(0, 5, 0)
turret.Parent = workspace

-- create ignore list 
local ignoreList = {}

-- create random obstacles 
for i = 1, 20 do
	local part = Instance.new("Part")
	part.Anchored = true
	-- random size
	part.Size = Vector3.new(
		math.random(1, 20), 
		10, 
		math.random(1, 20)
	)
	-- random position
	part.Position = Vector3.new(
		math.random(-50, 50),
		5,
		math.random(-50, 50)
	)
	local doIgnore = math.random(1, 2) == 1 
	-- randomly allocate to the ignore list or not
	if doIgnore then
		part.BrickColor = BrickColor.new("Bright green")
		part.Transparency = 0.7
		table.insert(ignoreList, part)
	else
		part.BrickColor = BrickColor.new("Bright red")
		part.Transparency = 0
	end
	part.Parent = workspace
end

-- create beam template
local beam = Instance.new("Beam")
beam.Segments = 1
beam.Width0 = 0.2
beam.Width1 = 0.2
beam.Color = ColorSequence.new(Color3.new(1, 1, 0))
beam.FaceCamera = true

-- function to draw a bullet's path
local function drawBullet(origin, hit)
	-- create attachmetns
	local attachment0 = Instance.new("Attachment")
	local attachment1 = Instance.new("Attachment")
	-- setup beam
	local beam = beam:Clone()
	beam.Attachment0 = attachment0 
	beam.Attachment1 = attachment1
	beam.Parent = attachment0 
	-- position attachments
	attachment0.Position = origin
	attachment1.Position = hit
	-- adorn attachments to terrain
	-- attachments need to be parented to an object in 3D space
	-- terrain has an origin of 0, 0, 0 making it ideal for this use
	attachment0.Parent = workspace.Terrain
	attachment1.Parent = workspace.Terrain
	-- add the attachments to debris
	Debris:AddItem(attachment0, 0.1)
	Debris:AddItem(attachment1, 0.1)
end

local function shoot()
	local origin = turret.Position
	local aimDirection = turret.CFrame.lookVector
	-- create a ray aiming the same way as the turret
	local ray = Ray.new(origin, aimDirection * 500)
	-- raycast
	local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
	-- draw bullet effect
	drawBullet(origin, position)
end

while wait(.15) do
	-- spin the turret
	turret.CFrame = turret.CFrame * CFrame.Angles(0, math.rad(2), 0)
	-- fire the turret
	shoot()
end
```

@param ray The specified `DataType/Ray`
@param ignoreDescendantsTable An array of objects to be ignored
@param terrainCellsAreCubes Whether terrain cells should be treated as cubes
@param ignoreWater Whether terrain water should be ignored
@returns A tuple containing:
 - The `BasePart` (or `Terrain`) hit
 - The `DataType/Vector3` point of intersection, 
 - The Vector3 surface normal at the point of intersection
 - The `Enum/Material` of the part or terrain cell hit */
	FindPartOnRayWithIgnoreList(
		ray: Ray,
		ignoreDescendantsTable: Array<Instance>,
		terrainCellsAreCubes?: boolean,
		ignoreWater?: boolean,
	): LuaTuple<[BasePart | undefined, Vector3, Vector3, Enum.Material]>;
	/** This function returns the first `BasePart` intersecting with the given `Ray` that is in, or is a descendant of an object in, the given white-list. It also returns the position of intersection, the surface normal of the intersecting part at the point of intersection, and the part's `Material`.

This function is a variant of `FindPartOnRay` with the addition of a whitelist. This allows the developer to only look at certain parts or `Models`. This can be particularly useful when, for example, looking for points of intersection between a ray and a single part.

```lua
local function getIntersection(part, ray)
	local whiteList = {part}
	local _, position, normal = workspace:FindPartOnRayWithWhitelist(ray, whiteList)
	return position, normal
end
```


Those looking to utilize an ignore list instead should use `FindPartOnRayWithIgnoreList`.

## Notes
 - Theoretically, a ray extends infinitely in one direction. However, the max length of the direction vector on Roblox is 5000 studs
 - The length of the direction vector is important - parts further away than its length will not be tested
 - If the ray does not intersect a part, the return values will be nil and the point at the end of the ray, respectively
 - If a nil value is given in the white list, instances after this value will be disregarded
 - Parts that are in a `collision group` that does not collide with the "Default" collision group are ignored implicitly

For more information on how raycasting works in Roblox, please see the articles on [raycasting basics][1] and [how to make raycasting guns][2].


  [1]: /articles/Raycasting
  [2]: /articles/Making-a-ray-casting-laser-gun-in-Roblox
@param ray The specified `DataType/Ray`
@param whitelistDescendantsTable An array of objects to be checked
@param ignoreWater Whether water will be ignored or not. This only applies if the `Workspace|Workspace's` `Terrain` has been included in the white-list. Otherwise, otherwise water is ignored along with terrain by default

@returns A tuple containing:
 - The `BasePart` (or `Terrain`) hit
 - The `DataType/Vector3` point of intersection
 - The `DataType/Vector3` surface normal at the point of intersection
 - `Enum/Material` of the `BasePart` or terrain cell hit */
	FindPartOnRayWithWhitelist(
		ray: Ray,
		whitelistDescendantsTable: Array<Instance>,
		ignoreWater?: boolean,
	): LuaTuple<[BasePart | undefined, Vector3, Vector3, Enum.Material]>;
	/** Returns an array of `BasePart`s in the given `Region3`.

This function takes an optional maxParts parameter (default 20) which limits the number of `BasePart`s that can be returned. Once this number has been reached, the search for `BasePart`s will stop. This means some `BasePart`s may not be returned even if they are within the `Region3`

The optional ignoreDescendentsInstance parameter can be used to specify a specific instance for whom itself and all of its descendants should be ignored by this function. This can be useful when, for example, looking to see if any `BasePart`s are inside a `BasePart` other than the `BasePart` itself. 

```lua
local min = part.Position - (0.5 * part.Size)
local max = part.Position + (0.5 * part.Size)
local region = Region3.new(min, max)
local parts = workspace:FindPartsInRegion3(region, part) --  ignore part
```


Variants of this function exist with ignore-list and white-list functionality, `FindPartsInRegion3WithIgnoreList` and `FindPartsInRegion3WithWhiteList`.

If no `BasePart`s are found, an empty array will be returned.

## How do Region3 checks work?

Checking if a part overlaps a `Region3` is not a simple process. It actually is time consuming and complicated. Instead it checks if parts are roughly in the same area. When this function is called, it figures out which voxels contain the `Region3`. It then figures out which parts might be in those voxels. It does this by comparing the axis-aligned bounding box (sometimes called the AABB) of the part with the voxels. The axis-aligned bounding box can be seen in Roblox Studio when a part is selected.

This means that the area that is inspected by the function may be larger than the `Region3`. For this reason it is recommended to make sure that the `Region3` is on the voxel grid. The best way to do this is by setting the coordinates of the `Region3` to multiples of 4 (since voxels are 4 x 4 x 4 studs).

This method is a fairly quick and easy way to see if parts are in a general area. If a game needs to know if parts are exactly in an area, then `GetTouchingParts` should be used. There is a higher cost to using `GetTouchingParts` since a part is needed in the `Workspace` and the function takes more time to run.

## Code Samples

### Workspace:FindPartsInRegion3

This will print the names of any parts inside a square from 0,0,0 to 10,10,10:
```lua
local Point1 = Vector3.new(0,0,0)
local Point2 = Vector3.new(10,10,10)
local Region = Region3.new(Point1,Point2)
for _,Part in pairs(game.Workspace:FindPartsInRegion3(Region,nil,math.huge)) do
  print(Part.Name)
end

```

@param region The `DataType/Region3` to be checked.
@param ignoreDescendantsInstance An `Instance` to be ignored.
@param maxParts The maximum amount of `BasePart`s to be returned.
@returns An array of `BasePart`s within the `DataType/Region3`. */
	FindPartsInRegion3(region: Region3, ignoreDescendantsInstance?: Instance, maxParts?: number): Array<Instance>;
	/** Returns an array of `BasePart`s in the given `Region3` that aren't in, or a descendant of an entry in, the given IgnoreList.

This function takes an optional maxParts parameter (default 20) which limits the number of `BasePart`s that can be returned. Once this number has been reached, the search for `BasePart`s will stop. This means some `BasePart`s may not be returned even if they are within the `Region3`

If no `BasePart`s are found, an empty array will be returned.

This function is a variant of `FindPartsInRegion3` with the addition of an ignore list. This allows the developer to exclude certain `BasePart`s or `Model`s, for example characters, from the search. Those looking to find `BasePart`s in a Region3 using a white list, should use `FindPartsInRegion3WithWhitelist`.

## How do Region3 checks work?

Checking if a part overlaps a `Region3` is not a simple process. It actually is time consuming and complicated. Instead it checks if parts are roughly in the same area. When this function is called, it figures out which voxels contain the `Region3`. It then figures out which parts might be in those voxels. It does this by comparing the axis-aligned bounding box (sometimes called the AABB) of the part with the voxels. The axis-aligned bounding box can be seen in Roblox Studio when a part is selected.

This means that the area that is inspected by the function may be larger than the `Region3`. For this reason it is recommended to make sure that the `Region3` is on the voxel grid. The best way to do this is by setting the coordinates of the `Region3` to multiples of 4 (since voxels are 4 x 4 x 4 studs).

This method is a fairly quick and easy way to see if parts are in a general area. If a game needs to know if parts are exactly in an area, then `GetTouchingParts` should be used. There is a higher cost to using `GetTouchingParts` since a part is needed in the `Workspace` and the function takes more time to run.

## Notes
 - If a nil value is given in the ignore list, instances after this value will not be ignored

## Code Samples

### Find Parts in Region3 Excluding Characters

This code sample includes a function for finding `BasePart`s within a `Region3` excluding `Player` characters.
```lua
local Players = game:GetService("Players")

function findPartsExcludingCharacters(region3, maxParts)
	-- build an ignore list of all characters
	local ignoreList = {}
	for _, player in pairs(Players:GetPlayers()) do
		if player and player.Character then
			table.insert(ignoreList, player.Character)
		end
	end	
	-- return region3 search
	return workspace:FindPartsInRegion3WithIgnoreList(region3, ignoreList, maxParts)
end
```

@param region The `DataType/Region3` to be checked.
@param ignoreDescendantsTable An array of objects to be ignored.
@param maxParts The maximum number of `BasePart`s to be returned.
@returns An array of `BasePart`s found within the `DataType/Region3`. */
	FindPartsInRegion3WithIgnoreList(region: Region3, ignoreDescendantsTable: Array<Instance>, maxParts?: number): Array<Instance>;
	/** Returns an array of `BasePart`s in the given `Region3` that are in, or descendant of an object in, a given white list.

This function takes an optional maxParts parameter (default 20) which limits the number of `BasePart`s that can be returned. Once this number has been reached, the search for `BasePart`s will stop. This means some `BasePart`s may not be returned even if they are within the `Region3`

If no `BasePart`s are found, an empty array will be returned.

This function is a variant of `FindPartsInRegion3` with the addition of a white list. Those looking to find `BasePart`s in a Region3 using an ignore list, should use `FindPartsInRegion3WithIgnoreList`.

## How do Region3 checks work?

Checking if a part overlaps a `Region3` is not a simple process. It actually is time consuming and complicated. Instead it checks if parts are roughly in the same area. When this function is called, it figures out which voxels contain the `Region3`. It then figures out which parts might be in those voxels. It does this by comparing the axis-aligned bounding box (sometimes called the AABB) of the part with the voxels. The axis-aligned bounding box can be seen in Roblox Studio when a part is selected.

This means that the area that is inspected by the function may be larger than the `Region3`. For this reason it is recommended to make sure that the `Region3` is on the voxel grid. The best way to do this is by setting the coordinates of the `Region3` to multiples of 4 (since voxels are 4 x 4 x 4 studs).

This method is a fairly quick and easy way to see if parts are in a general area. If a game needs to know if parts are exactly in an area, then `GetTouchingParts` should be used. There is a higher cost to using `GetTouchingParts` since a part is needed in the `Workspace` and the function takes more time to run.

## Notes
 - If a nil value is given in the white list, instances after this value will be disregarded

## Code Samples

### Workspace:FindPartsInRegion3WithWhiteList

Click the [link](https://www.roblox.com/games/1086610835/FindPartsInRegion3WithWhiteList) to go to a working place that runs this code sample.  It is not copy locked so anyone may open it.
```lua
-- Set up Region3 and return only the red parts
parts = workspace:FindPartsInRegion3WithWhiteList(Region3.new(Vector3.new(-100,-20,-100),Vector3.new(100,20,100)), {workspace.Reds}, 1000)

-- loop through the parts array and print the name of each part
for partIndex, part in pairs(parts) do 
	print(part.Name) 
end
```

@param region The `DataType/Region3` to be checked.
@param whitelistDescendantsTable An array of objects to check.
@param maxParts The maximum number of `BasePart`s to be returned.
@returns An array of `BasePart`s within the `DataType/Region3`. */
	FindPartsInRegion3WithWhiteList(region: Region3, whitelistDescendantsTable: Array<Instance>, maxParts?: number): Array<Instance>;
	/** Returns the number of `BasePart`s that are deemed physically active, due to being recently under the influence of physics.

This function provides a measure of how many `BasePart`s are being influenced by, or recently under the influence of, physical forces. 

```lua
print(workspace:GetNumAwakeParts()) -- prints the number of 'awake' parts
```

## Sleeping vs Awake Parts
In order to ensure good performance, Roblox sets `BaseParts` in which physics are not being applied to a 'sleeping' state. `BasePart`s with `Anchored` set to true, for example, will always be sleeping as physics does not apply to them. When a force is applied to an non anchored `BasePart`, an 'awake' state will be applied. Whilst a `BasePart` is awake the Roblox physics engine will perform continuous calculations to ensure physical forces interact correctly with the part. Once the `BasePart` is no longer subject to physical forces, it will revert to a 'sleeping' state.
@returns The number of awake parts. */
	GetNumAwakeParts(): number;
	/** Returns an integer, between 0 and 100, representing the percentage of real-time that physics simulation is currently being throttled to.

This function can be used to determine whether, and to what degree, physics throttling is occurring.

## What is physics throttling?
Physics throttling occurs when the physics engine detects it cannot keep up with the game in realtime. When physics is being throttled, it will update less frequently causing `BasePart`s to appear to move slower.

Without throttling, the physics simulation would fall further behind out of sync with the game. This can lead to lower frame rates and other undesirable behavior.

Objects associated with `Humanoid`s are exempt from physics throttling.

See also `SetPhysicsThrottleEnabled`.

## Demonstrating physics throttling

Developers should always avoid creating places that overload the physics engine, as it leads to sub-par experience for players. Those wishing to simulate physics throttling for research purposes however, need only create a lot of `Part`s very quickly.

```lua
local i = 0
while true do
	i = i + 1
	if i % 5 == 0 then
		wait()
	end
	local part = Instance.new("Part", workspace)
end
```
@returns The percentage of real-time that physics simulation is currently being throttled to. */
	GetPhysicsThrottling(): number;
	/** Returns the number of frames per second that physics is currently being simulated at.

## Using GetRealPhysicsFPS to combat exploiters

A common use of this function is to detect if exploiters are increasing their local physics frame rate to move faster. This is generally done by comparing the result returned by a client's GetRealPhysicsFPS to a maximum that will not be breached in normal circumstances (usually 65 or 70). If this limit is breached, developers can use the `Kick` function to remove that `Player` from the game. It is important to remember that, although this practice may be effective sometimes, client-side anti-exploiter measures are never 100% reliable.

## Code Samples

### Workspace:GetRealPhysicsFPS

Speed exploiters commonly increase their local physics FPS in order to increase their character speed. This can be detected from a LocalScript by checking if the player's physics FPS is over the maximum:
```lua
while wait(1) do
   if Workspace:GetRealPhysicsFPS() > 65 then
      game.Players.LocalPlayer:Kick()
   end
end
```

@returns Returns the number of frames per second that physics is currently being simulated at. */
	GetRealPhysicsFPS(): number;
	/** Returns a bool stating if no `BasePart`s are in the given `Region3`.

The optional ignoreDescendentsInstance parameter can be used to specify a specific instance for whom itself and all of its descendants should be ignored by this function. This can be useful when, for example, looking to see if any `BasePart`s are inside a `BasePart` other than the `BasePart` itself. 

```lua
local min = part.Position - (0.5 * part.Size)
local max = part.Position + (0.5 * part.Size)
local region = Region3.new(min, max)
local isPartEmpty = workspace:IsRegion3Empty(region, part) --  ignore part
```


If more than one object and its descendants need to be excluded from the search, developers should use `IsRegion3EmptyWithIgnoreList`.

This function only returns if a region is empty or not. Developers looking to find `BasePart`s in a region should use `FindPartsInRegion3`.

## How do Region3 checks work?

Checking if a part overlaps a `Region3` is not a simple process. It actually is time consuming and complicated. Instead it checks if parts are roughly in the same area. When this function is called, it figures out which voxels contain the `Region3`. It then figures out which parts might be in those voxels. It does this by comparing the axis-aligned bounding box (sometimes called the AABB) of the part with the voxels. The axis-aligned bounding box can be seen in Roblox Studio when a part is selected.

This means that the area that is inspected by the function may be larger than the `Region3`. For this reason it is recommended to make sure that the `Region3` is on the voxel grid. The best way to do this is by setting the coordinates of the `Region3` to multiples of 4 (since voxels are 4 x 4 x 4 studs).

This method is a fairly quick and easy way to see if any parts are in a general area. If a game needs to know if parts are exactly in an area, then `GetTouchingParts` should be used. There is a higher cost to using `GetTouchingParts` since a part is needed in the `Workspace` and the function takes more time to run.
@param region The `DataType/Region3` to be checked.
@param ignoreDescendentsInstance An `Instance` to be ignored.
@returns True if the `DataType/Region3` is empty. */
	IsRegion3Empty(region: Region3, ignoreDescendentsInstance?: Instance): boolean;
	/** Returns a bool stating if no `BasePart`s are in the given `Region3`, ignoring any `BasePart`s that are in, or descend from objects in, the ignore list given.

For example, the following code snippet will check to see if the Region is empty, ignoring the descendants of a `Model` named 'Scenery'.

```lua
local region3 = Region3.new(Vector3.new(0, 0, 0), Vector3.new(10, 10, 10))
local scenery = workspace:FindFirstChild("Scenery")
local ignoreList = {scenery}
local isEmpty = workspace:IsRegion3EmptyWithIgnoreList(region3, ignoreList)
```


This function only returns if a region is empty or not. Developers looking to find `BasePart`s in a region should use `FindPartsInRegion3WithIgnoreList`.

This function is a variant of `IsRegion3Empty` with the addition of an ignore list. In cases where a white list is required instead, developers should check to see if any parts are returned by `FindPartsinRegion3WithWhitelist`.

## How do Region3 checks work?

Checking if a part overlaps a `Region3` is not a simple process. It actually is time consuming and complicated. Instead it checks if parts are roughly in the same area. When this function is called, it figures out which voxels contain the `Region3`. It then figures out which parts might be in those voxels. It does this by comparing the axis-aligned bounding box (sometimes called the AABB) of the part with the voxels. The axis-aligned bounding box can be seen in Roblox Studio when a part is selected.

This means that the area that is inspected by the function may be larger than the `Region3`. For this reason it is recommended to make sure that the `Region3` is on the voxel grid. The best way to do this is by setting the coordinates of the `Region3` to multiples of 4 (since voxels are 4 x 4 x 4 studs).

This method is a fairly quick and easy way to see if any parts are in a general area. If a game needs to know if parts are exactly in an area, then `GetTouchingParts` should be used. There is a higher cost to using `GetTouchingParts` since a part is needed in the `Workspace` and the function takes more time to run.

## Notes
 - If a nil value is given in the ignore list, instances after this value will not be ignored
@param region The `DataType/Region3` to be checked.
@param ignoreDescendentsTable An array of objects to be ignored.
@returns True if the `DataType/Region3` is empty. */
	IsRegion3EmptyWithIgnoreList(region: Region3, ignoreDescendentsTable: Array<Instance>): boolean;
	/** This function creates joints between the specified `Parts` and any touching parts depending on the parts' surfaces and the specified joint creation mode.

The first parameter is an array of `BaseParts`. Joints will only be create between the parts in the array and not in the array. Joints will not be created between the parts in the array.

The second parameter is a `JointCreationMode` that determines how joints will be created. The following options are available:

| Name | Description |
| --- | --- |
| All | Joints created between any touching parts |
| Surface | Joints created between parts with compatible surfaces |
| None | No joints created. Causes this function to do nothing |


This function is used by the Roblox Studio Move tool when the user finishes moving a selection. In conjunction with `GetJoinMode` and `UnjoinFromOutsiders` it can be used to retain join functionality when developing custom studio build tools. See the snippets below for an example.

```lua
-- finished moving a selection, make joints
local function finishedMovingParts(parts)
	local joinMode = Plugin:GetJoinMode()
	workspace:JoinToOutsiders(parts, joinMode)
end
```

```lua
-- started moving a selection, break joints
local function startMovingParts(parts)
	workspace:UnjoinFromOutsiders(parts)
end
```


Developers interested in seeing how this function is used in the Roblox Studio should see the [Studio Tools GitHub repository][1].


  [1]: https://github.com/Roblox/Studio-Tools
@param objects An array of `BasePart`s for whom joints are to be made.
@param jointType The `Enum/JointCreationMode` to be used. */
	JoinToOutsiders(objects: Array<Instance>, jointType: CastsToEnum<Enum.JointCreationMode>): void;
	/** Returns true if the game has the PGS Physics solver enabled.

As `PGSPhysicsSolverEnabled` cannot be accessed by scripts, the PGSIsEnabled function allows developers to tell which physics solver the game is using.

```lua
print(workspace:PGSIsEnabled()) -- true = PGS solver enabled 
print(workspace:PGSIsEnabled()) -- false = Legacy solver enabled
```


## What is the PGS Solver?

The PGS Solver is Roblox's state of the art physics solver which offers a range of simulation capabilities not available in Roblox's legacy solver.

Note, the PGS solver is currently the default physics solver used by Roblox. Developers should expect the legacy physics solver to be deprecated or removed at some point in the future.

For more information on the PGS Solver, please see [this article][1].


  [1]: /articles/Building-with-PGS
@returns True if the PGS solver is enabled. */
	PGSIsEnabled(): boolean;
	/** Breaks all joints between the specified `BasePart`s and other `BasePart`s.

This function requires an array of `BasePart`s. Note, joints will not be broken between these `BasePart`s (each other), only between these `BasePart`s and other `BasePart`s not in the array.

This function is used by the Roblox Studio Move tool when the user starts moving a selection. In conjunction with `GetJoinMode` and `JoinToOutsiders` it can be used to retain join functionality when developing custom studio build tools. See the snippets below for an example.

```lua
-- finished moving a selection, make joints
local function finishedMovingParts(parts)
	local joinMode = Plugin:GetJoinMode()
	workspace:JoinToOutsiders(parts, joinMode)
end
```

```lua
-- started moving a selection, break joints
local function startMovingParts(parts)
	workspace:UnjoinFromOutsiders(parts)
end
```


Developers interested in seeing how this function is used in the Roblox Studio should see the [Studio Tools GitHub repository][1].


  [1]: https://github.com/Roblox/Studio-Tools
@param objects An array of `BasePart`s for whom joints are to be broken. */
	UnjoinFromOutsiders(objects: Array<Instance>): void;
}

/** The purpose of the PackageLink object is to link a `DataModel` instance to a corresponding asset in the cloud. This improves flows for collaboration, version control and sharing for models. The PackageLink instance will be a child of the root of the entire package hierarchy.

![PackageLink in Studio Explorer](https://developer.roblox.com/assets/5cbb90ccf8d0b9d818246d6b/PackageLink.jpg)

In this case PackageLink designates `Model` to be the root of the Package hierarchy. 

They not creatable through `scripts`. They can only be added through interaction with Studio and can only be parented to `Instances` that can be published independently of DataModel publish. The PackageLink instance will always be the first child shown in the tree view, regardless of sorting. */
interface PackageLink extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PackageLink";
	/** The id of the asset this package corresponds to.The id of the asset this package corresponds to.

Tags: ReadOnly, NotReplicated */
	readonly PackageId: string;
	/** This property refers to a revision of a specific packageThis property refers to a revision of a specific package

Tags: NotReplicated */
	readonly VersionNumber: number;
}

interface PackageService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PackageService";
}

interface RbxInternalPages extends RbxInternalInstance {
	/** Whether or not the current page is the last page available.Whether or not the current page is the last page available.

Tags: ReadOnly, NotReplicated */
	readonly IsFinished: boolean;
	/** Returns the items on the current page. The keys in the item are determined by the source of this object. */
	GetCurrentPage(): unknown;
	/** Iterates to the next page in the pages object, if possible.Iterates to the next page in the pages object, if possible.

Tags: Yields */
	AdvanceToNextPageAsync(): void;
}
/** An object which is essentially a table of pages, each of which is a sorted list of the key/value pairs.
When each page contains a list of multiple items, this iterator function may be handy:

```lua
function iterPageItems(pages)
	return coroutine.wrap(function()
		local pagenum = 1
		while true do
			for _, item in ipairs(pages:GetCurrentPage()) do
				coroutine.yield(item, pagenum)
			end
			if pages.IsFinished then
				break
			end
			pages:AdvanceToNextPageAsync()
			pagenum = pagenum + 1
		end
	end)
end
```

Which can be used as

```lua
for item, pageNo in iterPageItems(myPageObject) do
	-- look at item. Pages will advance automatically
end
``` */
type Pages = DataStorePages | FriendPages | InventoryPages | StandardPages;

/** A special type of `Pages` object whose pages contain key/value pairs from an `OrderedDataStore`. For this object, `GetCurrentPage()` returns an array of tables, each containing keys named **key** and **value**; these reflect the key/value pair data.

## Code Samples

### OrderedDataStore Basics

This code sample demonstrates usage of an `OrderedDataStore` and pages.
```lua
local DataStoreService = game:GetService("DataStoreService")
local PointsODS = DataStoreService:GetOrderedDataStore("Points") 

local function printTopTenPlayers()
	local isAscending = false
	local pageSize = 10
	local pages = PointsODS:GetSortedAsync(isAscending, pageSize)
	local topTen = pages:GetCurrentPage()

	-- The data in 'topTen' is stored with the index being the index on the page
	-- For each item, 'data.key' is the key in the OrderedDataStore and 'data.value' is the value
	for rank, data in ipairs(topTen) do
		local name = data.key
		local points = data.value
		print(data.key .. " is ranked #" .. rank .. " with " .. data.value .. "points")
	end

	-- Potentially load the next page...
	--pages:AdvanceToNextPageAsync()
end

-- Create some data
PointsODS:SetAsync("Alex", 55)
PointsODS:SetAsync("Charley", 32)
PointsODS:SetAsync("Sydney", 68)

-- Display the top ten players
printTopTenPlayers()
```
 */
interface DataStorePages extends RbxInternalPages {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DataStorePages";
}

/** FriendPages is a special version of the `Pages` returned by `GetFriendsAsync`. The items contained within describe information about a player's friends, and have the following structure:

| Name | Type | Description |
| --- | --- | --- |
| `Id` | int64 | The user ID of the friend |
| `Username` | string | The current username of the friend |
| `IsOnline` | boolean | Whether or not the user is presently online. |


See the code samples for an easy way to iterate over a player's friends.

## Code Samples

### Print Roblox Friends

This code sample loads the `UserId` of the player whose username is provided at the top of the script by using `GetUserIdFromNameAsync`. Then, it gets a `FriendPages` object by calling `GetFriendsAsync` and iterates over each entry using the `iterPageItems` function. The username of each friend is stored in a table, then printed at the end.
```lua
local Players = game:GetService("Players")

local USERNAME = "Shedletsky"

local function iterPageItems(pages)
	return coroutine.wrap(function()
		local pagenum = 1
		while true do
			for _, item in ipairs(pages:GetCurrentPage()) do
				coroutine.yield(item, pagenum)
			end
			if pages.IsFinished then
				break
			end
			pages:AdvanceToNextPageAsync()
			pagenum = pagenum + 1
		end
	end)
end

-- First, get the user ID of the player
local userId = Players:GetUserIdFromNameAsync(USERNAME)
-- Then, get a FriendPages object for their friends
local friendPages = Players:GetFriendsAsync(userId)
-- Iterate over the items in the pages. For FriendPages, these
-- are tables of information about the friend, including Username.
-- Collect each username in a table
local usernames = {}
for item, pageNo in iterPageItems(friendPages) do
	table.insert(usernames, item.Username)
end
-- and finally, print!
print("Friends of " .. USERNAME .. ": " table.concat(usernames, ", "))
```
 */
interface FriendPages extends RbxInternalPages {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FriendPages";
}

/** The InventoryPages class is used in the case of iterating over a specific category in a user's inventory. */
interface InventoryPages extends RbxInternalPages {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "InventoryPages";
}

/** A generic version of the Pages class, which may contain variable data, depending on what method it was returned from.
See the `Pages` class for more information. */
interface StandardPages extends RbxInternalPages {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StandardPages";
}

/** An internal instance used to save/load [solid models](https://developer.roblox.com/articles/3D-Modeling-with-Parts)
 onto the Roblox cloud. */
interface PartOperationAsset extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PartOperationAsset";
}

/** A ParticleEmitter allows for the creation of [particle systems][1]. is a special effect object that emits customizable 2D billboard particles into the world. On Roblox, a particle is a 2D image rendered in the world so that it always always face the camera, much like a `BillboardGui` with a single `ImageLabel` in it.

![A ParticleEmitter with default settings in a Part with default settings](https://developer.roblox.com/assets/blt7bc5555538e06faa/ParticleEmitter.png)

ParticleEmitter must be parented to a `BasePart` (such as a `Part`) or an `Attachment` within such a part. Particles spawn randomly in the **bounding box** of its parent part (for attachments, this is a single point). Particles from a single emitter will render so long as this condition is met; setting a ParticleEmitter's `Parent` to nil will remove all particles instantly, like how `Clear` works. If an emitter is `Enabled` and has a nonzero `Rate`, it will emit particles on its own. Finer control on the number of particles can be accomplished using `Emit`.

Roblox provides several pre-made particle effect objects - `Fire`, `Smoke` and `Sparkles`. They behave similarly to a ParticleEmitter, but they are not as customizable. They also lack certain particle-controlling methods: `Emit` and `Clear`.  An `Explosion` also uses particles, but provides little-to-no control with regards to how the effect looks.

## How to Insert a ParticleEmitter

 In Studio, a ParticleEmitter can be inserted in several ways:

  - Using the "Effects" drop-down (Model tab)
  - From the Advanced Objects window (In the model tab, or CTRL+I)
  - The add menu within the Explorer window
  - Using the Command bar, run `Instance.new("ParticleEmitter", workspace)`
  - If you find you are inserting ParticleEmitters often, you can add a ParticleEmitter button to the Quick Access toolbar

![Drop-down Efffects menu for inserting a ParticleEmitter](https://developer.roblox.com/assets/blt14277a5a3c807db6/ParticleEmitter_Insertion.png)![AdvancedObjects window insertion](https://developer.roblox.comundefined)![Explorer window insertion](https://developer.roblox.comundefined)


  [1]: https://en.wikipedia.org/wiki/Particle_system
  
  
  [4]: https://images.contentstack.io/v3/assets/blt309cc8bfb280dcec/blt885ce1cfde491cd3/5b0b5148dc1dd5cd0f3c9cb5/ParticleEmitter_Insertion2.png
  [5]: https://images.contentstack.io/v3/assets/blt309cc8bfb280dcec/blt0e3ad5ad5826a269/5b0b51557f08d31910651bd7/ParticleEmitter_Insertion3.png

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
interface ParticleEmitter extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ParticleEmitter";
	/** The Acceleration property determines how particles `Speed` changes over the particle's lifetime. It is defined using a `Vector3` to determine the acceleration on the global X/Y/Z axes. It is measured in studs per second squared. When changed, this property affects all particles emit by the emitter, both current and future particles.

Pictured below are two default ParticleEmitters. The foreground (right) emitter has an Acceleration on the positive-X axis, causing the path of the particles to bend in that direction.
![An image of two default ParticleEmitters, wherein the foreground emitter has a +X Acceleration](https://developer.roblox.com/assets/bltaeb3393ea3390868/ParticleEmitter_Acceleration.png)

Acceleration will slow particles down if the vector points in the opposite `EmissionDirection` in which particles are emitted. Otherwise, it will speed them up. You can use `Drag` to slow particles down no matter what direction they travel.

Acceleration is most often used to apply a gravity effect to particles (try a value of (0, -3, 0) for this). You can also use small values on the X/Z axes to make it look like particles are being blown away by wind. If you emit a bubble particle downwards, you could use an acceleration of (0, 5, 0) to cause the bubbles to decelerate and then float back upwards.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	Acceleration: Vector3;
	/** The Color property determines the color of all particles active in an emitter's system. The color is applied to the `Texture` when rendering, and uses the texture alpha along with the `Transparency`. If a particle has a `LightEmission` of greater than 0, darker colors will make particles appear more transparent. Below, two default `ParticleEmitter` are pictured, except the right emitter uses a Color from yellow to cyan.

![Two default ParticleEmitters, except the right has a Color from Yellow to Cyan](https://developer.roblox.com/assets/blt07a957ff7394b365/ParticleEmitter_Color.png)

Note that the default `Lifetime` is 5 to 10 seconds, so some particles next to each other have small variations in color due to the variations in individual particle lifetime.

A particle's present color is determined by linearly interpolating on this ColorSequence using the particle's age and the particle's total lifetime. For example, if a particle spawned 2 seconds ago and has a 4 second lifetime, the color will be whatever is 50% of the way through the `ColorSequence`.

Changing this property applies changes to all particles present in the system. This is because the color of a particle is determined using its present lifetime and this ColorSequence (the ColorSequence when the particle was emit is not stored on a per-particle basis).

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	Color: ColorSequence;
	/** The Drag property determines the rate in seconds at which individual particles will lose half their speed via exponential decay. Pictured below are two identical default ParticleEmitters, except that the right has a Drag value of 0.25.

![Animation of drag on a ParticleEmitter](https://developer.roblox.com/assets/blt9a58d2b5746274de/ParticleEmitter_Drag.gif)

Drag is applied by scaling the expected velocity (from `Speed` and any velocity inherited from the parent from `VelocityInheritance`) by the following formula: `2 ^ (elapsedTime * -drag)`, where `elapsedTime` is the time since the particle was emit. Consequently, setting Drag to a negative value will cause particles' velocities to grow exponentially.

Warning: if Drag is set to a sufficiently negative value, this can cause all particles emit by the emitter to completely disappear. Be careful when setting this property lower than -100.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	Drag: number;
	/** The EmissionDirection property determines the face (`NormalId`) of the parent object towards which particles will be emit. By default, this is the top (+Y) direction. A negative `Speed` will emit in the opposite direction. `SpreadAngle` will further vary the emission direction. If a `ParticleEmitter` is added to an `Attachment`, which has a direction, the the Attachment itself can be rotated (`Orientation`) instead of using this property. Below are pictured two ParticleEmitters which are otherwise the same, except the left has an EmissionDirection of Top (+Y, default) and the right uses Front (-Z).

![Two identical ParticleEmitters except with differing EmissionDirection (left is Top, right is Front)](https://developer.roblox.com/assets/blt529991a1b0fa24f4/ParticleEmitter_EmissionDirection.png)

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	EmissionDirection: Enum.NormalId;
	/** The Enabled property determines whether a `ParticleEmitter` should emit partciles according to its `Rate`. Setting Enabled to false will halt further particles from spawning; any existing particles will remain until they expire. This property is useful when you have a pre-made particle effect that you want to remain disabled until you need it to emit particles.

If you want no particles to render, you should call `Clear` to clear any existing particles. You can use `Emit` on disabled `ParticleEmitter`s and they will still emit and render particles.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	Enabled: boolean;
	/** The Lifetime property defines the maximum and minimum ages a newly emit particle will. When a particle is emit, a random lifetime is chosen uniformly. Lifetimes are stored on a per-particle basis, so if this value is changed, existing particles will stay "alive" until their randomly chosen lifetime is lived. The bounds for this property should be in the range [0, 20]. By default, `ParticleEmitter`s will have a lifetime of 5 to 10 seconds. A lifetime of 0 will prevent particles from being emit in the first place.

it is important to pick a sensible Lifetime and `Rate` so that you don't have too many particles being rendered at once. Long lifetimes and high emission rates are a quick way to cause performance issues. If you need many particles, pick a balance of lifetime and rate. To instantly remove any presently emit particles (perhaps ones with absurdly long lifetimes), you can call `Clear`.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	Lifetime: NumberRange;
	/** The LightEmission property determines the blending of the `Texture`'s colors with the colors behind them. It should be set on the range [0, 1]. A value of 0 uses normal blending modes, and a value of 1 will use additive blending. The value of the additive blending is determined by this property. When changed, this property instantly affects all particles owned by the emitter, both current and future particles.

Pictured below are two default ParticleEmitters. The right one has its LightEmission set to 1, so the particles appear brighter due to the additive blending when they overlap.
![Two default ParticleEmitters; the right one has a LightEmission of 1](https://developer.roblox.com/assets/bltfaa542eee7781432/ParticleEmitter_LightEmission.png)

When set to 1, only additive blending is used. As such, choosing a suitable `Texture` is necessary. Below is an example texture that is suitable for such a ParticleEmitter.
![A gray-scale image suitable as a particle Texture](https://developer.roblox.com/assets/bltf793b94e42b0b6bf/aura.png)

This property should not be confused with `LightInfluence`, which determines how particles are affected by environment light. This property does not cause particles to light the environment around them. To do that, consider using a `PointLight`.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	LightEmission: number;
	/** The LightInfluence property determines how much environment light affects the color of individual particles when they are rendered. It must be in the range [0, 1]; behavior of values outside of this range are not defined. At 0, particles are not influenced by light at all (they retain full brightness), and at 1 particles are fully influenced by light (in complete darkness, particles will be black).

Pictured below are three default ParticleEmitters [at night][1] with varing LightInfluence. There is a `PointLight` with sufficient `Brightness` and `Range` to light the particles near to their parent parts. Take note of how each particle is affected by the lack of light close to the end of their lifetime.

![Three default ParticleEmitters with varying LightInfluence values](https://developer.roblox.com/assets/blt0978dec6faf6d7ae/ParticleEmitter_LightInfluence.png)

By default, this value is 1 if inserted with Studio tools. If inserted using `Instance.new`, it is 0.

  [1]: https://www.youtube.com/watch?v=bLIVeQgS_pI

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	LightInfluence: number;
	/** The LocekdToPart property determines if particles will "stick" to the emission source (the `Attachment` or `BasePart` to which the `ParticleEmitter` is parented).

Below is an animation of two `Part`s being moved simultaneously in Studio. Inside each is a default `ParticleEmitter`; the background/left emitter has LockedToPart enabled so the column of particles moves as the part is moved. Contrast with the foreground/right emitter particles which stay in their world position.
![Moving two parts with default ParticleEmitters, the background emitter has LockedToPart enabled](https://developer.roblox.com/assets/bltdf5045209fff8b32/ParticleEmitter_LockedToPart.gif)

Also consider using the `VelocityInheritance` property set to 1, which may be more appropriate for some effects.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	LockedToPart: boolean;
	/** The Rate property determines how many particles are `Emit` emit per second while the `ParticleEmitter` is `Enabled`. It is the inverse of frequency - a Rate of 5 means that a particle will be emit every `5 = 0.2` seconds. When changed, this property will have no affect on any already emit particles.

it is important to pick a sensible `Lifetime` and Rate so that you don't have too many particles being rendered at once. Long lifetimes and high emission rates are a quick way to cause performance issues. If you need many particles, pick a balance of lifetime and rate. To instantly remove any presently emit particles (perhaps ones with absurdly long lifetimes), you can call `Clear`.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	Rate: number;
	/** The RotSpeed property determines a random range of angular speeds that newly emit particles will have. A random angular speed is chosen upon emission, so changing this property will not affect already emit particles. This property, along with `Rotation` affect the angle of the rendered particle image. This property is a `NumberRange` measured in degrees per second.

Below is an animation of two default `ParticleEmitter`s. The right has a nonzero RotSpeed, so its particles rotate as they move through the world.
![Two default ParticleEmitters; the right emitter has a RotSpeed applied](https://developer.roblox.com/assets/bltfe2427c2a9f0f3ad/ParticleEmitter_RotSpeed.gif)

Using a spiral as a `Texture` like the one below, you can create some quite interesting particle effects:
![A swirl texture](https://developer.roblox.com/assets/bltc50865c165e13d07/ParticleEmitter_RotSpeed2_swirl.gif)![A portal effect using RotSpeed and a Swirl texture](https://developer.roblox.comundefined)

Particles with very high angular speeds can appear to rotate slower or not at all - this is because the angle of rotation is synchronized with the software render speed. In other words, if the particle is rotating at exactly 360 degrees every frame, there will be no apparent change in rotation.


  
  
  [3]: https://images.contentstack.io/v3/assets/blt309cc8bfb280dcec/blt6c03c8e2536b2634/5b0b84d09a16a6df0e4973b5/ParticleEmitter_RotSpeed2.gif

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	RotSpeed: NumberRange;
	/** The Rotation property determines the angle at which new particles are emit. It is a `NumberRange` measured in degrees. Positive values are in the clockwise direction. This property is often set to [0, 360] to provide a completely random rotation to new particles. `RotSpeed` also influences the rotation of a particle over its lifetime. Finally, this property is useful for correcting any `Texture`s that aren't at the desired orientation.

Pictured below are two default ParticleEmitters, except that the right has a Rotation of 22.5. Note how the particles on the left are straight up, and the right are tilted slightly.

![Two default ParticleEmitters with varying Rotations](https://developer.roblox.com/assets/bltb0b7b9f3f01688b2/ParticleEmitter_Rotation.png)

Changes to this value only affect new particles; existing particles will maintain the rotation at which they were originally emitted.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	Rotation: NumberRange;
	/** The Size property determines the world size in studs of all active particles over their individual lifetimes. This property represents the dimensions of the square `Texture` for each particle. It is a `NumberSequence` that works similar to `Transparency` and `Color`.

Below is an animation of two default `ParticleEmitter` where the right one has a Size of 0 to 2. Note how the particles grow over their lifetime.
![Animation of two default ParticleEmitters; the right one has a Size of 0 to 2](https://developer.roblox.com/assets/blt908c9ca9b5bddace/ParticleEmitter_Size.gif)

A particle's present size is determined by linearly interpolating on this NumberSequence using the particle's age and the particle's total lifetime. For example, if a particle spawned 2 seconds ago and has a 4 second lifetime, the size will be whatever is 50% of the way through the `NumberSequence`. For any `NumberSequenceKeypoint` with a nonzero envelop value, a random value in the envelop range is chosen for each keypoint for each particle when it spawns.

Changing this property applies changes to all particles present in the system. This is because the size of a particle is determined using its present lifetime and this NumberSequence (the Size at the time the particle was emit is not stored on a per-particle basis).

## Design Note

When designing particle effects, size is probably the most important of all properties. Too large or too subtle can ruin a particle effect! The first thing you should do is decide how you want particles to enter and exit view - fade in/out, or grow/shrink from size 0? The choice is yours - start with a size NumberSequence from 0 to 3 or the reverse and go from there.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	Size: NumberSequence;
	/** The Speed property determines the random range of velocities that newly emit particles may have. It is measured in studs per second using a `NumberRange`. The velocity is chosen upon emission, and is applied in the `EmissionDirection`. Negative speed values will cause particles to travel in reverse.

Below is an animation of two default `ParticleEmitter`s; the left has the default Speed of 5. The right one has the Speed range set to [20, 20], so its particles emit at a constant speed of 20.
![Two default ParticleEmitters, the right has a speed of 20.](https://developer.roblox.com/assets/blte13fc189c250bd2b/ParticleEmitter_Speed.gif)

`VelocityInheritance`, `Acceleration` and `Drag` will affect a particle's speed over its lifetime. Changing Speed will not affect already existing particles - they will retain whatever speed they have already.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	Speed: NumberRange;
	/** The SpreadAngle property determines the random angles that a particle may be emit. On emission, a random angle is selected uniformly using the range defined by SpreadAngle. For example, if the `EmissionDirection` is Top (+Y), then this `Vector2` describes the size of the random angle spread on the X/Z axes, in degrees. The particle is given a velocity based on the `Speed` in the chosen direction.

Below is an animation of two default ParticleEmitters. The foreground (closer) emitter has one of its SpreadAngle axes set to 90 degrees, so particles are emit randomly in an arc.
![Two default ParticleEmitters. The foreground (closer) emitter has one axis of SpreadAngle set to 90 degrees](https://developer.roblox.com/assets/blt05b793010052f4b7/ParticleEmitter_SpreadAngle.gif)

Setting one axis to 360 will cause particles to emit in all direction in a **circle**. Setting both to 360 will cause particles to emit in all directions in a **sphere**.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	SpreadAngle: Vector2;
	/** The Texture property determines the image rendered on particle billboards. The rendered image is influenced by `Color`, `Transparency`, `LightInfluence`, and `LightEmission`. Transparent textures work best for particles

Pictured below are two default ParticleEmitters, but the right one uses the Robux icon as a texture.

![Two default ParticleEmitters, except the right one uses the Robux icon](https://developer.roblox.com/assets/blt15e439cb32a655c1/ParticleEmitter_Texture.png)

## Example Textures

The following texture is a transparent PNG image that works well as a Texture for a `ParticleEmitter`. Try uploading it as a decal to your account and using it in a ParticleEmitter's texture.
![Pixel art of a gold coin](https://developer.roblox.com/assets/bltfe72f664112679bb/coin_01.png)

Below is an opaque gray-scale Texture that works nicely for particles with `LightEmission` set to 1.
![An example particle texture](https://developer.roblox.com/assets/bltf793b94e42b0b6bf/aura.png)

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	Texture: string;
	/** The Transparency property determines the transparency in studs of all active particles over their individual lifetimes. It works similar to `Size` in how it affects particles over time. In terms of rendering, it works like the `Transparency` of a part.

Pictured below are two default `ParticleEmitter`s. The right emitter has a Transparency set to a `NumberSequence` that interpolates from 0 to 1.
![Two default ParticleEmitters; the right emitter Transparency fades over the lifetime of the particles](https://developer.roblox.com/assets/blt7d318803556982ca/ParticleEmitter_Transparency.png)

A particle’s present transparency is determined by linearly interpolating on this NumberSequence using the particle’s age and the particle’s total lifetime. For example, if a particle spawned 2 seconds ago and has a 4 second lifetime, the transparency will be whatever is 50% of the way through the `NumberSequence`. For any `NumberSequenceKeypoint` with a nonzero envelop value, a random value in the envelop range is chosen for each keypoint for each particle when it spawns.

Changing this property applies changes to all particles present in the system. This is because the transparency of a particle is determined using its present lifetime and this `NumberSequence` (the Transparency at the time the particle was emit is not stored on a per-particle basis).

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	Transparency: NumberSequence;
	/** The VelocityInheritance property determines how much of the parent part's `Velocity` is inherited by particles when they are emitted. A value of 0 means that no velocity is inherited, and a value of 1 means the particle will have the exact same speed as the parent `BasePart`.

Below is an animation of a `Part` moving back and forth. As it changes direction, the VelocityInheritance will toggle between 0 and 1. Note that when it is 1, the particles move with the part.
![A part moving back and forth with VelocityInheritance toggling from 0 to 1](https://developer.roblox.com/assets/blt6b88061023429950/ParticleEmitter_VelocityInheritance.gif)

When used in conjunction with `Drag`, a particle emitter can make appear to be "shedding" particles from a moving part.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	VelocityInheritance: number;
	/** The ZOffset property determines the forward-backward (Z) render position of particles, in studs. they render at a modified `Size` such that this property will not affect the screen size of particles. When changed, this property will affects all particles, both current and future particles. Note that this property accepts fractional values; it is not like `ZIndex` (an integer)

Pictured below are three default ParticleEmitters with varying ZOffset values. The center is default, the left has +2 and the right has -2. Note how all the particles have the same apparent screen size.
![Three default ParticleEmitters with varying ZOffset values](https://developer.roblox.com/assets/blt216bd741511f3108/ParticleEmitter_ZOffset.png)

A practical use of ZOffset is for `ParticleEmitters` placed in players' characters: use it to define if particles should appear in front of or behind the character (use a value of +/- 2).

![Two identical Roblox characters with ParticleEmitters in their head, with varying ZOffset values](https://developer.roblox.com/assets/blt8b9262a841414c12/ParticleEmitter_ZOffset2.png)

Positive values will move particles closer to the camera, and negative values move particles away. Sufficiently negative values can cause particles to render inside or behind the parent part.

## Code Samples

### Creating a Particle Emitter from Scratch

This rather lengthy code sample shows how every property of a `ParticleEmitter` can be set, including `NumberRange`, `NumberSequence` and `ColorSequence` properties. Below is how the ParticleEmitter should after every property is set. Try playing around with the different properties to customize how the effect looks!

![The final product](https://developer.roblox.com/assets/blt843cbffbfc114ea4/ParticleEmitter_FromScratch.gif)
```lua
local emitter = Instance.new("ParticleEmitter")
-- Number of particles = Rate * Lifetime
emitter.Rate = 5 -- Particles per second
emitter.Lifetime = NumberRange.new(1,1) -- How long the particles should be alive (min, max)
emitter.Enabled = true 

-- Visual properties
emitter.Texture = "rbxassetid://1266170131" -- A transparent image of a white ring
-- For Color, build a ColorSequence using ColorSequenceKeypoint
local colorKeypoints = {
	-- API: ColorSequenceKeypoint.new(time, color)
	ColorSequenceKeypoint.new( 0, Color3.new(1, 1, 1)),  -- At t=0, White
	ColorSequenceKeypoint.new(.5, Color3.new(1, .5, 0)), -- At t=.5, Orange
	ColorSequenceKeypoint.new( 1, Color3.new(1, 0, 0))   -- At t=1, Red
}
emitter.Color = ColorSequence.new(colorKeypoints)
local numberKeypoints = {
	-- API: NumberSequenceKeypoint.new(time, size, envelop)
	NumberSequenceKeypoint.new( 0, 1);    -- At t=0, fully transparent
	NumberSequenceKeypoint.new(.1, 0);    -- At t=.1, fully opaque
	NumberSequenceKeypoint.new(.5, .25);  -- At t=.5, mostly opaque
	NumberSequenceKeypoint.new( 1, 1);    -- At t=1, fully transparent
}
emitter.Transparency = NumberSequence.new(numberKeypoints)
emitter.LightEmission = 1 -- When particles overlap, multiply their color to be brighter
emitter.LightInfluence = 0 -- Don't be affected by world lighting

-- Speed properties
emitter.EmissionDirection = Enum.NormalId.Front -- Emit forwards
emitter.Speed = NumberRange.new(0, 0) -- Speed of zero
emitter.Drag = 0 -- Apply no drag to particle motion
emitter.VelocitySpread = NumberRange.new(0, 0)
emitter.VelocityInheritance = 0 -- Don't inherit parent velocity
emitter.Acceleration = Vector3.new(0, 0, 0)
emitter.LockedToPart = false -- Don't lock the particles to the parent 
emitter.SpreadAngle = Vector2.new(0,0) -- No spread angle on either axis

-- Simulation properties
local numberKeypoints2 = {
	NumberSequenceKeypoint.new(0, 0);  -- At t=0, size of 0
	NumberSequenceKeypoint.new(1, 10); -- At t=1, size of 10
}
emitter.Size = NumberSequence.new(numberKeypoints2)
emitter.ZOffset = -1 -- Render slightly behind the actual position
emitter.Rotation = NumberRange.new(0, 360) -- Start at random rotation
emitter.RotSpeed = NumberRange.new(0) -- Do not rotate during simulation

-- Create an attachment so particles emit from the exact same spot (concentric rings)
local attachment = Instance.new("Attachment", script.Parent)
attachment.Position = Vector3.new(0, 5, 0) -- Move the attachment upwards a little
emitter.Parent = attachment

```
 */
	ZOffset: number;
	/** The Clear method will instantly destroy any existing particles that have been emit by the `ParticleEmitter` via its natural emission (nonzero `Rate` on an `Enabled` emitter) or via `Emit`. It is not possible to clear individual particles - all are deleted at once.

Sometimes it is desirable to clear particles before teleporting a character so that there are no lingering effects that might follow due to `LockedToPart`.

## Code Samples

### ParticleEmitter Burst

This code sample causes a `ParticleEmitter` to `Emit` particles in bursts of 10 every 2 seconds. It `Clear`s any existing particles before doing so.
```lua
local emitter = script.Parent
while true do
	emitter:Clear()
	emitter:Emit(10)
	wait(2)
end
```
 */
	Clear(): void;
	/** The Emit method will cause the `ParticleEmitter` to emit the given number of particles similar to how `Rate` does on `Enalbed` emitters. Be warned - this always emits exactly the number of particles even if Roblox' graphics settings are lower. Emitting too many particles can cause performance issues on lower-end hardware.

To clear any emit particles, use `Clear`.

## Code Samples

### Emit Particles Over Distance

This code sample causes a parent `ParticleEmitter` to `Emit` particles based on how far the parent `BasePart` moves.
```lua
local RunService = game:GetService("RunService")
local emitter = script.Parent
local part = emitter.Parent

local PARTICLES_PER_STUD = 3

local lastPosition = part.Position
local distance = 0
local function onStep()
	local displacement = part.Position - lastPosition
	distance = distance + displacement.magnitude
	
	local n = math.floor(distance * PARTICLES_PER_STUD)
	emitter:Emit(n)
	distance = distance - n / PARTICLES_PER_STUD
	lastPosition = part.Position
end

RunService.Stepped:Connect(onStep)
emitter.Enabled = false

```

### ParticleEmitter Burst

This code sample causes a `ParticleEmitter` to `Emit` particles in bursts of 10 every 2 seconds. It `Clear`s any existing particles before doing so.
```lua
local emitter = script.Parent
while true do
	emitter:Clear()
	emitter:Emit(10)
	wait(2)
end
```

@param particleCount The number of particles to emit */
	Emit(particleCount?: number): void;
}

/** **Path** objects store the result of paths created by `PathfindingService:CreatePath()`.

Once a path object is created, you can call `Path:ComputeAsync()` with a starting point and ending point. This will attempt to compute a valid path for a character to move along, based on default or custom parameters passed to `CreatePath()`. If `ComputeAsync()` successfully finds a path, the `Path` object will have a `Status` value of `Enum.PathStatus.Success`. Otherwise the status will be `Enum.PathStatus.NoPath` which can occur if there are obstacles between the two points (and no way around) or if the points are inside of solid objects.

In addition to `ComputeAsync()`, `Path` objects have the `GetWaypoints()` method which returns a list of waypoints representing the points a character should follow in sequence to get from the beginning to the end of the path.

Finally, `Path` objects can be **connected** to the `Path.Blocked` event. This event will fire if, at any time during the path's existence, the path is blocked. Note that this can occur **behind** a character moving along the path, not just in front of it.

See the `Pathfinding` guide for details and examples on using pathfinding in Roblox. */
interface Path extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Path";
	/** The success of the generated `Path`. */
	readonly Status: Enum.PathStatus;
	/** This function returns an array of all the `PathWaypoints` in a `Path`, as computed by `ComputeAsync`. 

Each waypoint in the array specifies a `Vector3` position and `action` to take when this PathWaypoint is reached. The array is arranged in the order of waypoints from the path start to path end.

If a path could not be computed, this function will return an empty array.

## Code Samples

### Get Path Waypoints

The example below demonstrates how to create a `Path` and it's `PathWaypoints` using the `PathService`. 

It tries to `ComputeAsyc` a path between two `Vector3` positions, from pathStart to pathEnd. If a path is successfully created, indicated by it's `PathStatus`, the code block gets an array of its waypoints using `GetWaypoints`. Then, it loops through the array and prints each waypoint's position.
```lua
local PathfindingService = game:GetService("PathfindingService")

-- Create path object
local path = PathfindingService:CreatePath()

local pathStart = Vector3.new(0, 1, 0)
local pathEnd = Vector3.new(100, 1, 25)

-- Compute and check the path
path:ComputeAsync(pathStart, pathEnd)

if path.Status == Enum.PathStatus.Success then
	-- Get path waypoints
	local waypoints = path:GetWaypoints()
	-- Loop through waypoints
	for _, waypoint in pairs(waypoints) do
		-- Output position of waypoint
		print(waypoint.Position)
	end
end
```

@returns An array of `DataType/PathWaypoint|PathWaypoints` ordered from path start to path end */
	GetWaypoints(): Array<PathWaypoint>;
	/** This function checks if a path is blocked starting at the waypoint indicated by **start**. 

It returns the first waypoint of occlusion if blocked, -1 if not. it returns an error if **start** is less than 0 or greater than the number of waypoints in the `Path`. */
	CheckOcclusionAsync(start: number): number;

	ComputeAsync(start: Vector3, finish: Vector3): void;

	readonly Blocked: RBXScriptSignal<(blockedWaypointIdx: number) => void>;
}

/** **PathfindingService** is used to find paths between two points. These paths make sure that characters can move between the points without running into walls or other obstacles. Paths can be used for both player-controlled characters and non-player characters.

This service has one function, `CreatePath()`, which creates a `Path` object based on various parameters.

See the `Pathfinding` guide for details and examples on using pathfinding in Roblox.

## Navigation Mesh

**PathfindingService** generates a "navigation mesh" over all parts in a place while the game is running. Any path that is created with the service will stay within the mesh. If the geometry of the place changes — for example, if a part is created or a part moves — the navigation mesh will be recalculated.

To see the navigation mesh for a place:

1. Open the place in Studio.
2. Navigate to **File** → **Settings...** .
3. In the **Studio** tab, under **Visualization**, toggle on the **Show Navigation Mesh** setting. The mesh will then show up in the 3D view.

The purple areas show where a character can walk, while the non-colored
 areas are considered blocked. Studio also displays arrows on top of the mesh which show where a character would have to **jump** to reach one part of the mesh from another.

![](https://developer.roblox.com/assets/5ba161118c2893307fc122d0/NavigationMesh.jpg) */
interface PathfindingService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PathfindingService";
	/** Creates a `Path` object based on various agent parameters (see&nbsp;below).

## Agent Parameters| Key | Type | Default | Description |
| --- | --- | --- | --- |
| **AgentRadius** | integer | 2 | Humanoid radius. Used to determine the minimum separation from obstacles. |
| **AgentHeight** | integer | 5 | Humanoid height. Empty space smaller than this value will be marked as non-traversable, for instance the space under stairs. |
| **AgentCanJump** | boolean | true | Sets whether off-mesh |
 links for jumping are allowed.
@param agentParameters Lua table which lets you fine-tune the path for the size of the **agent** (the humanoid that will move along the path). See <a href="#agent-params">Agent&nbsp;Parameters</a>. */
	CreatePath(agentParameters?: AgentParameters): Path;
	/** This function is used to find a `Path` between two provided points. This path uses the navigation grid created by `PathfindingService` and makes sure that the path can be followed by a regular-sized
 Roblox character.

This function returns a `Path` object which contains the coordinates of the path. If no path is found between the two points, this function will still return a `Path` object, but that object's `Status` will be `Enum.PathStatus.NoPath`.

To get the waypoints of a `Path` object, you can use the `GetWaypoints` function.
@param start Path start coordinates.
@param finish Path finish coordinates.
@returns A `Path` object */
	FindPathAsync(start: Vector3, finish: Vector3): Path;
}

/** An internal service, used for physics networking. This service is not accessible to developers. */
interface PhysicsPacketCache extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PhysicsPacketCache";
}

/** PhysicsService is a game service that has functions for working with **collision groups**, which define a set of parts that may or may not collide with parts assigned to other collision groups. Assign a part to a collision group using `SetPartCollisionGroup`. Collision groups and their relationships are saved to and loaded from file.

## Network Replication
Creating, deleting and modifying collision relationships between collision groups is limited to server-side `Script`s. However, client-side `LocalScript`s may only set individual parts' associated collision group. */
interface PhysicsService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PhysicsService";
	/** Returns whether the specified part is in the specified collision group.
This function will throw a runtime error in the following circumstances:

* The specified group does not exist.
* The specified part is not a BasePart.Returns whether the part is in the collision group. */
	CollisionGroupContainsPart(name: string, part: BasePart): boolean;
	CollisionGroupContainsPart(name: string, part: BasePart): boolean;
	/** Sets the collision status between two groups.
This function will throw an error if either of the groups do not exist.Sets the collision status between two groups. */
	CollisionGroupSetCollidable(name1: string, name2: string, collidable: boolean): void;
	/** Returns whether the two specified collision groups will collide.
This function will throw an error if either of the groups do not exist.Returns whether the two groups will collide. */
	CollisionGroupsAreCollidable(name1: string, name2: string): boolean;
	/** Creates a new collision group with the given name, and returns the id of the created group.

## Code Samples

### PhysicsService:GetCollisionGroupId1


```lua
local physicsService = game:GetService("PhysicsService")

-- returns a valid group id (int) or nil
function getGroupId(name)
	-- GetCollisionGroupId will throw if it does not exist
	local ok, groupId = pcall(physicsService.GetCollisionGroupId, physicsService, name)
	return ok and groupId or nil
end

-- returns a valid group id (int) or nil
function getOrCreateGroupId(name)
	local ok, groupId = pcall(physicsService.GetCollisionGroupId, physicsService, name)
	if not ok then
		-- Create may fail if we have hit the maximum of 32 different groups
		ok, groupId = pcall(physicsService.CreateCollisionGroup, physicsService, name)
	end
	return ok and groupId or nil
end
	
print(getGroupId("Test")) -- prints nil
print(getOrCreateGroupId("Test")) -- prints 1
print(getGroupId("Test")) -- prints 1
```
 */
	CreateCollisionGroup(name: string): number;
	/** The GetCollisionGroupId function returns the id of the collision group with the specified name.

This function will throw an error if no group with the given name exists.

## Code Samples

### PhysicsService:GetCollisionGroupId1


```lua
local physicsService = game:GetService("PhysicsService")

-- returns a valid group id (int) or nil
function getGroupId(name)
	-- GetCollisionGroupId will throw if it does not exist
	local ok, groupId = pcall(physicsService.GetCollisionGroupId, physicsService, name)
	return ok and groupId or nil
end

-- returns a valid group id (int) or nil
function getOrCreateGroupId(name)
	local ok, groupId = pcall(physicsService.GetCollisionGroupId, physicsService, name)
	if not ok then
		-- Create may fail if we have hit the maximum of 32 different groups
		ok, groupId = pcall(physicsService.CreateCollisionGroup, physicsService, name)
	end
	return ok and groupId or nil
end
	
print(getGroupId("Test")) -- prints nil
print(getOrCreateGroupId("Test")) -- prints 1
print(getGroupId("Test")) -- prints 1
```

@param name The name of the collision group being retrieved.
@returns The id of the retrieved collision group, or nil if no such group exists. */
	GetCollisionGroupId(name: string): number;
	/** Returns the name of the collision group with the corresponding id. This function will return nil if the group with the corresponding id has not been named.
This function will throw an error if the id is not in the range of 0 */
	GetCollisionGroupName(name: number): string;
	/** Returns a table with info on all of the place's collision groups. Each value in this table is itself a table and contains 3 members:

| Member | Type | Description |
| --- | --- | --- |
| **id** | integer | The ID of the group |
| **mask** | integer | The mask of the group (for internal use) |
| **name** | string | The name of the group | */
	GetCollisionGroups(): Array<CollisionGroupInfo>;
	/** Returns the maximum number of collision groups the engine supports. This value is currently 32. */
	GetMaxCollisionGroups(): number;
	/** Removes the collision group with the given name. If an invalid name is provided the function will not do anything, although if the reserved name “Default” is provided then the function will throw an error.
If there are any parts in the collision group when it is removed, these parts will still maintain the same collision group id. The physical behavior of parts in a removed group is undefined, so it is recommended to move any parts in a removed group to another group (such as the Default group).

This function will throw a runtime error in the following circumstances:

* The name "Default" is provided.
* The function is called from a client.Removes the collision group with the given name. */
	RemoveCollisionGroup(name: string): void;
	/** Renames the specified collision group. The first argument of this function is the name of the group to rename, the second argument is the new name for the group. If the specified group does not exist, then this function will not do anything.
The naming conventions for the new name follow the same rules as if the group was being created with `CreateCollisionGroup`. The new name cannot be "Default", and it cannot contain the special characters "/" or "^".

This function will throw a runtime error in the following circumstances:

* Invalid or empty name provided for either argument.
* The function is called from a client.Renames specified collision group. */
	RenameCollisionGroup(from: string, to: string): void;
	/** The SetPartCollisionGroup function sets the collision group of the specified part to the group with the specified name. 

This function is equivalent to setting the `CollisionGroupId`, although this function is the recommended method of configuring a part’s collision group.

Note that for a part to respect its collision filter setting it must have its `CanCollide` property set to true.

This function will throw a runtime error in the following circumstances:

 * The part parameter is not a `BasePart` instance.
 * The specified group does not exist.

## Code Samples

### PhysicsService:GetCollisionGroupId1


```lua
local physicsService = game:GetService("PhysicsService")

-- returns a valid group id (int) or nil
function getGroupId(name)
	-- GetCollisionGroupId will throw if it does not exist
	local ok, groupId = pcall(physicsService.GetCollisionGroupId, physicsService, name)
	return ok and groupId or nil
end

-- returns a valid group id (int) or nil
function getOrCreateGroupId(name)
	local ok, groupId = pcall(physicsService.GetCollisionGroupId, physicsService, name)
	if not ok then
		-- Create may fail if we have hit the maximum of 32 different groups
		ok, groupId = pcall(physicsService.CreateCollisionGroup, physicsService, name)
	end
	return ok and groupId or nil
end
	
print(getGroupId("Test")) -- prints nil
print(getOrCreateGroupId("Test")) -- prints 1
print(getGroupId("Test")) -- prints 1
```

@param part The part being set.
@param name The name of collision group that the part's collision group is being set to.
@returns No return. */
	SetPartCollisionGroup(part: BasePart, name: string): void;
}

/** The PhysicsSettings is a singleton class, which lets developers view  debugging features in Roblox's physics engine.
It can be found under the Physics tab in Roblox Studio's settings menu. */
interface PhysicsSettings extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PhysicsSettings";
	/** When set to true, physically simulated objects will stop being simulated if they have little to no motion for a set period of time. */
	AllowSleep: boolean;
	/** When set to true, parts that are `Anchored` will show a gray surface outline on the surface of the part's bounding box that is currently facing the ground. */
	AreAnchorsShown: boolean;
	/** When set to true, each physics assembly is assigned a unique color and the `Part` associated with the assembly are outlined with the color. Parts that are attached together by `JointInstance` will share the same color. */
	AreAssembliesShown: boolean;
	/** When set to true, parts that are actively being physically simulated will have a red outline. */
	AreAwakePartsHighlighted: boolean;
	/** When set to true, `Part` will be outlined with a specific color, depending on the state of its root simulation body.
## Body Types

| Color | Body Type | Description |
|  | Real Time Body | Physics Body that is always simulated in real time, and is never throttled. Used for Humanoids. |
|  | Free Fall Body | Physics Body that is freely moving with no physical contact. |
|  | Joint Body | Physics Body that is being influenced by a physically simulated joint, such as a Motor or a Hinge. |
|  | Contact Body | Physics Body that is in contact with another physics body. |
|  | Symmetric Contact Body | Physics Body that is experiencing a torquing force, while in contact with another body. |
|  | Vertical Contact Body | Physics Body that is moving very little along the Y plane, while in contact with another body. | */
	AreBodyTypesShown: boolean;
	/** When set to true, each contact island will render `SelectionBox` adorns on the parts in contact islands, where each contact island is assigned a random color. */
	AreContactIslandsShown: boolean;
	/** When set to true, sphere adorns will be drawn at the contact points of each part where physics interactions are occurring.
Each sphere also has an arrow drawn in 3D, facing the surface that the contact point is detecting.

## Solver Variations

The behavior of this property varies depending on whether Roblox's physics engine is using the _PGS Physics Solver_, or the _Spring Physics Solver_.

This is controlled by the `Workspace`'s `PGSPhysicsSolverEnabled` property.

### Spring Physics Solver

When `PGSPhysicsSolverEnabled` is set to false, the contact points are color coded as listed below.

The length of the arrow extruding from the sphere depends on how much force the contact point is exerting, and what the contact type is.

| Color | Contact Type | Description |
|  | Normal Contact | Contact point with no special conditions. |
|  | Resting Contact | Contact point that has been active for at least 4 frames. |
|  | Second Pass Contact | Contact point that was made by a kernel joint going through a second pass. Rarely seen. |
|  | Real Time Contact | Contact point that was made with a real-time physics body. This applies to tripped `Humanoid`. |
|  | Joint Contact | Contact point that was made under the context of a physically simulated joint. This applies to Motors and Hinges. |

### PGS Physics Solver

When `PGSPhysicsSolverEnabled` is set to true, the contact points are always colored **RED**, and the length of the arrow will always be 1 stud. 

There are no special conditions tracked, because the PGS solver does not keep specific lookup tables for the states listed in the Spring Solver.


| Color | Contact Type | Description |
|  | Normal Contact | Contact point with no special conditions. | */
	AreContactPointsShown: boolean;
	/** When set to true, XYZ axes are rendered at the `CFrame` of every part. */
	AreJointCoordinatesShown: boolean;
	/** When set to true, every individual mechanism of parts is given a unique color. */
	AreMechanismsShown: boolean;
	/** An ancient property that hasn't work correctly since late 2007.
It's supposed to render an XYZ axis on the root part of a `Model`, but the axis rendering component doesn't work correctly. */
	AreModelCoordsShown: boolean;
	/** When set to true, each `Player`'s character is outlined with a unique color, and each part that the player has network ownership over is outlined with the same color. */
	AreOwnersShown: boolean;
	/** An ancient property that hasn't worked correctly since late 2007.
It's supposed to render a large XYZ axis in the center of each `BasePart`, but the axis rendering component doesn't work correctly. */
	ArePartCoordsShown: boolean;
	/** When set to true, a cylinder is drawn around each `Player`'s character, representing their `SimulationRadius`.
Each physically simulated object will check to see which player is closest to that object, and if they are within the player's simulation radius. If both conditions are met, that player will becomes the network owner of that object.When set to true, a cylinder is drawn around each `Player`'s character, representing their `SimulationRadius`. */
	AreRegionsShown: boolean;
	/** When set to true, parts that aren't aligned on the 1x1x1 grid will be outlined yellow. */
	AreUnalignedPartsShown: boolean;
	/** An ancient property that hasn't worked correctly since late 2007.
It's supposed to render a large XYZ axis in the center of the world, but the axis rendering component doesn't work correctly. */
	AreWorldCoordsShown: boolean;
	/** When set to true, Roblox will fall back to using its legacy CSG solver when performing [solid model operations](https://developer.roblox.com/articles/3D-Modeling-with-Parts "Solid modeling")
. */
	DisableCSGv2: boolean;
	/** This property is supposed to show the `ReceiveAge` of a part, but it does not work correctly. */
	IsReceiveAgeShown: boolean;
	/** When set to true, the joint connections of each part, and the states of their underlying primitive components are visualized as a spanning tree.
## Spanning Tree Table

There are several visualizations made available when this property is set to true:

| Color | Adorn Type | Description |
|  | Box | Root Primitive of a Mechanism that is currently anchored, or connected to an anchored primitive. (See: `IsGrounded`) |
|  | Box | Root Primitive of a Mechanism that is free to be physically simulated. |
|  | Box | Root Primitive of a Mechanism that has moving components. |
|  | Sphere | Root Primitive of an Assembly. |
|  | Cylinder | Root Primitive of a Clump. |
|  | Line | Connection between two Primitives that share the same Assembly and Clump. |
|  | Line | Connection between two Primitives that share the same Assembly. |
|  | Line | Connection between two Primitives. | */
	IsTreeShown: boolean;
	/** Controls the throttle rate of Roblox's physics engine.
By default, the physics engine will adjust the physics environment throttle depending on how much work the physics engine is doing, and the current framerate. See the enum page for [EnviromentalPhysicsThrottle](https://developer.roblox.com/api-reference/enum/EnviromentalPhysicsThrottle "EnviromentalPhysicsThrottle") for more information.Controls the throttle rate of Roblox's physics engine. */
	PhysicsEnvironmentalThrottle: Enum.EnviromentalPhysicsThrottle;
	/** When set to true, the underlying collision geometry for `PartOperation` and `MeshPart` is rendered. */
	ShowDecompositionGeometry: boolean;
	/** If the `PhysicsEnvironmentalThrottle` is set to _DefaultAuto_
, this specifies the maximum time that the physics environmental throttle has to wait before it is allowed to automatically change. */
	ThrottleAdjustTime: number;
	/** If set to true, version 2 of Roblox's CSG solver will be used instead of version 1. */
	UseCSGv2: boolean;
}

/** A Player object a client that is currently connected. These objects are added to the `Players` service when a new player connects, then removed when they eventually disconnect from the server.

The `Name` property reflects the player's username. When saving information about a player, you should use their `UserId` since it is possible that a player can change their username.

There are several similar methods in the `Players` for working with Player objects. Use these over their respective `Instance` methods:
  - You can get a table of current Player objects using `GetPlayers`; again, use this instead of `GetChildren`.
  - To detect the addition of Player objects, it is recommended to use the `PlayerAdded` event (instead of `ChildAdded` on the `Players` service).
  - Similarly, you can detect the removal of Player objects using `PlayerRemoving`, which fires just **before** the Player is removed (instead of `ChildRemoved` which fires after). This is important if you are saving information about the player that might be removed or cleaned up on-removal.

## Code Samples

### Leaderstats

This code sample demonstrates the creation of leaderboard stat values in Roblox's default player list UI. It creates a "Score" leaderstat that starts at 0.
```lua
local Players = game:GetService("Players") -- game.Players is OK here, too

-- Eventually, this function will be called once for all Player objects
local function onPlayerAdded(player)
	-- Create a container for leaderstats
	local leaderstats = Instance.new("Folder")
	leaderstats.Name = "leaderstats"
	
	-- Create one leaderstat value
	local vScore = Instance.new("IntValue")
	vScore.Name = "Score"
	vScore.Value = 0
	vScore.Parent = leaderstats
	
	-- Add to player (displaying it)
	leaderstats.Parent = player
end

-- Process Player objects that have already joined the game
for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
-- Process Player objects that are being added to the game
Players.PlayerAdded:Connect(onPlayerAdded) -- Note: PlayerAdded not ChildAdded here!

```
 */
interface Player extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Player";
	/** The AccountAge is a `Player` property that describes how long ago a player's account was registered in days. It is set using the `SetAccountAge` function, which cannot be accessed by scripts.

This property is useful for conditionally showing new Roblox players content such as tutorials.

## Code Samples

### Account Age Mark

This code sample adds a mark to players showing about how old their account is. The mark uses a player's account age to determine if they are a New Player, Veteran Player or Regular Player.
```lua
local Players = game:GetService("Players")

local MAX_AGE_NEW_PLAYER = 7 -- a week
local MIN_AGE_VETERAN = 365 -- one year

-- This function marks a part with text using a BillboardGui
local function mark(part, text)
	local bbgui = Instance.new("BillboardGui")
	bbgui.AlwaysOnTop = true
	bbgui.StudsOffsetWorldSpace = Vector3.new(0, 2, 0)
	bbgui.Size = UDim2.new(0, 200, 0, 50)
	local textLabel = Instance.new("TextLabel")
	textLabel.Size = UDim2.new(1, 0, 1, 0) -- Fill parent
	textLabel.Text = text
	textLabel.TextColor3 = Color3.new(1, 1, 1)
	textLabel.TextStrokeTransparency = 0
	textLabel.BackgroundTransparency = 1
	textLabel.Parent = bbgui
	-- Add to part
	bbgui.Parent = part
	bbgui.Adornee = part
end

local function onPlayerSpawned(player, character)
	local head = character:WaitForChild("Head")
	if player.AccountAge >= MIN_AGE_VETERAN then
		mark(head, "Veteran Player")
	elseif player.AccountAge <= MAX_AGE_NEW_PLAYER then
		mark(head, "New Player")
	else
		mark(head, "Regular Player")
	end
end

local function onPlayerAdded(player)
	-- Listen for this player spawning
	if player.Character then
		onPlayerSpawned(player, player.Character)
	end
	player.CharacterAdded:Connect(function ()
		onPlayerSpawned(player, player.Character)
	end)
end

-- Listen for players being added
for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)
```
 */
	readonly AccountAge: number;
	/** The AutoJumpEnabled property determines whether the `Character` of a `Player` using a mobile device will automatically jump when they hit an obstacle. This can make levels more navigable while on a mobile device.

When the player joins the game, the `AutoJumpEnabled` value determines the initial state of this property. Then, this property determines the value of the `AutoJumpEnabled` property of the `Character`s `Humanoid` on spawn. In other words, it is possible to set the auto-jump behavior on a per-character, per-player and per-game basis using these three properties.

## Code Samples

### Auto-Jump Toggle

This code sample is meant for a TextButton. It allows the player to toggle the auto-jumping behavior while on a mobile device.
```lua
local player = game.Players.LocalPlayer
local button = script.Parent

local function update()
	-- Update button text
	if player.AutoJumpEnabled then
		button.Text = "Auto-Jump is ON"
	else
		button.Text = "Auto-Jump is OFF"
	end
	-- Reflect the property in the player's character, if they have one
	if player.Character then
		local human = player.Character:FindFirstChild("Humanoid")
		if human then
			human.AutoJumpEnabled = player.AutoJumpEnabled
		end
	end
end

local function onActivated()
	-- Toggle auto-jump
	player.AutoJumpEnabled = not player.AutoJumpEnabled
	-- Update everything else
	update()
end
button.Activated:connect(onActivated)
update()

```
 */
	AutoJumpEnabled: boolean;
	/** The CameraMaxZoomDistance `Player` property sets the maximum distance in studs the camera can be from the character with the default cameras.

In other words, it controls the maximum distance the player's camera is allowed to zoom out.

The default value of this property is set by `CameraMaxZoomDistance`. If this value is set to a lower value than `CameraMinZoomDistance`, it will be increased to CameraMinZoomDistance.

## Code Samples

### Setting Camera Zoom Distance

​The example demonstrates how to set a player's camera minimum and maximum zoom distance.

In this example, we set the `CameraMinZoomDistance` and `CameraMaxZoomDistance` to set the min and max distance in studs a player's camera can be from their character.

Note that since the example attempts to set the CameraMinZoomDistance to be greater than the CameraMaxZoomDistance, the CameraMinZoomDistance value will be decreased and set to the value of the max zoom distance.

To change the default min and max zoom distance values for a player when they first enter the game, you can change the `CameraMinZoomDistance` and `CameraMaxZoomDistance` properties.
```lua
local player = game.Players.LocalPlayer

player.CameraMaxZoomDistance = 50
player.CameraMinZoomDistance = 75
```
 */
	CameraMaxZoomDistance: number;
	/** The CameraMinZoonDistance `Player` property sets the minimum distance in studs the camera can be from the character with the default cameras. 

In other words, it controls the minimum distance the player's camera is allowed to zoom in.

The default value of this property is set by `CameraMinZoomDistance`. If this value is set to a higher value than `CameraMaxZoomDistance` it will be decreased to CameraMaxZoomDistance.

## Code Samples

### Setting Camera Zoom Distance

​The example demonstrates how to set a player's camera minimum and maximum zoom distance.

In this example, we set the `CameraMinZoomDistance` and `CameraMaxZoomDistance` to set the min and max distance in studs a player's camera can be from their character.

Note that since the example attempts to set the CameraMinZoomDistance to be greater than the CameraMaxZoomDistance, the CameraMinZoomDistance value will be decreased and set to the value of the max zoom distance.

To change the default min and max zoom distance values for a player when they first enter the game, you can change the `CameraMinZoomDistance` and `CameraMaxZoomDistance` properties.
```lua
local player = game.Players.LocalPlayer

player.CameraMaxZoomDistance = 50
player.CameraMinZoomDistance = 75
```
 */
	CameraMinZoomDistance: number;
	/** The CameraMode `Player` property sets what mode that the player's camera is in. By default, the camera mode is set to third person.

The camera has two modes:
 1. First person
 2. Third person

The `CameraMode` Enum is used to set CameraMode in Player, and determines when first and third person cameras should be used.

First-person
------------
In first-person mode, the player's camera is zoomed all the way in. Unless there is a visible GUI present with the `/GuiButton/Modal` property set to *true*, the mouse will be locked and the user's camera will turn as the mouse moves.
![First Person CameraMode](https://developer.roblox.com/assets/5ade20a13a314ce34a0f6878/CameraMode_FirstPerson.jpg)

Third-person
------------
In third-person mode, the character can be seen in the camera. While in third-person mode on Roblox:

* You may right-click and drag to rotate your camera, or use the arrow keys at the bottom right-hand corner of the screen. 
* When you move your mouse, your camera does not change (unless you move the mouse to the end of the screen). 
* When you press any of the arrow keys, the user's character will face in the corresponding arrow key's direction. 
* You can zoom in and out freely. 

Third-person is the default camera setting.
![Third Person CameraMode](https://developer.roblox.com/assets/5ade20afbaed3a514c3722c4/CameraMode_ThirdPerson.jpg)

## Note
 - This item should be used in a `LocalScript` to work as expected online.

## Code Samples

### Playing in Third Person

This example demonstrates how to change the character's CameraMode to third person using the Classic value of the `CameraMode` enum.
```lua
local player = game.Players.LocalPlayer

player.CameraMode = Enum.CameraMode.Classic
```

### Playing in First Person

This example demonstrates how to change the character's CameraMode to first person using the LockFirstPerson value of the `CameraMode` enum.
```lua
local player = game.Players.LocalPlayer

player.CameraMode = Enum.CameraMode.LockFirstPerson
```
 */
	CameraMode: Enum.CameraMode;
	/** The CanLoadCharacterAppearance `Player` property determines whether the character's appearance will be loaded when the player spawns. The default value of this property is set by `LoadPlayerAppearance`.

If *true*, the character will load the appearance of the player corresponding to the player's `CharacterAppearanceId`.

If *false*, the player will spawn with a default appearance - a grey character model without any hats, shirts, pants, etc.

Attempting to set the property after the character has spawned will not change the character, you must call `LoadCharacter` to load the new appearance. */
	CanLoadCharacterAppearance: boolean;
	/** The Character property contains a reference to a `Model` containing a `Humanoid`, body parts, scripts and other objects required for simulating the player's avatar in-game. The model is parented to the `Workspace`, but may be moved.

Initially, this property is nil then set when the player's character first spawns. Use the `CharacterAdded` event to detect when a player's character properly loads, and the `CharacterRemoving` event to detect when the character is about to despawn. Avoid using `GetPropertyChangedSignal` on this property.

## Notes
LocalScripts that are cloned from `StarterGui` or `StarterPack` into a player's `Backpack` or `PlayerGui` are often run before the old Character model is deleted. Player.Character still refers to a model, but that model's parent is nil and it is has been destroyed. Because of this, if the Character already exists, you should check to make sure that the Character's parent is not nil before using it.

So if you're writing a `LocalScript`, do this:

```lua
lua
local player = game.Players.LocalPlayer
local character = player.Character
if not character or not character.Parent then
	character = player.CharacterAdded:wait()
end
```


But from the server it's fine to do this:

```lua
lua
if player.Character then
	-- do something
end
```


Or if you want to wait until the character respawns from a server `Script`:

```lua
lua
local character = player.Character or player.CharacterAdded:wait()
``` */
	Character?: Model;
	/** This property determines the user ID of the account whose character appearance is used for a player's `character. By default, this property is the `Player`'s `UserId`, which uses the player's avatar as they have created it on the Roblox website. 

Changing this property to the user ID of another account will cause the player to spawn with that account's appearance (hats, shirt, pants, etc).

Games can also toggle whether or not a player's character appearance is loaded in game by changing the `LoadCharacterAppearance` property.

## Code Samples

### Disguise Command

This code sample allows players to chat "/disguise xyz", where xyz is a user ID or username, and they will respawn appearing like that account's avatar. Try typing "/disguise 261" or "/disguise Shedletsky"!
```lua
local Players = game:GetService("Players")

local disguiseCommand = "/disguise "

local function onPlayerChatted(player, message)
	if message:sub(1, disguiseCommand:len()):lower() == disguiseCommand:lower() then
		local input = message:sub(disguiseCommand:len() + 1)
		local id = tonumber(input) -- Parse a number, or return nil if not a number
		if not id then -- Number failed to parse, maybe they typed a username instead
			pcall(function () -- This call can fail sometimes!
				id = Players:GetUserIdFromNameAsync(input) -- Fetch ID from name
			end)
		end
		if id then
			-- Set character appearance then respawn
			player.CharacterAppearanceId = id
			player:LoadCharacter()
		else
			-- We couldn't get an ID from their input
		end
	end
end

local function onPlayerAdded(player)
	player.Chatted:Connect(function (...)
		onPlayerChatted(player, ...)
	end)
end

-- Listen for players being added
for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)
```
 */
	CharacterAppearanceId: number;
	/** The DevCameraOcclusionMode `Player` property sets how the default camera handles objects between the camera and the player. Set by default by `DevCameraOcclusionMode`.

The default value is *Zoom* (0): The camera will zoom in until there is nothing between the player and camera.

See `DevCameraOcclusionMode` for the different occlusion modes available. Sets how the default camera handles objects between the camera and the player. */
	DevCameraOcclusionMode: Enum.DevCameraOcclusionMode;
	/** The DevComputerCameraMode property determines the manner in which a player moves their camera when using a mouse-and-keyboard device device. See `DevComputerCameraMovementMode` for a description of each camera control mode available. This property cannot be set using a `LocalScript` (it must be set on the server using a `Script`).

The default value of this property is determined by `DevComputerCameraMovementMode`.

## Note
* The word "Computer" in this property name refers to non-`TouchEnabled`, non-`GamepadEnabled` devices.
* When set to **UserChoice**, a player can choose between any control mode (except **Scriptable**) in the Roblox game settings. In general, it is a good idea to allow players to choose their control mode to maximize accessibility.
* It is possible to create a custom control scheme by setting this property to **Scriptable**. 
* This property does not affect players using a touch enabled device. See `DevTouchCameraMode ` instead.

## Code Samples

### Setting a Player's Camera Movement Mode (Desktop)

The example demonstrates how to set a player's camera movement mode for players on a computer.

In this example, we set the camera movement mode to Classic via the `DevComputerCameraMovementMode` enum. This means that the camera of players on touch enabled devices will track the player but will not automatically rotate if the player walks left or right.
```lua
local player = game.Players.LocalPlayer

-- Set the player's camera movement mode on computers to classic
player.DevComputerCameraMode = Enum.DevComputerCameraMovementMode.Classic
```
 */
	DevComputerCameraMode: Enum.DevComputerCameraMovementMode;
	/** The DevComputerMovementMode property determines the manner in which a player moves their character when using a mouse-and-keyboard device device. See `DevComputerMovementMode` for a description of each movement control mode available. This property cannot be set using a `LocalScript` (it must be set on the server using a `Script`).

The default value of this property is determined by `DevComputerMovementMode`.

## Note
* The word "Computer" in this property name refers to non-`TouchEnabled` devices.
* When set to **UserChoice**, a player can choose between any control mode (except **Scriptable**) in the Roblox game settings. In general, it is a good idea to allow players to choose their control mode to maximize accessibility.
* It is possible to create a custom control scheme by setting this property to **Scriptable**. 
* This property does not affect players using a touch enabled device. See `DevTouchMovementMode ` instead.

## Code Samples

### Setting a Player's Movement Mode (Desktop)

The example demonstrates how to set the movement mode for players on computers.

In this example, we set the movement mode to KeyboardMouse via the `DevComputerMovementMode` enum. This means that players on computers control their characters using their keyboard and mouse.
```lua
local player = game.Players.LocalPlayer

-- Set the player's movement mode on computers to keyboard and mouse
player.DevComputerMovementMode = Enum.DevComputerMovementMode.KeyboardMouse
```
 */
	DevComputerMovementMode: Enum.DevComputerMovementMode;
	/** This property determines if a player is able to toggle **`mouse` lock** by pressing **Shift**. A player can disable the mouse lock switch in Roblox's game settings. By default, this property is set to the value of `EnableMouseLockOption`. This can be set during run-time by using a `LocalScript`,

## What is Mouse Lock?
When mouse lock is enabled, the player's cursor is locked to the center of the screen. Moving the mouse will orbit the camera around the player's `character`, and character will face the same direction as the `camera`. It also offsets the camera view just over the right shoulder of the player's character.

Below, the camera is moved left and right first by holding right-click. Then, mouse lock is enabled which changes the mouse to a target reticule, and offsets the camera. The camera is again moved left and right (without holding right click).

## Code Samples

### Enabling a Player's Mouse Lock

The example demonstrates how to enable and disabled whether a player can lock their mouse.

In this example, we set the use a while true loop to toggle the state of the DevEnabledMouseLock property between *true* and *false* every 5 seconds. While this example has little practical use, it demos how to change the property via a `LocalScript`.
```lua
local player = game.Players.LocalPlayer

while true do
	player.DevEnableMouseLock = not player.DevEnableMouseLock
	wait(5)
end
```
 */
	DevEnableMouseLock: boolean;
	/** The DevTouchCameraMode property determines the manner in which a player moves their camera when using a `TouchEnabled` device. See `DevTouchCameraMovementMode` for a description of each camera control mode available. This property cannot be set using a `LocalScript` (it must be set on the server using a `Script`).

The default value of this property is determined by `DevTouchCameraMovementMode`.

## Note
* When set to **UserChoice**, a player can choose between any control mode (except **Scriptable**) in the Roblox game settings. In general, it is a good idea to allow players to choose their control mode to maximize accessibility.
* It is possible to create a custom control scheme by setting this property to **Scriptable**. 
* This property does not affect players who are not using a touch enabled device. See `DevComputerCameraMovementMode` instead.

## Code Samples

### Setting a Player's Camera Movement Mode (Touch)

The example demonstrates how to set a player's camera movement mode.

In this example, we set the camera movement mode to Classic via the `DevTouchCameraMovementMode` enum. This means that the camera of players on touch enabled devices will track the player but will not automatically rotate if the player walks left or right.
```lua
local player = game.Players.LocalPlayer

-- Set the player's camera movement mode on mobile devices to classic
player.DevTouchCameraMovementMode = Enum.DevTouchCameraMovementMode.Classic
```
 */
	DevTouchCameraMode: Enum.DevTouchCameraMovementMode;
	/** The DevTouchMovementMode property determines the manner in which a player moves their character when using a `TouchEnabled` device. See `DevTouchMovementMode` for a description of each movement control mode available. This property cannot be set using a `LocalScript` (it must be set on the server using a `Script`).

The default value of this property is determined by `DevTouchMovementMode`.

## Note
* When set to **UserChoice**, a player can choose between any control mode (except **Scriptable**) in the Roblox game settings. In general, it is a good idea to allow players to choose their control mode to maximize accessibility.
* It is possible to create a custom control scheme by setting this property to **Scriptable**. 
* This property does not affect players who are not using a touch enabled device. See `DevComputerMovementMode` instead.

## Code Samples

### Setting a Player's Movement Mode (Touch)

The example demonstrates how to set the movement mode for players on touch enabled devices.

In this example, we set the movement mode to Thumbstick via the `DevTouchMovementMode` enum. This means that players on touch enabled devices be able to move via a virtual thumbstick on their screen.
```lua
local player = game.Players.LocalPlayer

-- Set the player's movement mode on mobile devices to a virtual thumbstick
player.DevTouchMovementMode = Enum.DevTouchMovementMode.Thumbstick
```
 */
	DevTouchMovementMode: Enum.DevTouchMovementMode;
	/** The FollowUserId is a `Player` property that contains the `UserId` of the user that a player followed into the game. If the player did not follow anyone into the game, this property will be 0. This property is useful for alerting players who have been followed by another player into the game.

You can get the name of the player followed using this user ID and the `GetNameFromUserIdAsync` function.

## Code Samples

### Followed Alert

This code sample alerts players if a new player follows the local player into the game. It does so using a `Hint`. Place this in a `LocalScript` in `StarterPlayerScripts`.
```lua
local Players = game.GetService("Players")
local Debris = game:GetService("Debris")
local player = Players.LocalPlayer

local function onPlayerAdded(newPlayer)
	if newPlayer.FollowUserId == player.UserId then
		local hint = Instance.new("Hint")
		hint.Parent = player:WaitForChild("PlayerGui")
		hint.Text = "You were followed to this game by " .. newPlayer.Name .. "!"
		Debris:AddItem(hint, 3)
	end
end

Players.PlayerAdded:Connect(onPlayerAdded)

```
 */
	readonly FollowUserId: number;
	/** The HealthDisplayDistance `Player` property sets the distance in studs at which this player will see other `Humanoid`’s health bars. If set to 0, the health bars will not be displayed. This property is set to `HealthDisplayDistance` by default.

## Note
If a Humanoid's health bar is visible, you can set the display type using `DisplayDistanceType`. */
	HealthDisplayDistance: number;
	/** The LocaleId `Player` property shows the locale id that the local player has set for their Roblox account. It holds a string with the two letter code (for example, "en-us") for the locale.

This can be used to determine the geographic demographic of your game's player base.

The property is similar to `LocalizationService`'s `RobloxLocaleId` property. */
	readonly LocaleId: string;
	/** The MembershipType `Player` property can be used to determine the membership type of the player. It holds an Enum of the account's membership type (NBC, BC, TBC and OBC). The enum held is `MembershipType`.

##Note
This property can only be read from to determine membership. It cannot be set to another membership type. The property can only be changed via `CoreScript`s using `SetMembershipType` - which are not accessible.

## Code Samples

### How to Check Player Membership Status

The below example would print 

> User has regular Builder's Club!

 if the recently added player has a regular BC subscription.
```lua
game.Players.PlayerAdded:Connect(function(p)
	if p.MembershipType == Enum.MembershipType.BuildersClub then
		print("User has regular Builder's Club!")
	end
end)
```
 */
	readonly MembershipType: Enum.MembershipType;
	/** The NameDisplayDistance `StarterPlayer` property sets the distance in studs at which this player will see other `Humanoid`’s names. If the property is set to 0, names are hidden. This property is set to `NameDisplayDistance` by default.

## Note
If a Humanoid's health bar is visible, you can set the display type using `DisplayDistanceType`. */
	NameDisplayDistance: number;
	/** The Neutral property determines whether the player is on a specific team.

* When *true*, the player is not on a specific team. This also means that the `Team` property will be nil and the `TeamColor` will be white.
* When *false*, the player is on a specific team. The `Team` property will correspond to the `Team` that the player is on, as will the `TeamColor`.

## Code Samples

### Checking if a Player is Neutral

This example checks if a player is neutral. If the player is neutral, the game prints:

> Player is neutral!

If the player is neutral, the game prints:

> Player is not neutral!

*Note:* Although this example prints the value of the local player's neutral property, you can change the example to get the value for any player.
```lua
local player = game.Players.LocalPlayer

if (player.Neutral) then
	print("Player is neutral!")
else
	print("Player is not neutral!")
end
```
 */
	Neutral: boolean;
	/** The ReplicationFocus `Player` property sets the part to focus replication around a Player. Different Roblox systems that communicate over the network (such as physics, streaming, etc) replicate at different rates depending on how close objects are to the replication focus.

When this property is nil, it reverts to its default behavior which is to treat the local player's character's head as the replication focus.

This property should only be set on the server with a `Script`, not a `LocalScript`. Note that this property does not change or update network ownership of parts.

## Code Samples

### Setting a Player's Replication Focus

This example creates a new `BasePart` and sets the `Player`'s `ReplicationFocus` to that part.

This demonstrates the functionality of the ReplicationFocus property. You can easily change the part that the focus is set to to change the replication focus.
```lua
local part = Instance.new("Part")
part.Parent = game.Workspace
part.Name = "ReplicationFocusPart"
part.Anchored = true

local player = game.Players.LocalPlayer
player.ReplicationFocus = part
```
 */
	ReplicationFocus: BasePart | undefined;
	/** If set, the player will respawn at the given `SpawnLocation`. This property can only be set through Lua and must contain a reference to a valid `SpawnLocation`, which must meet the following criteria:

 - Descendant of `Workspace`
 - `SpawnLocation.TeamColor` is set to the `Player.TeamColor` or `SpawnLocation.Neutral` is set to true

If RespawnLocation is not set to a valid `SpawnLocation` then the default spawning logic will apply. For more information on this see the page for `SpawnLocation`.

## Alternatives to RespawnLocation

 - A `Player` will spawn from `SpawnLocations` belonging to their team. In some cases it may be simpler to change the `Player's` `Team` instead. This method also allows the `Player` to respawn from multiple `SpawnLocations`.
 - Developers may wish to implement their own custom spawn logic, using `SetPrimaryPartCFrame` to move the `Character` manually.

## Code Samples

### Change Spawn on Touch

This code sample will set the player to always respawn from the last SpawnLocation they touched. New players will respawn from the SpawnLocation named 'FirstSpawn' until they touch a different SpawnLocation.

This is an alternative to using the AllowTeamChangeOnTouch property to switch SpawnLocations and does not require Teams.
```lua
local Players = game:GetService("Players")

local function addSpawn(spawnLocation)
	-- listen for the spawn being touched
	spawnLocation.Touched:Connect(function(hit)
		local character = hit:FindFirstAncestorOfClass("Model")
		if character then
			local player = Players:GetPlayerFromCharacter(character)
			if player and player.RespawnLocation ~= spawnLocation then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				-- make sure the character isn't dead
				if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
					print("spawn set")
					player.RespawnLocation = spawnLocation
				end
			end
		end
	end)
end

local firstSpawn

-- look through the workspace for spawns
for _, descendant in pairs(workspace:GetDescendants()) do
	if descendant:IsA("SpawnLocation") then
		if descendant.Name == "FirstSpawn" then
			firstSpawn = descendant
		end
		addSpawn(descendant)
	end
end

local function playerAdded(player)
	player.RespawnLocation = firstSpawn
end

-- listen for new players
Players.PlayerAdded:Connect(playerAdded)

-- go through existing players
for _, player in pairs(Players:GetPlayers()) do 
	playerAdded(player)
end
```
 */
	RespawnLocation?: SpawnLocation;
	/** The Team property is a reference to a `Team` object within the `Teams` service. It determines the team the player is on; if the `Player` isn't on a team or has an invalid `TeamColor`, this property is nil. When this property is set, the player has joined the `Team` and the `PlayerAdded` event fires on the associated team. Similarly, `PlayerRemoved` fires when the property is unset from a certain `Team`.

## Code Samples

### Join Team Command

This code sample allows any player to chat "/jointeam " where  is the name of a team. It uses string manipulation using string.sub and string.lower to make the command case-insensitive and allow for partial matches. For example, "/jointeam red" will match the team "Red Robins".
```lua
local Players = game:GetService("Players")
local Teams = game:GetService("Teams")

-- Command to choose a team (note the trailing space)
local joinCommand = "/jointeam "

local function findTeamByName(name)
	-- First, check for the exact name of a team
	if Teams:FindFirstChild(name) then return Teams[name] end
	-- Let's check for case-insensitive partial matches, like "red" for "Red Robins"
	for _, team in pairs(Teams:GetChildren()) do
		if team.Name:sub(1, name:len()):lower() == name:lower() then
			return team
		end
	end
	-- If we get to this point, no team matched the one we were looking for :(
end

local function onPlayerChatted(player, message, recipient)
	-- Note: string.sub(message, ...) is the same as message:sub(...)
	if message:sub(1, joinCommand:len()):lower() == joinCommand:lower() then
		-- Matched "/JOINTEAM xyz" to our join command prefix "/jointeam "
		local teamName = message:sub(joinCommand:len() + 1) -- Cut out the "xyz" from "/jointeam xyz"
		local team = findTeamByName(teamName)
		if team then
			-- Set the team!
			player.Team = team
			player.Neutral = false
		else
			-- Tell the player that team could not be found :(
			player.Team = nil
			player.Neutral = true
		end
	end
end

local function onPlayerAdded(player)
	player.Chatted:connect(function (...)
		onPlayerChatted(player, ...)
	end)
end

-- Listen for players being added
for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)
```

### Playing/Spectating Teams

This code sample, although lengthy, is quite simple: detect when a player chats /play, then put them on the "Playing" team. When they die, move them back to the "Spectating" team.
```lua
local Players = game:GetService("Players")
local Teams = game:GetService("Teams")

-- Two teams: one for spectators (default) and one for those playing the game
local teamPlaying = Teams.Playing
local teamSpectators = Teams.Spectating
-- Command to play the game
local playCommand = "/play"

local function play(player)
	-- Set the player's team using one of the following:
	player.Team = teamPlaying
	player.TeamColor = teamPlaying.TeamColor
	-- Respawn the player (moves them to spawn location)
	player:LoadCharacter()
end

local function onPlayerDied(player, character)
	-- When someone dies, put them on the spectator team
	player.Team = teamSpectators
end

local function onPlayerSpawned(player, character)
	local human = character:WaitForChild("Humanoid")
	human.Died:connect(function () onPlayerDied(player, character) end)
end

local function onPlayerChatted(player, message)
	if message:sub(1, playCommand:len()):lower() == playCommand then
		play(player)
	end
end

local function onPlayerAdded(player)
	-- Listen for this player spawning
	if player.Character then
		onPlayerSpawned(player, player.Character)
	end
	player.CharacterAdded:connect(function ()
		onPlayerSpawned(player, player.Character)
	end)
end

-- Listen for players being added
for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded.Connect(onPlayerAdded)
```
 */
	Team?: Team;
	/** The TeamColor property determines which team a Player is associated with according to that Team's `TeamColor`. Changing this property will change `Team` according to whichever team has the same `BrickColor` for their `TeamColor`. If no Team object has the associated TeamColor, the player will not be associated with a team.

It's often a better idea to set `Team` to the respective `Team` instead of using this property. Setting this property often leads to repetition of the same BrickColor value for a certain teams across many scripts; this is something you want to avoid when adhering to the [don't-repeat-yourself][1] principle.


  [1]: https://en.wikipedia.org/wiki/Don%27t_repeat_yourself

## Code Samples

### Playing/Spectating Teams

This code sample, although lengthy, is quite simple: detect when a player chats /play, then put them on the "Playing" team. When they die, move them back to the "Spectating" team.
```lua
local Players = game:GetService("Players")
local Teams = game:GetService("Teams")

-- Two teams: one for spectators (default) and one for those playing the game
local teamPlaying = Teams.Playing
local teamSpectators = Teams.Spectating
-- Command to play the game
local playCommand = "/play"

local function play(player)
	-- Set the player's team using one of the following:
	player.Team = teamPlaying
	player.TeamColor = teamPlaying.TeamColor
	-- Respawn the player (moves them to spawn location)
	player:LoadCharacter()
end

local function onPlayerDied(player, character)
	-- When someone dies, put them on the spectator team
	player.Team = teamSpectators
end

local function onPlayerSpawned(player, character)
	local human = character:WaitForChild("Humanoid")
	human.Died:connect(function () onPlayerDied(player, character) end)
end

local function onPlayerChatted(player, message)
	if message:sub(1, playCommand:len()):lower() == playCommand then
		play(player)
	end
end

local function onPlayerAdded(player)
	-- Listen for this player spawning
	if player.Character then
		onPlayerSpawned(player, player.Character)
	end
	player.CharacterAdded:connect(function ()
		onPlayerSpawned(player, player.Character)
	end)
end

-- Listen for players being added
for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded.Connect(onPlayerAdded)
```
 */
	TeamColor: BrickColor;
	/** The UserId is a `Player` property that contains a read-only integer that **uniquely and consistently** identifies every user account on Roblox. Unlike the `Name` of a Player, which may change according the user's present username, this value will never change for the same account.

This property is essential when saving/loading player data using `GlobalDataStores`. Use a player's UserId as the data store key so that each player has a unique key.

## Code Samples

### Players:GetPlayerByUserId


```lua
local player = game:GetService("Players"):GetPlayerByUserId(1)
 
if player then
    print("Player with userId 1 is in this server! His name is: " .. player.Name)
else
    print("Player with userId 1 is not in this server!")
end
```

### Data Store to Leaderboard

This code sample retrieves a player's saved gold from a data store and puts the returned value onto the leaderboard. Note that this sample does not save players' gold&nbsp;&mdash; it only loads it.
```lua
local Players = game:GetService("Players")
local goldDataStore = game:GetService("DataStoreService"):GetDataStore("Gold") 

local STARTING_GOLD = 100

local function onPlayerAdded(player)
	local playerKey = "Player_" .. player.UserId

	local leaderstats = Instance.new("IntValue")
	leaderstats.Name = "leaderstats"

	local gold = Instance.new("IntValue", leaderstats)
	gold.Name = "Gold"

	local myGold
	local success, err = pcall(function()
		myGold = goldDataStore:GetAsync(playerKey)
	end)
	if success then
		gold.Value = myGold
	else
		gold.Value = STARTING_GOLD
	end

	leaderstats.Parent = player
end

for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)
```

### Met the Creator Badge

The following code sample gives an example of a 'met the creator' badge system. This script will award a specified badge (BADGE_ID) to anyone who is in a server at the same time as the user associated with OWNER_ID.
```lua
    local BadgeService = game:GetService("BadgeService")
    local Players = game:GetService("Players")
    
    -- change these
    local OWNER_ID = 212423 -- can use game.CreatorId for published places
    local BADGE_ID = 1
    
    local ownerInGame = false
    
    local function playerAdded(newPlayer)
    	if newPlayer.UserId == OWNER_ID then
    		-- if new player is the owner, set ownerInGame to true and give everyone the badge
    		ownerInGame = true
    		for _, player in pairs(Players:GetPlayers()) do
    			-- don't award the owner
    			if player ~= newPlayer then
    				BadgeService:AwardBadge(player.UserId, BADGE_ID)
    			end
    		end
    	elseif ownerInGame then 
    		-- if the owner is in the game, award the badge
    		BadgeService:AwardBadge(newPlayer.UserId, BADGE_ID)
    	end
    end
    
    local function playerRemoving(oldPlayer)
    	if oldPlayer.UserId == OWNER_ID then
    		-- set ownerInGame to false
    		ownerInGame = false 
    	end
    end
    
    -- listen for players joining and leaving
    Players.PlayerAdded:Connect(playerAdded)
    Players.PlayerRemoving:Connect(playerRemoving)
    
    -- fire playerAdded for existing players
    for _, player in pairs(Players:GetPlayers()) do
    	playerAdded(player)
    end


```

### Player.UserId

The below example would print the UserId of every user who entered a game.
```lua
game.Players.PlayerAdded:Connect(function(player)
     print(player.UserId)
end)
```
 */
	readonly UserId: number;
	/** The ClearCharacterAppearance function removes all `Hat`, `Shirt`, `Pants`, `CharacterMesh`, and `BodyColors` from the given player's `Character`. In addition, it also removes the T-Shirt `Decal` on the player's torso. The character's body part colors and face will remain unchanged. This method does nothing if the player does not have a Character.

##Note
It does not remove `t-shirts`, head meshes, or [Faces][1].


  [1]: /api-reference/datatype/Faces

## Code Samples

### Player:ClearCharacterAppearance


```lua

game.Players.LocalPlayer.Character.ChildRemoved:connect(function(child)
  print(child.ClassName, 'removed from character')
end)

game.Players.LocalPlayer:ClearCharacterAppearance()
--> BodyColors removed from character
--> ShirtGraphic removed from character
--> Shirt removed from character
--> Pants removed from character
--> CharacterMesh removed from character
--> Hat removed from character
--> Shirt removed from character

```

@returns No return. */
	ClearCharacterAppearance(): void;
	/** Returns the distance between the character's head and the given Vector3 point. Returns 0 if the player has no character.

## Code Samples

### Player:DistanceFromCharacter

This code will print the distance of each player's character from the origin (0, 0, 0):
```lua

for _, player in pairs(game.Players:GetPlayers()) do
    print(player:DistanceFromCharacter(Vector3.new(0, 0, 0)))
end

```
 */
	DistanceFromCharacter(point: Vector3): number;
	/** This function returns a dictionary containing information on how the `Player` joined the game.

The dictionary contains the fields below. Please note, whether these fields exists depends on the circumstances under which the `Player` joined the game.

| Key | Value Type | Description |
| --- | --- | --- |
| SourcePlaceId | int64 | The `PlaceId` of the place the `Player` was teleported from. Only present if the player was teleported to the current place. |
| Members | array | An array containing the `UserIds` teleported alongside the `Player`. Only present if the player was teleported in using `TeleportPartyAsync`. |
| TeleportData | variant | The _teleportData_ parameter specified in the original teleport function. Only present if _teleportData_ was specified and the teleport function was called from the server. |


## GetJoinData and TeleportData

If the teleport the `Player` arrived in the current place due to was initiated on a server (as opposed to a client) the `Player’s` *teleportData* is included in the dictionary returned by this function.

This function can only be used to fetch *teleportData* on the server, to retrieve it on the client use `GetLocalPlayerTeleportData`.

In contrast to `GetLocalPlayerTeleportData`, this function provides a number of security checks to the *teleportData*:

 - It is guaranteed to have been sent by a Roblox server in the last 48 hours
 - It is guaranteed to have been sent with this `Player`
 - The SourcePlaceId returned is guaranteed to be the place the data was sent from. This means you can verify the TeleportData came from an approved place
 
However, as this data is transmitted by the client, it not 100% secure. Although the user cannot modify this data it is possible for them to view it or insert data from a previous teleport.

Despite this, it is still appropriate for the secure transmission of [immutable data][1] (data that can not be changed). For example, if the user has completed a level that cannot be uncompleted. Such data can be securely transmitted using this function avoiding the need to use up and wait for `DataStore` requests when teleporting.

You should not use this function for data that can be changed. For example, the amount of in-game currency the user currently has. This is because GetJoinData cannot guarantee a malicious user is not transmitting data from a previous session. For data like this, you should rely on `GlobalDataStores`. 

As with all cases, you should implement proper server validation to ensure your game is secure. For more information see this article on `Game Security`.


  [1]: https://en.wikipedia.org/wiki/Immutable_object

## Code Samples

### Server TeleportData Example

The following code sample is an example of how teleport data can be retrieved on the server using `GetJoinData`. This code, when ran in a `Script` in `ServerScriptService`, will listen for new `Players` joining the game. When they join it will retrieve their teleport data (verifying it came from a valid place) to find their current level.
```lua
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local approvedPlaceIds = {1} -- insert approved PlaceIds here

local function isPlaceIdApproved(placeId)
    for _, id in pairs(approvedPlaceIds) do
        if id == placeId then
            return true
        end
    end
    return false
end

Players.PlayerAdded:Connect(function(player)
    local joinData = player:GetJoinData()

    -- verify this data was sent by an approved place
    if isPlaceIdApproved(joinData.SourcePlaceId) then

        local teleportData = joinData.TeleportData
        if teleportData then
            local currentLevel = teleportData.currentLevel
            print(player.Name.." is on level "..currentLevel)
        end
    end
end)

```

@returns A dictionary containing PlaceId and UserId values (see table in description). */
	GetJoinData(): PlayerJoinInfo;
	/** Returns the mouse being used by the client.

## Code Samples

### How to Track Mouse Input

The below example will print: 

> Button 1 is down

 whenever the `LocalPlayer` left clicks.
```lua

local Player = Game.Players.LocalPlayer
local Mouse = Player:GetMouse()
Mouse.Button1Down:Connect(function()
     print("Button 1 is down")
end)

```
 */
	GetMouse(): PlayerMouse;
	/** Returns whether or not the appearance of the player's character has loaded */
	HasAppearanceLoaded(): boolean;
	/** The Kick method allows a game to gracefully disconnect a client from the game and optionally provide a message to the disconnected player. This is useful for moderating abusive players. When used in conjunction with a `DataStore`, it is possible to create ban lists with expiration dates. Only allow specific whitelisted users whom you trust to trigger this method on other players.

When used from a LocalScript, only the local player's client can be kicked.

## Code Samples

### Kick Command

This code sample allows the creator of a place to kick other players by chatting "/kick xyz", where xyz is the exact username of a player.
```lua
local Players = game:GetService("Players")

local kickCommand = "/kick "

local function onOwnerChatted(player, message)
	if message:sub(1, kickCommand:len()):lower() == kickCommand:lower() then
		local name = message:sub(kickCommand:len() + 1)
		local playerToKick = Players:FindFirstChild(name)
		if playerToKick then
			playerToKick:Kick("You have been kicked by the owner.")
		else
			-- Couldn't find the player in question
		end
	end
end

local function onPlayerAdded(player)
	-- Restrict this command to only the creator/owner
	if player.UserId == game.CreatorId and game.CreatorType == Enum.CreatorType.User then
		player.Chatted:Connect(function (...)
			onOwnerChatted(player, ...)
		end)
	end
end

-- Listen for players being added
for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)
```

@param message The message to show the player upon kicking. */
	Kick(message?: string): void;
	/** Causes the player's character to walk in the given direction until stopped, or interrupted by the player (by using their controls).

## Code Samples

### Player:Move

The following example would cause the LocalPlayer to walk forward, towards where their camera is pointing.
```lua

game.Players.LocalPlayer:Move(Vector3.new(0, 0, -1), true)

```
 */
	Move(walkDirection: Vector3, relativeToCamera?: boolean): void;
	/** The GetFriendsOnline `Player` function returns a `Table#dictionaries` of online friends, specified by *maxFriends*.

## The Array's Content
Some fields are only present for certain location types. For example, *PlaceId* won't be present when the location type is *(mobile) website*.

| Name         | Type    | Description                                                                                                                            |
|--------------|---------|----------------------------------------------------------------------------------------------------------------------------------------|
| VisitorId    | number  | The `UserId` of the friend.                                                                                                              |
| UserName     | string  | The user name of the friend.                                                                                                           |
| LastOnline   | string  | When the user was last online.                                                                                                         |
| IsOnline     | boolean | If the friend is currently online.                                                                                                     |
| LastLocation | string  | The name of the friends current location.                                                                                              |
| PlaceId      | number  | The placeId of the friends last location.                                                                                              |
| GameId       | string  | The `JobId` of the friends last location.                                                                                               |
| LocationType | number  | The location type of the friends last location. 0 for mobile website. 1 for mobile in game. 2 for website. 3 for studio. 4 for ingame. |


  [1]: http://robloxdev.com/articles/Table#dictionaries

## Code Samples

### How to Get a List of Online Friends

This example demonstrates how to get a dictionary of a player's online friends. 

It will returns at max as many friends as specified in the argument, which we set to 10. If the argument is blank, the default max number of friends to return is 200.

The example then prints the names of all online friends.
```lua
local player = game.Players.LocalPlayer

local dict = player:GetFriendsOnline(10)

for i,friend in pairs(dict) do
	print(friend.UserName)
end
```

@param maxFriends The maximum number of online friends to return. The default is 200.
@returns An dictionary of online friends (see the table in the description to see what each the format of an entry). */
	/** ### TS Usage
	 * One should check the LocationType of each member of this array in order to verify which members are present. Should be compared to the LocationType const enum.
	 */
	GetFriendsOnline(maxFriends?: number): Array<FriendOnlineInfo>;
	/** Returns the player's rank in the group as an integer between 0 and 255, where 0 is a non-member and 255 is the group's owner.

## Code Samples

### How to Check a Player's Rank in a Group

The code below will check if a player that has entered the game has a rank equal to 255, in a group with an ID of 2. If they are, it will print "Player is the owner of the group, 'LOL'!", otherwise "Player is NOT the owner of the group, 'LOL'!" will be printed to the output.
```lua

game.Players.PlayerAdded:Connect(function(Player)
    if Player:GetRankInGroup(2) == 255 then
        print("Player is the owner of the group, 'LOL'!")
    else
        print("Player is NOT the owner of the group, 'LOL'!")
    end
end)

```
 */
	GetRankInGroup(groupId: number): number;
	/** Returns the player's role in the group as a string, or "Guest" if the player isn't part of the group.

## Code Samples

### How to Check a Player's Role in a Group

The code below will print the name of the rank that the player is currently a part of, in a specific group. In this instance we're checking what rank the player is within a group which has a group ID of 2.
```lua

game.Players.PlayerAdded:Connect(function(player)
    print("Player is ranked as '" .. player:GetRoleInGroup(2) .. "' in group, 'LOL'!")
end)

```
 */
	GetRoleInGroup(groupId: number): string;
	/** This function sends a request to the Roblox website asking whether a player is a friend of another user, given the `UserId` of that user.

Using this in a `Script`, as opposed to a `LocalScript`, will not get you the most up-to-date information. If a player leaves a group while they are in the game, it will still think they're in that group until they leave. However, this does not happen when used with a LocalScript.

This is because the method caches results, so multiple calls of the function on the same player with the same userId will yield the same result as when the method was first called with the given userId.

## See also
 - `Creating-VIP-Creating VIP Doors`

## Code Samples

### How to Check if a Player is a Friend

The below example would print whether or not a recently added player is friends with Gordonrox24.
```lua

game.Players.PlayerAdded:Connect(function(player)
	if player:IsFriendsWith(146569) then
		print(player.Name .. " is friends with gordonrox24!")
	end
end)

```

@param userId The `Player/UserId` of the specified player.
@returns A boolean indicating whether a player is a friend of the specified user. */
	IsFriendsWith(userId: number): boolean;
	/** IsInGroup sends a request to the Roblox website asking whether a player is a member of a group, given the ID of that group.

This method will caches results, so multiple calls of `IsInGroup` on the same player with the same group ID will yield the same result as when the method was first called with the given group ID. The caching behavior is on a per-peer basis: a server does not share the same cache as a client. Therefore, calling this method from a LocalScript may yield more up-to-date results.

## Code Samples

### How to Check if a Player is in a Group

The below example will print "Player is in the Roblox Fan club!" if the newly added player is in the group with a groupId of 7.
```lua

game.Players.PlayerAdded:Connect(function(newPlayer)
   if newPlayer:IsInGroup(7) then                    
      print "Player is in the Roblox Fan club!"     
   end
end)

```
 */
	IsInGroup(groupId: number): boolean;
	/** Creates a new character for the player, removing the old one. Also clears the player's `Backpack` and `PlayerGui`.

## Code Samples

### How to Turn of Auto-Loading and Simulate Character Respawn

This script turns off auto-loading and simulates character respawning.
```lua
local respawnDelay = 5

game.Players.CharacterAutoLoads = false

game.Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		-- find the humanoid, and detect when it dies
		local humanoid = character:FindFirstChild("Humanoid")
		if humanoid then
			humanoid.Died:Connect(function()
				wait(respawnDelay)
				player:LoadCharacter()
			end)
		end
	end)
	player:LoadCharacter() -- load the character for the first time
end)
```
 */
	/** @rbxts server */
	LoadCharacter(): void;
	/** @rbxts server */
	LoadCharacterWithHumanoidDescription(humanoidDescription: HumanoidDescription): void;
	/** The CharacterAdded event fires when a player's character spawns (or respawns). This event fires soon after setting `Character` to a non-nil value or calling `LoadCharacter`. Note, CharacterAdded fires when the Character is assigned to the `Player`, which is before the Character is parented to the `Workspace`. 

This can be used alongside the `CharacterRemoving` event, which fires right before a player's character is about to be removed, typically after death. As such, both of these event can potentially fire many times as players die then respawn in a place. If you want to detect when a player joins or leaves the game, you can use the `PlayerAdded` and `PlayerRemoving` events instead.

Note that the `Humanoid` and its body parts (head, torso and limbs) will exist when this event fires, but clothing items like `Hats` and `Shirts`, `Pants` may take a few seconds to be added to the character (connect `ChildAdded` on the added character to detect these).

## Code Samples

### Detecting Player Spawns and Despawns

This code sample demonstrates the usage of `PlayerAdded`, `CharacterAdded` and `CharacterRemoving` in order to detect the spawning and despawning of players' characters. You can use this as a boilerplate script to make changes to players' characters as they spawn, such as changing `WalkSpeed`.
```lua
local Players = game:GetService("Players")

local function onCharacterAdded(character)
	print(character.Name .. " has spawned")
end

local function onCharacterRemoving(character)
	print(character.Name .. " is despawning")
end

local function onPlayerAdded(player)
	player.CharacterAdded:Connect(onCharacterAdded)
	player.CharacterRemoving:Connect(onCharacterRemoving)
end

Players.PlayerAdded:Connect(onPlayerAdded)
```

### Respawn at Despawn Location

This code sample will cause players to respawn at the same place they died. It does this by keeping track of where the player despawned using `CharacterRemoving`. Note that the player's location is saved on-despawn, not on-death. This can be problematic if the player falls off a ledge and dies due to `FallenPartsDestroyHeight` - their respawn position won't be saved in this case.

It's also important to note the need to "forget" the location of players who leave the game. We use `ChildRemoved` on `Players` instead of `PlayerRemoving`. This is because PlayerRemoving fires before CharacterRemoving - and we need to make sure we don't forget the player's respawn location then immediately remember a new one (this is a memory leak; potentially many players could visit, respawn and leave). So, we use ChildRemoved on Players so the event fires after the character is removed.
```lua
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- This table maps "Player" objects to Vector3
local respawnLocations = {}

local function onCharacterAdded(character)
	local player = Players:GetPlayerFromCharacter(character)
	-- Check if we saved a respawn location for this player
	if respawnLocations[player] then
		-- Teleport the player there when their HumanoidRootPart is available
		local hrp = character:WaitForChild("HumanoidRootPart")
		-- Wait a brief moment before teleporting, as Roblox will teleport the
		-- player to their designated SpawnLocation (which we will override)
		RunService.Stepped:wait()
		hrp.CFrame = CFrame.new(respawnLocations[player] + Vector3.new(0, 3.5, 0))
	end
end

local function onCharacterRemoving(character)
	-- Get the player and their HumanoidRootPart and save their death location
	local player = Players:GetPlayerFromCharacter(character)
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if hrp then
		respawnLocations[player] = hrp.Position
	end
end

local function onPlayerAdded(player)
	-- Listen for spawns/despawns
	player.CharacterAdded:Connect(onCharacterAdded)
	player.CharacterRemoving:Connect(onCharacterRemoving)
end

local function onPlayerRemoved(player)
	-- Forget the respawn location of any player who is leaving; this prevents
	-- a memory leak if potentially many players visit
	respawnLocations[player] = nil
end

-- Note that we're NOT using PlayerRemoving here, since CharacterRemoving fires
-- AFTER PlayerRemoving, we don't want to forget the respawn location then instantly
-- save another right after 
Players.PlayerAdded:Connect(onPlayerAdded)
Players.ChildRemoved:Connect(onPlayerRemoved)
```

### Accessory Remover

This code sample automatically removes `Accessory` objects like hats from the `Player`'s character when they respawn. Warning: this includes hair, so this script may cause acute baldness.

When the `Character` is `added`, we wait for `Stepped` to fire once (using the `wait` function of events). This is so the accessory removal logic runs one frame after the character spawns. A warning can appear if you delete accessories too quickly after the player spawns, so waiting one frame will avoid that.
```lua
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Check if the given object is an Accessory (such as a hat)
local function destroyAccessories(object)
	if object:IsA("Hat") or object:IsA("Accessory") then
		object:Destroy()
	end
end

local function onCharacterAdded(character)
	-- Wait a brief moment before removing accessories to avoid the
	-- "Something unexpectedly set ___ parent to NULL" warning
	RunService.Stepped:wait()
	-- Check for any existing accessories in the player's character
	for _, child in pairs(character:GetChildren()) do
		destroyAccessories(child)
	end
	-- Hats may be added to the character a moment after
	-- CharacterAdded fires, so we listen for those using ChildAdded
	character.ChildAdded:Connect(destroyAccessories)
end

local function onPlayerAdded(player)
	-- Listen for spawns
	player.CharacterAdded:Connect(onCharacterAdded)
end

Players.PlayerAdded:Connect(onPlayerAdded)

```
 */
	readonly CharacterAdded: RBXScriptSignal<(character: Model) => void>;
	/** This event fires when the the full appearance of a `Player`'s `Character` has been inserted.

`Character`'s generally have a range of objects modifying their appearance including `Accoutrements`, `Shirts`, `Pants` and `CharacterMeshes`. This event will fire when all such objects have been inserted into the `Character`.

One use for this event, is to remove and save aspects of a `Characters` appearance to be used later. See below for an example of this.

## Code Samples

### Remove and Return Hats

This code sample will remove all the hats from a `Character` once the character has fully loaded. After five seconds, if the character still exists and is alive, it will return them.
```lua
local Players = game:GetService("Players")

local function playerAdded(player)
	player.CharacterAppearanceLoaded:Connect(function(character)
		local humanoid = character:WaitForChild("Humanoid")

		-- save hats for later
		local accessories = {}
		for _, accessory in pairs(humanoid:GetAccessories()) do 
			table.insert(accessories, accessory:Clone())
		end

		-- remove hats
		humanoid:RemoveAccessories()

		wait(5)

		-- make sure the player still exists, and has the same character
		if player and player.Character and player.Character == character then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
				-- give back the hats
				for _, accessory in pairs(accessories) do 
					humanoid:AddAccessory(accessory)
				end
			end
		end

		accessories = nil
	end)
end

-- get existing players
for _, player in pairs(Players:GetPlayers()) do 
	playerAdded(player)
end
-- listen for new players
Players.PlayerAdded:Connect(playerAdded)



```
 */
	readonly CharacterAppearanceLoaded: RBXScriptSignal<(character: Model) => void>;
	/** The CharacterRemoving event fires right before a player's character is removed, such as when the player is respawning.

This event can be used alongside the `CharacterAdded` event, which fires when a player's character spawns or respawns. For instance, if you would like print a message every time a player spawns and dies:

```lua
local Players = game:GetService("Players")

local function onCharacterSpawned(player)
	print(player.Name .. " is spawning")
end

local function onCharacterDespawned(player)
	print(player.Name .. " is despawning")
end

local function onPlayerAdded(player)
	player.CharacterAdded:connect(function ()
		onCharacterDespawned(player)
	end)
	player.CharacterRemoving:connect(function ()
		onCharacterDespawned(player)
	end)
end

Players.PlayerAdded:connect(onPlayerAdded)
```


This event is only concerned with the `Character` of a `Player`. If you instead need to track when a player joins/leaves the game, use the events `PlayerAdded` and `PlayerRemoving`.

## Code Samples

### Player.CharacterRemoving

This example prints the name of the character being removed, followed by "has died". 

For instance, if Shedletsky's character was to die in-game, "Shedletsky has died." would be printed.
```lua
game.Players.PlayerAdded:Connect(function(player)
    player.CharacterRemoving:Connect(function(character)
        print(character.Name .. " has died.")
    end)
end)
```
 */
	readonly CharacterRemoving: RBXScriptSignal<(character: Model) => void>;
	/** The Chatted event fires when a `Player` types a message and presses enter in Roblox's provided chat bar. This is done using some Lua bindings by the default chat script. You can prevent players from chatting by using `SetCoreGuiEnabled` and disabling the Chat `CoreGuiType`.

## Chat Commands

Using this event and some string manipulation functions like `string.sub` and `string.lower`, it is possible to create chat commands, even with arguments like player names. Usually, commands are prefixed such as `/heal PlayerName`. To check for a prefix in a string, use `string.sub` on the message to check a substring of the message: `string.sub(message, 1, 6) == "/heal "` (note the inclusion of the space) . Then, extract the rest of the command using `string.sub` again: `string.sub(message, 7)` will be equal to the player name. Check if that player exists, and if so, perform the command's action (in this example, healing them). Check the code samples for examples of chat commands.

## Filtering 

The message text fired with this event is **unfiltered**. If you are displaying player input like chat to other players in any form, it must be filtered using `FilterStringAsync`. Keep this in mind when creating your own chat systems; if your game does not properly filter chat it may have moderation action taken against it.

## Code Samples

### Player.Chatted

=== Setting chatted for all players ===
There is an easy way to make the Chatted event registered on all players. Simply use the `/Players/PlayerAdded` event in combination with this event.
```lua
game.Players.PlayerAdded:Connect(function(player)
  player.Chatted:Connect(function(msg)
        -- do stuff with msg and player
  end)
end)
```

### Join Team Command

This code sample allows any player to chat "/jointeam " where  is the name of a team. It uses string manipulation using string.sub and string.lower to make the command case-insensitive and allow for partial matches. For example, "/jointeam red" will match the team "Red Robins".
```lua
local Players = game:GetService("Players")
local Teams = game:GetService("Teams")

-- Command to choose a team (note the trailing space)
local joinCommand = "/jointeam "

local function findTeamByName(name)
	-- First, check for the exact name of a team
	if Teams:FindFirstChild(name) then return Teams[name] end
	-- Let's check for case-insensitive partial matches, like "red" for "Red Robins"
	for _, team in pairs(Teams:GetChildren()) do
		if team.Name:sub(1, name:len()):lower() == name:lower() then
			return team
		end
	end
	-- If we get to this point, no team matched the one we were looking for :(
end

local function onPlayerChatted(player, message, recipient)
	-- Note: string.sub(message, ...) is the same as message:sub(...)
	if message:sub(1, joinCommand:len()):lower() == joinCommand:lower() then
		-- Matched "/JOINTEAM xyz" to our join command prefix "/jointeam "
		local teamName = message:sub(joinCommand:len() + 1) -- Cut out the "xyz" from "/jointeam xyz"
		local team = findTeamByName(teamName)
		if team then
			-- Set the team!
			player.Team = team
			player.Neutral = false
		else
			-- Tell the player that team could not be found :(
			player.Team = nil
			player.Neutral = true
		end
	end
end

local function onPlayerAdded(player)
	player.Chatted:connect(function (...)
		onPlayerChatted(player, ...)
	end)
end

-- Listen for players being added
for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)
```

### Playing/Spectating Teams

This code sample, although lengthy, is quite simple: detect when a player chats /play, then put them on the "Playing" team. When they die, move them back to the "Spectating" team.
```lua
local Players = game:GetService("Players")
local Teams = game:GetService("Teams")

-- Two teams: one for spectators (default) and one for those playing the game
local teamPlaying = Teams.Playing
local teamSpectators = Teams.Spectating
-- Command to play the game
local playCommand = "/play"

local function play(player)
	-- Set the player's team using one of the following:
	player.Team = teamPlaying
	player.TeamColor = teamPlaying.TeamColor
	-- Respawn the player (moves them to spawn location)
	player:LoadCharacter()
end

local function onPlayerDied(player, character)
	-- When someone dies, put them on the spectator team
	player.Team = teamSpectators
end

local function onPlayerSpawned(player, character)
	local human = character:WaitForChild("Humanoid")
	human.Died:connect(function () onPlayerDied(player, character) end)
end

local function onPlayerChatted(player, message)
	if message:sub(1, playCommand:len()):lower() == playCommand then
		play(player)
	end
end

local function onPlayerAdded(player)
	-- Listen for this player spawning
	if player.Character then
		onPlayerSpawned(player, player.Character)
	end
	player.CharacterAdded:connect(function ()
		onPlayerSpawned(player, player.Character)
	end)
end

-- Listen for players being added
for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded.Connect(onPlayerAdded)
```
 */
	readonly Chatted: RBXScriptSignal<(message: string, recipient: Instance) => void>;
	/** This event is usually fired two minutes after the game engine classifies the `player` as idle. Time is the amount of seconds since this point.

This can be used to track when a player has been idled for approximately two minutes - which can be useful for implementing away from keyboard (AFK) features into a game.

When the game engine classifies a player as idle, this event is called after two minutes. After every check, if the player is still idled, the event will continue to fire until the check reveals the player is no longer idle.

This event is used by Roblox to automatically disconnect players that have been idle for at least 20 minutes. If you would like to track when this disconnect occurs, considering using `PlayerRemoving` alongside this event.

## Code Samples

### Player.Idled1

This example will print how long a player, named Player, has been idle for.
```lua
game.Players.Player.Idled:Connect(function(time)
     print("Player has been idle for " .. time .. " seconds")
end)

```
 */
	readonly Idled: RBXScriptSignal<(time: number) => void>;
	/** Fired when the TeleportState of a player changes. This event is useful for detecting whether a teleportation was successful.

## What is the TeleportState?

When a teleportation request is made using `TeleportService`, there are a series of stages before the `Player` is teleported. The current stage is represented by the `TeleportState` value which is given by OnTeleport. See below for a practical example of this.

## Code Samples

### Player.OnTeleport

This example prints which stage of a teleport a player is at, as well as printing if the teleport was a failure.
```lua
game.Players.PlayerAdded:Connect(function(player)
	local playerOnTeleport = player
	player.OnTeleport:Connect(function(teleportState, placeId, spawnName)
		if teleportState == Enum.TeleportState.Started then
			print("Teleport started ("..playerOnTeleport.Name..")")
		elseif teleportState == Enum.TeleportState.WaitingForServer then
			print("Teleport waiting for server ("..playerOnTeleport.Name..")")
		elseif teleportState == Enum.TeleportState.InProgress then
			print("Teleport in progress ("..playerOnTeleport.Name..")")
		elseif teleportState == Enum.TeleportState.Failed then
			print("Teleport failed! ("..playerOnTeleport.Name..")")
		end
	end)
end)
```
 */
	readonly OnTeleport: RBXScriptSignal<(teleportState: Enum.TeleportState, placeId: number, spawnName: string) => void>;
}

/** `PlayerScripts` is a container object located inside `Player` objects within the `Players` game service. It is created automatically when a player joins the game. Its main purpose is to contain `LocalScript`s copied from the `StarterPlayerScripts` container within the `StarterPlayer` game service, which happens once upon creation. Descendant `LocalScripts` of `PlayerScripts` will run code on the client of the `Player`.

Unlike the `Backpack` and `PlayerGui` containers, the `PlayerScripts` container is not accessible to the server. Server `Script` objects will not run when parented to `PlayerScripts`. */
interface PlayerScripts extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PlayerScripts";
	/** Unregisters all ComputerCameraMovementMode enums from the game settings menu. */
	ClearComputerCameraMovementModes(): void;
	/** Unregisters all ComputerMovementMode enums from the game settings menu. */
	ClearComputerMovementModes(): void;
	/** Unregisters all TouchCameraMovementMode enums from the game settings menu. */
	ClearTouchCameraMovementModes(): void;
	/** Unregisters all TouchMovementMode enums from the game settings menu.
@returns This return is void as nothing is returned. */
	ClearTouchMovementModes(): void;
	/** Registers that a computer camera movement mode is available to be selected from the game menu. */
	RegisterComputerCameraMovementMode(cameraMovementMode: CastsToEnum<Enum.ComputerCameraMovementMode>): void;
	/** Registers that a computer movement mode is available to be selected from the game menu. */
	RegisterComputerMovementMode(movementMode: CastsToEnum<Enum.ComputerMovementMode>): void;
	/** Registers that a touch camera movement mode is available to be selected from the game menu. */
	RegisterTouchCameraMovementMode(cameraMovementMode: CastsToEnum<Enum.TouchCameraMovementMode>): void;
	/** Registers that a touch movement mode is available to be selected from the game menu. */
	RegisterTouchMovementMode(movementMode: CastsToEnum<Enum.TouchMovementMode>): void;
}

/** The Players game service contains only `Player` objects for presently connected clients to a Roblox game server. It also contains information about a place's configuration (such as bubble chat or classic chat). It can fetch information about players not connected to the server, such as character appearances, friends and avatar thumbnail.

## Code Samples

### Give Sparkles to Everyone

This code sample listens for players spawning and gives them Sparkles in their head. It does this by defining two functions, `onPlayerSpawned` and `onPlayerAdded`. It calls these functions for players/characters already in the game, in case the script runs after players already arrive.
```lua
local Players = game:GetService("Players")

local function onCharacterAdded(character)
	-- Give them sparkles on their head if they don't have them yet
	if not character:FindFirstChild("Sparkles") then
		local sparkles = Instance.new("Sparkles")
		sparkles.Parent = character:WaitForChild("Head")
	end
end

local function onPlayerAdded(player)
	-- Check if they already spawned in
	if player.Character then
		onCharacterAdded(player.Character)
	end
	-- Listen for the player (re)spawning 
	player.CharacterAdded:Connect(onCharacterAdded)
end

-- Iterate over each player already connected
-- to the game using a generic for-loop
for i, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
-- Listen for newly connected players
Players.PlayerAdded:Connect(onPlayerAdded)

```
 */
interface Players extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Players";
	/** Indicates whether or not bubble chat is enabled. It is set with the `SetChatStyle` method. */
	readonly BubbleChat: boolean;
	/** The CharacterAutoLoads `Players` property indicates whether `Character`s will respawn automatically. The default value is *true*.

If this property is disabled (*false*), players `Characters` will not spawn until the `LoadCharacter` function is called for each `Player` - including when players join the game.

This can be useful in games where players have finite lives, such as competitive games in which players do not respawn until a game round ends.

## Code Samples

### 

This example demonstrates one possible usage of the `CharacterAutoLoads` property.

The example below respawns all players in the game, if dead, once every 10 seconds. This means that players who die 1 second after all players respawn must wait 9 seconds until the script loads all `Character` again.

First, this script removes a player's character when they die and the `Died` function fires. This is done so that the respawn loop that executes every 10 seconds reloads that player when it does not find the player's character in the Workspace.

To work as expected, this example should be run within a `Script`.
```lua
-- Set CharacterAutoLoads to false
game.Players.CharacterAutoLoads = false

-- Remove player's character from workspace on death
game.Players.PlayerAdded:Connect(function(player)
	while true do
		local char = player.CharacterAdded:wait()
		char.Humanoid.Died:Connect(function()
			char:Remove()
		end)
	end
end)

-- Respawn all dead players once every 10 seconds
while true do
	local players = game.Players:GetChildren()
	
	-- Check if each player is dead by checking if they have no character, if dead load that player's character
	for i, player in pairs (players) do		
		if (not game.Workspace:FindFirstChild(player.Name)) then
			player:LoadCharacter()
		end
	end

	-- Wait 10 seconds until next respawn check
	wait(10)
end
```
 */
	CharacterAutoLoads: boolean;
	/** Indicates whether or not classic chat is enabled. This property is set by the `SetChatStyle` method using the `ChatStyle` enum.

When this chat mode is enabled, the game displays chats in a bubble above the sender's head.

There are two other chat modes, `BubbleChat` and a chat mode where both classic and bubble chat are enabled.

## Code Samples

### How to Check a Game's Chat Mode

This example prints a string indicating the game's chat mode, which can be one of three modes:
 1. Classic chat
 2. Bubble chat
 3. Classic and bubble chat
```lua
local Players = game.Players

if (Players.ClassicChat and Players.BubbleChat) then
	print("Classic and Bubble chat are enabled!")
elseif (Players.ClassicChat) then
	print("Classic chat is enabled!")
elseif (Players.BubbleChat) then
	print("Bubble chat is enabled!")
end
```
 */
	readonly ClassicChat: boolean;
	/** This is a read-only property which contains a reference to the `Player` instance for which a `LocalScript` is running. For `Script`s running on the server, this property is nil.

This property is useful when creating GUIs that display information about the player. You can use it to accessing the player's `Character`, `PlayerGui`, and `Backpack`.

## Loading GUIs
When creating loading GUIs using `ReplicatedFirst`, sometimes a `LocalScript` may run before the `LocalPlayer` is created and becomes available. In such cases, it is useful to yield until it is by using `GetPropertyChangedSignal`

```lua
local Players = game:GetService("Players")
local player = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):wait()
```


Note that this technique is not required for `LocalScripts` within in `StarterGui`, `StarterPlayerScripts` or `StarterCharacterScripts`, as these kinds of scripts only run if the `Player` object is already available.

## Code Samples

### Setting the Player's Account Age

This example demonstrates how the `SetAccountAge` function would be used if it was accessible. It sets the local player's account age to 100 days.
```lua
​local player = game.Players.LocalPlayer
player:SetAccountAge(100)
```

### 

This example demonstrates the `LoadCharacterBlocking` function. 

First, the script changes the local player's appearance by changing the `CharacterAppearance` property to the *userId* 772462. Then, the script fires the LoadCharacterBlocking function to reload the player's character with the new appearance.

##Notes
 - This function cannot be used in scripts, but is usable in the command bar. As such, this example will only work as expected when fired from the command bar.
 - Since this function executes asynchronously, the script will not continue execution until the function finishes.
```lua
local player = game.Players.LocalPlayer

player.CharacterAppearanceId = 772462
player:LoadCharacterBlocking()
```
 */
	/** @rbxts client */
	readonly LocalPlayer: Player;
	/** The maximum amount of players that can be in this server. */
	readonly MaxPlayers: number;
	/** The PreferredPlayers property determines the number of players to which Roblox's matchmaker will fill servers. This is number should be less than the maximum number of players supported by the game in order to leave some spaces for additional players (such as friends or those following another player) to join.

This property can be set from the place settings' *Access* tab on the site. It cannot be set through `Script`s or `LocalScript`s in-game.

When a player press the Play button to join a game server, Roblox attempts to match that player to a server such that the player count will try not to exceed PreferredPlayers. If a friend (or friends) of the player are in a server that is not full, Roblox prioritizes that server instead.

## Example
There are 8 players in a server where the `MaximumPlayers` is 10 and the PreferredPlayers is 8. A player presses the play button:
* If the player has **at least one friend** in the server, Roblox selects the already-existing server so the player can play with their friend.
* If the player has **no friends** in the server, a new server is started since the existing server has met the number of PreferredPlayers (the player could still join the server by manually selecting it or following another user).

## Code Samples

### PreferredPlayers Example

The script below prints a table displaying the `MaxPlayers`, `PreferredPlayers`, and the number of players currently on the server.

| Maximum                                         | Preferred                                 | Current                                   |
|-------------------------------------------------|-------------------------------------------|-------------------------------------------|
| Maximum number of players allowed in the server | Preferred number of players in the server | Number of players currently in the server |
```lua
print("========== Player Count ===========")
print("Maximum\t| Preffered\t| Current")
print(game.Players.MaxPlayers.."\t| "..game.Players.PreferredPlayers.."\t| "..#game.Players:GetChildren())
print("=================================")
```
 */
	readonly PreferredPlayers: number;

	RespawnTime: number;
	/** This function searches each `player` in `Players` for one whose `UserId` matches the given UserId. If such a player does not exist, it simply returns `nil`. It is equivalent to the following function:

```lua
local Players = game:GetService("Players")
local function getPlayerByUserId(userId)
	for _, player in pairs(Players:GetPlayers()) do
		if player.UserId == userId then
			return player
		end
	end
end
```


This method is useful in finding the purchaser of a developer product using `ProcessReceipt`, which provides a table that includes the purchaser's UserId and not a reference to the Player object itself. Most games will require a reference to the player in order to grant products.

## Code Samples

### ProcessReceipt Callback

This code sample illustrates a `ProcessReceipt` callback function for a game to handle purchasing of two `Developer Products In Game developer products`
 (more can be added as needed). It properly checks for and records purchases using a `GlobalDataStore` called "PurchaseHistory."

Most importantly, it properly returns `Enum.ProductPurchaseDecision.PurchaseGranted` when the transaction is successfully completed **or** if it's detected that the purchase has already been granted using the "PurchaseHistory" data store.
```lua
local MarketplaceService = game:GetService("MarketplaceService")
local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")

-- Data store for tracking purchases that were successfully processed
local purchaseHistoryStore = DataStoreService:GetDataStore("PurchaseHistory")

-- Table setup containing product IDs and functions for handling purchases
local productFunctions = {}
-- ProductId 123123 for a full heal
productFunctions[123123] = function(receipt, player)
	-- Logic/code for player buying a full heal (may vary)
	if player.Character and player.Character:FindFirstChild("Humanoid") then
		-- Heal the player to full health
		player.Character.Humanoid.Health = player.Character.Humanoid.MaxHealth
		-- Indicate a successful purchase
		return true
	end
end
-- ProductId 456456 for 100 gold
productFunctions[456456] = function(receipt, player)
	-- Logic/code for player buying 100 gold (may vary)
	local stats = player:FindFirstChild("leaderstats")
	local gold = stats and stats:FindFirstChild("Gold")
	if gold then
		gold.Value = gold.Value + 100
		-- Indicate a successful purchase
		return true
	end
end

-- The core 'ProcessReceipt' callback function
local function processReceipt(receiptInfo)

	-- Determine if the product was already granted by checking the data store  
	local playerProductKey = receiptInfo.PlayerId .. "_" .. receiptInfo.PurchaseId
	local purchased = false
	local success, errorMessage = pcall(function()
		purchased = purchaseHistoryStore:GetAsync(playerProductKey)
	end)
	-- If purchase was recorded, the product was already granted
	if success and purchased then
		return Enum.ProductPurchaseDecision.PurchaseGranted
	else
		error("Data store error:" .. errorMessage)
	end

	-- Find the player who made the purchase in the server
	local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)
	if not player then
		-- The player probably left the game
		-- If they come back, the callback will be called again
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end
	
	-- Look up handler function from 'productFunctions' table above
	local handler = productFunctions[receiptInfo.ProductId]

	-- Call the handler function and catch any errors
	local success, result = pcall(handler, receiptInfo, player)
	if not success or not result then
		warn("Error occurred while processing a product purchase")
		print("\nProductId:", receiptInfo.ProductId)
		print("\nPlayer:", player)
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	-- Record transaction in data store so it isn't granted again
	local success, errorMessage = pcall(function()
		purchaseHistoryStore:SetAsync(playerProductKey, true)
	end)
	if not success then
		error("Cannot save purchase data: " .. errorMessage)
	end

	-- IMPORTANT: Tell Roblox that the game successfully handled the purchase
	return Enum.ProductPurchaseDecision.PurchaseGranted
end

-- Set the callback; this can only be done once by one script on the server! 
MarketplaceService.ProcessReceipt = processReceipt
```

### Players:GetPlayerByUserId


```lua
local player = game:GetService("Players"):GetPlayerByUserId(1)
 
if player then
    print("Player with userId 1 is in this server! His name is: " .. player.Name)
else
    print("Player with userId 1 is not in this server!")
end
```

@param userId The `Player/UserId` of the player being specified
@returns The player with the specified `Player/UserId`, or **nil** if that player is not in the game */
	GetPlayerByUserId(userId: number): Player | undefined;
	/** This function returns the `Player` associated with the given `Character`, or `nil` if one cannot be found. It is equivalent to the following function:

```lua
local function getPlayerFromCharacter(character)
	for _, player in pairs(game:GetService("Players"):GetPlayers()) do
		if player.Character == character then
			return player
		end
	end
end
```

This method is often used when some event in player's character fires (such as their `Humanoid` `dying`). Such an event might not directly reference the Player object, but this method provides easy access. The inverse of this function can be described as getting the Character of a Player. To do this, simply access the Character property.

## Code Samples

### Player Part Touch Detection

When pasted into a `Script` within a `Part`, this code sample detects when a `Player` touches the part and prints their name.
```lua
local Players = game:GetService("Players")

local part = script.Parent
local function onTouched(part)
	local player = Players:GetPlayerFromCharacter(part.Parent)
	if not player then return end
	print(player.Name .. " pressed me!")
end
part.Touched:Connect(onTouched)
```

### Players:GetPlayerFromCharacter


```lua

local character = game.Workspace.Player
local player = game.Players:GetPlayerFromCharacter(character)
 
if player then
    print("Player is " .. player.Name)
else
    print("Player doesn't exist!")
end

```

@param character A character instance that you want to get the player from.
@returns A player instance corresponding to the character passed as input. */
	GetPlayerFromCharacter(character: Model): Player | undefined;
	/** This method returns a table of all presently connected `Player`. It functions the same way `GetChildren` would except that it only returns Player objects. It functions similarly to `GetChildren` when called on `Players`. 0 When used in conjunction with a for-loop, it is useful for iterating over all players in a game.

```lua
Players = game:GetService("Players")
for i, player in pairs(Players:GetPlayers()) do
	print(player.Name)
end
```

Scripts that connect to `PlayerAdded` are often trying to process every Player that connects to the game. This method is useful for iterating over already-connected players that wouldn't fire `PlayerAdded`. Using this method ensures that no player is missed!

```lua
local Players = game:GetService("Players")

local onPlayerAdded(player)
	print("Player: " .. player.Name)
end

for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
Players.PlayerAdded:Connect(onPlayerAdded)
```

## Code Samples

### Give Sparkles to Everyone

This code sample listens for players spawning and gives them Sparkles in their head. It does this by defining two functions, `onPlayerSpawned` and `onPlayerAdded`. It calls these functions for players/characters already in the game, in case the script runs after players already arrive.
```lua
local Players = game:GetService("Players")

local function onCharacterAdded(character)
	-- Give them sparkles on their head if they don't have them yet
	if not character:FindFirstChild("Sparkles") then
		local sparkles = Instance.new("Sparkles")
		sparkles.Parent = character:WaitForChild("Head")
	end
end

local function onPlayerAdded(player)
	-- Check if they already spawned in
	if player.Character then
		onCharacterAdded(player.Character)
	end
	-- Listen for the player (re)spawning 
	player.CharacterAdded:Connect(onCharacterAdded)
end

-- Iterate over each player already connected
-- to the game using a generic for-loop
for i, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end
-- Listen for newly connected players
Players.PlayerAdded:Connect(onPlayerAdded)

```

@returns A table containing all the players in the server. */
	GetPlayers(): Array<Player>;
	/** This function returns a `Model` containing the assets which the player is wearing, excluding gear.

If you prefer a Lua table of information about these assets instead of a model, use `GetCharacterAppearanceInfoAsync`.

This method behaves similar to `LoadAsset`, and is like using `LoadAsset` on the asset information returned by `GetCharacterAppearanceInfoAsync` except faster.

## Code Samples

### How To Get A Character's Appearance

This example demonstrates how to retrieve a character's appearance.

The returned `Model` is not a child of Workspace by default. If you want the model to be visible, its `parent` property must be set.
```lua
local appearanceModel = game.Players:GetCharacterAppearanceAsync(772462)
appearanceModel.Parent = game.Workspace
```

@param userId The `Player/UserId` of the specified player
@returns A `Model` containing the assets which the player is wearing, excluding gear */
	GetCharacterAppearanceAsync(userId: number): Model | undefined;
	/** This function returns information about a player's avatar (ignoring gear) on the Roblox website in the form of a dictionary. It is not to be confused with `GetCharacterAppearanceAsync`, which actually loads the assets described by this method. You can use `LoadAsset` to load the assets that are used in the player's avatar. The structure of the returned dictionary is as follows:

| Name | Type | Description |
| --- | --- | --- |
| `bodyColors` | table (see below) | Describes the BrickColor values for each limb |
| `assets` | table (see below) | Describes the equipped assets (hats, body parts, etc) |
| `defaultPantsApplied` | bool | Describes whether default pants are applied |
| `defaultShirtApplied` | bool | Describes whether default shirt is applied |
| `playerAvatarType` | string | Either "R15" or "R6" |
| `scales` | table (see below) | Describes various body scaling factors |

### Assets sub-table
The assets table is an array of tables containing the following keys that describe the assets currently equipped by the player:

| Name | Type | Description |
| --- | --- | --- |
| `id` | number | The asset ID of the equipped asset |
| `assetType` | table | A table with `name` and `id` fields, each describing the kind of asset equipped ("Hat", "Face", etc.) |
| `name` | string | The name of the equipped asset |


### Scales sub-table
The scales table has the following keys, each a number corresponding to one `Humanoid` scaling property:
`bodyType`, `head`, `height`, `proportion`, `depth`, `width`

### Body Colors sub-table
The body colors table has the following keys, each a number corresponding to a `BrickColor` ID number which can be used with `BrickColor.new(id)`: `leftArmColorId`, `torsoColorId`, `rightArmColorId`, `headColorId`, `leftLegColorId`, `rightLegColorId`

## Code Samples

### Example Return Character Appearance Dictionary

Sometimes it is best to see an example of the returned dictionary structure in pure Lua. Here is one such example of a player whose avatar uses a package and wears several hats. Can you guess who it is?
```lua
local t = {
	playerAvatarType = "R15",
	defaultPantsApplied = false,
	defaultShirtApplied = false,
	scales = {
		bodyType = 0,
		head = 1,
		height = 1.05,
		proportion = 0,
		depth = 0.92,
		width = 0.85
	},
	bodyColors = {
		leftArmColorId = 1030,
		torsoColorId = 1001,
		rightArmColorId = 1030,
		headColorId = 1030,
		leftLegColorId = 1001,
		rightLegColorId = 1001
	},
	assets = {
		{
			id = 1031492,
			assetType = {
				name = "Hat",
				id = 8
			},
			name = "Striped Hat"
		},
		{
			id = 13062491,
			assetType = {
				name = "Face Accessory",
				id = 42
			},
			name = "Vision Française "
		},
		{
			id = 16598440,
			assetType = {
				name = "Neck Accessory",
				id = 43
			},
			name = "Red Bow Tie"
		},
		{
			id = 28999228,
			assetType = {
				name = "Face",
				id = 18
			},
			name = "Joyous Surprise"
		},
		{
			id = 86896488,
			assetType = {
				name = "Shirt",
				id = 11
			},
			name = "Expensive Red Tuxedo Jacket"
		},
		{
			id = 86896502,
			assetType = {
				name = "Pants",
				id = 12
			},
			name = "Expensive Red Tuxedo Pants"
		},
		{
			id = 376530220,
			assetType = {
				name = "Left Arm",
				id = 29
			},
			name = "ROBLOX Boy Left Arm"
		},
		{
			id = 376531012,
			assetType = {
				name = "Right Arm",
				id = 28
			},
			name = "ROBLOX Boy Right Arm"
		},
		{
			id = 376531300,
			assetType = {
				name = "Left Leg",
				id = 30
			},
			name = "ROBLOX Boy Left Leg"
		},
		{
			id = 376531703,
			assetType = {
				name = "Right Leg",
				id = 31
			},
			name = "ROBLOX Boy Right Leg"
		},
		{
			id = 376532000,
			assetType = {
				name = "Torso",
				id = 27
			},
			name = "ROBLOX Boy Torso"
		}
	}
}
```

@param userId The **userId* of the specified player.
@returns A dictionary containing information about the character appearance of a given user. */
	GetCharacterAppearanceInfoAsync(userId: number): CharacterAppearanceInfo;
	/** The GetFriends `Players` function returns a `FriendPages` object which contains information for all of the given `Player's` friends. The items within the FriendPages object are tables with the following fields:

| Name | Type | Description |
| --- | --- | --- |
| Id | int64 | The friend's UserId |
| Username | string | The friend's username |
| IsOnline | bool | If the friend is currently online |


See the code samples for an easy way to iterate over all a player's friends.

## Code Samples

### Print Roblox Friends

This code sample loads the `UserId` of the player whose username is provided at the top of the script by using `GetUserIdFromNameAsync`. Then, it gets a `FriendPages` object by calling `GetFriendsAsync` and iterates over each entry using the `iterPageItems` function. The username of each friend is stored in a table, then printed at the end.
```lua
local Players = game:GetService("Players")

local USERNAME = "Shedletsky"

local function iterPageItems(pages)
	return coroutine.wrap(function()
		local pagenum = 1
		while true do
			for _, item in ipairs(pages:GetCurrentPage()) do
				coroutine.yield(item, pagenum)
			end
			if pages.IsFinished then
				break
			end
			pages:AdvanceToNextPageAsync()
			pagenum = pagenum + 1
		end
	end)
end

-- First, get the user ID of the player
local userId = Players:GetUserIdFromNameAsync(USERNAME)
-- Then, get a FriendPages object for their friends
local friendPages = Players:GetFriendsAsync(userId)
-- Iterate over the items in the pages. For FriendPages, these
-- are tables of information about the friend, including Username.
-- Collect each username in a table
local usernames = {}
for item, pageNo in iterPageItems(friendPages) do
	table.insert(usernames, item.Username)
end
-- and finally, print!
print("Friends of " .. USERNAME .. ": " table.concat(usernames, ", "))
```

@param userId The **userId** of the player being specified.
@returns A `FriendPages` object which contains information for all of the given player's friends. */
	GetFriendsAsync(userId: number): FriendPages;

	GetHumanoidDescriptionFromOutfitId(outfitId: number): HumanoidDescription;

	GetHumanoidDescriptionFromUserId(userId: number): HumanoidDescription;
	/** The GetNameFromUserIdAsync `Players` function will send a query to the Roblox website asking what the username is of the account with the given `UserId`.

This method errors if no account exists with the given UserId. If you aren't certain such an account exists, it's recommended to wrap calls to this function with `pcall`. In addition, you can manually cache results to make future calls with the same UserId fast. See the code samples to learn how to do this.

## Code Samples

### Fast Username Lookup

This code sample demonstrates memoization (not memorization!) of the `GetNameFromUserIdAsync` method. It uses a table to cache the results of the function. It also uses `pcall` in case the UserId doesn't exist.
```lua
local Players = game:GetService("Players")

-- Memoization: since these results are rarely (if ever) going to change
-- all we have to do is check a cache table for the UserId.
-- If we find the UserId, then we have no work to do! Just return the name (fast).
-- If we don't find the UserId (cache miss), go look it up (takes time).
local cache = {}
function getUsernameFromUserId(userId)
	-- First, check if the cache contains the name
	if cache[userId] then return cache[userId] end
	-- Second, check if the user is already connected to the server
	local player = Players:GetPlayerByUserId(userId)
	if player then
		cache[userId] = player.Name
		return player.Name
	end 
	-- If all else fails, send a request
	local name
	pcall(function ()
		name = Players:GetNameFromUserIdAsync(userId)
	end)
	cache[userId] = name
	return name
end

print(getUsernameFromUserId(269323)) --> Ozzypig
print(getUsernameFromUserId(269323)) --> Ozzypig, but this one returns much quicker
print(getUsernameFromUserId(261)) --> Shedletsky

```

@param userId The `Player/UserId` of the player being specified
@returns The name of a user with the specified `Player/UserId` */
	GetNameFromUserIdAsync(userId: number): string;
	/** This function will send a query to the Roblox website asking what the `UserId` is of the account with the given `Player` name.

This method errors if no account exists with the given username. If you aren't certain such an account exists, it's recommended to wrap calls to this function with `pcall`. In addition, you can manually cache results to quickly make future calls with the same username. See the code samples to learn how to do this.

## Code Samples

### Fast User ID Lookup

This code sample demonstrates memoization (not memorization!) of the `GetUserIdFromNameAsync` method. It uses a table to cache the results of the function. It also uses `pcall` in case the username doesn't exist.
```lua
local Players = game:GetService("Players")

-- Memoization: since these results are rarely (if ever) going to change
-- all we have to do is check a cache table for the name.
-- If we find the name, then we have no work to do! Just return the user id (fast).
-- If we don't find the name (cache miss), go look it up (takes time).
local cache = {}
function getUserIdFromUsername(name)
	-- First, check if the cache contains the name
	if cache[name] then return cache[name] end
	-- Second, check if the user is already connected to the server
	local player = Players:FindFirstChild(name)
	if player then
		cache[name] = player.UserId
		return player.UserId
	end 
	-- If all else fails, send a request
	local id
	pcall(function ()
		id = Players:GetUserIdFromNameAsync(name)
	end)
	cache[name] = id
	return id
end

print(getUserIdFromUsername("Ozzypig")) --> 269323
print(getUserIdFromUsername("Ozzypig")) --> 269323, but this one returns much quicker
print(getUserIdFromUsername("Shedletsky")) --> 261

```

@param userName The **username** of the player being specified
@returns The `Player/UserId` of a user whose name is specified */
	GetUserIdFromNameAsync(userName: string): number;
	/** This function fetches a `content URL` of an image of a player's avatar given their `UserId`, the image size (as an enum) and type (also an enum: avatar, bust, headshot). It also returns a bool describing if the image is ready to be used.

Most often, this method is used with `Image` to display player pictures next to their username in-game. It is also appropriate for `Texture` as well.

## Available Sizes
`Enum.ThumbnailSize`: `Size48x48`, `Size60x60`, `Size100x100`, `Size150x150`, `Size180x180`, `Size353x353`, `Size420x420`

## Types of User Thumbnails

| Enum.ThumbnailType | Description | Example (60px) |
| --- | --- | --- |
| `AvatarBust` | Upper chest and head | ![](https://www.roblox.com/bust-thumbnail/image?userId=269323&width=60&height=60&format=png) |
| `AvatarThumbnail` | Entire avatar | ![](https://www.roblox.com/avatar-thumbnail/image?userId=269323&width=60&height=60&format=png) |
| `HeadShot` |
Just the head and face | ![](https://www.roblox.com/headshot-thumbnail/image?userId=269323&width=60&height=60&format=png) |

## Code Samples

### Display Player Thumbnail

This code sample displays the current player's thumbnail in a parent `ImageLabel` by using `GetUserThumbnailAsync` and setting the `Image` property as well as its `Size`.
```lua
local Players = game:GetService("Players")

local player = Players.LocalPlayer

-- Fetch the thumbnail
local userId = player.UserId
local thumbType = Enum.ThumbnailType.HeadShot
local thumbSize = Enum.ThumbnailSize.Size420x420
local content, isReady = Players:GetUserThumbnailAsync(userId, thumbType, thumbSize)

-- Set the ImageLabel's content to the user thumbnail
local imageLabel = script.Parent
imageLabel.Image = content
imageLabel.Size = UDim2.new(0, 420, 0, 420)
```

@param userId The `Player/UserId` of the player being specified
@param thumbnailType A `Enum/ThumbnailType` describing the type of thumbnail
@param thumbnailSize A `Enum/ThumbnailSize` specifying the size of the thumbnail
@returns A tuple containing the content URL of a user thumbnail based on the specified parameters, and a bool describing if the image is ready to be used or not */
	GetUserThumbnailAsync(
		userId: number,
		thumbnailType: CastsToEnum<Enum.ThumbnailType>,
		thumbnailSize: CastsToEnum<Enum.ThumbnailSize>,
	): LuaTuple<[string, boolean]>;
	/** The PlayerAdded event fires when a player enters the game. This is used to fire an event when a player joins a game, such as loading the player's saved `GlobalDataStore` data. 

This can be used alongside the `PlayerRemoving` event, which fires when a player is about to leave the game. For instance, if you would like print a message every time a new player joins or leaves the game:

```lua
local Players = game:GetService("Players")

Players.PlayerAdded:Connect(function(player)
	print(player.Name .. " joined the game!")
end)

Players.PlayerRemoving:Connect(function(player)
	print(player.Name .. " left the game!")
end)
```


If you want to track when a player's character is added or removed from the game, such as when a player respawns or dies, you can use the `CharacterAdded` and `CharacterRemoving` functions.

Notes
----------

 - Up until recently, this event didn't work on the client (in `Localscript`s), but this has been changed

 - This event does not work as expected in *solo mode*, because the player is created before scripts that connect to PlayerAdded run. To handle this case, as well as cases in which the script is added into the game after a player enters, create an OnPlayerAdded function that you can call to handle a player's entrance.

## Code Samples

### Players.PlayerAdded

This example will print "A player has entered: " followed by the name of the player that enters/joins a game every time a player joins.
```lua
game.Players.PlayerAdded:Connect(function(player)
	print("A player has entered: " .. player.Name)
end)
```
 */
	readonly PlayerAdded: RBXScriptSignal<(player: Player) => void>;
	/** The PlayerRemoving event fires right before a `Player` is leaves the game. This event fires before `ChildRemoved` does on `Players`, and behaves somewhat similarly to `DescendantRemoving`. Since event fires before the actual removal of a `Player`, this event is useful to store player data using a `GlobalDataStore`.

This can be used alongside the `PlayerAdded` event, which fires when a player joins the game. For instance, if you would like print a message every time a new player joins or leaves the game:

    local Players = game:GetService("Players")
    
    Players.PlayerAdded:Connect(function(player)
    	print(player.Name + " joined the game!")
    end)
    
    Players.PlayerRemoving:Connect(function(player)
    	print(player.Name + " left the game!")
    end)

If you want to track when a player's character is added or removed from the game, such as when a player respawns or dies, you can use the `CharacterAdded` and `CharacterRemoving` functions.

## Code Samples

### Players.PlayerRemoving

This code will print "A player has left: ", followed by the player's name, every time a player leaves:
```lua
game.Players.PlayerRemoving:Connect(function(player)
    print("A player has left: " .. player.Name)
end)
```
 */
	readonly PlayerRemoving: RBXScriptSignal<(player: Player) => void>;
}

/** Plugin is the main object responsible for creating basic studio widgets. It is a custom add-on to Studio which adds new behavior and features that are not normally included.

Both the `using animation Animation Editor` and `Intro To Terrain Tools`
 were originally developed as plugins. There are also many plugins made by the Roblox community that you can use to help make games and experiences.

## See also
`Intro to Plugins`, an introductory article to plugin use and development */
interface Plugin extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Plugin";
	/** Returns whether the user enabled _Collisions_
 in studio under the Model tab.Returns whether the user enabled _Collisions_
 in studio under the Model tab.

Tags: ReadOnly, NotReplicated */
	readonly CollisionEnabled: boolean;
	/** Returns the grid size the user has set in studio under the Model tab. This can be 1, 0.2 or 0.01, but has rounding errors.
The 1/5th option should return 0.2, but could return 0.20000000298023 instead. This code can be used to get the real gridsize:

```lua
local gridsize = plugin.GridSize
if math.abs(gridsize-0.2) < 0.005 then -- Check if the gridsize is between 0.195 and 0.205
	gridsize = 0.2
elseif math.abs(gridsize-0.01) < 0.005 then -- Between 0.005 and 0.015
	gridsize = 0.01
else -- Assume it's 1
	gridsize = 1
end
```Returns the grid size the user has set in studio under the Model tab. This can be 1, 0.2 or 0.01, but has rounding errors.
The 1/5th option should return 0.2, but could return 0.20000000298023 instead. This code can be used to get the real gridsize:

```lua
local gridsize = plugin.GridSize
if math.abs(gridsize-0.2) < 0.005 then -- Check if the gridsize is between 0.195 and 0.205
	gridsize = 0.2
elseif math.abs(gridsize-0.01) < 0.005 then -- Between 0.005 and 0.015
	gridsize = 0.01
else -- Assume it's 1
	gridsize = 1
end
```

Tags: ReadOnly, NotReplicated */
	readonly GridSize: number;
}

/** PluginAction is an object that represents a generic performable action in Roblox Studio, with no directly associated `Toolbar` or `Button`. In Roblox Studio, they can be assigned a keyboard shortcut under `File → Advanced → Customize Shortcuts...`, and they can also be added to the Quick Access Toolbar.

PluginActions must be created using the `CreatePluginAction` function in order to work as expected. */
interface PluginAction extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginAction";
	/** A string that uniquely identifies this action. This string is the key used when saving and loading the action's state in Roblox Studio.A string that uniquely identifies this action. This string is the key used when saving and loading the action's state in Roblox Studio.

Tags: ReadOnly, NotReplicated */
	readonly ActionId: string;
	/** [LACKS DOCUMENTATION]

Tags: ReadOnly, NotReplicated */
	readonly AllowBinding: boolean;
	/** The description of the action, when viewing it from the keyboard shortcuts window in Roblox Studio.The description of the action, when viewing it from the keyboard shortcuts window in Roblox Studio.

Tags: ReadOnly, NotReplicated */
	readonly StatusTip: string;
	/** The text that is displayed when viewing this action in Roblox Studio.The text that is displayed when viewing this action in Roblox Studio.

Tags: ReadOnly, NotReplicated */
	readonly Text: string;
}

interface PluginDragEvent extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginDragEvent";
	/** [LACKS DOCUMENTATION]

Tags: ReadOnly, NotReplicated */
	readonly Data: string;
	/** [LACKS DOCUMENTATION]

Tags: ReadOnly, NotReplicated */
	readonly MimeType: string;
	/** [LACKS DOCUMENTATION]

Tags: ReadOnly, NotReplicated */
	readonly Position: Vector2;
	/** [LACKS DOCUMENTATION]

Tags: ReadOnly, NotReplicated */
	readonly Sender: string;
}

/** PluginGuiService is a service that stores `PluginGui` objects to be displayed in Roblox Studio. It only allows PluginGuis to be direct children of the service, and PluginGuis are not allowed to be parented anywhere besides the service. */
interface PluginGuiService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginGuiService";
}

/** A singleton class used to create `Plugins`. Has been superseded by the [official plugins feature](https://developer.roblox.com/articles/Intro-to-Plugins)
, but can be used to create plugins with the command bar.

The PluginManager object can be retrieved using the deprecated `PluginManager()` function. */
interface PluginManager extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginManager";
}

/** A context menu that can be shown in Studio. It displays a list of PluginActions and supports submenus.

PluginMenus must be created using the `CreatePluginMenu` function in order to work as expected.

## See also
  - `Intro to Plugins`, an introductory article to plugin use and development
  - `PluginAction`, an object that represents a generic performable action in Roblox Studio, with no directly associated `Toolbar` or `Button`.
  - `CreatePluginAction`, creates a PluginAction
  - `Title`, the text to be displayed when used as a sub menu
  - `Icon`, the icon to be displayed when used as a sub menu
  - `AddAction`, adds the given action to the menu
  - `AddNewAction`, creates a temporary action that is hidden from Studio's customize shortcuts window
  - `AddMenu`, adds the given menu as a separator
  - `AddSeparator`, adds a separator between items in the menu
  - `Clear`, clears the menu
  - `ShowAsync`, shows the menu at the mouse cursor. Yields until either an item is selected or the menu is closed. The selected action fires its Triggered event

## Code Samples

### Creating a PluginAction and PluginMenu

This code sample visualizes how `PluginMenus` and `PluginActions` behave when created for a `Plugin`. Outside of this example, you should not parent the plugin or its functional components to the game’s workspace.

In order to work as expected, the code block must but pasted into the command bar, but only once. Consecutive attempts at executing the code in the command bar will result in an error because a plugin cannot create more than one PluginMenu with the same id.

After executing the code, changing the created `BoolValue` in the game’s workspace via the Explorer window opens the plugin’s menus. Selecting an action from the menus the function connected to the trigger signal.

![Example Plugin in Studio Explorer Window](https://developer.roblox.com/assets/5c8affb64f9ad00f434ccbd4/PluginDemoInExplorer.png)
```lua
-- This code can be pasted into the command bar, but only once.

local plugin = plugin or getfenv().PluginManager():CreatePlugin()
plugin.Name = "Plugin"
plugin.Parent = workspace

local pluginMenu = plugin:CreatePluginMenu(math.random(), "Test Menu")
pluginMenu.Name = "Test Menu"

pluginMenu:AddNewAction("ActionA", "A", "rbxasset://textures/loading/robloxTiltRed.png")
pluginMenu:AddNewAction("ActionB", "B", "rbxasset://textures/loading/robloxTilt.png")

local subMenu = plugin:CreatePluginMenu(math.random(), "C", "rbxasset://textures/explosion.png")
subMenu.Name = "Sub Menu"

subMenu:AddNewAction("ActionD", "D", "rbxasset://textures/whiteCircle.png")
subMenu:AddNewAction("ActionE", "E", "rbxasset://textures/icon_ROBUX.png")

pluginMenu:AddMenu(subMenu)
pluginMenu:AddSeparator()

pluginMenu:AddNewAction("ActionF", "F", "rbxasset://textures/sparkle.png")

local toggle = Instance.new("BoolValue")
toggle.Name = "TogglePluginMenu"
toggle.Parent = workspace

local function onToggled()
	if toggle.Value then
		toggle.Value = false
		
		local selectedAction = pluginMenu:ShowAsync()
		if selectedAction then
			print("Selected Action:", selectedAction.Text, "with ActionId:", selectedAction.ActionId)
		else
			print("User did not select an action!")
		end
	end
end

toggle.Changed:Connect(onToggled)
```
 */
interface PluginMenu extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginMenu";
	/** This property determines the icon to be displayed when used as a sub menu. It defaults to an empty string `””`.

## See also
  - `Intro to Plugins`, an introductory article to plugin use and development
  - `PluginAction`, an object that represents a generic performable action in Roblox Studio, with no directly associated `Toolbar` or `Button`.
  - `CreatePluginAction`, creates a PluginAction
  - `Title`, the text to be displayed when used as a sub menu
  - `AddAction`, adds the given action to the menu
  - `AddNewAction`, creates a temporary action that is hidden from Studio's customize shortcuts window
  - `AddMenu`, adds the given menu as a separator
  - `AddSeparator`, adds a separator between items in the menu
  - `Clear`, clears the menu
  - `ShowAsync`, shows the menu at the mouse cursor. Yields until either an item is selected or the menu is closed. The selected action fires its Triggered event

## Code Samples

### Creating a PluginAction and PluginMenu

This code sample visualizes how `PluginMenus` and `PluginActions` behave when created for a `Plugin`. Outside of this example, you should not parent the plugin or its functional components to the game’s workspace.

In order to work as expected, the code block must but pasted into the command bar, but only once. Consecutive attempts at executing the code in the command bar will result in an error because a plugin cannot create more than one PluginMenu with the same id.

After executing the code, changing the created `BoolValue` in the game’s workspace via the Explorer window opens the plugin’s menus. Selecting an action from the menus the function connected to the trigger signal.

![Example Plugin in Studio Explorer Window](https://developer.roblox.com/assets/5c8affb64f9ad00f434ccbd4/PluginDemoInExplorer.png)
```lua
-- This code can be pasted into the command bar, but only once.

local plugin = plugin or getfenv().PluginManager():CreatePlugin()
plugin.Name = "Plugin"
plugin.Parent = workspace

local pluginMenu = plugin:CreatePluginMenu(math.random(), "Test Menu")
pluginMenu.Name = "Test Menu"

pluginMenu:AddNewAction("ActionA", "A", "rbxasset://textures/loading/robloxTiltRed.png")
pluginMenu:AddNewAction("ActionB", "B", "rbxasset://textures/loading/robloxTilt.png")

local subMenu = plugin:CreatePluginMenu(math.random(), "C", "rbxasset://textures/explosion.png")
subMenu.Name = "Sub Menu"

subMenu:AddNewAction("ActionD", "D", "rbxasset://textures/whiteCircle.png")
subMenu:AddNewAction("ActionE", "E", "rbxasset://textures/icon_ROBUX.png")

pluginMenu:AddMenu(subMenu)
pluginMenu:AddSeparator()

pluginMenu:AddNewAction("ActionF", "F", "rbxasset://textures/sparkle.png")

local toggle = Instance.new("BoolValue")
toggle.Name = "TogglePluginMenu"
toggle.Parent = workspace

local function onToggled()
	if toggle.Value then
		toggle.Value = false
		
		local selectedAction = pluginMenu:ShowAsync()
		if selectedAction then
			print("Selected Action:", selectedAction.Text, "with ActionId:", selectedAction.ActionId)
		else
			print("User did not select an action!")
		end
	end
end

toggle.Changed:Connect(onToggled)
```
This property determines the icon to be displayed when used as a sub menu. It defaults to an empty string `””`.

## See also
  - `Intro to Plugins`, an introductory article to plugin use and development
  - `PluginAction`, an object that represents a generic performable action in Roblox Studio, with no directly associated `Toolbar` or `Button`.
  - `CreatePluginAction`, creates a PluginAction
  - `Title`, the text to be displayed when used as a sub menu
  - `AddAction`, adds the given action to the menu
  - `AddNewAction`, creates a temporary action that is hidden from Studio's customize shortcuts window
  - `AddMenu`, adds the given menu as a separator
  - `AddSeparator`, adds a separator between items in the menu
  - `Clear`, clears the menu
  - `ShowAsync`, shows the menu at the mouse cursor. Yields until either an item is selected or the menu is closed. The selected action fires its Triggered event

## Code Samples

### Creating a PluginAction and PluginMenu

This code sample visualizes how `PluginMenus` and `PluginActions` behave when created for a `Plugin`. Outside of this example, you should not parent the plugin or its functional components to the game’s workspace.

In order to work as expected, the code block must but pasted into the command bar, but only once. Consecutive attempts at executing the code in the command bar will result in an error because a plugin cannot create more than one PluginMenu with the same id.

After executing the code, changing the created `BoolValue` in the game’s workspace via the Explorer window opens the plugin’s menus. Selecting an action from the menus the function connected to the trigger signal.

![Example Plugin in Studio Explorer Window](https://developer.roblox.com/assets/5c8affb64f9ad00f434ccbd4/PluginDemoInExplorer.png)
```lua
-- This code can be pasted into the command bar, but only once.

local plugin = plugin or getfenv().PluginManager():CreatePlugin()
plugin.Name = "Plugin"
plugin.Parent = workspace

local pluginMenu = plugin:CreatePluginMenu(math.random(), "Test Menu")
pluginMenu.Name = "Test Menu"

pluginMenu:AddNewAction("ActionA", "A", "rbxasset://textures/loading/robloxTiltRed.png")
pluginMenu:AddNewAction("ActionB", "B", "rbxasset://textures/loading/robloxTilt.png")

local subMenu = plugin:CreatePluginMenu(math.random(), "C", "rbxasset://textures/explosion.png")
subMenu.Name = "Sub Menu"

subMenu:AddNewAction("ActionD", "D", "rbxasset://textures/whiteCircle.png")
subMenu:AddNewAction("ActionE", "E", "rbxasset://textures/icon_ROBUX.png")

pluginMenu:AddMenu(subMenu)
pluginMenu:AddSeparator()

pluginMenu:AddNewAction("ActionF", "F", "rbxasset://textures/sparkle.png")

local toggle = Instance.new("BoolValue")
toggle.Name = "TogglePluginMenu"
toggle.Parent = workspace

local function onToggled()
	if toggle.Value then
		toggle.Value = false
		
		local selectedAction = pluginMenu:ShowAsync()
		if selectedAction then
			print("Selected Action:", selectedAction.Text, "with ActionId:", selectedAction.ActionId)
		else
			print("User did not select an action!")
		end
	end
end

toggle.Changed:Connect(onToggled)
```


Tags: NotReplicated */
	Icon: string;
	/** This property determines the text to be displayed when a `PluginMenu` is used as a sub menu. It defaults to an empty string `””`.

## See also
  - `Intro to Plugins`, an introductory article to plugin use and development
  - `PluginAction`, an object that represents a generic performable action in Roblox Studio, with no directly associated `Toolbar` or `Button`.
  - `CreatePluginAction`, creates a PluginAction
  - `Icon`, the icon to be displayed when used as a sub menu
  - `AddAction`, adds the given action to the menu
  - `AddNewAction`, creates a temporary action that is hidden from Studio's customize shortcuts window
  - `AddMenu`, adds the given menu as a separator
  - `AddSeparator`, adds a separator between items in the menu
  - `Clear`, clears the menu
  - `ShowAsync`, shows the menu at the mouse cursor. Yields until either an item is selected or the menu is closed. The selected action fires its Triggered event

## Code Samples

### Creating a PluginAction and PluginMenu

This code sample visualizes how `PluginMenus` and `PluginActions` behave when created for a `Plugin`. Outside of this example, you should not parent the plugin or its functional components to the game’s workspace.

In order to work as expected, the code block must but pasted into the command bar, but only once. Consecutive attempts at executing the code in the command bar will result in an error because a plugin cannot create more than one PluginMenu with the same id.

After executing the code, changing the created `BoolValue` in the game’s workspace via the Explorer window opens the plugin’s menus. Selecting an action from the menus the function connected to the trigger signal.

![Example Plugin in Studio Explorer Window](https://developer.roblox.com/assets/5c8affb64f9ad00f434ccbd4/PluginDemoInExplorer.png)
```lua
-- This code can be pasted into the command bar, but only once.

local plugin = plugin or getfenv().PluginManager():CreatePlugin()
plugin.Name = "Plugin"
plugin.Parent = workspace

local pluginMenu = plugin:CreatePluginMenu(math.random(), "Test Menu")
pluginMenu.Name = "Test Menu"

pluginMenu:AddNewAction("ActionA", "A", "rbxasset://textures/loading/robloxTiltRed.png")
pluginMenu:AddNewAction("ActionB", "B", "rbxasset://textures/loading/robloxTilt.png")

local subMenu = plugin:CreatePluginMenu(math.random(), "C", "rbxasset://textures/explosion.png")
subMenu.Name = "Sub Menu"

subMenu:AddNewAction("ActionD", "D", "rbxasset://textures/whiteCircle.png")
subMenu:AddNewAction("ActionE", "E", "rbxasset://textures/icon_ROBUX.png")

pluginMenu:AddMenu(subMenu)
pluginMenu:AddSeparator()

pluginMenu:AddNewAction("ActionF", "F", "rbxasset://textures/sparkle.png")

local toggle = Instance.new("BoolValue")
toggle.Name = "TogglePluginMenu"
toggle.Parent = workspace

local function onToggled()
	if toggle.Value then
		toggle.Value = false
		
		local selectedAction = pluginMenu:ShowAsync()
		if selectedAction then
			print("Selected Action:", selectedAction.Text, "with ActionId:", selectedAction.ActionId)
		else
			print("User did not select an action!")
		end
	end
end

toggle.Changed:Connect(onToggled)
```
This property determines the text to be displayed when a `PluginMenu` is used as a sub menu. It defaults to an empty string `””`.

## See also
  - `Intro to Plugins`, an introductory article to plugin use and development
  - `PluginAction`, an object that represents a generic performable action in Roblox Studio, with no directly associated `Toolbar` or `Button`.
  - `CreatePluginAction`, creates a PluginAction
  - `Icon`, the icon to be displayed when used as a sub menu
  - `AddAction`, adds the given action to the menu
  - `AddNewAction`, creates a temporary action that is hidden from Studio's customize shortcuts window
  - `AddMenu`, adds the given menu as a separator
  - `AddSeparator`, adds a separator between items in the menu
  - `Clear`, clears the menu
  - `ShowAsync`, shows the menu at the mouse cursor. Yields until either an item is selected or the menu is closed. The selected action fires its Triggered event

## Code Samples

### Creating a PluginAction and PluginMenu

This code sample visualizes how `PluginMenus` and `PluginActions` behave when created for a `Plugin`. Outside of this example, you should not parent the plugin or its functional components to the game’s workspace.

In order to work as expected, the code block must but pasted into the command bar, but only once. Consecutive attempts at executing the code in the command bar will result in an error because a plugin cannot create more than one PluginMenu with the same id.

After executing the code, changing the created `BoolValue` in the game’s workspace via the Explorer window opens the plugin’s menus. Selecting an action from the menus the function connected to the trigger signal.

![Example Plugin in Studio Explorer Window](https://developer.roblox.com/assets/5c8affb64f9ad00f434ccbd4/PluginDemoInExplorer.png)
```lua
-- This code can be pasted into the command bar, but only once.

local plugin = plugin or getfenv().PluginManager():CreatePlugin()
plugin.Name = "Plugin"
plugin.Parent = workspace

local pluginMenu = plugin:CreatePluginMenu(math.random(), "Test Menu")
pluginMenu.Name = "Test Menu"

pluginMenu:AddNewAction("ActionA", "A", "rbxasset://textures/loading/robloxTiltRed.png")
pluginMenu:AddNewAction("ActionB", "B", "rbxasset://textures/loading/robloxTilt.png")

local subMenu = plugin:CreatePluginMenu(math.random(), "C", "rbxasset://textures/explosion.png")
subMenu.Name = "Sub Menu"

subMenu:AddNewAction("ActionD", "D", "rbxasset://textures/whiteCircle.png")
subMenu:AddNewAction("ActionE", "E", "rbxasset://textures/icon_ROBUX.png")

pluginMenu:AddMenu(subMenu)
pluginMenu:AddSeparator()

pluginMenu:AddNewAction("ActionF", "F", "rbxasset://textures/sparkle.png")

local toggle = Instance.new("BoolValue")
toggle.Name = "TogglePluginMenu"
toggle.Parent = workspace

local function onToggled()
	if toggle.Value then
		toggle.Value = false
		
		local selectedAction = pluginMenu:ShowAsync()
		if selectedAction then
			print("Selected Action:", selectedAction.Text, "with ActionId:", selectedAction.ActionId)
		else
			print("User did not select an action!")
		end
	end
end

toggle.Changed:Connect(onToggled)
```


Tags: NotReplicated */
	Title: string;
}

/** A PluginToolbar is an object created by using the `CreateToolbar` method. It is used to create `PluginToolbarButton`s using the `CreateButton` function. In general, it is good practice for a plugin to use **one and only one** uniquely named toolbar for all of its buttons. In Roblox Studio, toolbars are rendered under the Plugins tab.

![A screenshot of Roblox Studio's Plugins tab, rendering several PluginToolbars](https://developer.roblox.com/assets/5c48e228da4c5b970f6efb58/PluginToolbar-light.png)

Pictured above are three PluginToolbars in Roblox Studio: Animations, Three Wise Monkeys and Localization. The center toolbar is a custom toolbar created by a plugin; the other toolbars are created by built-in Roblox Studio plugins.

## Example
The following code sample creates a basic toolbar with one button. It should be run as a Roblox Studio plugin, and not run as a `Script`.

```lua
local toolbar = plugin:CreateToolbar("Three Wise Monkeys")
local button = toolbar:CreateButton("Mizaru", "See No Evil", "rbxassetid://2778270261")
``` */
interface PluginToolbar extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginToolbar";
}

/** A PluginToolbarButton is an object created by the `CreateButton` function. It allows the user to initiate a single, one-off action in Roblox Studio through the `Click` event. Pictured below are three PluginToolbarButtons. From left to right: the default, hover and pressed states. The hovered button in the center shows tooltip text, which is the 2nd argument passed to `CreateButton`.

![Three PluginToolbarButtons rendered on a PluginToolbar titled "Three Wise Monkeys"](https://developer.roblox.com/assets/5c48e310f8a426690c84250e/PluginToolbarButton-light.png)

## Behavior

When pressed, the `Click` event fires. A button will also remain in the pressed state, which may be set manually using `SetActive`. Upon plugin activation (`Activate`), buttons in all other `PluginToolbar`s will be toggled off. If all buttons in a toolbar are off, the toolbar's plugin is deactivated (`Deactivate`).

When the game viewport is not visible, buttons will be disabled as if their `Enabled` property were false. Disabled buttons are desaturated and do not respond to user clicks. By setting `ClickableWhenViewportHidden` to true, you can allow plugin buttons to remain clickable (such as during script editing).

## History

* Prior to an update released in January 2019, this class was simply known as "Button". This was changed to reduce confusion with similarly named in-game UI element classes, such as `TextButton`. */
interface PluginToolbarButton extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PluginToolbarButton";
	/** [LACKS DOCUMENTATION]

Tags: NotReplicated */
	ClickableWhenViewportHidden: boolean;
	/** [LACKS DOCUMENTATION]

Tags: NotReplicated */
	Enabled: boolean;
	/** [LACKS DOCUMENTATION]

Tags: NotReplicated */
	Icon: string;
}

/** The PointsService class controls points. 

Points are an award system used to showcase a player's achievements and participation throughout Roblox. How points are awarded through this service is at the discretion of the game's developer. */
interface PointsService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PointsService";
	/** This event fires when points have been successfully awarded to a player, whilst also passing along the updated balance of points the player has in the current game and all games.

When a player is awarded points successfully the below example would print the userId and their new point balance. If, for example, the Roblox account was awarded thirty points (and had none to begin with)

> User: 1 has now earned 30 (+30) points in the current game, now making
> their total balance

would be printed.

```lua
local function pointsAwarded(userId, pointsAwarded, userBalanceInGame, userTotalBalance)
	print("User: " .. userId .. " has now earned " .. userBalanceInGame .. " (+" .. pointsAwarded ..") points in the current game, now making their total balance " .. userTotalBalance)
end

game:GetService("PointsService").PointsAwarded:Connect(pointsAwarded)
```

## Code Samples

### PointsService.PointsAwarded

When a player is awarded points successfully the below example would print the userId and their new point balance. If, for example, the Roblox account was awarded thirty points (and had none to begin with) "User: 1 has now earned 30 (+30) points in the current game, now making their total balance 30" would be printed.
```lua
game:GetService("PointsService").PointsAwarded:Connect(function(userId, pointsAwarded, userBalanceInGame, userTotalBalance)
    print("User: " .. userId .. " has now earned " .. userBalanceInGame .. " (+" .. pointsAwarded ..") points in the current game, now making their total balance " .. userTotalBalance)
end)
```
 */
	readonly PointsAwarded: RBXScriptSignal<(userId: number, pointsAwarded: number, userBalanceInGame: number, userTotalBalance: number) => void>;
}

/** A Pose holds the `CFrame` applied to the `Motor6D` connected to its associated `BasePart`. The part which is controlled depends on the name of the Pose.

Poses are the fundamental building blocks of animations and, with `Keyframes`, make up `KeyframeSequences`.

## Poses, joints and hierarchy

Although a Pose is assigned to a `BasePart` by name, the object manipulated during animation playback is actually the `Motor6D` connected to this part. Animation rigs branch out from the model's root part through such joints.

As an example. In a R15 character rig the root part is the HumanoidRootPart. The LowerTorso is connected to the HumanoidRootPart by the a motor named 'Root'. Therefore, the `CFrame` of a Pose named 'LowerTorso' in a `Keyframe` would be applied to the motor named 'Root', and not the LowerTorso itself.

Poses are arranged in a `Keyframe` based on joint hierarchy. This means, the Pose's `CFrame` is applied to the motor connecting the part associated with the pose to the part associated with the pose's parent. See below for a visual example of the structure of Poses on a R15 character.

![][1]

## Pose CFrame

The Roblox animation system applies `CFrame` to the corresponding `Motor6D` by manipulating the relative transformation of the motor, the `Transform` property. The original `C0` and `C1` values are not changed.

## Code Samples

### Keyframe Reset Poses

This code sample includes a function to reset the CFrame of the Poses in a Keyframe.
```lua
    local function resetPoses(parent)
    	-- both functions are equivalent to GetChildren
    	local poses = parent:IsA("Keyframe") and parent:GetPoses() 
    		or parent:IsA("Pose") and parent:GetSubPoses()
    
    	for _, pose in pairs(poses) do 
    		if pose:IsA("Pose") then
    			pose.CFrame = CFrame.new()
    			-- recurse
    			resetPoses(pose)
    		end
    	end
    end
```

### Keyframe Generate Poses

This sample includes a function that will generate a 'blank' keyframe containing blank poses for all of the model's connected parts in the correct hierarchical order.
```lua
    local function generateKeyframe(model)
    	if not model.PrimaryPart then
    		warn("No primary part set")
    		return
    	end
    	
    	local rootPart = model.PrimaryPart:GetRootPart()
    
    	if not rootPart then
    		warn("Root part not found")
    		return
    	end
    
    	local partsAdded = {}
    	partsAdded[rootPart] = true
    
    	local function addPoses(part, parentPose)
    		-- get all of the joints attached to the part 
    		for _, joint in pairs(part:GetJoints()) do
    			-- we're only interested in Motor6Ds
    			if joint:IsA("Motor6D") then
    				-- find the connected part
    				local connectedPart = nil
    				if joint.Part0 == part then 
    					connectedPart = joint.Part1
    				elseif joint.Part1 == part then 
    					connectedPart = joint.Part0
    				end	
    				if connectedPart then 	
    					-- make sure we haven't already added this part
    					if not partsAdded[connectedPart] then
    						partsAdded[connectedPart] = true
    						-- create a pose
    						local pose = Instance.new("Pose")
    						pose.Name = connectedPart.Name
    						parentPose:AddSubPose(pose)
    						-- recurse
    						addPoses(connectedPart, pose)
    					end
    				end			
    			end
    		end
    	end
    
    	local keyframe = Instance.new("Keyframe")
    
    	-- populate the keyframe
    	local rootPose = Instance.new("Pose")
    	rootPose.Name = rootPart.Name 
    	addPoses(rootPart, rootPose)
    	keyframe:AddPose(rootPose)
    
    	return keyframe
    end
```
 */
interface Pose extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Pose";
	/** The `CFrame` that will be applied to the `Motor6D` corresponding with the `Pose`. This `CFrame` is applied by changing the `Motor6D\Transform` property of the motor. The original `C0` and `C1` values are not changed.

`Pose` objects are arranged in a `Keyframe` based on joint hierarchy. This means, the the `CFrame` is applied to the motor connecting the part associated with the pose to the part associated with the pose’s parent. */
	CFrame: CFrame;
	/** The EasingDirection determines the 'direction' of the interpolation style set by `EasingStyle`. Along with `EasingStyle`, it determines how the joint will interpolate from this `Pose` to the subsequent `Pose` during animation playback.

##Pose EasingDirection Values

 - **In** - Interpolation will play forwards, default value for poses
 - **Out** - Interpolation will play in reverse, default value in animation edtior
 - **InOut** - Interpolation will play forwards, then reverse at the mid-point

Note, this property is a `PoseEasingDirection`, which despite sharing the same options is different to the `EasingDirection` used by other objects. Attempting to set this property to an `EasingDirection` value will produce an error.


##Pose Interpolation

The `CFrame` of each `Pose` determines the `Transform` of the joint associated with the pose at the time of its parent `Keyframe`. It does not reach this value instantly, but interpolates from the previous pose applied to that joint (which may not necessarily be in the previous keyframe).

The way in which a joint will interpolate between two `Pose`s during animation playback is determined by the `EasingStyle` and EasingDirection of the first pose.

## Code Samples

### Keyframe Add/Remove Pose

This sample demonstrates quickly the Keyframe.AddPose, Keyframe.RemovePose and Pose.AddSubPose and Pose.RemoveSubPose functions. Note these are functionally equivalent to parenting and un-parenting the poses.
```lua
local keyframe = Instance.new("Keyframe", workspace)

local pose = Instance.new("Pose")
pose.EasingStyle = Enum.PoseEasingStyle.Cubic
pose.EasingDirection = Enum.PoseEasingDirection.Out
local pose2 = Instance.new("Pose")
pose2.EasingStyle = Enum.PoseEasingStyle.Cubic
pose2.EasingDirection = Enum.PoseEasingDirection.Out

keyframe:AddPose(pose) -- pose.Parent = keyframe

wait(2)

keyframe:RemovePose(pose) -- pose.Parent = nil 

wait(2)

keyframe:AddPose(pose) -- pose.Parent = keyframe

wait(2)

pose:AddSubPose(pose2) -- pose2.Parent = pose

wait(2)

pose:RemoveSubPose(pose2) -- pose2.Parent = nil
```
 */
	EasingDirection: Enum.PoseEasingDirection;
	/** The EasingStyle determines the 'style' of the interpolation. Along with `EasingDirection`, it determines how the joint will interpolate from this `Pose` to the subsequent `Pose` during animation playback.

##Pose EasingStyle Values

 - **Linear** - Linear interpolation
 - **Constant** - Does not interpolate but snaps to the next pose. The point at which this occurs is determined by `EasingDirection`. 
	 - **In** - Happens immediately
	 - **Out** - Happens at the time of the next pose
	 - **InOut** - Happens at the midpoint between poses
 - **Elastic** - Springs back and overshoots the target in an elastic manner
 - **Cubic** - Cubic interpolation, speed changes as target nears
 - **Bounce** - Bounces several times before reaching the target

![enter image description here](https://developer.roblox.com/assets/blt5b5cb41b1d832713/Easing_-_Copy.gif)

Note, this property is a `PoseEasingStyle`, which is different to the `EasingStyle` used by other objects. Attempting to set this property to an `EasingStyle` value will produce an error.

##Pose Interpolation

The `CFrame` of each `Pose` determines the `Transform` of the joint associated with the pose at the time of its parent `Keyframe`. It does not reach this value instantly, but interpolates from the previous pose applied to that joint (which may not necessarily be in the previous keyframe).

The way in which a joint will interpolate between two `Pose`s during animation playback is determined by the `EasingStyle` and EasingDirection of the first pose.

## Code Samples

### Keyframe Add/Remove Pose

This sample demonstrates quickly the Keyframe.AddPose, Keyframe.RemovePose and Pose.AddSubPose and Pose.RemoveSubPose functions. Note these are functionally equivalent to parenting and un-parenting the poses.
```lua
local keyframe = Instance.new("Keyframe", workspace)

local pose = Instance.new("Pose")
pose.EasingStyle = Enum.PoseEasingStyle.Cubic
pose.EasingDirection = Enum.PoseEasingDirection.Out
local pose2 = Instance.new("Pose")
pose2.EasingStyle = Enum.PoseEasingStyle.Cubic
pose2.EasingDirection = Enum.PoseEasingDirection.Out

keyframe:AddPose(pose) -- pose.Parent = keyframe

wait(2)

keyframe:RemovePose(pose) -- pose.Parent = nil 

wait(2)

keyframe:AddPose(pose) -- pose.Parent = keyframe

wait(2)

pose:AddSubPose(pose2) -- pose2.Parent = pose

wait(2)

pose:RemoveSubPose(pose2) -- pose2.Parent = nil
```
 */
	EasingStyle: Enum.PoseEasingStyle;

	Weight: number;
	/** This function adds a sub `Pose` to the `Pose` by parenting it to it. It is functionally identical to setting the new pose's `Parent` to the pose.

Note, this function will not error when an instance other than a `Pose` is given as the pose parameter and will parent it successfully.

## Code Samples

### Keyframe Add/Remove Pose

This sample demonstrates quickly the Keyframe.AddPose, Keyframe.RemovePose and Pose.AddSubPose and Pose.RemoveSubPose functions. Note these are functionally equivalent to parenting and un-parenting the poses.
```lua
local keyframe = Instance.new("Keyframe", workspace)

local pose = Instance.new("Pose")
pose.EasingStyle = Enum.PoseEasingStyle.Cubic
pose.EasingDirection = Enum.PoseEasingDirection.Out
local pose2 = Instance.new("Pose")
pose2.EasingStyle = Enum.PoseEasingStyle.Cubic
pose2.EasingDirection = Enum.PoseEasingDirection.Out

keyframe:AddPose(pose) -- pose.Parent = keyframe

wait(2)

keyframe:RemovePose(pose) -- pose.Parent = nil 

wait(2)

keyframe:AddPose(pose) -- pose.Parent = keyframe

wait(2)

pose:AddSubPose(pose2) -- pose2.Parent = pose

wait(2)

pose:RemoveSubPose(pose2) -- pose2.Parent = nil
```

@param pose The `Pose` to be added. */
	AddSubPose(pose: Pose): void;
	/** This function returns an array containing all sub `Pose`s that have been added to a `Pose`. This is functionally the same as using the `GetChildren` function on the `Pose`.

Note, this function will return all children of the `Pose`, including non `Pose` `Instance`s if any are present.

## Code Samples

### Keyframe Reset Poses

This code sample includes a function to reset the CFrame of the Poses in a Keyframe.
```lua
    local function resetPoses(parent)
    	-- both functions are equivalent to GetChildren
    	local poses = parent:IsA("Keyframe") and parent:GetPoses() 
    		or parent:IsA("Pose") and parent:GetSubPoses()
    
    	for _, pose in pairs(poses) do 
    		if pose:IsA("Pose") then
    			pose.CFrame = CFrame.new()
    			-- recurse
    			resetPoses(pose)
    		end
    	end
    end
```

@returns An array of sub `Pose`s. */
	GetSubPoses(): Array<Instance>;
	/** This function removes a sub `Pose` from the `Pose` by parenting it to nil. It is functionally identical to setting the new pose's `Parent` to nil.

Note, this function will not error when an instance other than a `Pose` is given as the pose parameter and remove it successfully.

## Code Samples

### Keyframe Add/Remove Pose

This sample demonstrates quickly the Keyframe.AddPose, Keyframe.RemovePose and Pose.AddSubPose and Pose.RemoveSubPose functions. Note these are functionally equivalent to parenting and un-parenting the poses.
```lua
local keyframe = Instance.new("Keyframe", workspace)

local pose = Instance.new("Pose")
pose.EasingStyle = Enum.PoseEasingStyle.Cubic
pose.EasingDirection = Enum.PoseEasingDirection.Out
local pose2 = Instance.new("Pose")
pose2.EasingStyle = Enum.PoseEasingStyle.Cubic
pose2.EasingDirection = Enum.PoseEasingDirection.Out

keyframe:AddPose(pose) -- pose.Parent = keyframe

wait(2)

keyframe:RemovePose(pose) -- pose.Parent = nil 

wait(2)

keyframe:AddPose(pose) -- pose.Parent = keyframe

wait(2)

pose:AddSubPose(pose2) -- pose2.Parent = pose

wait(2)

pose:RemoveSubPose(pose2) -- pose2.Parent = nil
```

@param pose The `Pose` to be removed. */
	RemoveSubPose(pose: Pose): void;
}

interface RbxInternalPostEffect extends RbxInternalInstance {
	/** Toggles whether or not the PostEffect is enabled. */
	Enabled: boolean;
}
/** PostEffect is an abstract base class for post-processing effects, such as `BloomEffect` and `ColorCorrectionEffect`. They change how the world looks **after** it has been rendered. They do not affect `GuiObject`s. Objects of this kind should be parented to the `Lighting` or the `CurrentCamera` in order to work.

It should also be noted that some post-processing effects will work differently or **not at all** when Roblox is set to a low `QualityLevel` (or `EditQualityLevel` in Studio). On some low-end devices, faster rendering algorithms may be used. By default, these quality settings are set to Automatic, so if you aren't seeing post-processing effects you should check Roblox's settings under the "Rendering" section. It may be necessary to override the automatic behavior temporarily in order to preview post-processing effects. */
type PostEffect = BloomEffect | BlurEffect | ColorCorrectionEffect | SunRaysEffect;

/** The BloomEffect creates the effect of a camera viewing very bright light. It causes brighter colors to glow, similar to applying the Neon `Material` to everything, including the the `Sky`. Multiple BloomEffect objects can be used at the same time; doing so can further strengthen the result. Like other post-processing effects, objects of this type will only work while `Enabled` and when parented to `Lighting` or the `CurrentCamera`.

The render behavior may also change or **disable completely** depending on the `EditQualityLevel` (in Studio) or the `QualityLevel`. If you don't see BloomEffect rendering, check Roblox's settings. If set to Automatic, Roblox may choose a lower quality level which isn't high enough to render BloomEffect. You can override this manually: In Studio, at Level07 and below, BloomEffect does not render at all. At Level08 through Level11 a simple algorithm is used, and at Level12 and above the default behavior is used. */
interface BloomEffect extends RbxInternalPostEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BloomEffect";
	/** Intensity determines how intensely the colors that bloom (as determined by the `Threshold`) will additively blend with themselves. Higher values will produce brighter colors. By default, this value is 0.4. In Studio, this property can be set on the range [0, 1], though any value in the range [0, 4] will produce change. Values outside of this range have undefined behavior. */
	Intensity: number;
	/** Size determines the radius of the bloom effect in pixels in a similar manner to `Size`. Larger values create a wider bloom effect, and a value of 0 will disable the bleed (but not the color adjustment). By default, this value is 24. Although this property can be set to any float, only values in the range [0, 56] produce change. Values outside of this range have undefined behavior. */
	Size: number;
	/** Threshold determines how bright a color can be before it blooms. By default, this value is 0.95, which means that a pixel's color must have a lightness of 95% in order to bloom. If set to 1, only pure white colors will bloom. Conversely, if you set this to 0 all colors will bloom.  In Studio, the slider is bound to [0.8, 1]; however, values in the range [0, 1] are valid too. Values outside of this range have undefined behavior. */
	Threshold: number;
}

/** BlurEffect will apply a [Gaussian blur](https://en.wikipedia.org/wiki/Gaussian_blur) to the image of the world rendered by Roblox. The strength of the blur is controlled by the `Size`. Only one BlurEffect can be applied at once — the BlurEffect with the greatest Size takes priority. Like other `post-processing effects`, objects of this kind will only work when `Enabled` and parented to the `Lighting` or `Workspace.CurrentCamera`.

Note: on some low-end devices, BlurEffect may not render for performance. Keep this in mind when using this effect for mobile games.

## Example
`Size` = 0 (or no BlurEffect at all):
![No change](/assets/5b2db585fda2af4e7866ab7d/Brightness0.png)
`Size` = 10:
![BlurEffect with Size = 10](/assets/5b2db58568a9cd0a78be426b/Blur10.png)
`Size` = 50:
![BlurEffect applie with Size = 50](/assets/5b2db5855928634658e3ce06/Blur50.png) */
interface BlurEffect extends RbxInternalPostEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BlurEffect";
	/** Size controls the blur radius. The larger the size, the blurrier the screen will become. It is measured in pixels. By default, this value is 24. Although this value is a float and can be set without being clamped, only integer values in the range [0, 56] will produce a change.

## Example
`Size` = 0 (or no BlurEffect at all):
![No change](/assets/5b2db585fda2af4e7866ab7d/Brightness0.png)
`Size` = 10:
![BlurEffect with Size = 10](/assets/5b2db58568a9cd0a78be426b/Blur10.png)
`Size` = 50:
![BlurEffect applie with Size = 50](/assets/5b2db5855928634658e3ce06/Blur50.png) */
	Size: number;
}

/** ColorCorrectionEffect is a post-processing effect that can be used to adjust several color-related properties at once: `Saturation`, `TintColor`, `Brightness` and `Contrast`.  It is useful for fine-tuning the visual aesthetic of a world, or communicating status effects to the player such as flashing the world red upon taking damage, or going grayscale on character death. Like all `PostEffect` objects, objects of this kind should be parented to either the `Lighting` or the `CurrentCamera` to work.

Multiple ColorCorrectionEffects can be applied at once, and they will compose their effects together. For example, if you use one with a yellow `TintColor` and another with a blue tint, you will see green. Using more than one object can further strengthen the effects.

# Example
No ColorCorrectionEffect (original):
![No change](/assets/5b2db585fda2af4e7866ab7d/Brightness0.png)
Increased Saturation (`Saturation` = 1):
![Increased saturation](/assets/5b2db361ca8406e05d89fa2e/ColorSaturated.png)
No Saturation (`Saturation` = -1):
![No saturation](/assets/5b2db361cfc846f95726a8fc/Saturation-1.png)
Sepia (No saturation plus `TintColor`):
![Sepia effect](/assets/5b2db3615928634658e3ce00/ColorSepia.png) */
interface ColorCorrectionEffect extends RbxInternalPostEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ColorCorrectionEffect";
	/** Brightness determines by how much the colors of pixels will be shifted. This value works multiplicatively across many ColorCorrectionEffects' Brightnesses. A value of -1 will cause all pixels to be completely black, and a value of 1 will cause them to be white. By default, this value is 0 (no shift). Only values in the range [-1, 1] will produce a change. Values outside of this range have undefined behavior.

This property should be carefully tuned along with `Contrast` to create the desired color adjustment.

## Examples
Brightness of 0 vs -0.5:
Brightness of 0 vs 0.5:



  [1]: https://images.contentstack.io/v3/assets/bltc2ad39afa86662c8/bltc3deedcf50c436da/5b2db585fda2af4e7866ab7d/Brightness0.png
  [2]: https://images.contentstack.io/v3/assets/bltc2ad39afa86662c8/blt324e99d2306fbe66/5b3fd07bd0af7f6e0ba49a5b/Brightness-0.5.png
  [3]: https://images.contentstack.io/v3/assets/bltc2ad39afa86662c8/blt82ebfb4a8ad69539/5b3fd082d873a86d0baed76b/Brightness0.5.png */
	Brightness: number;
	/** Contrast determines the separation between the dark and light colors. This value works multiplicatively across many ColorCorrectionEffects' Contrasts. Values less than 0 have reduced contrast, and values greater than 0 have increased contrast. By default, this value is 0 (no change). Only values in the range [-1, 1] will produce a change. Values outside of this range have undefined behavior.

## Examples
Contrast of 0 vs 0.5:
Contrast of 0 vs -0.5:


  [1]: https://images.contentstack.io/v3/assets/bltc2ad39afa86662c8/blt0538a81c68335ac2/5b3fd4d3cbdac88b0b7f2dce/Contrast0.5.png
  [2]: https://images.contentstack.io/v3/assets/bltc2ad39afa86662c8/bltb466e83eee457f1a/5b3fd4da811ef5800bf7c393/Contrast-0.5.png */
	Contrast: number;
	/** Saturation determines the change in intensity of pixel colors. Values above 1 will have cause colors to be more vivid, while values below 0 will make colors more dull, eventually reaching grayscale at -1.  By default, this value is 0 (no change). Although any float value can be entered for this property, only values in the range [-1, 1] have defined behavior.

## Example
Saturation of 0 vs -1:
Saturation of 0 vs 1:


  [1]: https://images.contentstack.io/v3/assets/bltc2ad39afa86662c8/blt3c5e095a9246bce0/5b3fd68db496a3810b47f270/Saturation-1.png
  [2]: https://images.contentstack.io/v3/assets/bltc2ad39afa86662c8/blt619f44d80359b1cc/5b3fd693c321297a0b1bbc51/Saturation1.png */
	Saturation: number;
	/** TintColor determines by what factors the RGB channels of pixel colors are scaled. The effect is multiplicative, so changing this to `(255, 0, 0)` (red) would cause the green and blue channels to be multiplied by 0. This works similarly to how `ImageColor3` works.

## Example
Drag the slider below to see how a red (`Color3.fromRGB(255,0,0)`) TintColor affects this scene. Notice how blue and green colors become very dark. */
	TintColor: Color3;
}

/** SunRaysEffect is a post-processing effect which renders a halo of light around sun. The halo is shaped/blocked by world objects between the `CurrentCamera` and the sun. It is helpful in simulating dust or fog in the air. Remember: subtlety is key. sun rays can become annoying to the eye if they are even slightly too strong. Like all `PostEffect` objects, objects of this kind should be parented to either the `Lighting` or the `CurrentCamera` to work.

This object does not work on mobile devices for performance reasons. In Studio, the `EditQualityLevel` must be Level16 or higher in order for SunRaysEffect to render.

## Example
Pictured below is a SunRaysEffect in Crossroads. Notice how the tower blocks portions of the halo around the sun.
![SunRaysEffect in the Crossroads place](/assets/5b2db36179099e4b58a77443/Sunrays.jpg) */
interface SunRaysEffect extends RbxInternalPostEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SunRaysEffect";
	/** Intensity determines the opacity of the sun rays. Values closer to 0 are less visible, while values closer 1 become more visible. By default, this value is 0.25. Although this property can be set to any float, only values in the range [0, 1] are valid. Values outside of this range have undefined behavior. */
	Intensity: number;
	/** Spread determines by how wide the sun rays will spread across the sky. By default, this property is set to 1. Although this property can be set to any valid float, only values in the range [0, 1] produce a change. Values out of this range have undefined behavior. */
	Spread: number;
}

/** A currently unused object whose functionality was split into `ReflectionMetadataClasses` and `ReflectionMetadataEnums`. */
interface ReflectionMetadata extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadata";
}

/** Acts as a `Folder` containing information about callbacks for a `ReflectionMetadataClass`, and should be parented to it.
`ReflectionMetadataMember`s that are parented to this object will be perceived as callbacks under the class this is parented to. */
interface ReflectionMetadataCallbacks extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataCallbacks";
}

/** Acts as a `Folder` for `ReflectionMetadataClass` objects. */
interface ReflectionMetadataClasses extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataClasses";
}

/** The ReflectionMetadataEnums is the class that acts as a `Folder` for `ReflectionMetadataEnum` objects.

Since it is an internal object, it cannot be used by developers. */
interface ReflectionMetadataEnums extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataEnums";
}

/** Acts as a `Folder` containing information about events for a `ReflectionMetadataClass`, and should be parented to it.
`ReflectionMetadataMember`s that are parented to this object will be perceived as events under the class this is parented to. */
interface ReflectionMetadataEvents extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataEvents";
}

/** Acts as a `Folder` containing information about functions for a `ReflectionMetadataClass`, and should be parented to it.
`ReflectionMetadataMember`s that are parented to this object will be perceived as functions under the class this is parented to. */
interface ReflectionMetadataFunctions extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataFunctions";
}

interface RbxInternalReflectionMetadataItem extends RbxInternalInstance {
	/** When this value is true, it means that this property/class can be seen in Studio, e.g. in the explorer. */
	Browsable: boolean;
	/** Describes the category of this class. */
	ClassCategory: string;
	/** [LACKS DOCUMENTATION] */
	ClientOnly: boolean;
	/** Describes a constraint for a single-argument function whose argument type is a `ClassName`.
Currently there are two constraints available:

| Constraint | Description |
| isScriptCreatable | The specified class must be creatable with Instance.new |
| isService | The specified class must be a service. | */
	Constraint: string;
	/** When an object is deprecated, it should not be used anymore for new scripts. */
	Deprecated: boolean;
	/** Toggles whether this property can be edited from the Properties window. */
	EditingDisabled: boolean;
	/** This should determine if a method needs to use stuff on the Roblox main servers. This property isn't applied where it should be, though. */
	IsBackend: boolean;
	/** Describes the context where this member can be used.

If set to ["Server"](https://developer.roblox.com/articles/String "String"), this member will not be available to auto fill when editing a `LocalScript`.

If set to ["Client"](https://developer.roblox.com/articles/String "String"), this member will not be available to auto fill when editing a `Script`. */
	ScriptContext: string;
	/** [LACKS DOCUMENTATION] */
	ServerOnly: boolean;
	/** The maximum value of this property. Used with `UIMinimum` to control the slider bar of this property in the _Properties_
 window. */
	UIMaximum: number;
	/** The minimum value of this property. Used with `UIMaximum` to control the slider bar of this property in the _Properties_
 window. */
	UIMinimum: number;
	/** The number of potential values the property's slider bar can be set to, between [UIMinimum](https://developer.roblox.com/api-reference/property/ReflectionMetadataItem/UIMinimum "UIMinimum") and [UIMaximum](https://developer.roblox.com/api-reference/property/ReflectionMetadataItem/UIMaximum "UIMaximum")
. */
	UINumTicks: number;
	/** This summary gives a description of the item, as given by the Roblox developers while working on it. */
	summary: string;
}
/** Acts as abstract properties for generic information about Classes, Members, Enums, and EnumItems. */
type ReflectionMetadataItem = ReflectionMetadataClass | ReflectionMetadataEnum | ReflectionMetadataEnumItem | ReflectionMetadataMember;

/** Registers information about a class, and its members.
Should be parented to `ReflectionMetadataClasses` */
interface ReflectionMetadataClass extends RbxInternalReflectionMetadataItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataClass";
	/** A number index, which refers to a specific class icon. */
	ExplorerImageIndex: number;
	/** Determines how this class is sorted in the Explorer compared to other classes. */
	ExplorerOrder: number;
	/** Toggles whether or not this object can be inserted through the Advanced Objects menu. */
	Insertable: boolean;
	/** Sets the class that this class would prefer parenting to. */
	PreferredParent: string;
	/** [LACKS DOCUMENTATION] */
	PreferredParents: string;
}

/** The ReflectionMetadataEnum is the class that registers information about an Enum, and its EnumItems. It should be parented to `ReflectionMetadataEnums`.

Since it is an internal object, it cannot be used by developers. */
interface ReflectionMetadataEnum extends RbxInternalReflectionMetadataItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataEnum";
}

/** The ReflectionMetadataEnumItem is the class containing information about a specific EnumItem embedded within an Enum and should be parented to a `ReflectionMetadataEnum`.

Since it is an internal object, it cannot be used by developers. */
interface ReflectionMetadataEnumItem extends RbxInternalReflectionMetadataItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataEnumItem";
}

/** ReflectionMetadataMember represents either a _Function_, _YieldFunction_, or _Property_
 in Roblox's ReflectionMetadata. */
interface ReflectionMetadataMember extends RbxInternalReflectionMetadataItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataMember";
}

/** Acts as a `Folder` containing information about properties for a `ReflectionMetadataClass`, and should be parented to it.
`ReflectionMetadataMember`s that are parented to this object will be perceived as properties under the class this is parented to. */
interface ReflectionMetadataProperties extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataProperties";
}

/** Acts as a `Folder` containing information about yielding functions for a `ReflectionMetadataClass`, and should be parented to it.
`ReflectionMetadataMember`s that are parented to this object will be perceived as yielding functions under the class this is parented to. */
interface ReflectionMetadataYieldFunctions extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReflectionMetadataYieldFunctions";
}

/** A **RemoteEvent** is designed to provide a one-way message between the server and clients, allowing `Scripts` to call code in `LocalScripts` and vice-versa
. This message can be directed from one client to the server, from the server to a particular client, or from the server to all clients.

In order for both the server and clients to utilize a remote event, the RemoteEvent object itself must be in a place where both sides can see it. As such, we recommend that you store the RemoteEvent inside of `ReplicatedStorage`, although in some cases it's appropriate to store it in the workspace or inside a `Tool`.

If you need the result of the call, you should use a `RemoteFunction` instead. Otherwise a remote event is recommended since it will minimize network traffic/latency and won't yield the script to wait for a response. See `Remote Functions and Remote Functions and Events` for more info.

## Code Samples

### RemoteEvents: Client to Server

In order for a client to send a message to the server, it needs to fire the `RemoteEvent` with the function `FireServer` in a `LocalScript`.

The server meanwhile needs to connect a function to the OnServerEvent of the RemoteEvent.

When a client calls the FireServer function, any functions on the server that are connected to OnServerEvent will fire. Note that this is not immediate - the network connection between the client and server will determine how quickly this happens.

When firing a RemoteEvent from a client to the server, data can be included in the firing. By default, the functions connected to OnServerEvent will be passed the player who fired the event as the first parameter. If any other arguments are provided in the FireServer function, they will also be included in OnServerEvent after the player argument.
```lua
-- LocalScript
 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local createPartEvent = ReplicatedStorage:WaitForChild("CreatePartEvent")
 
createPartEvent:FireServer(BrickColor.Green(), Vector3.new(10, 20, 0))


-- ========================================


-- Script
 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local createPartEvent = Instance.new("RemoteEvent", ReplicatedStorage)
createPartEvent.Name = "CreatePartEvent"
 
local function onCreatePartFired(player, color, position)
	print(player.Name, "wants to create a part")
	local newPart = Instance.new("Part")
	newPart.BrickColor = color
	newPart.Position = position
	newPart.Parent = game.Workspace
end
 
createPartEvent.OnServerEvent:Connect(onCreatePartFired)
```

### RemoteEvents: Server to a Single Client

The server can send messages to the client through remote events in two ways: it can send a message to an individual client or it can send a message to every client at the same time.

In order to send a message to a single client, the FireClient function should be called from the server via a `Script`.

To listen for the message on the client, a `LocalScript` needs to connect a function to the OnClientEvent event of the RemoteEvent.
```lua
-- Script

local Players = game:GetService("Players")
 
local welcomePlayerEvent = Instance.new("RemoteEvent")
welcomePlayerEvent.Parent = game.ReplicatedStorage
welcomePlayerEvent.Name = "WelcomePlayerEvent"
 
local function onPlayerAdded(player)
	welcomePlayerEvent:FireClient(player)
end
 
Players.PlayerAdded:Connect(onPlayerAdded)


-- ========================================


--LocalScript 

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local player = Players.LocalPlayer
local welcomePlayerEvent = ReplicatedStorage:WaitForChild("WelcomePlayerEvent")
local playerGui = player:WaitForChild("PlayerGui")
 
local welcomeScreen = Instance.new("ScreenGui")
welcomeScreen.Parent = playerGui
local welcomeMessage = Instance.new("TextLabel")
welcomeMessage.Size = UDim2.new(0, 200, 0, 50)
welcomeMessage.Parent = welcomeScreen
welcomeMessage.Visible = false
welcomeMessage.Text = "Welcome to the game!"
 
local function onWelcomePlayerFired()
	welcomeMessage.Visible = true
	wait(3)
	welcomeMessage.Visible = false
end
 
welcomePlayerEvent.OnClientEvent:Connect(onWelcomePlayerFired)
```

### RemoteEvents: Server to Multiple Clients

The server can send messages to the client through remote events in two ways: it can send a message to an individual client or it can send a message to every client at the same time.

To fire a message to all clients, the server needs to call `FireAllClients`. Note that in this case a player does not have to be passed into the arguments (as the function fires the remote event on all of the connected clients).

To listen for this event, each client needs to connect a function to OnClientEvent.
```lua
-- Script

local Players = game:GetService("Players")
 
local newPlayerEvent = Instance.new("RemoteEvent")
newPlayerEvent.Parent = game.ReplicatedStorage
newPlayerEvent.Name = "NewPlayer"
 
local function onPlayerAdded(player)
	newPlayerEvent:FireAllClients()
end
 
Players.PlayerAdded:Connect(onPlayerAdded)


-- ========================================


--LocalScript (for each client)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local player = Players.LocalPlayer
local newPlayerEvent = ReplicatedStorage:WaitForChild("NewPlayerEvent")
local playerGui = player:WaitForChild("PlayerGui")
 
local welcomeScreen = Instance.new("ScreenGui")
welcomeScreen.Parent = playerGui
local newPlayerMessage = Instance.new("TextLabel")
newPlayerMessage.Size = UDim2.new(0, 200, 0, 50)
newPlayerMessage.Parent = welcomeScreen
newPlayerMessage.Visible = false
newPlayerMessage.Text = "A new player has joined the game!"
 
local function onNewPlayerFired()
	newPlayerMessage.Visible = true
	wait(3)
	newPlayerMessage.Visible = false
end
 
newPlayerEvent.OnClientEvent:Connect(onNewPlayerFired)
```
 */
interface RemoteEvent extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RemoteEvent";
	/** The FireAllClients function fires the `OnClientEvent` event for each client. 

Unlike `FireClient`, this event does not take a target player as an argument. Instead it will fire to all clients who have the same remote event connected to an OnClientEvent event.

Since this function is used to communicate from the server to the client, it will only work when used in a `Script`.

The functionality of this function, as well as other `RemoteEvent` and `RemoteFunction` events and functions, is well documented in [this][1] article.

Note
----------

 - Data can be passed from server to client through remote events in the same way data is passed from client to server. Any extra information can be passed in as arguments to the `FireClient` and FireAllClients functions. Note that the FireClient function still needs to pass the player to send the message to as the first argument.


  [1]: /articles/Remote-Functions-and-Events

## Code Samples

### RemoteEvents: Server to Multiple Clients

The server can send messages to the client through remote events in two ways: it can send a message to an individual client or it can send a message to every client at the same time.

To fire a message to all clients, the server needs to call `FireAllClients`. Note that in this case a player does not have to be passed into the arguments (as the function fires the remote event on all of the connected clients).

To listen for this event, each client needs to connect a function to OnClientEvent.
```lua
-- Script

local Players = game:GetService("Players")
 
local newPlayerEvent = Instance.new("RemoteEvent")
newPlayerEvent.Parent = game.ReplicatedStorage
newPlayerEvent.Name = "NewPlayer"
 
local function onPlayerAdded(player)
	newPlayerEvent:FireAllClients()
end
 
Players.PlayerAdded:Connect(onPlayerAdded)


-- ========================================


--LocalScript (for each client)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local player = Players.LocalPlayer
local newPlayerEvent = ReplicatedStorage:WaitForChild("NewPlayerEvent")
local playerGui = player:WaitForChild("PlayerGui")
 
local welcomeScreen = Instance.new("ScreenGui")
welcomeScreen.Parent = playerGui
local newPlayerMessage = Instance.new("TextLabel")
newPlayerMessage.Size = UDim2.new(0, 200, 0, 50)
newPlayerMessage.Parent = welcomeScreen
newPlayerMessage.Visible = false
newPlayerMessage.Text = "A new player has joined the game!"
 
local function onNewPlayerFired()
	newPlayerMessage.Visible = true
	wait(3)
	newPlayerMessage.Visible = false
end
 
newPlayerEvent.OnClientEvent:Connect(onNewPlayerFired)
```

@param arguments The arguments that will be passed to all `RemoteEvent/OnClientEvent` methods.
@returns No return. */
	FireAllClients(...arguments: Array<unknown>): void;
	/** Fires `OnClientEvent` for the specified player.  Only [connections][1] in `LocalScript`s that are running on the specified player's client will fire. This varies from the RemoteFunction class which will queue requests.

Since this function is used to communicate from the server to the client, it will only work when used in a `Script`.

The functionality of this function, as well as other `RemoteEvent` and `RemoteFunction` events and functions, is well documented in [this][2] article.

Notes
----------

 - Data can be passed from server to client through remote events in the same way data is passed from client to server. Any extra information can be passed in as arguments to the FireClient and `FireAllClients` functions. Note that the FireClient function still needs to pass the player to send the message to as the first argument.

 - Sometimes a game will need to send information from one client to another. Roblox does not support direct client to client contact, so any communication must first go through the server. This is typically done using remote events (although functions could be used if desired). First, the sending client would call FireServer. On the server, the function connected to OnServerEvent would hear this firing, and itself would then call FireClient.


  [1]: /api-reference/datatype/RBXScriptConnection
  [2]: /articles/Remote-Functions-and-Events

## Code Samples

### RemoteEvents: Server to a Single Client

The server can send messages to the client through remote events in two ways: it can send a message to an individual client or it can send a message to every client at the same time.

In order to send a message to a single client, the FireClient function should be called from the server via a `Script`.

To listen for the message on the client, a `LocalScript` needs to connect a function to the OnClientEvent event of the RemoteEvent.
```lua
-- Script

local Players = game:GetService("Players")
 
local welcomePlayerEvent = Instance.new("RemoteEvent")
welcomePlayerEvent.Parent = game.ReplicatedStorage
welcomePlayerEvent.Name = "WelcomePlayerEvent"
 
local function onPlayerAdded(player)
	welcomePlayerEvent:FireClient(player)
end
 
Players.PlayerAdded:Connect(onPlayerAdded)


-- ========================================


--LocalScript 

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local player = Players.LocalPlayer
local welcomePlayerEvent = ReplicatedStorage:WaitForChild("WelcomePlayerEvent")
local playerGui = player:WaitForChild("PlayerGui")
 
local welcomeScreen = Instance.new("ScreenGui")
welcomeScreen.Parent = playerGui
local welcomeMessage = Instance.new("TextLabel")
welcomeMessage.Size = UDim2.new(0, 200, 0, 50)
welcomeMessage.Parent = welcomeScreen
welcomeMessage.Visible = false
welcomeMessage.Text = "Welcome to the game!"
 
local function onWelcomePlayerFired()
	welcomeMessage.Visible = true
	wait(3)
	welcomeMessage.Visible = false
end
 
welcomePlayerEvent.OnClientEvent:Connect(onWelcomePlayerFired)
```

@param player The `Player` that the remote event is being fired to.
@param arguments The arguments passed to the `RemoteEvent/OnClientEvent` method.
@returns No return. */
	FireClient(player: Player, ...arguments: Array<unknown>): void;
	/** The FireServer event fires the `OnServerEvent` event on the server using the arguments specified with an additional player argument at the beginning.

Since this function is used to communicate from the client to the server, it will only work when used in a `LocalScript`.

When firing from the client note that nothing has to be passed in by default (unlike firing to the client from the server - where the player is passed in).

The functionality of this function, as well as other `RemoteEvent` and `RemoteFunction` events and functions, is well documented in [this][1] article.


  [1]: /articles/Remote-Functions-and-Events

## Code Samples

### RemoteEvents: Client to Server

In order for a client to send a message to the server, it needs to fire the `RemoteEvent` with the function `FireServer` in a `LocalScript`.

The server meanwhile needs to connect a function to the OnServerEvent of the RemoteEvent.

When a client calls the FireServer function, any functions on the server that are connected to OnServerEvent will fire. Note that this is not immediate - the network connection between the client and server will determine how quickly this happens.

When firing a RemoteEvent from a client to the server, data can be included in the firing. By default, the functions connected to OnServerEvent will be passed the player who fired the event as the first parameter. If any other arguments are provided in the FireServer function, they will also be included in OnServerEvent after the player argument.
```lua
-- LocalScript
 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local createPartEvent = ReplicatedStorage:WaitForChild("CreatePartEvent")
 
createPartEvent:FireServer(BrickColor.Green(), Vector3.new(10, 20, 0))


-- ========================================


-- Script
 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local createPartEvent = Instance.new("RemoteEvent", ReplicatedStorage)
createPartEvent.Name = "CreatePartEvent"
 
local function onCreatePartFired(player, color, position)
	print(player.Name, "wants to create a part")
	local newPart = Instance.new("Part")
	newPart.BrickColor = color
	newPart.Position = position
	newPart.Parent = game.Workspace
end
 
createPartEvent.OnServerEvent:Connect(onCreatePartFired)
```

@param arguments The arguments passed to the `RemoteEvent/OnServerEvent` method.
@returns No return. */
	FireServer(...arguments: Array<unknown>): void;
	/** The OnClientEvent event fires listening functions in `LocalScript` when either `FireClient` or `FireAllClients` is fired by the server from a `Script`.

This is used to retrieve remote events fired by the server and intended for the client. This event is in place to provide a method for communicating between the server and client, which is well documented in [this][1] article. This event retrieves remote events fired by the server to the client.

To fire from the client to the server, you should use `FireServer` and `OnServerEvent`.


  [1]: /articles/Remote-Functions-and-Events

## Code Samples

### RemoteEvents: Server to a Single Client

The server can send messages to the client through remote events in two ways: it can send a message to an individual client or it can send a message to every client at the same time.

In order to send a message to a single client, the FireClient function should be called from the server via a `Script`.

To listen for the message on the client, a `LocalScript` needs to connect a function to the OnClientEvent event of the RemoteEvent.
```lua
-- Script

local Players = game:GetService("Players")
 
local welcomePlayerEvent = Instance.new("RemoteEvent")
welcomePlayerEvent.Parent = game.ReplicatedStorage
welcomePlayerEvent.Name = "WelcomePlayerEvent"
 
local function onPlayerAdded(player)
	welcomePlayerEvent:FireClient(player)
end
 
Players.PlayerAdded:Connect(onPlayerAdded)


-- ========================================


--LocalScript 

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local player = Players.LocalPlayer
local welcomePlayerEvent = ReplicatedStorage:WaitForChild("WelcomePlayerEvent")
local playerGui = player:WaitForChild("PlayerGui")
 
local welcomeScreen = Instance.new("ScreenGui")
welcomeScreen.Parent = playerGui
local welcomeMessage = Instance.new("TextLabel")
welcomeMessage.Size = UDim2.new(0, 200, 0, 50)
welcomeMessage.Parent = welcomeScreen
welcomeMessage.Visible = false
welcomeMessage.Text = "Welcome to the game!"
 
local function onWelcomePlayerFired()
	welcomeMessage.Visible = true
	wait(3)
	welcomeMessage.Visible = false
end
 
welcomePlayerEvent.OnClientEvent:Connect(onWelcomePlayerFired)
```
 */
	readonly OnClientEvent: RBXScriptSignal<(...arguments: Array<unknown>) => void, true>;
	/** Fires listening functions in `Script` when `FireServer` is called from a `LocalScript`.

This is used to retrieve remote events fired by the client and intended for the server. This event is in place to provide a method for communicating between the client and server, which is well documented in [this][1] article. This event retrieves remote events fired by the client to the server.

To fire from the server to the client, you should use `FireClient` and `OnClientEvent`.

  [1]: /articles/Remote-Functions-and-Events

## Code Samples

### RemoteEvents: Client to Server

In order for a client to send a message to the server, it needs to fire the `RemoteEvent` with the function `FireServer` in a `LocalScript`.

The server meanwhile needs to connect a function to the OnServerEvent of the RemoteEvent.

When a client calls the FireServer function, any functions on the server that are connected to OnServerEvent will fire. Note that this is not immediate - the network connection between the client and server will determine how quickly this happens.

When firing a RemoteEvent from a client to the server, data can be included in the firing. By default, the functions connected to OnServerEvent will be passed the player who fired the event as the first parameter. If any other arguments are provided in the FireServer function, they will also be included in OnServerEvent after the player argument.
```lua
-- LocalScript
 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local createPartEvent = ReplicatedStorage:WaitForChild("CreatePartEvent")
 
createPartEvent:FireServer(BrickColor.Green(), Vector3.new(10, 20, 0))


-- ========================================


-- Script
 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local createPartEvent = Instance.new("RemoteEvent", ReplicatedStorage)
createPartEvent.Name = "CreatePartEvent"
 
local function onCreatePartFired(player, color, position)
	print(player.Name, "wants to create a part")
	local newPart = Instance.new("Part")
	newPart.BrickColor = color
	newPart.Position = position
	newPart.Parent = game.Workspace
end
 
createPartEvent.OnServerEvent:Connect(onCreatePartFired)
```
 */
	readonly OnServerEvent: RBXScriptSignal<(player: Player, ...arguments: Array<unknown>) => void>;
}

/** A **RemoteFunction** is used to create in-game
 APIs that both the client and the server can use to communicate with each other. Like `BindableFunction`, a RemoteFunction can be invoked (called) to do a certain action and return the results.

If the result is **not** needed, we recommend that you use a `RemoteEvent` instead, since its call is asynchronous and doesn't need to wait for a response to continue execution. See `Remote Functions and Events` for more info.

## Code Samples

### RemoteFunctions: Server to Client

Invoking a client is very similar to invoking the server, except in this case the invocation has to pass the player to invoke. The function used to do this is `InvokeClient`.

The client listens for this function to be invoked by binding a function to `OnClientInvoke` using the assignment operator =, and not with an event within a `LocalScript`. When the player (client) is invoked, it will execute the bound function.
```lua
-- Server
 
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local createPopupRequest = Instance.new("RemoteFunction")
createPopupRequest.Name = "CreatePopupRequest"
createPopupRequest.Parent = ReplicatedStorage
Players.CharacterAutoLoads = false
 
local function onPlayerAdded(player)
	createPopupRequest:InvokeClient(player)
	player:LoadCharacter()
end
 
Players.PlayerAdded:Connect(onPlayerAdded)


-- ==================================================


-- LocalScript
 
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local createPopupRequest = ReplicatedStorage:WaitForChild("CreatePopupRequest")
 
local function onCreatePopupRequested()
	local screen = Instance.new("ScreenGui")
	screen.Parent = playerGui
	local closeButton = Instance.new("TextButton")
	closeButton.Text = "Welcome to the game! Click me to play!"
	closeButton.Size = UDim2.new(0, 300, 0, 50)
	closeButton.Parent = screen
 
	closeButton.MouseButton1Click:Wait()
	closeButton.Visible = false
end
 
createPopupRequest.OnClientInvoke = onCreatePopupRequested
```

### RemoteFunctions: Client to Server

When a client wants to use a remote function, it will invoke the server with the `InvokeServer` function within a `LocalScript`.

The server listens for this function to be invoked by binding a function to `OnServerInvoke` using the assignment operator =, and not with an event within a `Script`. When the server is invoked, it will execute the bound function.
```lua
-- LocalScript
 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local createPartRequest = ReplicatedStorage:WaitForChild("CreatePartRequest")
 
local newPart = createPartRequest:InvokeServer()
print("The server created this part for me:", newPart)


-- ==================================================


-- Script
 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local createPartRequest = Instance.new("RemoteFunction")
createPartRequest.Parent = ReplicatedStorage
createPartRequest.Name = "CreatePartRequest"
 
local function onCreatePartRequested(player)
	print(player.Name, "wants to create a new part")
	local newPart = Instance.new("Part")
	newPart.Parent = game.Workspace
	return newPart
end
 
createPartRequest.OnServerInvoke = onCreatePartRequested
```

### RemoteFunction1

This example triggers a server script when a client invokes the remote function.
```lua
-- In a server script
function RemoteFunction.OnServerInvoke(player, name)
	print("Hi, my name is", name, "and this invocation came from", player.Name)
	return player.Name
end
```
 */
interface RemoteFunction extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RemoteFunction";
	/** Calls the method bound to the RemoteFunction by `OnClientInvoke` for the given `Player`. Use from a `Script`.

If the result is not needed then it is recommended to use a `FireClient` instead, as its call is asynchronous and doesn't need to wait for a response to continue execution.

This is used to bind functions to invoke the client when the remote event is invoked by the server. This function is in place to provide a method for communicating between the client and server, which is well documented in [this][1] article.

To fire from the server to the client, you should use `InvokeServer` and `OnServerInvoke`.

Note
----------

In practice, the server does not often invoke the client. Clients typically do not have information the server doesn’t have and the actions that only a client can take (displaying a GUI for instance), often do not require a callback. That said, the server invoking clients is still an action that the Roblox engine will support and may be useful in niche situations.

Warning
----------

If a client disconnects or leaves the game while it is being invoked from the server, the InvokeClient function will error. It is therefore recommended to wrap this function in a pcall so it does stop the execution of other code.

  [1]: /articles/Remote-Functions-and-Events

## Code Samples

### RemoteFunctions: Client to Server

When a client wants to use a remote function, it will invoke the server with the `InvokeServer` function within a `LocalScript`.

The server listens for this function to be invoked by binding a function to `OnServerInvoke` using the assignment operator =, and not with an event within a `Script`. When the server is invoked, it will execute the bound function.
```lua
-- LocalScript
 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local createPartRequest = ReplicatedStorage:WaitForChild("CreatePartRequest")
 
local newPart = createPartRequest:InvokeServer()
print("The server created this part for me:", newPart)


-- ==================================================


-- Script
 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local createPartRequest = Instance.new("RemoteFunction")
createPartRequest.Parent = ReplicatedStorage
createPartRequest.Name = "CreatePartRequest"
 
local function onCreatePartRequested(player)
	print(player.Name, "wants to create a new part")
	local newPart = Instance.new("Part")
	newPart.Parent = game.Workspace
	return newPart
end
 
createPartRequest.OnServerInvoke = onCreatePartRequested
```

@param player The `Player` that the remote function is being fired to.
@param arguments The arguments passed to the `RemoteEvent/OnClientInvoke` method.
@returns Values returned by `RemoteFunction/OnClientInvoke`. */
	InvokeClient(player: Player, ...arguments: Array<any>): unknown;
	/** Clients invoking the server is often used because the server either has access to information the client does not, or the client is requesting a game action that only the server can perform. When invoked, this calls the method bound to the RemoteFunction by `OnServerInvoke`. Use from a `LocalScript`.

If the result is not needed then it is recommended to use a `FireServer` instead, as its call is asynchronous and doesn't need to wait for a response to continue execution.

This is used to bind functions to invoke the server when the remote event is invoked by a client. This function is in place to provide a method for communicating between the client and server, which is well documented in [this][1] article.

To fire from the client to the server, you should use `InvokeClient` and `OnClientInvoke`.

Note
----------

When handling the invocation from the client note that nothing has to be passed in by default (unlike invoking the server where the player is passed in).

## Code Samples

### RemoteFunctions: Server to Client

Invoking a client is very similar to invoking the server, except in this case the invocation has to pass the player to invoke. The function used to do this is `InvokeClient`.

The client listens for this function to be invoked by binding a function to `OnClientInvoke` using the assignment operator =, and not with an event within a `LocalScript`. When the player (client) is invoked, it will execute the bound function.
```lua
-- Server
 
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local createPopupRequest = Instance.new("RemoteFunction")
createPopupRequest.Name = "CreatePopupRequest"
createPopupRequest.Parent = ReplicatedStorage
Players.CharacterAutoLoads = false
 
local function onPlayerAdded(player)
	createPopupRequest:InvokeClient(player)
	player:LoadCharacter()
end
 
Players.PlayerAdded:Connect(onPlayerAdded)


-- ==================================================


-- LocalScript
 
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local createPopupRequest = ReplicatedStorage:WaitForChild("CreatePopupRequest")
 
local function onCreatePopupRequested()
	local screen = Instance.new("ScreenGui")
	screen.Parent = playerGui
	local closeButton = Instance.new("TextButton")
	closeButton.Text = "Welcome to the game! Click me to play!"
	closeButton.Size = UDim2.new(0, 300, 0, 50)
	closeButton.Parent = screen
 
	closeButton.MouseButton1Click:Wait()
	closeButton.Visible = false
end
 
createPopupRequest.OnClientInvoke = onCreatePopupRequested
```

@param arguments The arguments passed to the `RemoteEvent/OnServerInvoke` method.
@returns Values returned by `RemoteFunction/OnServerInvoke`. */
	InvokeServer<R = unknown>(...arguments: Array<any>): R;
	/** The OnClientInvoke event fires the bound functions in `LocalScript`s when `InvokeClient` is called by the server from a `Script`. When the bound function returns, the returned values are sent back to the server.

This is used to listen to remote functions invoked by the server and intended for the client. This callback is in place to provide a method for communicating between the server and client.

To fire from the client to the server, you should use `InvokeServer` and `OnServerInvoke`.

## Code Samples

### RemoteFunctions: Server to Client

Invoking a client is very similar to invoking the server, except in this case the invocation has to pass the player to invoke. The function used to do this is `InvokeClient`.

The client listens for this function to be invoked by binding a function to `OnClientInvoke` using the assignment operator =, and not with an event within a `LocalScript`. When the player (client) is invoked, it will execute the bound function.
```lua
-- Server
 
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local createPopupRequest = Instance.new("RemoteFunction")
createPopupRequest.Name = "CreatePopupRequest"
createPopupRequest.Parent = ReplicatedStorage
Players.CharacterAutoLoads = false
 
local function onPlayerAdded(player)
	createPopupRequest:InvokeClient(player)
	player:LoadCharacter()
end
 
Players.PlayerAdded:Connect(onPlayerAdded)


-- ==================================================


-- LocalScript
 
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local createPopupRequest = ReplicatedStorage:WaitForChild("CreatePopupRequest")
 
local function onCreatePopupRequested()
	local screen = Instance.new("ScreenGui")
	screen.Parent = playerGui
	local closeButton = Instance.new("TextButton")
	closeButton.Text = "Welcome to the game! Click me to play!"
	closeButton.Size = UDim2.new(0, 300, 0, 50)
	closeButton.Parent = screen
 
	closeButton.MouseButton1Click:Wait()
	closeButton.Visible = false
end
 
createPopupRequest.OnClientInvoke = onCreatePopupRequested
```
 */
	OnClientInvoke: (arguments: Array<any>) => void;
	/** The OnServerInvoke event fires the bound functions in `Script`s when `InvokeServer` is called by the server from a `LocalScript`. When the bound function returns, the returned values are sent back to the client.

This is used to retrieve remote events fired by the client and intended for the server. This event is in place to provide a method for communicating between the client and server, which is well documented in [this][1] article.

To fire from the server to the client, you should use `InvokeClient` and `OnClientInvoke`.

Note
----------

 - Binding a function to OnServerInvoke is done with the assignment operator `=`, and not with an event. That is because OnServerInvoke is a callback and expects a function to be assigned to it. When the RemoteFunction is invoked, it will execute the function that was assigned to the onInvoke function.

 - Only one function can be assigned to OnServerInvoke at a time. If multiple functions are assigned, only the last function to be assigned will be used.

## Code Samples

### RemoteFunctions: Client to Server

When a client wants to use a remote function, it will invoke the server with the `InvokeServer` function within a `LocalScript`.

The server listens for this function to be invoked by binding a function to `OnServerInvoke` using the assignment operator =, and not with an event within a `Script`. When the server is invoked, it will execute the bound function.
```lua
-- LocalScript
 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local createPartRequest = ReplicatedStorage:WaitForChild("CreatePartRequest")
 
local newPart = createPartRequest:InvokeServer()
print("The server created this part for me:", newPart)


-- ==================================================


-- Script
 
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local createPartRequest = Instance.new("RemoteFunction")
createPartRequest.Parent = ReplicatedStorage
createPartRequest.Name = "CreatePartRequest"
 
local function onCreatePartRequested(player)
	print(player.Name, "wants to create a new part")
	local newPart = Instance.new("Part")
	newPart.Parent = game.Workspace
	return newPart
end
 
createPartRequest.OnServerInvoke = onCreatePartRequested
```
 */
	OnServerInvoke: (player: Player, arguments: Array<any>) => void;
}

/** The RenderSettings is a singleton class, which lets developers debug components of Roblox's graphics engine.

It can be found under the _Rendering_
 tab in Roblox Studio's settings menu. */
interface RenderSettings extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RenderSettings";
	/** Sets the starting quality level of the framerate manager, when `EnableFRM` is set to true. */
	AutoFRMLevel: number;
	/** When set to true, all scene updates will be given an unlimited budget, regardless of how computationally expensive it may be.

This ensures each frame will look as it should, at the cost of a more unstable frame rate.When set to true, all scene updates will be given an unlimited budget, regardless of how computationally expensive it may be.

## Notes

* This is used when rendering game thumbnails. */
	EagerBulkExecution: boolean;
	/** Sets the graphics quality level in Roblox Studio, when `EnableFRM` is set to false. */
	EditQualityLevel: Enum.QualityLevel;
	/** Toggles the enabled state of the framerate manager.Toggles the enabled state of the framerate manager.

Tags: Hidden, NotReplicated */
	EnableFRM: boolean;
	/** Sets whether materials should be generated per part, or per unique appearance in Roblox's obj exporter. */
	ExportMergeByMaterial: boolean;
	/** Specifies the behavior of the framerate manager. */
	FrameRateManager: Enum.FramerateManagerMode;
	/** The graphics API that Roblox will use on startup. */
	GraphicsMode: Enum.GraphicsMode;
	/** The size in bytes of the mesh cache.
Defaults to 32 MBs. */
	MeshCacheSize: number;
	/** If `EnableFRM` is set to true, this property controls the quality level in Roblox Studio. */
	QualityLevel: Enum.QualityLevel;
	/** When set to true, Roblox Studio will automatically reload changes that are made to files in Roblox's `content`
 folder. */
	ReloadAssets: boolean;
	/** When set to true, a wireframe of polygons will be shown on all `PartOperation` objects. */
	RenderCSGTrianglesDebug: boolean;
	/** If set to true, renders bounding boxes around each individual rendered entity in the scene. */
	ShowBoundingBoxes: boolean;
	/** Returns the maximum quality level. */
	GetMaxQualityLevel(): number;
}

/** RenderingTest is an internal testing utility used by Roblox engineers to do performance/regression tests on the rendering pipeline. It is expected to be parented inside of the `TestService`, and will run LocalScripts parented inside of it when the TestService is ran via `Run`.

![Selected RenderingTest](https://developer.roblox.com/assets/5b404eddcbdac88b0b7f2e4e/RenderingTest.png)

One of its more notable features is that, upon being selected in the Explorer, it draws an accurate wireframe of the Camera frustum, visualizing what a Camera would see in the RenderingTest's configuration.

## Recording Test Results

When a RenderingTest is executed by the TestService, the `CurrentCamera` of the `Workspace` has its properties updated so it mirrors the Camera configuration of the RenderingTest. 

The recorded data is then sent as JSON with an HTTP-POST request to: `localhost:8001/api/v1/submit_test`.

For the RenderingTest to pass in Roblox Studio, the request expects the response to be the string `"passed"`. It will also acknowledge the strings `"failed"` or `"golden"` as a string response. */
interface RenderingTest extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RenderingTest";
	/** The CFrame that the `Camera` will use when this RenderingTest is executed.
The value of this property is reflected into `Position` and `Orientation`. */
	CFrame: CFrame;
	/** The maximum difference that this RenderingTest can have between the image it captures and the original image.
This property is only used if the RenderingTest's ComparisonMethod is set to **diff**. */
	ComparisonDiffThreshold: number;
	/** The comparison method that is expected to be used when this RenderingTest's image capture is compared to its original image. */
	ComparisonMethod: Enum.RenderingTestComparisonMethod;
	/** The maximum peak signal-to-noise ratio that this RenderingTest can have between the image it captures and the original image.
This property is only used if the RenderingTest's ComparisonMethod is set to **psnr**. */
	ComparisonPsnrThreshold: number;
	/** A description to describe this RenderingTest. */
	Description: string;
	/** The FieldOfView that will be used by the `Camera` when running this RenderingTest.
Should fall between 1 and 120 in order to work as expected. */
	FieldOfView: number;
	/** The derived orientation of the RenderingTest’s CFrame.The derived orientation of the RenderingTest’s CFrame.

Tags: NotReplicated */
	Orientation: Vector3;
	/** The derived position of the RenderingTest's CFrame.The derived position of the RenderingTest's CFrame.

Tags: NotReplicated */
	Position: Vector3;
	/** The graphics quality that will be used by the rendering pipeline when running this RenderingTest.
Should fall between 1 and 21 in order to work as expected. */
	QualityLevel: number;
	/** Indicates whether or not this RenderingTest should be skipped. */
	ShouldSkip: boolean;
	/** A label of the internal JIRA ticket this RenderingTest is associated with. */
	Ticket: string;
	/** [LACKS DOCUMENTATION] */
	RenderdocTriggerCapture(): void;
}

/** A container whose contents are replicated to all clients (but not back to the server) first before anything else.

## What is ReplicatedFirst for?
ReplicatedFirst is most commonly used to store `LocalScript`s and other objects that are essential for the game's start. As the contents of ReplicatedFirst replicate to the client before anything else in the game, it is ideal for creating loading GUIs or tutorials.

For objects that do not need to be replicated first, developers should use the `ReplicatedStorage` container instead.

## How can I use ReplicatedFirst?

`LocalScript`s placed within ReplicatedFirst will run. This means code for custom loading screens or other ReplicatedFirst uses can be ran at the earliest possible point.

There a number of key considerations developers need to remember when running `LocalScript`s in ReplicatedFirst. 

 - Its contents replicate before anything else in the game, meaning `LocalScript`s running in ReplicatedFirst will need to wait for any objects they require to replicate using `WaitForChild`
 - Any objects that are to be used by a `LocalScript` in ReplicatedFirst should also be parented to ReplicatedFirst. Otherwise, they may replicate to the client late, yielding the script and negating the benefit of ReplicatedFirst.

ReplicatedFirst also includes the function `RemoveDefaultLoadingScreen`, which can be used to immediately remove the default Roblox loading screen. Note if any object has been placed in ReplicatedFirst, the default loading screen will remove after 5 seconds regardless if this function has been called or not.

## Code Samples

### Custom Loading Screen

This sample is a simple demonstration of how a custom loading screen can be implemented. To run this code it should be placed in a `LocalScript` and parented to `ReplicatedFirst`.

In this example, a basic loading screen will be created and shown until the game has loaded (for a minimum time of 3 seconds). Developers may wish to expand on this with more elegant GUI elements. When doing so ensure that all such elements are parented to `ReplicatedFirst` and fetched using `WaitForChild` to ensure they replicate correctly.
```lua
    local Players = game:GetService("Players")
    local ReplicatedFirst = game:GetService("ReplicatedFirst")
    
    local localPlayer = Players.LocalPlayer 
    local playerGui = localPlayer:WaitForChild("PlayerGui")
    
    local MIN_TIME = 3
    
    -- create a basic loading gui
    local screenGui = Instance.new("ScreenGui")
    local textLabel = Instance.new("TextLabel", screenGui)
    textLabel.Text = "Loading"
    textLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
    textLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    textLabel.Size = UDim2.new(1 , 0, 1, 100) -- make sure the topbar is covered
    textLabel.FontSize = Enum.FontSize.Size14
    screenGui.Parent = playerGui
    
    -- hide the default loading screen 
    ReplicatedFirst:RemoveDefaultLoadingScreen()
    
    -- loop
    local count = 0
    local startTick = tick()
    while true do 
    	local timeElapsed = tick() - startTick
    	-- if the game has loaded and the minimum time has elapsed then break the loop
    	if game:IsLoaded() and timeElapsed > MIN_TIME then
    		break
    	end
    
    	-- animate the text 
    	textLabel.Text = "Loading " .. string.rep(".",count)
    	count = (count + 1) % 4
    
    	wait(.3)
    end
    
    -- destroy the loading screen
    screenGui:Destroy()


```
 */
interface ReplicatedFirst extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReplicatedFirst";
	/** Immediately removes the default Roblox loading screen. Note if any object has been placed in `ReplicatedFirst`, the default loading screen will remove after 5 seconds regardless if this function has been called or not.

Developers should run this function from a `LocalScript` in `ReplicatedFirst`, as scripts in `ReplicatedFirst` will execute before anything else.

It is advised to not remove the default loading screen unless the developer wishes to display their own loading screen as an alternative. If the default screen is removed without replacement users will be able to see geometry loading in the background.

## Code Samples

### Custom Loading Screen

This sample is a simple demonstration of how a custom loading screen can be implemented. To run this code it should be placed in a `LocalScript` and parented to `ReplicatedFirst`.

In this example, a basic loading screen will be created and shown until the game has loaded (for a minimum time of 3 seconds). Developers may wish to expand on this with more elegant GUI elements. When doing so ensure that all such elements are parented to `ReplicatedFirst` and fetched using `WaitForChild` to ensure they replicate correctly.
```lua
    local Players = game:GetService("Players")
    local ReplicatedFirst = game:GetService("ReplicatedFirst")
    
    local localPlayer = Players.LocalPlayer 
    local playerGui = localPlayer:WaitForChild("PlayerGui")
    
    local MIN_TIME = 3
    
    -- create a basic loading gui
    local screenGui = Instance.new("ScreenGui")
    local textLabel = Instance.new("TextLabel", screenGui)
    textLabel.Text = "Loading"
    textLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
    textLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    textLabel.Size = UDim2.new(1 , 0, 1, 100) -- make sure the topbar is covered
    textLabel.FontSize = Enum.FontSize.Size14
    screenGui.Parent = playerGui
    
    -- hide the default loading screen 
    ReplicatedFirst:RemoveDefaultLoadingScreen()
    
    -- loop
    local count = 0
    local startTick = tick()
    while true do 
    	local timeElapsed = tick() - startTick
    	-- if the game has loaded and the minimum time has elapsed then break the loop
    	if game:IsLoaded() and timeElapsed > MIN_TIME then
    		break
    	end
    
    	-- animate the text 
    	textLabel.Text = "Loading " .. string.rep(".",count)
    	count = (count + 1) % 4
    
    	wait(.3)
    end
    
    -- destroy the loading screen
    screenGui:Destroy()


```
 */
	RemoveDefaultLoadingScreen(): void;
}

/** Complex games often require a range of assets that are held in storage until they're required. **ReplicatedStorage** is a container whose contents are replicated to all connected clients, allowing such objects to be stored until needed. ReplicatedStorage is also an ideal location for `RemoteFunctions` and `RemoteEvents` since they can be found on both the client and server.

Note these additional details about ReplicatedStorage:

* Objects descending from ReplicatedStorage can be accessed from a `Script` or `LocalScript` on both the server and client.
* Objects can be replicated to the client by parenting them to ReplicatedStorage:

```
prettyprintlua
object.Parent = game:GetService("ReplicatedStorage")  -- From the server
```


* Although the client can access and modify ReplicatedStorage, these changes will not replicate to the server or other clients.
* `Scripts` and `LocalScripts` will not run when they are parented to ReplicatedStorage, although `ModuleScripts` contained within it can be accessed and executed. There are a number of alternative containers where client-side
 scripts will run, such as `StarterPlayerScripts` and `ReplicatedFirst`.
* For objects that only the server requires access to, we recommended you use `ServerStorage` to minimize network traffic. */
interface ReplicatedStorage extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReplicatedStorage";
}

/** RobloxReplicatedStorage is an internal version of the `ReplicatedStorage` service. It is used by Roblox's `CoreScript`s for backend server/client interactions, and it cannot be utilized by developers in-game. */
interface RobloxReplicatedStorage extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RobloxReplicatedStorage";
}

/** The RunService contains methods and events for time-management as well as for managing the context in which a game or script is running. Methods like `IsClient`, `IsServer`, `IsStudio`, can help you determine where Lua code is running. These methods are useful for ModuleScripts that could be required by both the client and server. In addition, you can use `IsStudio` to add special behavior for in-studio testing.

`RunService` also provides events that help you manage time. `Stepped` and `Heartbeat` can be used for game logic while `RenderStepped` can be used for visual effects. These events fire with "delta time" values. `Stepped` also includes the total amount of time passed in a game. Correctly using the change in time values for game logic is important for changing values over time. As a general rule, multiply your change in time by the rate of change to get the amount a value should change in one frame. For example:

    -- Note: delta just means "change in/of"
    speed = deltaPosition / deltaTime
    deltaPosition = speed * deltaTime

## Code Samples

### RunService Stepped

This code sample uses RunService's Stepped event to create a Part that flies in a direction given a start position and speed. It uses a BodyPosition to move the Part, and calculates the new position of the Part each frame.
```lua
local RunService = game:GetService("RunService")

local PART_START_POS = Vector3.new(0, 10, 0)
local PART_SPEED = Vector3.new(10, 0, 0)

-- Create a Part with a BodyPosition
local part = Instance.new("Part")
part.CFrame = CFrame.new(PART_START_POS)
local bp = Instance.new("BodyPosition")
bp.Parent = part
bp.Position = PART_START_POS
part.Parent = workspace

local function onStep(currentTime, deltaTime)
	-- Move the part the distance it is meant to move
	-- in the last `deltaTime` seconds
	bp.Position = bp.Position + PART_SPEED * deltaTime
	
	-- Here's the math behind this:
	-- speed = displacement / time
	-- displacement = speed * time
end

RunService.Stepped:Connect(onStep)
```
 */
interface RunService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RunService";
	/** The `BindToRenderStep` function binds a custom function to be called at a specific time during the render step. There are three main arguments for BindToRenderStep: `name`, `priority`, and `what function to call`. 

As it is linked to the client's rendering process, BindToRenderStep can only be called on the client.

Name
----------

The `name` parameter is a label for the binding, and can be used with `UnbindFromRenderStep` if the binding is no longer needed.

    local RunService = game:GetService("RunService")
    
    local function functionToBind() end
    
    -- Bind the function above to the binding named "tempBinding"
    RunService:BindToRenderStep("tempBinding", 1, functionToBind)
    -- Unbind the function bound to "tempBinding"
    RunService:UnbindFromRenderStep("tempBinding")

Priority
----------

The `priority` of the binding is an integer, and determines when during the render step to call the custom function. The lower this number, the sooner the custom function will be called. If two bindings have the same priority the Roblox engine will randomly pick one to run first. The default Roblox control scripts run with these specific priorities:
 - Player Input: 100
 - Camera Controls: 200
For convenience, the `RenderPriority` enum can be used to determine the integer value to set a binding. For example, to make a binding right before the default camera update, simply subtract 1 from the camera priority level.

> **Note:** When using Enum.RenderPriority, remember to use ***InlineCode.Value*** at the end of the desired enum. BindToRenderStep will not work if just the enum on its own is used.

    local RunService = game:GetService("RunService")
    
    local function beforeCamera(delta)
    	-- Code in here will run before the default Roblox camera script
    end
    
    RunService:BindToRenderStep("Before camera", Enum.RenderPriority.Camera.Value - 1, beforeCamera)

Custom Function and Delta Time
----------

The last argument of BindToRenderStep is the `custom function` to call. This function will be passed one parameter called deltaTime. ***DeltaTime*** shows how much time passed between the beginning of the previous render step and the beginning of the current render step.

> **Note:** All rendering updates will wait until the code in the render step finishes. Make sure that any code called by BindToRenderStep runs quickly and efficiently. If code in BindToRenderStep takes too long, then the game visuals will be choppy.

## Code Samples

### Frame Moving in Circle

This code sample moves a GuiObject in a circle within its parent object using RunService's BindToRenderStep. It defines a parametric equation in a function to help with positioning the GuiObject.

To try this code out, put a ScreenGui in the StarterGui. Inside the ScreenGui, insert a Frame with a LocalScript. Paste this code into the LocalScript, then play the game. Watch the Frame travel counterclockwise within.
```lua
local RunService = game:GetService("RunService")

-- How fast the frame ought to move
local SPEED = 2

local frame = script.Parent
frame.AnchorPoint = Vector2.new(.5, .5)

-- A simple parametric equation of a circle
-- centered at (0.5, 0.5) with radius (0.5)
local function circle(t)
	return .5 + math.cos(t) * .5,
	       .5 + math.sin(t) * .5
end

-- Keep track of the current time
local currentTime = 0
local function onRenderStep(deltaTime)
	-- Update the current time
	currentTime = currentTime + deltaTime * SPEED
	-- ...and our frame's position
	local x, y = circle(currentTime)
	frame.Position = UDim2.new(x, 0, y, 0)
end

-- This is just a visual effect, so use the "Last" priority
RunService:BindToRenderStep("FrameCircle", Enum.RenderPriority.Last.Value, onRenderStep)
--RunService.RenderStepped:Connect(onRenderStep) -- Also works, but not recommended
```

### Bind and Unbind a Function

This example uses the `RunService` to bind and unbind a function named `printHello`. First, we bind the function to the RenderStep so that fires every *step*. Then, after we wait 5 seconds (`wait(5)`), we unbind the function.

Please note that we take caution to surround the function unbind in a [pcall][1] to prevent the code from breaking due to an error being thrown if the function name passed does not match the name of an already bound function. While we know that the function used in this example is bound when we try to unbind it, doing this is good coding practice.

  [1]: http://wiki.roblox.com/index.php?title=Global_namespace/Basic_functions#pcall
```lua
local RunService = game:GetService("RunService")

-- Step 1: Declare the function and a name
local name = "Print Hello"
function printHello()
	print("Hello")
end

-- Step 3: Bind the function
RunService:BindToRenderStep(name, Enum.RenderPriority.First.Value, printHello)

-- Step 3: Unbind the function
local success, message = pcall(function() RunService:UnbindFromRenderStep(name) end)
if success then
	print("Success: Function unbound!")
else 
	print("An error occurred: " .. message)
end
```

### RunService Custom Function

This example shows how to bind a simple function to the render step. All this function does is print how much time passed between the last render step and the current one. Note that this code will need to be in a `LocalScript` to run.
```lua
-- Make variables for Roblox services
local RunService = game:GetService("RunService")

-- Function that will be bound to the render step
local function checkDelta(deltaTime)
	-- Print the time since the last render step
	print("Time since last render step:", deltaTime)
end

-- Bind the function
RunService:BindToRenderStep("Check delta", Enum.RenderPriority.First.Value, checkDelta)
```

@param name The **name** parameter is a label for the binding, and can be used with `RunService.Unbind` if the binding is no longer needed.
@param priority The *priority* of the binding is an integer, and determines when during the render step to call the custom function. The lower this number, the sooner the custom function will be called. If two bindings have the same priority the Roblox engine will randomly pick one to run first. The default Roblox control scripts run with these specific priorities:
 - Player Input: 100
 - Camera Controls: 200
For convenience, the '''RenderPriority''' enum can be used to determine the integer value to set a binding. For example, to make a binding right before the default camera update, simply subtract 1 from the camera priority level.
@param function The custom function being bound.
@returns None. */
	BindToRenderStep(name: string, priority: number, callback: Function): void;
	/** If the code that invoked this method is running in a client context (within or originating from a LocalScript), this method returns true. In all other cases, it returns false. If this returns true, the code has access to client-side features like `RunService.RenderStepped` or `Players.LocalPlayer`.

## Code Samples

### Run Context

This code prints out details of a script's running context, like if it is running on the server, client, in studio, etc. It uses RunService to do this.

Try pasting this code into a Script or LocalScript. See how it runs in online mode and on a Roblox server (open the developer console).
```lua
local RunService = game:GetService("RunService")

if RunService:IsStudio() then
	print("I am in Roblox Studio")
else
	print("I am in an online Roblox Server")
end

if RunService:IsRunMode() then
	print("Running in Studio")
end

if RunService:IsClient() then
	print("I am a client")
else
	print("I am not a client")
end

if RunService:IsServer() then
	print("I am a server")
else
	print("I am not a server")
end

if RunService:IsRunning() then
	print("The game is running")
else
	print("The game is stopped or paused")
end
```
 */
	IsClient(): boolean;
	/** This method returns true if and only if the "Run" button was pressed within Studio.

## Code Samples

### Run Context

This code prints out details of a script's running context, like if it is running on the server, client, in studio, etc. It uses RunService to do this.

Try pasting this code into a Script or LocalScript. See how it runs in online mode and on a Roblox server (open the developer console).
```lua
local RunService = game:GetService("RunService")

if RunService:IsStudio() then
	print("I am in Roblox Studio")
else
	print("I am in an online Roblox Server")
end

if RunService:IsRunMode() then
	print("Running in Studio")
end

if RunService:IsClient() then
	print("I am a client")
else
	print("I am not a client")
end

if RunService:IsServer() then
	print("I am a server")
else
	print("I am not a server")
end

if RunService:IsRunning() then
	print("The game is running")
else
	print("The game is stopped or paused")
end
```
 */
	IsRunMode(): boolean;
	/** This method returns true if the game is not paused or stopped. In all other cases it returns false. This only changes within Roblox Studio.

## Code Samples

### Run Context

This code prints out details of a script's running context, like if it is running on the server, client, in studio, etc. It uses RunService to do this.

Try pasting this code into a Script or LocalScript. See how it runs in online mode and on a Roblox server (open the developer console).
```lua
local RunService = game:GetService("RunService")

if RunService:IsStudio() then
	print("I am in Roblox Studio")
else
	print("I am in an online Roblox Server")
end

if RunService:IsRunMode() then
	print("Running in Studio")
end

if RunService:IsClient() then
	print("I am a client")
else
	print("I am not a client")
end

if RunService:IsServer() then
	print("I am a server")
else
	print("I am not a server")
end

if RunService:IsRunning() then
	print("The game is running")
else
	print("The game is stopped or paused")
end
```
 */
	IsRunning(): boolean;
	/** If the code that invoked this method is running in a server context (within or originating from a Script), this method returns true. In all other cases, it returns false. If this returns true, the code has access to server-side features like `ServerStorage` or `ServerScriptService`.

## Code Samples

### Run Context

This code prints out details of a script's running context, like if it is running on the server, client, in studio, etc. It uses RunService to do this.

Try pasting this code into a Script or LocalScript. See how it runs in online mode and on a Roblox server (open the developer console).
```lua
local RunService = game:GetService("RunService")

if RunService:IsStudio() then
	print("I am in Roblox Studio")
else
	print("I am in an online Roblox Server")
end

if RunService:IsRunMode() then
	print("Running in Studio")
end

if RunService:IsClient() then
	print("I am a client")
else
	print("I am not a client")
end

if RunService:IsServer() then
	print("I am a server")
else
	print("I am not a server")
end

if RunService:IsRunning() then
	print("The game is running")
else
	print("The game is stopped or paused")
end
```
 */
	IsServer(): boolean;
	/** If the script that invoked this method is running within Roblox Studio, this method returns true. In all other cases, it returns false. This method is useful for adding code used to test your game within Studio.

## Code Samples

### Run Context

This code prints out details of a script's running context, like if it is running on the server, client, in studio, etc. It uses RunService to do this.

Try pasting this code into a Script or LocalScript. See how it runs in online mode and on a Roblox server (open the developer console).
```lua
local RunService = game:GetService("RunService")

if RunService:IsStudio() then
	print("I am in Roblox Studio")
else
	print("I am in an online Roblox Server")
end

if RunService:IsRunMode() then
	print("Running in Studio")
end

if RunService:IsClient() then
	print("I am a client")
else
	print("I am not a client")
end

if RunService:IsServer() then
	print("I am a server")
else
	print("I am not a server")
end

if RunService:IsRunning() then
	print("The game is running")
else
	print("The game is stopped or paused")
end
```
 */
	IsStudio(): boolean;
	/** Given a name of a function sent to `BindToRenderStep`, this method will unbind the function from being called during RenderStepped. This is used to unbind bound functions once they are no longer needed, or when they no longer need to fire every *step*.

If there is no bound function by the given name, this method raises an error. You can prevent such an error from being raised by using `pcall`. For example, if you bind a function named `drawImage` using `BindToRenderStep`, the following code would unbind the function, suppressing errors if there wasn't already a function with the name `drawImage` bound.

    local RunService = game:GetService("RunService")
    
    local success, message = pcall(function() RunService:UnbindFromRenderStep("drawImage") end)
    if success then
        print("Success: Function unbound!")
    else 
        print("An error occurred: "..message)
    end

## Code Samples

### Bind and Unbind a Function

This example uses the `RunService` to bind and unbind a function named `printHello`. First, we bind the function to the RenderStep so that fires every *step*. Then, after we wait 5 seconds (`wait(5)`), we unbind the function.

Please note that we take caution to surround the function unbind in a [pcall][1] to prevent the code from breaking due to an error being thrown if the function name passed does not match the name of an already bound function. While we know that the function used in this example is bound when we try to unbind it, doing this is good coding practice.

  [1]: http://wiki.roblox.com/index.php?title=Global_namespace/Basic_functions#pcall
```lua
local RunService = game:GetService("RunService")

-- Step 1: Declare the function and a name
local name = "Print Hello"
function printHello()
	print("Hello")
end

-- Step 3: Bind the function
RunService:BindToRenderStep(name, Enum.RenderPriority.First.Value, printHello)

-- Step 3: Unbind the function
local success, message = pcall(function() RunService:UnbindFromRenderStep(name) end)
if success then
	print("Success: Function unbound!")
else 
	print("An error occurred: " .. message)
end
```

@param name The name of the function being unbound.
@returns None. */
	UnbindFromRenderStep(name: string): void;
	/** The Heartbeat event fires every **frame** in the `RunService`. The step argument indicates how much time has passed between frames - usually around 1/60th of a second. 

Please note that this will vary depending on the performance of the machine. If the game is only running at 40 FPS, that means that Heartbeat will fire 40 times per second, and the step argument will be roughly 1/40th of a second.

## Code Samples

### Printing Heartbeat Frequency

The following example will print the time between each Heartbeat loop 5 times - while the value of count is less than the value of loopCount.
```lua
local RunService = game:GetService('RunService')local loopCount = 5
local count = 0

RunService.Heartbeat:Connect(function(step)
    if count < loopCount then
        count = count + 1
        print("Time between each loop: "..step)
    end
end)
```
 */
	readonly Heartbeat: RBXScriptSignal<(step: number) => void>;
	/** The RenderStepped event fires when a frame is rendered on the client. It fires at around 60 times per second, so the time step is around 0.0166 seconds. If the framerate drops, this event fires less often.

There's no guarantee that functions connected to this event will fire at the exact same time. To be sure that certain functions are called in synchronization with each other, use `BindToRenderStep` instead, which allows specification of a "render priority".

Also note that RenderStepped must only be used in `LocalScript`s, as they refer to each frame that is being rendered.

## Code Samples

### Spin GuiObject

This code sample rotates a parent `GuiObject` (such as a `Frame`) using a given rotation speed and the `RenderStepped` event.
```lua
local RunService = game:GetService("RunService")

local guiObject = script.Parent

local degreesPerSecond = 180

local function onRenderStep(deltaTime)
	local deltaRotation = deltaTime * degreesPerSecond
	guiObject.Rotation = guiObject.Rotation + deltaRotation 
end
RunService.RenderStepped:Connect(onRenderStep)

```
 */
	readonly RenderStepped: RBXScriptSignal<(step: number) => void>;
	/** The Stepped event fires on every *step* in the `RunService`, which is approximately every 1/60th (or 0.0166) seconds. If the framerate drops, this event fires less often. It is recommended that this event be used for visual effects; use RunService/Heartbeat for gameplay-related events.

There’s no guarantee that functions connected to this event will fire at the exact same time. To be sure that certain functions are called in synchronization with each other, use `BindToRenderStep` instead, which allows specification of a ***render priority***.

## Code Samples

### RunService.Stepped1

This code will print Stepped every frame.
```lua
game:GetService('RunService').Stepped:Connect(function()
	print("Stepped")
end)

```
 */
	readonly Stepped: RBXScriptSignal<(time: number, step: number) => void>;
}

/** An internal service, probably in charge of managing the execution of scripts in run-time. */
interface RuntimeScriptService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RuntimeScriptService";
}

/** This service controls all `BaseScript` objects. Most of the properties and methods of this service are locked for internal use, however you may use the `ScriptsDisabled` property to disable all scripts from a thread with normal security access. */
interface ScriptContext extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ScriptContext";
	/** Fired when an error occurs.

## Code Samples

### ScriptContext.Error

When an error occurs, this example prints the name of the script that errored, the reason it errored, and a trace of the error.
```lua
game:GetService("ScriptContext").Error:Connect(function(message, trace, script)
	print(script:GetFullName().." errored!")
	print("Reason: "..message)
	print("Trace: "..trace)
end)

-- Another script in Workspace:

KILLEVERYONE()
```
 */
	readonly Error: RBXScriptSignal<(message: string, stackTrace: string, script: Instance) => void>;
}

/** A ScriptDebugger is used to handle the debugging of a specific script. It can be retrieved from the `DebuggerManager`. */
interface ScriptDebugger extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ScriptDebugger";
	/** The current line that the script is on. */
	readonly CurrentLine: number;
	/** Describes if this ScriptDebugger is actually debugging the script attached to it. */
	readonly IsDebugging: boolean;
	/** Describes if this ScriptDebugger is paused. */
	readonly IsPaused: boolean;
	/** The script object this debugger is linked to. */
	readonly Script?: Instance;
	/** Adds a watch with the given expression. */
	AddWatch(expression: string): Instance | undefined;
	/** Returns a list of `DebuggerBreakpoint` present in the script. */
	GetBreakpoints(): Array<Instance>;
	/** Returns a dictionary of all variables that are visible to the script's global stack, where the keys are the names of the variables, and the values are the actual values of the variables. */
	GetGlobals(): Map<string, any>;
	/** Returns a dictionary of all local variables in the specified stack, where the keys are the names of the variables, and the values are the actual values of the variables. */
	GetLocals(stackFrame?: number): Map<string, any>;
	/** Returns an array of all active call stacks in the script. */
	GetStack(): unknown;
	/** Returns a dictionary of all upvalues present in the stack specified. */
	GetUpvalues(stackFrame?: number): Map<string, any>;
	/** Returns the current value of a variable being watched by a `DebuggerWatch`. */
	GetWatchValue(watch: Instance): unknown;
	/** Returns a list with all the watches for this debugger */
	GetWatches(): Array<Instance>;
	/** Sets the specified line of the script as a breakpoint. Returns a `DebuggerBreakpoint` that you can use to manage the breakpoint. */
	SetBreakpoint(line: number): Instance | undefined;
	/** Sets the value of the variable _name_ as _value_
 in the script's main stack. */
	SetGlobal(name: string, value?: any): void;
	/** Sets the value of the variable _name_ as _value_
 in the stack specified. */
	SetLocal(name: string, value?: any, stackFrame?: number): void;
	/** Sets the value of the upvalue _name_ as _value_
 in the stack specified. */
	SetUpvalue(name: string, value?: any, stackFrame?: number): void;
	/** Fired when a breakpoint is added to the script. */
	readonly BreakpointAdded: RBXScriptSignal<(breakpoint: Instance) => void>;
	/** Fired when a breakpoint is removed from the script. */
	readonly BreakpointRemoved: RBXScriptSignal<(breakpoint: Instance) => void>;
	/** Fired when a breakpoint is encountered by the script. */
	readonly EncounteredBreak: RBXScriptSignal<(line: number) => void>;
	/** Fired when the game is resumed after being paused by a breakpoint. */
	readonly Resuming: RBXScriptSignal<() => void>;
	/** Fired when an expression watch is added to this script debugger. */
	readonly WatchAdded: RBXScriptSignal<(watch: Instance) => void>;
	/** Fired when an expression watch is removed from this script debugger. */
	readonly WatchRemoved: RBXScriptSignal<(watch: Instance) => void>;
}

/** An unimplemented service that has zero functionality, in a similar manner to the `LocalWorkspace` service. */
interface ScriptService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ScriptService";
}

/** The Selection service controls the `Instance`s that are selected in Roblox Studio.

This service is particularly useful when developing `Plugin`s, as it allows the developer to access and manipulate the current selection. 

Currently selected `Instance`s can be obtained and set using the `Get` and `Set` functions. The `SelectionChanged` event fires whenever the current selection changes.

For more information on using Selection and `Plugin`s please see `Intro to this tutorial`.

Selection is also often used in the command bar, to set hidden properties or run functions for selected `Instance`s. For example:

```lua
game.Selection:Get()[1]:SetPrimaryPartCFrame(CFrame.new()) -- move the selected model to the origin
```


Note this class only applies to Roblox Studio and has no applicability to games.

  [1]: /articles/Intro-to-Plugins

## Code Samples

### Selection

The following code sample, when used in a plugin or the command bar, will rotate currently selected `BasePart`s.
```lua
local Selection = game:GetService("Selection")

for _, object in pairs(Selection:Get()) do
	if object:IsA("BasePart") then
		object.CFrame = object.CFrame * CFrame.Angles(0, math.pi / 2, 0)
	end
end
```
 */
interface Selection extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Selection";
	/** Fires when the `Instance`s selected in Roblox Studio changes.

Note this event does not give the new selection. Developers will need to use `Selection`'s `Get` function to obtain the current selection. 

Although this event can be used outside of plugins and the command bar, it only applies to the selection in Roblox Studio and therefore has no functionality outside of Studio.

To change the selection use the `Set` function.

## Code Samples

### Selection.SelectionChanged

This example prints the number of selected items whenever SelectionChanged is fired:
```lua
local selection = game:GetService("Selection")
selection.SelectionChanged:Connect(function()
	print("Selection contains " .. #selection:Get() .. " items.")
end)

```
 */
	readonly SelectionChanged: RBXScriptSignal<() => void>;
}

/** @server */
	/** A semantic, organized place to put your server-sided game logic, which does not interfere with the world. Scripts will run inside this service, and will not replicate to game clients, allowing for secure storage of your scripts. */
interface ServerScriptService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ServerScriptService";
}

/** @server */
	/** A container whose contents are only accessible on the server. Objects descending from ServerStorage will not replicate to the client and will not be accessible from `LocalScript`s.

As ServerStorage is a service it can only be accessed using the `GetService` method.

By storing large objects such as maps in ServerStorage until they are needed, network traffic will not be used up transmitting these objects to the client when they join the game.

`Script`s will not run when they are parented to ServerStorage, although `ModuleScript`s contained within can be accessed and ran. It is recommended developers use `ServerScriptService` to hold `Script`s they wish the server to execute.

Note that as the contents of ServerStorage can only be accessed by the server, its contents will need to be parented elsewhere (such as `Workspace`) before clients can access them. Developers who require a container that is accessible by both the server and client are advised to use `ReplicatedStorage` instead.

## Code Samples

### ServerStorage Map Rotation

This is a very simple example of how a multiple map system can be made using ServerStorage.

It creates three dummy models (to take the place of maps), that are parented to ServerStorage. Then, it will load a random map (different to the previous map) and wait a specified duration on a loop.

Developers wishing to integrate something similar into their games should consider measures to ensure players respawn correctly, or go to a lobby during intermission periods.
```lua
    local ServerStorage = game:GetService("ServerStorage")
    
    local ROUND_TIME = 5
    
    local map1 = Instance.new("Model", ServerStorage)
    map1.Name = "Map1"
    local map2 = Instance.new("Model", ServerStorage)
    map2.Name = "Map2"
    local map3 = Instance.new("Model", ServerStorage)
    map3.Name = "Map3"
    
    local maps = {map1, map2, map3}
    local currentMap = nil
    local lastPick = nil
    
    while true do 
    	print("New map!")
    
    	-- remove current map 
    	if currentMap then 
    		currentMap:Destroy()
    	end
    
    	-- pick a map 
    	local randomPick = nil
    	if #maps > 1 then
    		repeat 
    			randomPick = math.random(1, #maps)
    		until randomPick ~= lastPick
    		lastPick = randomPick
    	end
    
    	-- fetch new map
    	local map = maps[randomPick]
    	currentMap = map:Clone()
    	currentMap.Parent = workspace
    
    	wait(ROUND_TIME)
    end
```
 */
interface ServerStorage extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ServerStorage";
}

interface RbxInternalServiceProvider extends RbxInternalInstance {
	/** Returns the service specified by the given className if it's already created, errors for an invalid name.

## Code Samples

### ServiceProvider:FindService


```lua

print(game:FindService("Part"))
--> nil

print(game:FindService("Workspace"))
--> Workspace

```
 */
	FindService(className: string): Instance | undefined;
	FindService(className: string): Services[keyof Services] | undefined;
	/** Returns a service with the class name requested. When called with the name of a service (such as `Debris`) it will return the instance of that service. If the service does not yet exist it will be created and the new service is returned. This is the only way to create some services, and can also be used for services that have unusual names, e.g. RunService's name is "Run Service".

## Notes

* This function will return nil if the className parameter is an existing class, but the class is not a service.
* If you attempt to fetch a service that is present under another Object, an error will be thrown stating that the "singleton serviceName already exists".

## Code Samples

### ServiceProvider:GetService


```lua
local badgeService = game:GetService("BadgeService")
local gameSettings = UserSettings():GetService("UserGameSettings")
```

### Calling ServiceProvider:GetService twice for same instance


```lua
local gameSettings = game:GetService("UserGameSettings")
local gameSettings2 = game:GetService("UserGameSettings")
```
 */
	GetService<T extends keyof Services>(className: T): Services[T];
	GetService(className: string): Services[keyof Services] | undefined;
	/** Fires when the current place is exited.

## Code Samples

### ServiceProvider.Close

This example prints "The place is closing" when the game.Close event fires.
```lua
game.Close:Connect(function()
print("The place is closing")
end)

```
 */
	readonly Close: RBXScriptSignal<() => void>;
	/** Fired when a service is created. */
	readonly ServiceAdded: RBXScriptSignal<(service: Services[keyof Services]) => void>;
	/** Fired when a service is about to be removed. */
	readonly ServiceRemoving: RBXScriptSignal<(service: Services[keyof Services]) => void>;
}
/** A ServiceProvider is an abstract class, which stores, and provides certain singleton classes, depending on what inherited class you are using its members with. */
type ServiceProvider = DataModel | GenericSettings;

/** The DataModel (commonly known as **game** after the global variable used to access it) is the root of Roblox's parent-child hierarchy. Its direct children are services (such as the `Workspace` and `Lighting`) that act as the fundamental components of a Roblox game.

## Code Samples

### DataModel


```lua
game.Workspace.Part:Destroy() --'game' is a reference to the DataModel
```
 */
interface DataModel extends RbxInternalServiceProvider {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DataModel";
	/** This property describes the ID of the user or group that owns the `place`

If the `CreatorType` property is *’User’* then CreatorId will be the `UserId` of the place’s owner. If the `CreatorType` is *’Group’* then CreatorId will be the ID of the group that owns the place.

## Code Samples

### Detect when the place owner joins the game

This code sample will print an output when the user that owns the game, or a member of the group that owns the game joins the server.

To run this script, place it inside a `Script` in `ServerScriptService`
```lua
local Players = game:GetService("Players")

Players.PlayerAdded:Connect(function(player)
    if game.CreatorType == Enum.CreatorType.User then
        if player.UserId == game.CreatorId then
            print("The place owner has joined the game!")
        end
    elseif game.CreatorType == Enum.CreatorType.Group then
        if player:IsInGroup(game.CreatorId) then
            print("A member of the group that owns the place has joined the game!")
        end
    end
end)

```
 */
	readonly CreatorId: number;
	/** This property describes the `CreatorType` of the `place`, whether the place is owned by a user or a group.

If the `CreatorType` is *‘User’*, then the `CreatorId` property will describe the `UserId` of the account that owns the game. If the CreatorType is *‘Group’* then it will describe the group ID.

## Code Samples

### Detect when the place owner joins the game

This code sample will print an output when the user that owns the game, or a member of the group that owns the game joins the server.

To run this script, place it inside a `Script` in `ServerScriptService`
```lua
local Players = game:GetService("Players")

Players.PlayerAdded:Connect(function(player)
    if game.CreatorType == Enum.CreatorType.User then
        if player.UserId == game.CreatorId then
            print("The place owner has joined the game!")
        end
    elseif game.CreatorType == Enum.CreatorType.Group then
        if player:IsInGroup(game.CreatorId) then
            print("A member of the group that owns the place has joined the game!")
        end
    end
end)

```
 */
	readonly CreatorType: Enum.CreatorType;
	/** This property describes the ID of the `Multi Place game` the `place` running on the server belongs to.

This ID can be found in the top right corner of the [game explorer][1] in Roblox Studio.
When using Roblox Studio, if the place has not been published to Roblox then the GameId will correspond with the template being used.

  [1]: https://www.robloxdev.com/resources/studio/Game-Explorer

## See also
 - `PlaceId`, which describes the ID of the `place` running on the server
 - `JobId`, which is a unique identifier for the server game instance running
 - `TeleportService`, which is a service that can be used to transport `Players` between games */
	readonly GameId: number;
	/** This property is broken and should not be used.


This property historically described the `GearGenreSetting` of the `place`, reflecting the gear permissions configured in the place settings. These settings determine what gear could be added to a `Player's` `StarterGear`.

This property, along with `Genre`, no longer functions correctly and attempting to read it may throw an error. */
	readonly GearGenreSetting: Enum.GearGenreSetting;
	/** This property is broken and should not be used.


This property historically described the `Genre` of the `place` as set on the Roblox website.

This property, along with `GearGenreSetting`, no longer functions correctly due to genres existing on the Roblox website that are not reflected in the `Genre` enum. As a result, attempting to read this property may throw an error. */
	readonly Genre: Enum.Genre;
	/** This property is a unique identifier for the game server instance running. 

The JobId is a [universally unique identifier (UUID)][1] meaning that no two servers, past or present, will ever have the same JobId.

JobId defaults to an empty string in Roblox Studio.

## See also
 - `GetPlayerPlaceInstanceAsync` which can be used to retrieve the JobId of a `Player’s` current server 
 - `TeleportToPlaceInstance` which can be used to teleport a `Player` to a specific server
 - `PrivateServerId` describes the ID of the private server the game server instance belongs to
 - `GenerateGUID`, a function that can be used to generate your own UUIDs

  [1]: https://en.wikipedia.org/wiki/Universally_unique_identifier */
	readonly JobId: string;
	/** This property describes the ID of the `place` running on the server.

This ID corresponds with the number in the `place’s` URL. For example, the ID of the place at the following URL is *1818*:

```lua
https://www.roblox.com/games/1818/Classic-Crossroads
```


The place ID can also be found in the [game explorer][1] in Roblox Studio by right clicking on the place and selecting ‘Copy ID to clipboard’.

When using Roblox Studio, if the place has not been published to Roblox then the PlaceId will correspond with the template being used.

## See also
 - `GameId`, which describes the ID of the `Multi Place game` the current `place` belongs to
 - `JobId`, which is a unique identifier for the server game instance running
 - `TeleportService`, which is a service that can be used to transport `Players` between places

  [1]: https://www.robloxdev.com/resources/studio/Game-Explorer */
	readonly PlaceId: number;
	/** This property describes the version of the `place` the server is running on.

This version number corresponds with the version number shown under the *Version History* section of the `place’s` settings. It is not the current version of the Roblox client.

In Roblox Studio, this property is set to *0*.

When a server instance is created for a `place` it is done so at the place’s current version. If the place is later updated whilst this server is running, the server will remain at its current version. 

This property can be used to display a `ScreenGui` showing the current version of the game to `Players` to assist with debugging.

## Code Samples

### Server version number GUI

This code sample will place a simple GUI in the `StarterGui` showing the place version the server is running at.

To use this sample, place it inside a `Script` in `ServerScriptService`.
```lua
local StarterGui = game:GetService("StarterGui")

-- create a screenGui
local versionGui = Instance.new("ScreenGui")

-- create a textLabel
local textLabel = Instance.new("TextLabel")

-- position in the bottom right corner
textLabel.Position = UDim2.new(1, -10, 1, 0)
textLabel.AnchorPoint = Vector2.new(1, 1)
textLabel.Size = UDim2.new(0, 150, 0, 40)

-- configure the text settings
textLabel.BackgroundTransparency = 1
textLabel.TextColor3 = Color3.new(1, 1, 1)
textLabel.TextStrokeTransparency = 0
textLabel.TextXAlignment = Enum.TextXAlignment.Right
textLabel.TextScaled = true

-- display the version number
local placeVersion = game.PlaceVersion
textLabel.Text = string.format("Server version: %s", placeVersion)
textLabel.Parent = versionGui

-- parent to the StarterGui
versionGui.Parent = StarterGui

```
 */
	readonly PlaceVersion: number;
	/** This property describes the private server ID of the server, if the server is a private server.

If the server is not a private server then this property will be an empty string.

## Private servers
Private servers refer to the following:

 - `Creating a VIP Server on VIP servers`, private servers that can be purchased by players from the games page
 -  Reserved servers, private servers created by the developer using `ReserveServer`

## PrivateServerId vs JobId
The PrivateServerId of a server is different to the `JobId`. The `JobId` is the unique identifier of the current server instance. 

Private servers (VIP or reserved servers) can have multiple server instances associated with them over time. This is because, although only one server instance can be running at once for a private server, new server instances can open and close as players join and leave the game. For example, no server instance is running when nobody is playing in the server. The PrivateServerId will be consistent across all of these server instances, the `JobId` will be unique for each once.

## See also
 - `PrivateServerOwnerId`, a property describing the owner of a VIP server
 - `ReserveServer`, a function which creates a reserved server

## Code Samples

### Detecting Private Servers

`PrivateServerId` and `PrivateServerOwnerId` can be used to detect if the current server instance is a standard server, a VIP server or a reserved server.
```lua
local function getServerType()
	if game.PrivateServerId ~= "" then
		if game.PrivateServerOwnerId ~= 0 then
			return "VIPServer"
		else
			return "ReservedServer"
		end
	else
		return "StandardServer"
	end
end
```
 */
	readonly PrivateServerId: string;
	/** This property describes the `UserId` of the `Player` that owns the `Creating a VIP Server on VIP server` if the server is a VIP server.

If the server is a standard or reserved server then this property will be set to *0*.

This property could be used to identify if a `Player` is the owner of the VIP server, for example:

```lua
local Players = game:GetService("Players")

-- is this a VIP server?
if game.PrivateServerId ~= "" and game.PrivateServerOwnerId ~= 0 then

	-- listen for new players being added
	Players.PlayerAdded:Connect(function(player)

		-- check if the player is the server owner
		if player.UserId == game.PrivateServerOwnerId then
			print("The private server owned has joined the game")
		end
	end)
End
```


## See also
 - `PrivateServerId`, a property describing the unique ID of VIP and `reserved servers`

## Code Samples

### Detecting Private Servers

`PrivateServerId` and `PrivateServerOwnerId` can be used to detect if the current server instance is a standard server, a VIP server or a reserved server.
```lua
local function getServerType()
	if game.PrivateServerId ~= "" then
		if game.PrivateServerOwnerId ~= 0 then
			return "VIPServer"
		else
			return "ReservedServer"
		end
	else
		return "StandardServer"
	end
end
```
 */
	readonly PrivateServerOwnerId: number;
	/** The Workspace property is a reference to the `Workspace` service.

This property will always point to the `Workspace` and will never be *nil*.

The `Workspace` can also be accessed using the global variable `workspace` and the `GetService` function. For example:

```lua
workspace -- a global variable
game.Workspace -- a property of the DataModel (game)
game:GetService("Workspace") -- workspace is a service
``` */
	readonly Workspace: Workspace;
	/** This function binds a function to be called prior to the game shutting down.

Multiple functions can be bound using BindToClose if it is called repeatedly. The game will wait a maximum of 30 seconds for all bound functions to complete running before shutting down. After 30 seconds, the game will shut down regardless if all bound functions have completed or not.

Bound functions will be called in parallel, meaning they will run at the same time.

When using the `DataStoreService`, best practice is to bind a function saving all unsaved data to `DataStores` using BindToClose. Otherwise, data may be lost if the game shuts down unexpectedly. For an example of this, see below.

You are advised to use `IsStudio` to verify the current session is not Roblox Studio. If this is not done, all bound functions will be required to complete in offline testing sessions.

## See also
 - `BindToClose`, which is used to bind a function to a `PluginGui` close button and should not be confused with this function

## Code Samples

### Saving player data before shutting down

The following code sample is an example of how `BindToClose` can be used to save player data in the event of a server shutdown. In this example, player data is stored in a dictionary named *playerData* with `UserIds` as keys.
```lua
local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")

local dataStore = DataStoreService:GetDataStore("Data")

local playerData = {
    -- [UserId] = data
}

game:BindToClose(function()
    -- if the current session is studio, do nothing
    if RunService:IsStudio() then
        return
    end

    print("saving player data")

    -- go through all players, saving their data
    local players = Players:GetPlayers()
    for _, player in pairs(players) do
        local userId = player.UserId
        local data = playerData[userId]
        if data then
            -- wrap in pcall to handle any errors
            local success, result = pcall(function()
                -- SetAsync yields so will stall shutdown
                dataStore:SetAsync(userId, data)
            end)
            if not success then
                warn(result)
            end    
        end
    end

    print("completed saving player data")

end)

```

### DataModel:BindToClose

The example below would print "4" to the output. It would wait three seconds and then print "Done". At this point Roblox will be able to shut down the server.
```lua

game:BindToClose(function()
	print(2*2)
	wait(3)
	print("Done")
end)

```

@param function A function to be called prior to the game shutting down */
	BindToClose(callback: Function): void;
	/** Currently this function only returns the correct value on the client


This function returns whether gear of the given `GeareType` is permitted to be added to `Players’` `StarterGears`. For example:

```lua
local meleeWeaponsAllowed = game:IsGearTypeAllowed(Enum.GearType.MeleeWeapons)
```


Whether gear of a specific `GearType` is permitted in the game is determined in a place’s settings page under ‘Permissions’. Note, all of a gear’s associated `GearTypes` must be enabled for it to be permitted in a place.
@param gearType The given `Enum/GearType`
@returns Whether gear of the given `Enum/GearType` is permitted in the game */
	IsGearTypeAllowed(gearType: CastsToEnum<Enum.GearType>): boolean;
	/** This function returns true if the client has finished loading the game for the first time.

When all initial `Instances` in the game has finished replicating to the client, this function will return true.

Unless they are parented to `ReplicatedFirst`, `LocalScripts` will not run while the game has not loaded. The following snippet, ran from a `LocalScript` in `ReplicatedFirst` will yield until the game has loaded:

```lua
if not game:IsLoaded() then
	game.Loaded:Wait()
end
```


## See also
 - `Loaded`, an event that fires when the game has loaded
 - `WaitForChild`, a function which can be used to wait for an individual `Instance` to replicate without having to wait for the whole game to

## Code Samples

### Custom Loading Screen

This sample is a simple demonstration of how a custom loading screen can be implemented. To run this code it should be placed in a `LocalScript` and parented to `ReplicatedFirst`.

In this example, a basic loading screen will be created and shown until the game has loaded (for a minimum time of 3 seconds). Developers may wish to expand on this with more elegant GUI elements. When doing so ensure that all such elements are parented to `ReplicatedFirst` and fetched using `WaitForChild` to ensure they replicate correctly.
```lua
    local Players = game:GetService("Players")
    local ReplicatedFirst = game:GetService("ReplicatedFirst")
    
    local localPlayer = Players.LocalPlayer 
    local playerGui = localPlayer:WaitForChild("PlayerGui")
    
    local MIN_TIME = 3
    
    -- create a basic loading gui
    local screenGui = Instance.new("ScreenGui")
    local textLabel = Instance.new("TextLabel", screenGui)
    textLabel.Text = "Loading"
    textLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
    textLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    textLabel.Size = UDim2.new(1 , 0, 1, 100) -- make sure the topbar is covered
    textLabel.FontSize = Enum.FontSize.Size14
    screenGui.Parent = playerGui
    
    -- hide the default loading screen 
    ReplicatedFirst:RemoveDefaultLoadingScreen()
    
    -- loop
    local count = 0
    local startTick = tick()
    while true do 
    	local timeElapsed = tick() - startTick
    	-- if the game has loaded and the minimum time has elapsed then break the loop
    	if game:IsLoaded() and timeElapsed > MIN_TIME then
    		break
    	end
    
    	-- animate the text 
    	textLabel.Text = "Loading " .. string.rep(".",count)
    	count = (count + 1) % 4
    
    	wait(.3)
    end
    
    -- destroy the loading screen
    screenGui:Destroy()


```

@returns Whether the client has finished loading the game for the first time */
	IsLoaded(): boolean;
	/** This event is fired when the user prompts an increase or decrease in graphics quality using the hotkeys.

This event fires under the following conditions:
 - If the user presses F10, this event fires with a *betterQuality* argument of *true*
 - If the user presses Shift + F10, this event fires with a *betterQuality* argument of *false*

GraphicsQualityChangeRequest does not provide the current graphics quality level or cover all updates to the graphics quality. For example, changes made in the core GUI escape menu are not registered. This event is intended to be used by Roblox core scripts to update the graphics quality and display notifications.

You can retrieve a user's `SavedQualitySetting` using `UserGameSettings` with the following snippet:

```lua
UserSettings():GetService("UserGameSettings").SavedQualityLevel
```


Note, if the user’s graphics settings are set to automatic then the `SavedQualitySetting` will be *‘Automatic’*. There is currently no way for developers to reliably get the current graphics quality level of a user’s machine.

## Code Samples

### DataModel.GraphicsQualityChangeRequest


```lua
game.GraphicsQualityChangeRequest:Connect(function (betterQuality)
	if betterQuality then
		print("The user has requested an increase in graphics quality!")
	else
		print("The user has requested a decrease in graphics quality!")
	end
end)

```
 */
	readonly GraphicsQualityChangeRequest: RBXScriptSignal<(betterQuality: boolean) => void>;
	/** This event fires on the client when the game finishes loading for the first time.

The Loaded event fires when all initial `Instances` in the game have finished replicating to the client.

Unless they are parented to `ReplicatedFirst`, `LocalScripts` will not run prior to this event firing. The following snippet, ran from a `LocalScript` in `ReplicatedFirst`, will yield until the game has loaded:

```lua
if not game:IsLoaded() then
	game.Loaded:Wait()
end
```


## See also
 - `IsLoaded`, a function that returns if the game is loaded or not
 - `WaitForChild`, a function which can be used to wait for an individual `Instance` to replicate without having to wait for the whole game to */
	readonly Loaded: RBXScriptSignal<() => void>;
}

interface RbxInternalGenericSettings extends RbxInternalServiceProvider {}
/** The abstract class for settings database classes. */
type GenericSettings = AnalysticsSettings | GlobalSettings | UserSettings;

/** AnalysticsSettings is an internal settings provider that stores the `GoogleAnalyticsConfiguration` object. */
interface AnalysticsSettings extends RbxInternalGenericSettings {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "AnalysticsSettings";
}

/** The base object used for Roblox Studio's settings menu.
Can be accessed by using the `settings()` function.

## Settings classes under the GlobalSettings

* `DebugSettings`
* `GameSettings`
* `LuaSettings`
* `NetworkSettings`
* `PhysicsSettings`
* `RenderSettings`
* `Studio` */
interface GlobalSettings extends RbxInternalGenericSettings {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "GlobalSettings";
	/** Returns the value of an FFlag if it exists. */
	GetFFlag(name: string): boolean;
	/** Returns the value of an FVariable, if it exists. */
	GetFVariable(name: string): string;
}

/** UserSettings is a singleton object that is used to house basic user settings, which persist across all games. Currently, it only stores the `UserGameSettings` object.

You can retrieve a reference to this object via the `UserSettings()` function, which returns it.

## Code Samples

### UserGameSettings Listener

A basic example that shows how you can listen to changes in the user's settings.
With this code pasted into a LocalScript running in the StarterPlayerScripts, you can change settings in Roblox's game menu, and see their values appear in the output as detected changes.
```lua
local GameSettings = UserSettings().GameSettings

local function onGameSettingChanged(nameOfSetting)
	-- Fetch the value of this setting through a pcall to make sure we can retrieve it.
	-- Sometimes the event fires with properties that LocalScripts can't access.	
	local canGetSetting,setting = pcall(function ()
		return GameSettings[nameOfSetting]
	end)
	
	if canGetSetting then
		print("Your " .. nameOfSetting .. " has changed to: " .. tostring(setting))
	end
end

GameSettings.Changed:Connect(onGameSettingChanged)
```

### Full Screen Mode Detection

A LocalScript that demonstrates how you can detect whether a game is in full screen or not.
```lua
local GameSettings = UserSettings().GameSettings

local function checkFullScreenMode()
	local inFullscreen = GameSettings:InFullScreen()
	if inFullscreen then
		print("Full Screen mode enabled!")
	else
		print("Full Screen mode disabled!")
	end
end

checkFullScreenMode()
GameSettings.FullscreenChanged:Connect(checkFullScreenMode)
```

### IsUserFeatureEnabled Sample

A basic sample of how the IsUserFeatureEnabled function is used by Roblox to control certain features.
```lua
if UserSettings():IsUserFeatureEnabled("UserNoCameraClickToMove") then
	print("'ClickToMove' should no longer be loaded from the CameraScript!")
else
	print("'ClickToMove' is still loaded from the CameraScript!")
end
```
 */
interface UserSettings extends RbxInternalGenericSettings {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UserSettings";
	/** Returns true if the specified user feature is enabled. This will throw an error if the user feature does not exist.

This function checks against a list of FFlags, whose name starts with "User". The function is intended to be used by Roblox-created scripts, and functions similarly to `GetFFlag`.

## Code Samples

### IsUserFeatureEnabled Sample

A basic sample of how the IsUserFeatureEnabled function is used by Roblox to control certain features.
```lua
if UserSettings():IsUserFeatureEnabled("UserNoCameraClickToMove") then
	print("'ClickToMove' should no longer be loaded from the CameraScript!")
else
	print("'ClickToMove' is still loaded from the CameraScript!")
end
```
 */
	IsUserFeatureEnabled(name: string): boolean;
	/** Erases the saved state of the UserSettings, and restores its values back to default. This function will fail to run correctly from a LocalScript, as it does not have permission to restore all of the properties in the `UserGameSettings` class. */
	Reset(): void;
}

/** The Sky object is an object, when placed inside `Lighting`, will change the appearance of the game's sky. This allows for a custom sky to be used as opposed to the Roblox default sky. The Skybox is composed of six sides, much like that of a cube. If the skybox is changed/customised, the Sun and other objects in the sky will remain visible, unless you turn off the Sky object's `CelestialBodiesShown` property, which will remove the Sun, Moon, and stars from the sky. The recommended picture dimensions for a Skybox side are 256x256 pixels. By adjusting the `StarCount` property of the Sky object, you can change how many stars will appear in the sky at night. */
interface Sky extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Sky";
	/** Sets whether the Sun, Moon, and stars will show. */
	CelestialBodiesShown: boolean;
	/** The perceived angular size of the moon while using this skybox, in degrees. */
	MoonAngularSize: number;
	/** The texture of the moon while using this skybox. */
	MoonTextureId: string;
	/** The URL link to a picture for the back surface of the sky. */
	SkyboxBk: string;
	/** The URL asset link to a picture for the Bottom surface of the sky. */
	SkyboxDn: string;
	/** The URL link to a picture for the front surface of the skybox. */
	SkyboxFt: string;
	/** The URL link to a picture for the left surface of the sky. */
	SkyboxLf: string;
	/** The URL link to a picture for the right surface of the sky. */
	SkyboxRt: string;
	/** The URL link to a picture for the top surface of the sky. */
	SkyboxUp: string;
	/** How many stars are shown in the skybox. Note that too many stars may cause severe lag. Only works if `CelestialBodiesShown` is true. */
	StarCount: number;
	/** The perceived angular size of the sun while using this skybox, in degrees. */
	SunAngularSize: number;
	/** The texture of the sun while using this skybox. */
	SunTextureId: string;
}

/** Smoke is one of several particle-emitting classes. Like other particle emitters of its kind, Smoke objects emit particles when parented to a `BasePart` (such as a `Part`) or an `Attachment` within such a `BasePart`. Compared to the `ParticleEmitter` class, Smoke lacks many different customization properties and special methods, such as `Lifetime` or `Emit`. It is useful to create a quick special effect in a pinch; for more detailed work it is preferable to use a `ParticleEmitter` instead.

![Smoke rising from the part to which it was parented](https://developer.roblox.com/assets/blt3634602492a8e3eb/Smoke.png)

When `Enabled` is toggled off, particles emit by this object will continue to render until their lifetime expires. When a Smoke object's `Parent` is set to nil (and/or `Destroy`ed), all particles will instantly disappear. If this effect is not desired, try hiding the parent object at a far away position, then removing the Smoke after a few seconds using `Debris` to give the last particles a chance to expire. This object does not have a `Clear` method, but it is possible to set the `Parent` to nil and back to the exact same object for the same effect.

Smoke particles are only emit from the center of `BasePart` to which they are parented. Parenting a Smoke object to an `Attachment` instead allows customization of the particles' start position.

## Code Samples

### Add Smoke to All Fire

This code sample adds a `Smoke` object to every `Fire` object in the `Workspace`. It does this by using a recursive search.
```lua
local function recurseForFire(object)
	-- Check if we found a Fire object that has no Smoke
	if object:IsA("Fire") and not object.Parent:FindFirstChildOfClass("Smoke") then
		-- Create a smoke effect for this fire
		local smoke = Instance.new("Smoke")
		smoke.Color = Color3.new(0, 0, 0)
		smoke.Opacity = 0.15
		smoke.RiseVelocity = 4
		smoke.Size = object.Size / 4
		smoke.Parent = object.Parent
	end
	-- Continue search for Fire objects
	for _, child in pairs(object:GetChildren()) do
		recurseForFire(child)
	end
end
recurseForFire(workspace)
```
 */
interface Smoke extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Smoke";
	/** The Color property determines the color of all the particles emit by a `Smoke` object (both existing and future particles). It behaves similarly to `Color`, except that it is only one color and not a `ColorSequence`. A color of white with some `Opacity` makes for a nice fog effect, and a very opaque black color can compliment a `Fire` object nicely.

![Two Smoke objects with different colors](https://developer.roblox.com/assets/blt6952d1f0943c1f61/Smoke_Color.png)

In the screenshot below, a `Fire` object within a torch model is complimented by a `Smoke` object above it with `RiseVelocity` set to 5 and Color set to black.
![A Smoke object complimenting a Fire object on a torch](https://developer.roblox.com/assets/blt02d5fee090b5bc62/Smoke_Fire.png)

## Code Samples

### Add Smoke to All Fire

This code sample adds a `Smoke` object to every `Fire` object in the `Workspace`. It does this by using a recursive search.
```lua
local function recurseForFire(object)
	-- Check if we found a Fire object that has no Smoke
	if object:IsA("Fire") and not object.Parent:FindFirstChildOfClass("Smoke") then
		-- Create a smoke effect for this fire
		local smoke = Instance.new("Smoke")
		smoke.Color = Color3.new(0, 0, 0)
		smoke.Opacity = 0.15
		smoke.RiseVelocity = 4
		smoke.Size = object.Size / 4
		smoke.Parent = object.Parent
	end
	-- Continue search for Fire objects
	for _, child in pairs(object:GetChildren()) do
		recurseForFire(child)
	end
end
recurseForFire(workspace)
```
 */
	Color: Color3;
	/** The Enabled property, much like `Enabled`, determines whether smoke particles are emit. Any particles already emit will continue to render until their lifetime expires. This property is useful for keeping pre-made smoke effects off until they are needed later. Since smoke particles are destroyed when the `Smoke` object's `Parent` is set to nil, this property is useful in allowing existing particles the opportunity to expire before destroying the Fire object altogether. See the function below.

```lua
local Debris = game:GetService("Debris")
local part = script.Parent
function stopSmoke(smoke)
	smoke.Enabled = false -- No more new particles
	Debris:AddItem(smoke, 10) -- Remove the object after a delay (after existing particles have expired)
end
stopSmoke(part.Smoke)
```

## Code Samples

### Add Smoke to All Fire

This code sample adds a `Smoke` object to every `Fire` object in the `Workspace`. It does this by using a recursive search.
```lua
local function recurseForFire(object)
	-- Check if we found a Fire object that has no Smoke
	if object:IsA("Fire") and not object.Parent:FindFirstChildOfClass("Smoke") then
		-- Create a smoke effect for this fire
		local smoke = Instance.new("Smoke")
		smoke.Color = Color3.new(0, 0, 0)
		smoke.Opacity = 0.15
		smoke.RiseVelocity = 4
		smoke.Size = object.Size / 4
		smoke.Parent = object.Parent
	end
	-- Continue search for Fire objects
	for _, child in pairs(object:GetChildren()) do
		recurseForFire(child)
	end
end
recurseForFire(workspace)
```
 */
	Enabled: boolean;
	/** Opacity determines the opaqueness of the smoke particles. It must be in the range [0, 1]. This property works **inversely** in comparison to a part's `Transparency` or ParticleEmitter's `Transparency`: a value of 0 is completely invisible, 1 is completely visible. Below, the left `Smoke` effect has an Opacity of 0.25 (or, 25%), the center has the default 0.5 (50%), and the right has 1.0 (or 100%).

![Smoke with varying opacity levels](https://developer.roblox.com/assets/blt40432eff6f9ab4f2/Smoke_Opacity.png)

It should be noted that the texture that Roblox uses for `Smoke` particles is partially transparent, so setting this property to 1 will still yield transparency in rendered smoke.

## Code Samples

### Add Smoke to All Fire

This code sample adds a `Smoke` object to every `Fire` object in the `Workspace`. It does this by using a recursive search.
```lua
local function recurseForFire(object)
	-- Check if we found a Fire object that has no Smoke
	if object:IsA("Fire") and not object.Parent:FindFirstChildOfClass("Smoke") then
		-- Create a smoke effect for this fire
		local smoke = Instance.new("Smoke")
		smoke.Color = Color3.new(0, 0, 0)
		smoke.Opacity = 0.15
		smoke.RiseVelocity = 4
		smoke.Size = object.Size / 4
		smoke.Parent = object.Parent
	end
	-- Continue search for Fire objects
	for _, child in pairs(object:GetChildren()) do
		recurseForFire(child)
	end
end
recurseForFire(workspace)
```
Opacity determines the opaqueness of the smoke particles. It must be in the range [0, 1]. This property works **inversely** in comparison to a part's `Transparency` or ParticleEmitter's `Transparency`: a value of 0 is completely invisible, 1 is completely visible. Below, the left `Smoke` effect has an Opacity of 0.25 (or, 25%), the center has the default 0.5 (50%), and the right has 1.0 (or 100%).

![Smoke with varying opacity levels](https://developer.roblox.com/assets/blt40432eff6f9ab4f2/Smoke_Opacity.png)

It should be noted that the texture that Roblox uses for `Smoke` particles is partially transparent, so setting this property to 1 will still yield transparency in rendered smoke.

## Code Samples

### Add Smoke to All Fire

This code sample adds a `Smoke` object to every `Fire` object in the `Workspace`. It does this by using a recursive search.
```lua
local function recurseForFire(object)
	-- Check if we found a Fire object that has no Smoke
	if object:IsA("Fire") and not object.Parent:FindFirstChildOfClass("Smoke") then
		-- Create a smoke effect for this fire
		local smoke = Instance.new("Smoke")
		smoke.Color = Color3.new(0, 0, 0)
		smoke.Opacity = 0.15
		smoke.RiseVelocity = 4
		smoke.Size = object.Size / 4
		smoke.Parent = object.Parent
	end
	-- Continue search for Fire objects
	for _, child in pairs(object:GetChildren()) do
		recurseForFire(child)
	end
end
recurseForFire(workspace)
```


Tags: NotReplicated */
	Opacity: number;
	/** RiseVelocity behaves similarly to `Speed` and `Heat`: it determines how fast the smoke particles move during their lifetime. It must be in the range [-25, 25]. Negative values will cause particles to emit in the bottom (-Y) direction of the parent `BasePart`.

When using a `Smoke` effect to create fog, set this property to 0. For large smoke effects, make the rise subtle (2 to 8). For chimneys and smokestacks, higher values are appropriate.

## Code Samples

### Add Smoke to All Fire

This code sample adds a `Smoke` object to every `Fire` object in the `Workspace`. It does this by using a recursive search.
```lua
local function recurseForFire(object)
	-- Check if we found a Fire object that has no Smoke
	if object:IsA("Fire") and not object.Parent:FindFirstChildOfClass("Smoke") then
		-- Create a smoke effect for this fire
		local smoke = Instance.new("Smoke")
		smoke.Color = Color3.new(0, 0, 0)
		smoke.Opacity = 0.15
		smoke.RiseVelocity = 4
		smoke.Size = object.Size / 4
		smoke.Parent = object.Parent
	end
	-- Continue search for Fire objects
	for _, child in pairs(object:GetChildren()) do
		recurseForFire(child)
	end
end
recurseForFire(workspace)
```
RiseVelocity behaves similarly to `Speed` and `Heat`: it determines how fast the smoke particles move during their lifetime. It must be in the range [-25, 25]. Negative values will cause particles to emit in the bottom (-Y) direction of the parent `BasePart`.

When using a `Smoke` effect to create fog, set this property to 0. For large smoke effects, make the rise subtle (2 to 8). For chimneys and smokestacks, higher values are appropriate.

## Code Samples

### Add Smoke to All Fire

This code sample adds a `Smoke` object to every `Fire` object in the `Workspace`. It does this by using a recursive search.
```lua
local function recurseForFire(object)
	-- Check if we found a Fire object that has no Smoke
	if object:IsA("Fire") and not object.Parent:FindFirstChildOfClass("Smoke") then
		-- Create a smoke effect for this fire
		local smoke = Instance.new("Smoke")
		smoke.Color = Color3.new(0, 0, 0)
		smoke.Opacity = 0.15
		smoke.RiseVelocity = 4
		smoke.Size = object.Size / 4
		smoke.Parent = object.Parent
	end
	-- Continue search for Fire objects
	for _, child in pairs(object:GetChildren()) do
		recurseForFire(child)
	end
end
recurseForFire(workspace)
```


Tags: NotReplicated */
	RiseVelocity: number;
	/** The Size property of `Smoke` determines the size of the newly emit smoke particles. Unlike `Color`, this property will not change the size of existing particles. It must be in the range [0.1, 100]. Unlike `Size`, this property is only a number (not a `NumberSequence`). Also note also that the size of the particles is not 1-to-1 with studs; in fact, the size of the smoke particle is more than twice as large. At the largest size, smoke particles can render larger than 200 studs wide!

## Code Samples

### Add Smoke to All Fire

This code sample adds a `Smoke` object to every `Fire` object in the `Workspace`. It does this by using a recursive search.
```lua
local function recurseForFire(object)
	-- Check if we found a Fire object that has no Smoke
	if object:IsA("Fire") and not object.Parent:FindFirstChildOfClass("Smoke") then
		-- Create a smoke effect for this fire
		local smoke = Instance.new("Smoke")
		smoke.Color = Color3.new(0, 0, 0)
		smoke.Opacity = 0.15
		smoke.RiseVelocity = 4
		smoke.Size = object.Size / 4
		smoke.Parent = object.Parent
	end
	-- Continue search for Fire objects
	for _, child in pairs(object:GetChildren()) do
		recurseForFire(child)
	end
end
recurseForFire(workspace)
```
The Size property of `Smoke` determines the size of the newly emit smoke particles. Unlike `Color`, this property will not change the size of existing particles. It must be in the range [0.1, 100]. Unlike `Size`, this property is only a number (not a `NumberSequence`). Also note also that the size of the particles is not 1-to-1 with studs; in fact, the size of the smoke particle is more than twice as large. At the largest size, smoke particles can render larger than 200 studs wide!

## Code Samples

### Add Smoke to All Fire

This code sample adds a `Smoke` object to every `Fire` object in the `Workspace`. It does this by using a recursive search.
```lua
local function recurseForFire(object)
	-- Check if we found a Fire object that has no Smoke
	if object:IsA("Fire") and not object.Parent:FindFirstChildOfClass("Smoke") then
		-- Create a smoke effect for this fire
		local smoke = Instance.new("Smoke")
		smoke.Color = Color3.new(0, 0, 0)
		smoke.Opacity = 0.15
		smoke.RiseVelocity = 4
		smoke.Size = object.Size / 4
		smoke.Parent = object.Parent
	end
	-- Continue search for Fire objects
	for _, child in pairs(object:GetChildren()) do
		recurseForFire(child)
	end
end
recurseForFire(workspace)
```


Tags: NotReplicated */
	Size: number;
}

interface SocialService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SocialService";
	/** This function will invoke a Reflected *RobloxScriptSecurity* only event `PromptInviteRequested`. 

The targetPlayer will be shown a modal invite screen. It can error if *targetPlayer* is not in the datamodel.

### How Game Invites Work
  - User joins a game and presses a developer-constructed button. Activating the button will invoke `PromptGameInvite(localPlayer)`.

![Step 1](https://developer.roblox.com/assets/5ca56a2de2c6d6592e0b0bd5/inviteFlow1.png)

  - This function call will fire a `rbx::signal` (called `PromptInviteRequested`). The `CoreScripts` are bound to this signal through Reflection and once invoked will show the user a version of the following screen:

![Step 2](https://developer.roblox.com/assets/5ca56a51d06594542e9667ac/inviteFlow2.png)

  - When the user successfully sends an invite, a rbx::signal will fire on the client and server (called SocialService.PromptInviteRequested).  

![Step 3](https://developer.roblox.com/assets/5ca56aa66f69e6812ec3331a/inviteFlow3.png)

### See also
This is part of the `SocialService` class containing a set of APIs that allow you to integrate game invitations into your games.
  - `GameInvitePromptClosed`, fires when a player closes a game invite prompt
  - `CanSendGameInviteAsync`, returns true or false depending on the user

## Code Samples

### Sending a Game Invite

The following code sample demonstrates how to implement several `SocialService` APIs to allow players to invite other players to your game.

In order to work as expected, the code sample must be placed in a `LocalScript` descending from a `GuiButton`. When the `LocalPlayer` touches or left clicks the GUI button, it executes *openGameInvitePrompt()* which opens the game invite prompt using `PromptGameInvite` after firing *canSendGameInvite()* to check if the player can send game invites using `CanSendGameInviteAsync`.

When the player closes the invite prompt, the *invitePromptClosed()* function connected to the `GameInvitePromptClosed`event fires.
```lua
local SocialService = game:GetService(“SocialService”)
local Players = game:GetService(“Players”)
local player = Players.LocalPlayer

local function canSendGameInvite(targetPlayer)
	local res, canSend = pcall(SocialService:CanSendGameInvite(targetPlayer))
	return res and canSend
end

local function promptGameInvite(targetPlayer)
	local res, canInvite = pcall(PromptGameInvite(targetPlayer))
	return res and canInvite
end

local function openGameInvitePrompt(targetPlayer)
	local canInvite = canSendGameInvite(targetPlayer)
	if canInvite then
		local promptOpened = promptGameInvite(targetPlayer)
		return promptOpened
	end
	return false
end

local function invitePromptClosed(senderPlayer, recipientIds)
	-- Handle custom logic for players invited by sender
end

local function inputBegan(input, gameProcessed)
	local inputType = input.UserInputType
	local touch = Enum.UserInputType.Touch
	local mouse1 = Enum.UserInputType.MouseButton1

	if inputType == touch or inputType == mouse1 then
		openGameInvitePrompt(player)
	end
end

script.Parent.InputBegan:Connect(inputBegan)
SocialService.GameInvitePromptClosed:Connect(invitePromptClosed)
```

@param player The player to prompt with the game invite screen
@returns No return */
	PromptGameInvite(targetPlayer: Player): void;
	/** This function indicates whether the specified `Player` can send game invites. It returns true or false depending on the client's platform and privacy settings. It can error if *targetPlayer* is not in the datamodel.

### How Game Invites Work
  - User joins a game and presses a developer-constructed button. Activating the button will invoke `PromptGameInvite(localPlayer)`.

![Step 1](https://developer.roblox.com/assets/5ca56a2de2c6d6592e0b0bd5/inviteFlow1.png)

  - This function call will fire a `rbx::signal` (called `PromptInviteRequested`). The `CoreScripts` are bound to this signal through Reflection and once invoked will show the user a version of the following screen:

![Step 2](https://developer.roblox.com/assets/5ca56a51d06594542e9667ac/inviteFlow2.png)

  - When the user successfully sends an invite, a rbx::signal will fire on the client and server (called SocialService.PromptInviteRequested).  

![Step 3](https://developer.roblox.com/assets/5ca56aa66f69e6812ec3331a/inviteFlow3.png)

### See also
This is part of the `SocialService` class containing a set of APIs that allow you to integrate game invitations into your games.
  - `PromptGameInvite`, prompts the specified player with the game invite screen
  - `GameInvitePromptClosed`, fires when a player closes a game invite prompt

## Code Samples

### Sending a Game Invite

The following code sample demonstrates how to implement several `SocialService` APIs to allow players to invite other players to your game.

In order to work as expected, the code sample must be placed in a `LocalScript` descending from a `GuiButton`. When the `LocalPlayer` touches or left clicks the GUI button, it executes *openGameInvitePrompt()* which opens the game invite prompt using `PromptGameInvite` after firing *canSendGameInvite()* to check if the player can send game invites using `CanSendGameInviteAsync`.

When the player closes the invite prompt, the *invitePromptClosed()* function connected to the `GameInvitePromptClosed`event fires.
```lua
local SocialService = game:GetService(“SocialService”)
local Players = game:GetService(“Players”)
local player = Players.LocalPlayer

local function canSendGameInvite(targetPlayer)
	local res, canSend = pcall(SocialService:CanSendGameInvite(targetPlayer))
	return res and canSend
end

local function promptGameInvite(targetPlayer)
	local res, canInvite = pcall(PromptGameInvite(targetPlayer))
	return res and canInvite
end

local function openGameInvitePrompt(targetPlayer)
	local canInvite = canSendGameInvite(targetPlayer)
	if canInvite then
		local promptOpened = promptGameInvite(targetPlayer)
		return promptOpened
	end
	return false
end

local function invitePromptClosed(senderPlayer, recipientIds)
	-- Handle custom logic for players invited by sender
end

local function inputBegan(input, gameProcessed)
	local inputType = input.UserInputType
	local touch = Enum.UserInputType.Touch
	local mouse1 = Enum.UserInputType.MouseButton1

	if inputType == touch or inputType == mouse1 then
		openGameInvitePrompt(player)
	end
end

script.Parent.InputBegan:Connect(inputBegan)
SocialService.GameInvitePromptClosed:Connect(invitePromptClosed)
```

@param player The player instance of the user used to determine if the client can send a game invite
@returns Whether the specified player can send a game invite */
	CanSendGameInviteAsync(targetPlayer: Player): boolean;
	/** This event is a signal  invoked when a player has closed the game invite prompt and batches all users and conversation participants into a single array. This prompt can be prompted by the developer or accessed from the SettingsHub menu.

### How Game Invites Work
  - User joins a game and presses a developer-constructed button. Activating the button will invoke `PromptGameInvite(localPlayer)`.

![Step 1](https://developer.roblox.com/assets/5ca56a2de2c6d6592e0b0bd5/inviteFlow1.png)

  - This function call will fire a `rbx::signal` (called `PromptInviteRequested`). The `CoreScripts` are bound to this signal through Reflection and once invoked will show the user a version of the following screen:

![Step 2](https://developer.roblox.com/assets/5ca56a51d06594542e9667ac/inviteFlow2.png)

  - When the user successfully sends an invite, a rbx::signal will fire on the client and server (called SocialService.PromptInviteRequested).  

![Step 3](https://developer.roblox.com/assets/5ca56aa66f69e6812ec3331a/inviteFlow3.png)

### See also
This is part of the `SocialService` class containing a set of APIs that allow you to integrate game invitations into your games.
  - `PromptGameInvite`, prompts the specified player with the game invite screen
  - `CanSendGameInviteAsync`, returns true or false depending on the user

## Code Samples

### Sending a Game Invite

The following code sample demonstrates how to implement several `SocialService` APIs to allow players to invite other players to your game.

In order to work as expected, the code sample must be placed in a `LocalScript` descending from a `GuiButton`. When the `LocalPlayer` touches or left clicks the GUI button, it executes *openGameInvitePrompt()* which opens the game invite prompt using `PromptGameInvite` after firing *canSendGameInvite()* to check if the player can send game invites using `CanSendGameInviteAsync`.

When the player closes the invite prompt, the *invitePromptClosed()* function connected to the `GameInvitePromptClosed`event fires.
```lua
local SocialService = game:GetService(“SocialService”)
local Players = game:GetService(“Players”)
local player = Players.LocalPlayer

local function canSendGameInvite(targetPlayer)
	local res, canSend = pcall(SocialService:CanSendGameInvite(targetPlayer))
	return res and canSend
end

local function promptGameInvite(targetPlayer)
	local res, canInvite = pcall(PromptGameInvite(targetPlayer))
	return res and canInvite
end

local function openGameInvitePrompt(targetPlayer)
	local canInvite = canSendGameInvite(targetPlayer)
	if canInvite then
		local promptOpened = promptGameInvite(targetPlayer)
		return promptOpened
	end
	return false
end

local function invitePromptClosed(senderPlayer, recipientIds)
	-- Handle custom logic for players invited by sender
end

local function inputBegan(input, gameProcessed)
	local inputType = input.UserInputType
	local touch = Enum.UserInputType.Touch
	local mouse1 = Enum.UserInputType.MouseButton1

	if inputType == touch or inputType == mouse1 then
		openGameInvitePrompt(player)
	end
end

script.Parent.InputBegan:Connect(inputBegan)
SocialService.GameInvitePromptClosed:Connect(invitePromptClosed)
```
 */
	readonly GameInvitePromptClosed: RBXScriptSignal<(senderPlayer: Player, recipientIds: Array<number>) => void>;
}

/** A `Sound` is an object that emits sound. See `Adding Adding Sounds` for more info on how to upload a sound file.

## 2D and 3D Sound

A sound placed in a `BasePart` or an `Attachment` will emit its sound from that part's `Position` or the attachment's `WorldPosition`. A sound exhibits the Doppler effect, meaning its frequency and pitch varies with the relative motion of whatever attachment or part it is attached to. The volume of the sound will be determined by the distance between the client's sound listener (by default the `Camera` position) and the position of the sound's parent. For more information on this see `RollOffMode`.

A sound is considered "global" if it is not parented to a `BasePart` or an `Attachment`. In this case, the sound will play at the same volume throughout the entire place.

## Sound Replication

Sound playback is not filtered. If a particular client starts playing a sound, all of the other clients will also play it unless `RespectFilteringEnabled` is set to true.

#### Important

* While the playback of sounds will replicate, other properties such as the playback speed, pitch, volume, etc. will **not** replicate. This behavior can be avoided by creating all sounds locally on the client, as instancing sounds will not replicate to the server.
* `TimePosition`, `TimeLength`, and `Playing` will all properly replicate when set from the server.

## Code Samples

### Music Playing Part

The code in this sample demonstrates how a sound parented to a Part or Attachment will play locally and experience volume drop off the further the player's camera is away from the part.

A part is instanced, and a sound is instanced and parented to the part. A click detector is set up on the part that will check if the sound is playing, using `Sound.IsPlaying` and play or stop the sound depending.
```lua
-- create a part
local part = Instance.new("Part")
part.Anchored = true
part.Position = Vector3.new(0, 3, 0)
part.BrickColor = BrickColor.new("Bright red")
part.Name = "MusicBox"
part.Parent = game.Workspace

-- create a sound
local sound = Instance.new("Sound", part)
sound.SoundId = "rbxassetid://301964312" 
sound.EmitterSize = 5 -- decrease the emitter size (for earlier volume drop off)
sound.Looped = true

-- create a click detector
local clickDetector = Instance.new("ClickDetector", part)
clickDetector.MouseClick:Connect(function()
	-- toggle the sound playing / not playing
	if not sound.IsPlaying then
		part.BrickColor = BrickColor.new("Bright green")	
		sound:Play()
	else
		part.BrickColor = BrickColor.new("Bright red")	
		sound:Stop()
	end
end)
```

### Sound in the Workspace

This sample gives a simple example of how a Sound that is not parented to a Part or Attachment will play at a constant volume throughout the place. A sound is instanced and parented to the Workspace, and then played.
```lua
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"
sound.Looped = true
sound:Play()
```
 */
interface Sound extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Sound";
	/** The minimum distance at which a 3D `Sound` (direct child of a `BasePart` or `Attachment`) will begin to attenuate (decrease in volume).

Sounds parented to a `BasePart` or `Attachment` that are descendants of the `Workspace` are considered 3D sounds and their volume whilst playing is dependent on the distance between the client's sound listener (`Camera` position by default) and the Sound's parent. Two properties influence this behavior `EmitterSize` and `RollOffMode`.

The way the `Sound` attenuates (fades out) after the distance between the listener and the sound exceeds the `EmitterSize` is determined by `RollOffMode`.

## Code Samples

### Music Playing Part

The code in this sample demonstrates how a sound parented to a Part or Attachment will play locally and experience volume drop off the further the player's camera is away from the part.

A part is instanced, and a sound is instanced and parented to the part. A click detector is set up on the part that will check if the sound is playing, using `Sound.IsPlaying` and play or stop the sound depending.
```lua
-- create a part
local part = Instance.new("Part")
part.Anchored = true
part.Position = Vector3.new(0, 3, 0)
part.BrickColor = BrickColor.new("Bright red")
part.Name = "MusicBox"
part.Parent = game.Workspace

-- create a sound
local sound = Instance.new("Sound", part)
sound.SoundId = "rbxassetid://301964312" 
sound.EmitterSize = 5 -- decrease the emitter size (for earlier volume drop off)
sound.Looped = true

-- create a click detector
local clickDetector = Instance.new("ClickDetector", part)
clickDetector.MouseClick:Connect(function()
	-- toggle the sound playing / not playing
	if not sound.IsPlaying then
		part.BrickColor = BrickColor.new("Bright green")	
		sound:Play()
	else
		part.BrickColor = BrickColor.new("Bright red")	
		sound:Stop()
	end
end)
```
 */
	EmitterSize: number;
	/** This property will be true when the `Sound` has loaded loaded from Roblox servers and is ready to play.

In Roblox, audio files are not stored in games themselves but hosted on the Roblox servers and referenced by the `SoundId` property. This means that they need to be downloaded to a client's device before they can be played. This can take a while depending on the user's internet connection, the length of the sound and the number of other objects that need to be loaded. 

Developers can use the `IsLoaded` property and the `Loaded` event if they wish to verify a sound has loaded before playing it.

## Code Samples

### Load Sound

This simple function will verify a Sound has loaded by checking the Sound.IsLoaded property. If Sound.IsLoaded is false it will wait for the Loaded event before resuming.

It is important to check Sound.IsLoaded before connecting to the Sound.Loaded event, as if the sound has already loaded the Sound.Loaded event will not fire and the function will yield indefinitely.
```lua
local function loadSound(sound)
	-- Has the sound already loaded?
	if not sound.IsLoaded then 
		-- if not, wait until it has been
		sound.Loaded:Wait()
	end
end
loadSound(Workspace.Sound)

```
This property will be true when the `Sound` has loaded loaded from Roblox servers and is ready to play.

In Roblox, audio files are not stored in games themselves but hosted on the Roblox servers and referenced by the `SoundId` property. This means that they need to be downloaded to a client's device before they can be played. This can take a while depending on the user's internet connection, the length of the sound and the number of other objects that need to be loaded. 

Developers can use the `IsLoaded` property and the `Loaded` event if they wish to verify a sound has loaded before playing it.

## Code Samples

### Load Sound

This simple function will verify a Sound has loaded by checking the Sound.IsLoaded property. If Sound.IsLoaded is false it will wait for the Loaded event before resuming.

It is important to check Sound.IsLoaded before connecting to the Sound.Loaded event, as if the sound has already loaded the Sound.Loaded event will not fire and the function will yield indefinitely.
```lua
local function loadSound(sound)
	-- Has the sound already loaded?
	if not sound.IsLoaded then 
		-- if not, wait until it has been
		sound.Loaded:Wait()
	end
end
loadSound(Workspace.Sound)

```


Tags: ReadOnly, NotReplicated */
	readonly IsLoaded: boolean;
	/** This read-only property will return true when the `Sound` is not playing. Note that this property will not only return true once a sound has been paused using the `Pause` function but also if it has been stopped using the `Stop` function or never been played. 

This property will only be true when `IsPlaying` is false.

As IsPaused is read only it can not be used to stop the sound, `Stop` and `Pause` should be used instead.

## Code Samples

### Sound IsPlaying and SoundIsPaused

This code sample contains demonstrates when the Sound.IsPlaying and Sound.IsPaused properties will be true or false.

A sound is instanced in the Workspace and the Sound.IsLoaded property is checked to ensure it has loaded, if it has not the Sound.Loaded event is used to yield the script until the sound has.

As the sound is played, paused and stopped the Sound.IsPlaying and Sound.IsPaused properties are printed to demonstrate how they respond to each of these functions. Note Sound.IsPaused will always be true if even if the sound has been stopped rather than paused.
```lua
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312" 
sound.Looped = true

if not sound.isLoaded then
	sound.Loaded:wait()
end

sound:Play()
print(sound.IsPlaying, sound.IsPaused) -- true, false

wait(2)
sound:Pause()
print(sound.IsPlaying, sound.IsPaused) -- false, true

wait(2)
sound:Play()
print(sound.IsPlaying, sound.IsPaused) -- true, false

wait(2)
sound:Stop()
print(sound.IsPlaying, sound.IsPaused) -- false, true
```
This read-only property will return true when the `Sound` is not playing. Note that this property will not only return true once a sound has been paused using the `Pause` function but also if it has been stopped using the `Stop` function or never been played. 

This property will only be true when `IsPlaying` is false.

As IsPaused is read only it can not be used to stop the sound, `Stop` and `Pause` should be used instead.

## Code Samples

### Sound IsPlaying and SoundIsPaused

This code sample contains demonstrates when the Sound.IsPlaying and Sound.IsPaused properties will be true or false.

A sound is instanced in the Workspace and the Sound.IsLoaded property is checked to ensure it has loaded, if it has not the Sound.Loaded event is used to yield the script until the sound has.

As the sound is played, paused and stopped the Sound.IsPlaying and Sound.IsPaused properties are printed to demonstrate how they respond to each of these functions. Note Sound.IsPaused will always be true if even if the sound has been stopped rather than paused.
```lua
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312" 
sound.Looped = true

if not sound.isLoaded then
	sound.Loaded:wait()
end

sound:Play()
print(sound.IsPlaying, sound.IsPaused) -- true, false

wait(2)
sound:Pause()
print(sound.IsPlaying, sound.IsPaused) -- false, true

wait(2)
sound:Play()
print(sound.IsPlaying, sound.IsPaused) -- true, false

wait(2)
sound:Stop()
print(sound.IsPlaying, sound.IsPaused) -- false, true
```


Tags: ReadOnly, NotReplicated */
	readonly IsPaused: boolean;
	/** This read-only property will return true when the `Sound` is playing.

This property can only be true when `IsPaused` is false.

As IsPlaying is read only it can not be used to play the sound, `Play` should be used instead.

## Code Samples

### Sound IsPlaying and SoundIsPaused

This code sample contains demonstrates when the Sound.IsPlaying and Sound.IsPaused properties will be true or false.

A sound is instanced in the Workspace and the Sound.IsLoaded property is checked to ensure it has loaded, if it has not the Sound.Loaded event is used to yield the script until the sound has.

As the sound is played, paused and stopped the Sound.IsPlaying and Sound.IsPaused properties are printed to demonstrate how they respond to each of these functions. Note Sound.IsPaused will always be true if even if the sound has been stopped rather than paused.
```lua
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312" 
sound.Looped = true

if not sound.isLoaded then
	sound.Loaded:wait()
end

sound:Play()
print(sound.IsPlaying, sound.IsPaused) -- true, false

wait(2)
sound:Pause()
print(sound.IsPlaying, sound.IsPaused) -- false, true

wait(2)
sound:Play()
print(sound.IsPlaying, sound.IsPaused) -- true, false

wait(2)
sound:Stop()
print(sound.IsPlaying, sound.IsPaused) -- false, true
```
This read-only property will return true when the `Sound` is playing.

This property can only be true when `IsPaused` is false.

As IsPlaying is read only it can not be used to play the sound, `Play` should be used instead.

## Code Samples

### Sound IsPlaying and SoundIsPaused

This code sample contains demonstrates when the Sound.IsPlaying and Sound.IsPaused properties will be true or false.

A sound is instanced in the Workspace and the Sound.IsLoaded property is checked to ensure it has loaded, if it has not the Sound.Loaded event is used to yield the script until the sound has.

As the sound is played, paused and stopped the Sound.IsPlaying and Sound.IsPaused properties are printed to demonstrate how they respond to each of these functions. Note Sound.IsPaused will always be true if even if the sound has been stopped rather than paused.
```lua
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312" 
sound.Looped = true

if not sound.isLoaded then
	sound.Loaded:wait()
end

sound:Play()
print(sound.IsPlaying, sound.IsPaused) -- true, false

wait(2)
sound:Pause()
print(sound.IsPlaying, sound.IsPaused) -- false, true

wait(2)
sound:Play()
print(sound.IsPlaying, sound.IsPaused) -- true, false

wait(2)
sound:Stop()
print(sound.IsPlaying, sound.IsPaused) -- false, true
```


Tags: ReadOnly, NotReplicated */
	readonly IsPlaying: boolean;
	/** This sets whether or not the `Sound` repeats once it has finished when it is playing. 

Looped sounds are suitable for a range of applications including music and background ambient sounds. The `DidLoop` event can be used to track the number of times as sound has looped.

## Code Samples

### Loop a Number of Times

This code sample includes a function that will play a sound and allow it to loop for a given number of times before stopping it.
```lua
local function loopNTimes(sound, numberOfLoops)
	if not sound.IsPlaying then
		sound.Looped = true
		local connection = nil
		connection = sound.DidLoop:Connect(function(soundId, numOfTimesLooped)
			print(numOfTimesLooped)
			if numOfTimesLooped >= numberOfLoops then
				-- disconnect the connection
				connection:Disconnect()
				-- stop the sound
				sound:Stop()
			end
		end)
		sound:Play()
	end
end
```

### Sound Looping

Whilst looping is most appropriate for longer tracks such as music or ambient sounds, this sample demonstrates sound looping by creating the Roblox death sound in every character's head and looping it. 

The Players.PlayerAdded and Player.CharacterAdded functions are used to detect new player characters. One a new character has been added a sound is created in their head. For demonstration purposes, the Sound.DidLoop function is used to show how the number of times a particular sound has looped can be tracked.
```lua
local Players = game:GetService("Players")

Players.PlayerAdded:Connect(function(player)

	-- listen for new characters
	player.CharacterAdded:Connect(function(character)
		-- wait for the head to be added
		local head = character:WaitForChild("Head")

		-- create a sound
		local sound = Instance.new("Sound", head)
		sound.Name = "TestSound"
		sound.SoundId = "rbxasset://sounds/uuhhh.mp3" -- oof
	
		-- loop the sound
		sound.Looped = true
		
		-- listen for loops
		sound.DidLoop:Connect(function(soundId, numOfTimesLooped)
			print("oof! "..tostring(numOfTimesLooped))
		end)

		-- play the sound
		sound:Play()
	end)
end)
```
 */
	Looped: boolean;
	/** The maximum distance a client's listener can be from the `Sound`'s origin and still hear it. Only applies to `Sound`s parented to a `Part` or `Attachment` (3D sounds).

How MaxDistance impacts the attenuation of a sound (manner in which it fades out) is dependent on the `RollOffMode` property. When `RollOffMode` is set to use an inverse type distance model (Inverse or InverseTapered) the MaxDistance will not effect the attenuation of the sound. This means that low values for MaxDistance will cause the sound to abruptly cut off when the listener reaches the MaxDistance. In most cases this is not desirable and developers are advised not to use low MaxDistance values.

When `RollOffMode` is set to a linear type distance model (Linear or LinearSquared) the sound will attenuate between `EmitterSize` and MaxDistance (with playback volume reaching zero at MaxDistance). This is less realistic, but in some cases allows attenuation to be handled in a more intuitive way.

## Code Samples

### Sound MaxDistance

This sample includes a brief demonstration of how Sound.MaxDistance works.

A Part is instanced in the Workspace with a looped Sound playing within it. A function is made to listen to the Sound's MaxDistance and change the size of a sphere whenever it changes. The sphere's radius will always be equal to the Sound's MaxDistance.

This example helps demonstrate how the sound is only audible when the client's listener (by default the Camera's position) is within the sphere.
```lua
-- create a part
local part = Instance.new("Part")
part.Position = Vector3.new(0, 3, 0)
part.Size = Vector3.new(1, 1, 1)
part.Anchored = true
part.Parent = game.Workspace

-- create a part to visualise the MaxDistance
local sphere = Instance.new("Part")
sphere.Name = "MaxDistanceSphere"
sphere.CFrame = part.CFrame
sphere.Anchored = true
sphere.CanCollide = false
sphere.Size = Vector3.new(1, 1, 1)
sphere.Shape = Enum.PartType.Ball
sphere.Transparency = 0.8
sphere.BrickColor = BrickColor.new("Lime green")
sphere.Parent = game.Workspace

-- create a looped sound
local sound = Instance.new("Sound", part)
sound.Name = "TestSound"
sound.MaxDistance = 20
sound.SoundId = "rbxasset://sounds/uuhhh.mp3" -- oof
sound.Looped = true

-- a function that changes the sphere size to reflect the sound's MaxDistance
local function updateSize()
	local distance = sound.MaxDistance
	sphere.Size = Vector3.new(distance * 2, distance * 2, distance * 2)
end

-- update the sphere size
updateSize()
-- listen for any changes to MaxDistance
sound:GetPropertyChangedSignal("MaxDistance"):Connect(updateSize)

-- play the sound
sound:Play()

```
 */
	MaxDistance: number;
	/** When true, the `Sound` will play when it is removed from the game.

Note the sound will play when the `Parent` property of the `Sound` or one of its ancestors is set to nil. This means all of the following will cause the sound to play when PlayOnRemove is true. Note, this includes `Destroy` as the destroy function sets the parent to nil.

    sound:Destroy()
    sound.Parent = nil
    sound.Parent.Parent = nil

## Code Samples

### Sound PlayOnRemove

In this sample a sound is created in the workspace, PlayOnRemove is set to true and the sound is then destroyed.

As Sound.PlayOnRemove is true, the sound will play when it is removed.
```lua
-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.Name = "TestSound"
sound.SoundId = "rbxasset://sounds/uuhhh.mp3" -- oof

-- set PlayOnRemove to true
sound.PlayOnRemove = true

wait(3)
-- destroy the sound
sound:Destroy()

```
 */
	PlayOnRemove: boolean;
	/** A number between 0 and 1000 indicating how loud the `Sound` is currently playing back.

This property reflects the amplitude of the `Sound`'s playback in the instance of time it is read. Therefore, for most sounds it will fluctuate constantly. Due to this it can appear in the Roblox Studio properties window as 0, however when read by code in the command bar or `Script`s it will return the correct value.

## Code Samples

### Volume Amplitude Bar

In this sample Sound.PlaybackLoudness is used to create an amplitude bar that shows the amplitude of a sound playing.

This code sample should be placed in StarterPlayerScripts. 

A simple GUI is created, a frame holding that bar and a frame containing the bar. A Sound is then played and the size of the bar is set to reflect the Sound.PlaybackLoudness on a loop.
```lua
-- to be placed in StarterPlayer > StarterPlayerScripts

local Players = game:GetService("Players")

-- wait for local player PlayerGui
local LocalPlayer = Players.LocalPlayer
local playerGui = LocalPlayer:WaitForChild("PlayerGui")

-- create a ScreenGui
local screenGui = Instance.new("ScreenGui", playerGui)

-- create a holder for our bar
local frame = Instance.new("Frame", screenGui)
frame.AnchorPoint = Vector2.new(0.5, 0.5)
frame.Position = UDim2.new(0.5, 0, 0.5, 0)
frame.Size = UDim2.new(0.3, 0, 0.05, 0)

-- create a bar
local bar = Instance.new("Frame", frame)
bar.Position = UDim2.new(0, 0, 0, 0)
bar.Size = UDim2.new(1, 0, 1, 0)
bar.BackgroundColor3 = Color3.new(0, 1, 0)

-- create a sound
local sound = Instance.new("Sound", screenGui)
sound.SoundId = "rbxassetid://301964312"
sound.Looped = true
sound:Play()

-- define a max loudness
local maxLoudness = 30

-- animate the amplitude bar
while true do
	local amplitude = math.clamp(sound.PlaybackLoudness / maxLoudness, 0, 1)
	bar.Size = UDim2.new(amplitude, 0, 1, 0)
	wait(0.05)
end

```
A number between 0 and 1000 indicating how loud the `Sound` is currently playing back.

This property reflects the amplitude of the `Sound`'s playback in the instance of time it is read. Therefore, for most sounds it will fluctuate constantly. Due to this it can appear in the Roblox Studio properties window as 0, however when read by code in the command bar or `Script`s it will return the correct value.

## Code Samples

### Volume Amplitude Bar

In this sample Sound.PlaybackLoudness is used to create an amplitude bar that shows the amplitude of a sound playing.

This code sample should be placed in StarterPlayerScripts. 

A simple GUI is created, a frame holding that bar and a frame containing the bar. A Sound is then played and the size of the bar is set to reflect the Sound.PlaybackLoudness on a loop.
```lua
-- to be placed in StarterPlayer > StarterPlayerScripts

local Players = game:GetService("Players")

-- wait for local player PlayerGui
local LocalPlayer = Players.LocalPlayer
local playerGui = LocalPlayer:WaitForChild("PlayerGui")

-- create a ScreenGui
local screenGui = Instance.new("ScreenGui", playerGui)

-- create a holder for our bar
local frame = Instance.new("Frame", screenGui)
frame.AnchorPoint = Vector2.new(0.5, 0.5)
frame.Position = UDim2.new(0.5, 0, 0.5, 0)
frame.Size = UDim2.new(0.3, 0, 0.05, 0)

-- create a bar
local bar = Instance.new("Frame", frame)
bar.Position = UDim2.new(0, 0, 0, 0)
bar.Size = UDim2.new(1, 0, 1, 0)
bar.BackgroundColor3 = Color3.new(0, 1, 0)

-- create a sound
local sound = Instance.new("Sound", screenGui)
sound.SoundId = "rbxassetid://301964312"
sound.Looped = true
sound:Play()

-- define a max loudness
local maxLoudness = 30

-- animate the amplitude bar
while true do
	local amplitude = math.clamp(sound.PlaybackLoudness / maxLoudness, 0, 1)
	bar.Size = UDim2.new(amplitude, 0, 1, 0)
	wait(0.05)
end

```


Tags: ReadOnly, NotReplicated */
	readonly PlaybackLoudness: number;
	/** Determines the speed at which a `Sound` will play. The greater the value the faster the sound will play back.

For example, a value of 2 will cause the `Sound` to play 2x faster, whereas a value of 0.5 will cause it to play 2x slower. When PlaybackSpeed is equal to 1, the sound will take `TimeLength` (in seconds) to complete.

Note that increasing the PlaybackSpeed of a sound will cause it to play at a higher pitch.

## Code Samples

### Sound PlaybackSpeed

In this example a Sound is played in the Workspace. The PlaybackSpeed property is increased and decreased at intervals to demonstrate its impact on the playback of the Sound.
```lua
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"
sound.Looped = true

sound:Play()
wait(10)
sound.PlaybackSpeed = 3 -- 3x faster
wait(5)
sound.PlaybackSpeed = 0.5 -- 2x slower
wait(5)
sound.PlaybackSpeed = 1 -- default
```
 */
	PlaybackSpeed: number;
	/** Indicates whether the `Sound` is currently playing. This can be toggled, and this property will always replicate.

This property should not be confused with `IsPlaying` which is a read-only
 property. Playing can be set to true or false to start or stop the playback of a sound. 

Note that when Playing is set to false, the `TimePosition` property of the sound will not reset. This means when the Playing is set to true again the audio will continue from the time position it was at when it was stopped. However, if the `Play` function is used to resume the sound the time position will reset to 0.

## Code Samples

### Sound Playing

This sample demonstrates how the Sound.Playing property can be used to start and stop playback of a sound.

A sound is instanced in the Workspace and playback is started by setting Sound.Playing to true. After ten seconds the playback is stopped by setting Sound.Playing to false. When the playback is again resumed using Sound.Playing it resumes at the previous Sound.TimePosition it was stopped at. This is demonstrated by printing the TimePosition property immediately after resuming the sound.
```lua
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"
sound.Looped = true

print("playing sound")
sound.Playing = true

wait(10)

print("stopping sound")
sound.Playing = false

wait(5)

sound.Playing = true
local timePosition = sound.TimePosition
print("resumed at time position: "..tostring(timePosition)) -- c. 10 seconds
```
 */
	Playing: boolean;
	/** This property sets how 3D `Sound`s attenuate (fade out) as the distance between the listener and the `Sound`'s parent increase. The following code will set RollOffMode to Linear.

```lua
sound.RollOffMode = Enum.RollOffMode.Linear
```


Thee following options are available.

 - **Inverse:** Volume attenuates from `EmitterSize` in an inverse manner
 - **InverseTapered:** A hybrid model. Follows the Inverse model when close to `EmitterSize` and the Linear Square model when close to `MaxDistance`.
 - **Linear**: Volume attenuates between `EmitterSize` and `MaxDistance` with a linear relationship.
 - **LinearSquare:** Volume attenuates between `EmitterSize` and `MaxDistance` with a linear squared relationship

**Inverse vs Linear Distance Attenuation** 

By default sounds are set to use inverse distance attenuation (Enum.RollOffMode.Inverse) which mirrors how sounds attenuate in the real world. Under inverse distance attenuation, sounds will begin to attenuate once the distance between the listener and the Sound's parent exceeds `EmitterSize`. The rate of attenuation depends on the emitter size, as sounds with larger EmitterSize's will attenuate at a slower rate. Inverse rate of inverse distance attenuation is further influenced by `RolloffScale`.

Note, `MaxDistance` will not effect attenuation under the inverse model but will cause the sound to cut off completely once this distance is reached. This can be particularly abrupt when using low values for max distance.

Linear distance attenuation works differently. Under linear distance attenuation the sound will attenuate between `EmitterSize` and `MaxDistance`, falling silent once MaxDistance is reached. `EmitterSize` still denotes the point at which the sound will begin attenuating. However, the audible volume at any point now depends on the point the listener is at between EmitterSize and MaxDistance. This means, in contrast to the inverse distance attenuation model, the audible volume of the sound will approach silence at MaxDistance point. This is less realistic, but may be more desirable in some cases. */
	RollOffMode: Enum.RollOffMode;
	/** The `SoundGroup` that is linked to this `Sound`. `Volume` and `SoundEffect`s applied to this sound group will pass onto the sound. A sound can only be in one sound group at a time.

`SoundGroup`s are used to manage the volume and effects of multiple `Sound`s at once. A `Sound` is added to a `SoundGroup` by setting the SoundGroup property of the sound.

## Code Samples

### SoundGroups

This sample demonstrates how a SoundGroup can be used to change the volume of its associated Sounds and apply SoundEffects. 

In this example a Sound is instanced in the Workspace and assigned to a new SoundGroup. The Sound is played and during playback the volume is changed via the SoundGroup and a SoundEffect is added.
```lua
local SoundService = game:GetService("SoundService")

-- create a sound group
local soundGroup = Instance.new("SoundGroup", SoundService)

-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"
sound.Looped = true
sound.PlaybackSpeed = 2
sound.SoundGroup = soundGroup

-- play the sound
sound:Play()

wait(10)

-- change the volume
soundGroup.Volume = 0.1 

wait(3)

-- return the volume
soundGroup.Volume = 0.5
 
wait(4)

-- add a sound effect
Instance.new("ReverbSoundEffect", soundGroup) 
```
 */
	SoundGroup?: SoundGroup;
	/** This property is the content ID of the sound file a `Sound` object is associated with. Once a sound has been uploaded to Roblox the content ID can be found in the uploaded sound’s URL. 

It’s important to remember the URL is not the same as the content ID. It will work when pasted directly into the SoundId property of a `Sound` in Roblox studio, as Studio will automatically correct it, however if it is being set from a `Script` then the correct content ID will need to be used, using the number from the URL. For example:

```lua
"https://www.roblox.com/catalog/12222216" -- Web URL (will not work)
"http://www.roblox.com/asset/?id=12222216" -- Content ID (will work)
"rbxassetid://12222216" -- Content ID (alternative version, will work)
```

## Code Samples

### Sound in the Workspace

This sample gives a simple example of how a Sound that is not parented to a Part or Attachment will play at a constant volume throughout the place. A sound is instanced and parented to the Workspace, and then played.
```lua
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"
sound.Looped = true
sound:Play()
```
 */
	SoundId: string;
	/** The length of the `Sound` in seconds. If the `Sound` is not loaded, this value will be 0.

This property is often used in conjunction with `PlaybackSpeed` to adjust the speed of a sound so it lasts for a specific duration (see examples). When `PlaybackSpeed` is equal to 1, the sound will take TimeLength seconds to complete.

## Code Samples

### Play a Sound for a Specific Duration

This code sample includes a simple function that uses Sound.TimeLength and Sound.PlaybackSpeed to play a sound that'll take the given duration to complete. It achieves this by setting the PlaybackSpeed of the sound to be equal to the TimeLength of the sound divided by the desired duration.

Note that as TimeLength is equal to 0 when the sound has not loaded, the function will yield whilst it loads the sound.
```lua
local function playForDuration(sound, duration)
	if not sound.IsLoaded then
		sound.Loaded:wait()
	end
	local speed = sound.TimeLength / duration
	sound.PlaybackSpeed = speed 
	sound:Play()
end

```
The length of the `Sound` in seconds. If the `Sound` is not loaded, this value will be 0.

This property is often used in conjunction with `PlaybackSpeed` to adjust the speed of a sound so it lasts for a specific duration (see examples). When `PlaybackSpeed` is equal to 1, the sound will take TimeLength seconds to complete.

## Code Samples

### Play a Sound for a Specific Duration

This code sample includes a simple function that uses Sound.TimeLength and Sound.PlaybackSpeed to play a sound that'll take the given duration to complete. It achieves this by setting the PlaybackSpeed of the sound to be equal to the TimeLength of the sound divided by the desired duration.

Note that as TimeLength is equal to 0 when the sound has not loaded, the function will yield whilst it loads the sound.
```lua
local function playForDuration(sound, duration)
	if not sound.IsLoaded then
		sound.Loaded:wait()
	end
	local speed = sound.TimeLength / duration
	sound.PlaybackSpeed = speed 
	sound:Play()
end

```


Tags: ReadOnly, NotReplicated */
	readonly TimeLength: number;
	/** Shows the progress in seconds of the `Sound`. Can be changed to move the playback position of the sound. If the sound is already playing then playback will snap to the specified position. If it is not playing the `Sound` will begin playback at the set position when the sound is next played.

As a `Sound` is played, TimePosition increases at a rate of `PlaybackSpeed` per second. Once TimePosition reaches `TimeLength` the Sound will stop unless it is looped. This means, unless `Looped` is set to true setting TimePosition to a value equal or greater to `TimeLength` will stop the sound. 

Note that setting TimePositio` to a value greater than the length in a looped track will not cause it to wrap around. If that behavior is desired the developer should do the following.

    if newPosition &gt;= sound.TimeLength then
    	newPosition = newPosition - sound.TimeLength
    end
    sound.TimePosition = newPosition

Setting TimePosition to a value less than zero currently does not influence playback, but this behavior should not be relied upon.

## Code Samples

### Sound TimePosition

This sample demonstrates how Sound.TimePosition can be used to jump to particular points in an audio file both before and during Sound playback. 

A Sound is created in the Workspace and set to start at 30 seconds in. During playback, it jumps forwards to 100 seconds and then back to the start (0 seconds).
```lua
-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"

-- set the sound to start at 30 seconds
sound.TimePosition = 30

-- play the sound
sound:Play()

wait(5)

-- jump forwards to 100 seconds
sound.TimePosition = 100

wait(5)

-- jump back to the start
sound.TimePosition = 0
```
 */
	TimePosition: number;
	/** The volume of the `Sound`. Can be set between 0 and 10. Defaults to 0.5

Note that if the `Sound` is a member of a `SoundGroup` its playback volume (but not the Volume property) will be influenced by the `Volume` property of that `SoundGroup`. The effect of this is multiplicative, meaning that a sound will play at the same volume if its Volume is 0.1 and its `SoundGroup`'s volume is 5 and vice-versa.

## Code Samples

### Sound Volume

This sample includes a demonstration of how a Sound's volume can be set using the Sound.Volume property.
```lua
-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"
sound.Looped = true
sound.PlaybackSpeed = 2

-- make the sound loud
sound.Volume = 2

-- play the sound
sound:Play()

wait(7)

-- make the sound quiet
sound.Volume = 0.2
```
 */
	Volume: number;
	/** Sets `Playing` to false. This pauses the playback of the `Sound` if the sound is playing. Unlike `Stop` it does not reset `TimePosition` meaning the sound can be resumed using `Resume`.

The impact of the different Sound functions on `Playing` and `TimePosition` are shown below.


| Function | Sound.Playing | Sound.TimePosition |
| --- | --- | --- |
| Sound:Play() | True | Last value set in Lua (default 0) |
| Sound:Pause() | False | - |
| Sound:Resume() | True | - |
| Sound:Stop() | False | 0 |

## Code Samples

### Sound Functions

This sample gives a simple demonstration of what each of the Sound functions (Sound.Play, Sound.Stop, Sound.Pause and Sound.Resume) do to Sound.Playing and Sound.TimePosition.
```lua
-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"

if not sound.IsLoaded then
	sound.Loaded:wait()
end

-- listen for events
sound.Played:Connect(function(soundId)
	print("Sound.Played event")
end)

sound.Paused:Connect(function(soundId)
	print("Sound.Paused event")
end)

sound.Resumed:Connect(function(soundId)
	print("Sound.Resumed event")
end)

sound.Stopped:Connect(function(soundId)
	print("Sound.Stopped event")
end)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

wait(10)

sound:Pause()
print("pause", sound.Playing, sound.TimePosition) -- pause false 10

wait(3)

sound:Resume()
print("play", sound.Playing, sound.TimePosition) -- play true 10

wait(3)

sound:Stop()
print("stop", sound.Playing, sound.TimePosition) -- stop false 0

wait(3)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

```
 */
	Pause(): void;
	/** Plays the `Sound`. Sets `TimePosition` to the last value set by a `Script` (or 0 if it has not been set), and then sets `Playing` to true.

The impact of the different `Sound` functions on `Playing` and `TimePosition` are shown below.


| Function | Sound.Playing | Sound.TimePosition |
| --- | --- | --- |
| Sound:Play() | True | Last value set in Lua (default 0) |
| Sound:Pause() | False | - |
| Sound:Resume() | True | - |
| Sound:Stop() | False | 0 |

## Code Samples

### Sound Functions

This sample gives a simple demonstration of what each of the Sound functions (Sound.Play, Sound.Stop, Sound.Pause and Sound.Resume) do to Sound.Playing and Sound.TimePosition.
```lua
-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"

if not sound.IsLoaded then
	sound.Loaded:wait()
end

-- listen for events
sound.Played:Connect(function(soundId)
	print("Sound.Played event")
end)

sound.Paused:Connect(function(soundId)
	print("Sound.Paused event")
end)

sound.Resumed:Connect(function(soundId)
	print("Sound.Resumed event")
end)

sound.Stopped:Connect(function(soundId)
	print("Sound.Stopped event")
end)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

wait(10)

sound:Pause()
print("pause", sound.Playing, sound.TimePosition) -- pause false 10

wait(3)

sound:Resume()
print("play", sound.Playing, sound.TimePosition) -- play true 10

wait(3)

sound:Stop()
print("stop", sound.Playing, sound.TimePosition) -- stop false 0

wait(3)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

```
 */
	Play(): void;
	/** Resumes the `Sound`. Sets `Playing` to true. Does not alter `TimePosition` and thus can be used to resume the playback of a sound stopped using `Pause`.

The impact of the different sound functions on `Playing` and `TimePosition` are shown below.


| Function | Sound.Playing | Sound.TimePosition |
| --- | --- | --- |
| Sound:Play() | True | Last value set in Lua (default 0) |
| Sound:Pause() | False | - |
| Sound:Resume() | True | - |
| Sound:Stop() | False | 0 |

## Code Samples

### Sound Functions

This sample gives a simple demonstration of what each of the Sound functions (Sound.Play, Sound.Stop, Sound.Pause and Sound.Resume) do to Sound.Playing and Sound.TimePosition.
```lua
-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"

if not sound.IsLoaded then
	sound.Loaded:wait()
end

-- listen for events
sound.Played:Connect(function(soundId)
	print("Sound.Played event")
end)

sound.Paused:Connect(function(soundId)
	print("Sound.Paused event")
end)

sound.Resumed:Connect(function(soundId)
	print("Sound.Resumed event")
end)

sound.Stopped:Connect(function(soundId)
	print("Sound.Stopped event")
end)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

wait(10)

sound:Pause()
print("pause", sound.Playing, sound.TimePosition) -- pause false 10

wait(3)

sound:Resume()
print("play", sound.Playing, sound.TimePosition) -- play true 10

wait(3)

sound:Stop()
print("stop", sound.Playing, sound.TimePosition) -- stop false 0

wait(3)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

```
 */
	Resume(): void;
	/** Stops the `Sound`. Sets `Playing` to false then sets `TimePosition` to 0.

The impact of the different sound functions on `Playing` and `TimePosition` are shown below.


| Function | Sound.Playing | Sound.TimePosition |
| --- | --- | --- |
| Sound:Play() | True | Last value set in Lua (default 0) |
| Sound:Pause() | False | - |
| Sound:Resume() | True | - |
| Sound:Stop() | False | 0 |

## Code Samples

### Sound Functions

This sample gives a simple demonstration of what each of the Sound functions (Sound.Play, Sound.Stop, Sound.Pause and Sound.Resume) do to Sound.Playing and Sound.TimePosition.
```lua
-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"

if not sound.IsLoaded then
	sound.Loaded:wait()
end

-- listen for events
sound.Played:Connect(function(soundId)
	print("Sound.Played event")
end)

sound.Paused:Connect(function(soundId)
	print("Sound.Paused event")
end)

sound.Resumed:Connect(function(soundId)
	print("Sound.Resumed event")
end)

sound.Stopped:Connect(function(soundId)
	print("Sound.Stopped event")
end)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

wait(10)

sound:Pause()
print("pause", sound.Playing, sound.TimePosition) -- pause false 10

wait(3)

sound:Resume()
print("play", sound.Playing, sound.TimePosition) -- play true 10

wait(3)

sound:Stop()
print("stop", sound.Playing, sound.TimePosition) -- stop false 0

wait(3)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

```
 */
	Stop(): void;
	/** Event that fires whenever the `Sound` loops. Returns soundId and numOfTimesLooped, giving the contentID of the sound and the number of times looped respectively. 

When the `Sound` is stopped the looped counter resets meaning the next DidLoop event will return 1 for numOfTimesLooped.

## Code Samples

### Loop a Number of Times

This code sample includes a function that will play a sound and allow it to loop for a given number of times before stopping it.
```lua
local function loopNTimes(sound, numberOfLoops)
	if not sound.IsPlaying then
		sound.Looped = true
		local connection = nil
		connection = sound.DidLoop:Connect(function(soundId, numOfTimesLooped)
			print(numOfTimesLooped)
			if numOfTimesLooped >= numberOfLoops then
				-- disconnect the connection
				connection:Disconnect()
				-- stop the sound
				sound:Stop()
			end
		end)
		sound:Play()
	end
end
```
 */
	readonly DidLoop: RBXScriptSignal<(soundId: string, numOfTimesLooped: number) => void>;
	/** Fires when the `Sound` has completed playback and stopped. Note this event will not fire for sounds with `Looped` set to true as they continue playing upon reaching their end.

This event is often used to destroy a sound when it has completed playback.
```lua
sound:Play()
sound.Ended:Wait()
sound:Destroy()
```


This event only fires if the sound has reached its end. This means it will also not fire when the sound is stopped before playback has completed, for this use `Stopped`. */
	readonly Ended: RBXScriptSignal<(soundId: string) => void>;
	/** The Sound.Loaded event fires when the `/Sound` is loaded. 

Note this event will only fire at the time the sound is loaded. This means if it is listened for when the sound is already loaded it will not return. Therefore it is recommended to check `IsLoaded` prior to connecting to this event.

## Code Samples

### Load Sound

This simple function will verify a Sound has loaded by checking the Sound.IsLoaded property. If Sound.IsLoaded is false it will wait for the Loaded event before resuming.

It is important to check Sound.IsLoaded before connecting to the Sound.Loaded event, as if the sound has already loaded the Sound.Loaded event will not fire and the function will yield indefinitely.
```lua
local function loadSound(sound)
	-- Has the sound already loaded?
	if not sound.IsLoaded then 
		-- if not, wait until it has been
		sound.Loaded:Wait()
	end
end
loadSound(Workspace.Sound)

```
 */
	readonly Loaded: RBXScriptSignal<(soundId: string) => void>;
	/** Fires whenever the `Sound` is paused using `Pause`.

As with `Played`, `Resumed` and `Stopped` only the respective sound function will cause the event to fire. This means that Pause will only fire when `Pause` is called.

## Code Samples

### Sound Functions

This sample gives a simple demonstration of what each of the Sound functions (Sound.Play, Sound.Stop, Sound.Pause and Sound.Resume) do to Sound.Playing and Sound.TimePosition.
```lua
-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"

if not sound.IsLoaded then
	sound.Loaded:wait()
end

-- listen for events
sound.Played:Connect(function(soundId)
	print("Sound.Played event")
end)

sound.Paused:Connect(function(soundId)
	print("Sound.Paused event")
end)

sound.Resumed:Connect(function(soundId)
	print("Sound.Resumed event")
end)

sound.Stopped:Connect(function(soundId)
	print("Sound.Stopped event")
end)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

wait(10)

sound:Pause()
print("pause", sound.Playing, sound.TimePosition) -- pause false 10

wait(3)

sound:Resume()
print("play", sound.Playing, sound.TimePosition) -- play true 10

wait(3)

sound:Stop()
print("stop", sound.Playing, sound.TimePosition) -- stop false 0

wait(3)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

```
 */
	readonly Paused: RBXScriptSignal<(soundId: string) => void>;
	/** Fires whenever the `Sound` is played using the `Play` function.

As with `Stopped`, `Paused` and `Resumed` only the respective sound function will cause the event to fire. This means that Played will only fire when `Play` is called. This event will not fire if the `Sound` is played due to the sound being destroyed and `PlayOnRemove` being set to true.

## Code Samples

### Sound Functions

This sample gives a simple demonstration of what each of the Sound functions (Sound.Play, Sound.Stop, Sound.Pause and Sound.Resume) do to Sound.Playing and Sound.TimePosition.
```lua
-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"

if not sound.IsLoaded then
	sound.Loaded:wait()
end

-- listen for events
sound.Played:Connect(function(soundId)
	print("Sound.Played event")
end)

sound.Paused:Connect(function(soundId)
	print("Sound.Paused event")
end)

sound.Resumed:Connect(function(soundId)
	print("Sound.Resumed event")
end)

sound.Stopped:Connect(function(soundId)
	print("Sound.Stopped event")
end)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

wait(10)

sound:Pause()
print("pause", sound.Playing, sound.TimePosition) -- pause false 10

wait(3)

sound:Resume()
print("play", sound.Playing, sound.TimePosition) -- play true 10

wait(3)

sound:Stop()
print("stop", sound.Playing, sound.TimePosition) -- stop false 0

wait(3)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

```
 */
	readonly Played: RBXScriptSignal<(soundId: string) => void>;
	/** Fires when the `Sound` is resumed using `Resume`.

As with `Played`, `Paused` and `Stopped` only the respective sound function will cause the event to fire. This means that Resumed will only fire when `Resume` is called.

## Code Samples

### Sound Functions

This sample gives a simple demonstration of what each of the Sound functions (Sound.Play, Sound.Stop, Sound.Pause and Sound.Resume) do to Sound.Playing and Sound.TimePosition.
```lua
-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"

if not sound.IsLoaded then
	sound.Loaded:wait()
end

-- listen for events
sound.Played:Connect(function(soundId)
	print("Sound.Played event")
end)

sound.Paused:Connect(function(soundId)
	print("Sound.Paused event")
end)

sound.Resumed:Connect(function(soundId)
	print("Sound.Resumed event")
end)

sound.Stopped:Connect(function(soundId)
	print("Sound.Stopped event")
end)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

wait(10)

sound:Pause()
print("pause", sound.Playing, sound.TimePosition) -- pause false 10

wait(3)

sound:Resume()
print("play", sound.Playing, sound.TimePosition) -- play true 10

wait(3)

sound:Stop()
print("stop", sound.Playing, sound.TimePosition) -- stop false 0

wait(3)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

```
 */
	readonly Resumed: RBXScriptSignal<(soundId: string) => void>;
	/** Fires when the `Sound` is stopped due to the `Stop` function.

As with `Played`, `Paused` and `Resumed` only the respective sound function will cause the event to fire. This means that Stopped will only fire when `Stop` is called. Destroying a sound whilst it is playing will not cause this event to fire.

## Code Samples

### Sound Functions

This sample gives a simple demonstration of what each of the Sound functions (Sound.Play, Sound.Stop, Sound.Pause and Sound.Resume) do to Sound.Playing and Sound.TimePosition.
```lua
-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"

if not sound.IsLoaded then
	sound.Loaded:wait()
end

-- listen for events
sound.Played:Connect(function(soundId)
	print("Sound.Played event")
end)

sound.Paused:Connect(function(soundId)
	print("Sound.Paused event")
end)

sound.Resumed:Connect(function(soundId)
	print("Sound.Resumed event")
end)

sound.Stopped:Connect(function(soundId)
	print("Sound.Stopped event")
end)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

wait(10)

sound:Pause()
print("pause", sound.Playing, sound.TimePosition) -- pause false 10

wait(3)

sound:Resume()
print("play", sound.Playing, sound.TimePosition) -- play true 10

wait(3)

sound:Stop()
print("stop", sound.Playing, sound.TimePosition) -- stop false 0

wait(3)

sound:Play()
print("play", sound.Playing, sound.TimePosition) -- play true 0

```
 */
	readonly Stopped: RBXScriptSignal<(soundId: string) => void>;
}

interface RbxInternalSoundEffect extends RbxInternalInstance {
	/** Toggles the effect on and off. True by default. */
	Enabled: boolean;
	/** Determines the order the effect will be applied in relation to other effects. Highger priority effects will be applied earlier. The exception is when Priority equals 0 (which is the default). In this case, the base priority for the effect will be used. If the priority of two effects are equal, then the order is undetermined. */
	Priority: number;
}
/** SoundEffect is the base class that all other sound effects derive from. A SoundEffect can be applied to either a `Sound` or `SoundGroup` by being parented to either.

Multiple effects can be applied to the same Sound or SoundGroup. The order the effects will be applied in is determined by that effect’s Priority. */
type SoundEffect = ChorusSoundEffect | CompressorSoundEffect | DistortionSoundEffect | EchoSoundEffect | EqualizerSoundEffect | FlangeSoundEffect | PitchShiftSoundEffect | ReverbSoundEffect | TremoloSoundEffect;

/** A ChorusSoundEffect simulates the effect of multiple vocals or instruments playing the same part. It does this by taking the original sound and overlaying copies of that sound. These copies are not exact matches to the original but instead vary in pitch slightly. This simulates a real chorus, as different singers or instruments will have slight variations. This effect can be applied to either an individual sound or to a sound group by parenting it to the desired instance.

Like all other `SoundEffect`, a ChorusSoundEffect can be applied either to a `Sound` or `SoundGroup` by being parented to either. */
interface ChorusSoundEffect extends RbxInternalSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ChorusSoundEffect";
	/** Range: 0 to 1 (default 0.15)
Controls how intense the effect is.Controls how intense the effect is. */
	Depth: number;
	/** Range: 0 to 1 (default 0.5)
Percentage of the original sound that will be applied to the filter. Raising this value will make the effect sound louder and be more apparent.Percentage of the original sound that will be applied to the filter. */
	Mix: number;
	/** Range: 0 to 20 (default 0.5)
How frequently the pitch variation changes. Measured in Hz.How frequently the pitch variation changes. */
	Rate: number;
}

/** A compressor is used to reduce the dynamic range of audio by moving the highs and lows of a signal closer together. It does this by lowering the volume of the highest parts of a source while at the same time raising the overall volume. This type of effect is useful when you have many sounds playing and you want to make sure the quieter ones are still audible. This effect can be applied to either an individual sound or to a sound group by parenting it to the desired instance.

Like all other `SoundEffect`, a ChorusSoundEffect can be applied either to a `Sound` or `SoundGroup` by being parented to either.

A compressor has several properties which determine how it works. The `Threshold` is the audio level where the compressor will start to lower the volume. As soon as the source goes below the threshold, the compressor will stop lowering the volume.

The `Attack` determines how long it takes for the compressed effect to fully apply. After the threshold has been crossed the compressor will lower the volume over time until the desired ratio has been reached. It will take the time specified by Attack to reach this ratio.

The `Release` determines how long it takes for the compressor to remove its effect. After the volume of the source is under the threshold, the compressor will restore the volume back to the original over the time specified by Release.

Along with lowering the volume when the sound has passed the threshold, a compressor will also amplify the entire sound (after any threshold lowering has taken effect). This allows quieter sounds to be amplified while louder sounds can stay about the same. The `GainMakeup` determines how much the effect amplifies the sound. */
interface CompressorSoundEffect extends RbxInternalSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CompressorSoundEffect";
	/** Range: 0.1 to 1 (default 0.1)
The time the effect takes to become active after its Threshold has be reached. Measured in seconds.The time the effect takes to become active after its Threshold has be reached. */
	Attack: number;
	/** Range: 0 to 30 (default 0)
The overall amplification applied to the effect's Sound or SoundGroup after attenuation of sounds above the threshold. Keep in mind this amplification will occur as long as the effect is Active, regardless of whether the Threshold has be reached or not. Measured in dB.The overall amplification applied to the effect's Sound or SoundGroup after attenuation of sounds above the threshold. */
	GainMakeup: number;
	/** The ratio between the `SideChain` sound effect, and this sound effect. */
	Ratio: number;
	/** Range: 0 to 5 (default 0.1)
The time the effect takes to become inactive after its sound is below the Threshold. Measured in seconds.The time the effect takes to become inactive after its sound is below the Threshold. */
	Release: number;
	/** Applies a [ducking](https://en.wikipedia.org/wiki/Ducking)
 effect to the compressor sound effect.

The behavior of the sidechain depends on the `Sound` or `SoundGroup` linked to it. */
	SideChain?: Sound | SoundGroup;
	/** Range: -80 to 0 (default 0)
Volume level at which point the compressor applies its effect. If the effect's Sound or SoundGroup is below the effect will not attenuate the sound, although the GainMakeup will still be applied. Measured in dB.Volume level at which point the compressor applies its effect. */
	Threshold: number;
}

/** A distortion effect is used to simulate the effect that would occur when overdriving older style audio equipment (such as vaccuum tubes). This effect causes clipping in the sound and adds a general “fuzzyness”.

Like all other `SoundEffect`, a DistortionSoundEffect can be applied either to a `Sound` or `SoundGroup` by being parented to either. */
interface DistortionSoundEffect extends RbxInternalSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DistortionSoundEffect";
	/** Range: 0 to 1 (default 0.5)
The intensity of the effect. Setting this property to its minimum (0) will cause no distortion at all.The intensity of the effect. */
	Level: number;
}

/** An echo effect causes a sound to repeat on a delay with diminishing volume, simulating the real effect of an echo. This effect can be applied to either an individual sound or to a sound group by parenting it to the desired instance.

The effect is controlled by several properties. First, the Delay is how long the effect will wait to play the echoed sound. Feedback determines how much the original signal is diminished to play as the echoed sound. Note that this echoed sound also goes through the echo effect which will wait another delay and play another echo. This process will repeat until the volume of the echoed sound is negligible. 

You can also adjust the wet/dry mix of the effect. The dry component of the sound is the original sound that the effect is being applied to. You can adjust the volume of the dry sound by adjusting the DryLevel. The wet sound is the echoed effect itself, and its volume can be adjusted with WetLevel.

It is recommended to only use the EchoSoundEffect with sound groups. If an echo effect is applied to a regular Sound, once that sound stops playing the echo effect will also be cut off. When applied to a SoundGroup, the echo effect will continue playing even if the original source sound has stopped.Like all other `SoundEffect`, a EchoSoundEffect can be applied either to a `Sound` or `SoundGroup` by being parented to either. */
interface EchoSoundEffect extends RbxInternalSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "EchoSoundEffect";
	/** Range: 0.01 to 5 (default 1)
The amount of time between echoes. Measured in seconds.

If a EchoSoundEffect is applied to a singular sound instead of a sound group, if the sound stops playing before the delay causes an echo, the echo will not play. Because of this, it is recommended to apply echo effects to SoundGroups and not Sounds. */
	Delay: number;
	/** Range: -80 to 10 (default 0)
The output volume of the original sound.The output volume of the original sound. */
	DryLevel: number;
	/** Range: 0 to 1 (default 0.5)
The echo decay every time the echo plays. Setting this at it's minimum (0) will cause no feedback, meaning the echo won't be audible at all. Setting this at the maximum (1) will have no decay, meaning the echoed sound will play at the level of the original and will not diminish over time.The echo decay every time the echo plays. */
	Feedback: number;
	/** Range: -80 to 10 (default 0)
The output volume of the echoed effect.The output volume of the echoed effect. */
	WetLevel: number;
}

/** The EqualizerSoundEffect allows for control of the volume of various frequency ranges for the Sound or SoundGroup the effect is applied to. This can be used to highlight particular elements of audio or minimize or outright eliminate others.

The EqualizerSoundEffect gives control over three ranges of frequency: Low, Mid, and High, and their specific frequencies are as follows:

* Low: 0 - 400 Hz

* Mid: 400 - 4000 Hz

* High: 4000+ Hz
Like all other `SoundEffect`, a EqualizerSoundEffect can be applied either to a `Sound` or `SoundGroup` by being parented to either. */
interface EqualizerSoundEffect extends RbxInternalSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "EqualizerSoundEffect";
	/** Range: -80 to 10 (default 0)
The output volume of frequencies greater than 4000 Hz. Measured in dB.The output volume of frequencies greater than 4000 Hz. */
	HighGain: number;
	/** Range: -80 to 10 (default 0)
The output volume of frequencies lower than 400 Hz. Measured in dB.The output volume of frequencies lower than 400 Hz. */
	LowGain: number;
	/** Range: -80 to 10 (default 0)
The output volume of frequencies between 400 and 4000 Hz. Measured in dB.The output volume of frequencies between 400 and 4000 Hz. */
	MidGain: number;
}

/** The FlangeSoundEffect creates a sweeping or swooshing effect on the Sound or SoundGroup it is applied to. It does this by copying the original audio signal and playing on top of the original but slightly offset and modulated.

Like all other `SoundEffect`, a FlangeSoundEffect can be applied either to a `Sound` or `SoundGroup` by being parented to either. */
interface FlangeSoundEffect extends RbxInternalSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "FlangeSoundEffect";
	/** Range: 0.01 to 1 (default 0.45)
The intensity of the effect. This value determines how offset the duplicated signal will be from the original. This value is the percentage of the max offset (40ms).The intensity of the effect. */
	Depth: number;
	/** Range: 0 to 1 (default 0.85)
Percentage of the original sound that will be applied to the filter. Raising this value will make the effect sound louder and be more apparent.Percentage of the original sound that will be applied to the filter. */
	Mix: number;
	/** Range: 0 to 20 (default 5)
The frequency that the effect oscillates at. Measured in Hz.The frequency that the effect oscillates at. */
	Rate: number;
}

/** The PitchShiftSoundEffect raises or lowers the pitch of the associated Sound or SoundGroup without changing the playback speed of the audio.

This effect can be computationally expensive. */
interface PitchShiftSoundEffect extends RbxInternalSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "PitchShiftSoundEffect";
	/** Range: 0.5 to 2 (default 1.25)
The percentage to shift the original pitch. Setting this to its minimum (0.5) lowers the octave by 1, setting this to its maximum (2) increases the octave by 1.The percentage to shift the original pitch. */
	Octave: number;
}

/** The ReverbSoundEffect simulates the effect of sounds bouncing off of several surfaces (such as walls in a room), which causes several overlapping echoes that arrive at the listener at slightly offset times. 

Like all other `SoundEffect`, a ChorusSoundEffect can be applied either to a `Sound` or `SoundGroup` by being parented to either. */
interface ReverbSoundEffect extends RbxInternalSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ReverbSoundEffect";
	/** Range: 0.1 to 20 (default 1.5)
Sets how long it takes for the reverberating echoes to fade out completely. Larger decay times simulate larger (empty) spaces Sets how long it takes for the reverberating echoes to fade out completely. */
	DecayTime: number;
	/** Range: 0 to 1 (default 1)
Controls how many reflections are generated.Controls how many reflections are generated. */
	Density: number;
	/** Range: 0 to 1 (default 1)
Controls how smooth and reflective the simulated surfaces are. The lower this value, the more discrete the echoes are. At higher levels the echos will blend more.Controls how smooth and reflective the simulated surfaces are. */
	Diffusion: number;
	/** Range: -80 to 10 (default -6)
The output volume of the original sound.The output volume of the original sound. */
	DryLevel: number;
	/** Range: -80 to 10 (default 0)
The output volume of the echoed effect.The output volume of the echoed effect. */
	WetLevel: number;
}

/** The TremoloSoundEffect creates a trembling effect on a sound by varying the volume of the sound up and down. 

Like all other `SoundEffect`s, a TremoloSoundEffect can be applied either to a `Sound` or `SoundGroup` by being parented to either. */
interface TremoloSoundEffect extends RbxInternalSoundEffect {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TremoloSoundEffect";
	/** Range: 0 to 1 (default 1)
Controls how much the volume will raise and lower. This value ranges between 0 (minimum volume) and 1 (maximum volume). If set to its minimum, the volume will not oscillate at all.Controls how much the volume will raise and lower. */
	Depth: number;
	/** Range: 0 to 1 (default 0.5)
Controls how long during one volume oscillation the effect will be active, specifically what percentage between 0 (0%) and 1 (100%). */
	Duty: number;
	/** Range: 0.1 to 20 (default 5)
Sets how often the effect will oscillate the volume. Measured in Hz. */
	Frequency: number;
}

/** A `SoundGroup` is used to manage the volume and effects on multiple `Sound`s at once. Every sound in the sound group will have its volume adjusted by the group’s `Volume` property. If the SoundGroup has any `SoundEffect`s as children, those effects will be applied to all of the `Sound`s in the group.

The `Volume` property acts as a multiplier, and thus sounds in a SoundGroup will retain their relative volumes when it is set. This means if a sound's volume is 0.5 and it is assigned to a SoundGroup with a volume of 0.5, its effective volume will be 0.25.

Grouping sounds of the same category has several uses for developers. One common usage of a sound group is to assign all of the music that can play in game to a SoundGroup called "music." Players could then easily toggle all music on or off. 

## Setting sound groups

A `Sound` is added to a `SoundGroup` by setting the `SoundGroup` property of the `Sound`. A `Sound` can only be in one `SoundGroup` at a time. Whilst they can be parented elsewhere, it is recommended to keep SoundGroups parented to the `SoundService`. In the below example, a sound is parented to a SoundGroup called 'Music'.

    Sound.SoundGroup = game:GetService("SoundService"):FindFirstChild("Music")

## Code Samples

### SoundGroups

This sample demonstrates how a SoundGroup can be used to change the volume of its associated Sounds and apply SoundEffects. 

In this example a Sound is instanced in the Workspace and assigned to a new SoundGroup. The Sound is played and during playback the volume is changed via the SoundGroup and a SoundEffect is added.
```lua
local SoundService = game:GetService("SoundService")

-- create a sound group
local soundGroup = Instance.new("SoundGroup", SoundService)

-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"
sound.Looped = true
sound.PlaybackSpeed = 2
sound.SoundGroup = soundGroup

-- play the sound
sound:Play()

wait(10)

-- change the volume
soundGroup.Volume = 0.1 

wait(3)

-- return the volume
soundGroup.Volume = 0.5
 
wait(4)

-- add a sound effect
Instance.new("ReverbSoundEffect", soundGroup) 
```
 */
interface SoundGroup extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SoundGroup";
	/** The volume multiplier applied to `Sound`s that are in the `SoundGroup`. This value ranges from 0 to 10.

This property acts as a multiplier, and thus sounds in a `SoundGroup` will retain their relative volumes when it is set. This means if a sound's `Volume` is 0.5 and it is assigned to a `SoundGroup` with a volume of 0.5, its effective volume will be 0.25.

## Code Samples

### SoundGroups

This sample demonstrates how a SoundGroup can be used to change the volume of its associated Sounds and apply SoundEffects. 

In this example a Sound is instanced in the Workspace and assigned to a new SoundGroup. The Sound is played and during playback the volume is changed via the SoundGroup and a SoundEffect is added.
```lua
local SoundService = game:GetService("SoundService")

-- create a sound group
local soundGroup = Instance.new("SoundGroup", SoundService)

-- create a sound
local sound = Instance.new("Sound", game.Workspace)
sound.SoundId = "rbxassetid://301964312"
sound.Looped = true
sound.PlaybackSpeed = 2
sound.SoundGroup = soundGroup

-- play the sound
sound:Play()

wait(10)

-- change the volume
soundGroup.Volume = 0.1 

wait(3)

-- return the volume
soundGroup.Volume = 0.5
 
wait(4)

-- add a sound effect
Instance.new("ReverbSoundEffect", soundGroup) 
```
 */
	Volume: number;
}

/** A service that determines various aspects of how `Sound`s play in the game. SoundService is also often used to store `SoundGroup`s although this is not mandatory for `SoundGroup`s to work.

## What can SoundService do?

SoundService properties such as `AmbientReverb`, `DistanceFactor`, `DopplerScale` and `RolloffScale` can be used to change how all `Sound`s play in the game.

The `SetListener` function allows developers to set the position where sounds are heard from.

`PlayLocalSound` can be used to play a sound locally regardless of where it is parented to.

Developers looking to find out more about how sound works in Roblox should consult the documentation provided for the [FMOD sound engine][1].


  [1]: https://www.fmod.com/docs/api/content/generated/overview/3dsound.html

## Code Samples

### Play Local Sound

This sample creates and plays a sound locally when a button in a custom Studio plugin is pressed.
```lua
local SoundService = game:GetService("SoundService")

-- Create custom plugin button
local toolbar = plugin:CreateToolbar("Empty Script Adder")
local newScriptButton = toolbar:CreateButton("Add Script", "Create an empty Script", "rbxassetid://1507949215")

local function playLocalSound(soundId)
	-- Create a sound
	local sound = Instance.new("Sound")
	sound.SoundId = soundId
	-- Play the sound locally
	SoundService:PlayLocalSound(sound)
	-- Once the sound has finished, destroy it
	sound.Ended:Wait()
	sound:Destroy()
end

local function onNewScriptButtonClicked()
	-- Create new empty script
	local newScript = Instance.new("Script")
	newScript.Source = ""
	newScript.Parent = game:GetService("ServerScriptService")
	-- Call function to play local sound
	playLocalSound("")  -- Insert audio asset ID here
end

-- Connect plugin button to action function
newScriptButton.Click:Connect(onNewScriptButtonClicked)
```

### Dynamic Reverb System

The code in this sample, when ran from a `LocalScript`, will change the `AmbientReverb` property of `SoundService` when the player is inside a `BasePart` tagged using `CollectionService`.

To add or remove tags and reverb types, change the entries in the 'reverbTags' table.
```lua
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local SoundService = game:GetService("SoundService")

local localPlayer = Players.LocalPlayer

-- define tags
local reverbTags = {
	["reverb_Cave"] = Enum.ReverbType.Cave
}

-- collect parts and group them by tag
local parts = {}
for reverbTag, reverbType in pairs(reverbTags) do
	for _, part in pairs(CollectionService:GetTagged(reverbTag)) do
		parts[part] = reverbType
	end
end

-- function to check if a position is within a part's extents
local function positionInPart(part, position)
	local extents = part.Size / 2
	local offset = part.CFrame:pointToObjectSpace(position)
	return offset.x < extents.x
		and offset.y < extents.y
		and offset.z < extents.z
end

local reverbType = SoundService.AmbientReverb

while true do 
	wait()
	if not localPlayer then
		return
	end

	local character = localPlayer.Character

	-- default to no reverb
	local newReverbType = Enum.ReverbType.NoReverb

	if character and character.PrimaryPart then
		local position = character.PrimaryPart.Position

		-- go through all the indexed parts
		for part, type in pairs(parts) do
			-- see if the character is within them
			if positionInPart(part, position) then
				-- if so, pick that reverb type
				newReverbType = type
				break
			end
		end
	end

	-- set the reverb type if it has changed
	if newReverbType ~= reverbType then
		SoundService.AmbientReverb = newReverbType
		reverbType = newReverbType
	end
end
```
 */
interface SoundService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SoundService";
	/** The ambient sound environment preset used by `SoundService`.

The `ReverbType` this property simulates a range of different environment's impact on sound. Each different option corresponds with a preset available in the FMOD sound engine. For example, when AmbientReverb is set to Hangar, the sound will reverberate differently to simulate being in a large enclosed space.

Changing the AmbientReverb effects the following properties used by Roblox's sound engine.

 - Reverberation decay time
 - Initial reflection delay time
 - Late reverberation delay time relative to initial reflection
 - Reference high frequency
 - High-frequency to mid-frequency decay time ratio
 - Value that controls the echo density in the late reverberation decay
 - Value that controls the modal density in the late reverberation decay
 - Reference low frequency
 - Relative room effect level at low frequencies
 - Relative room effect level at high frequencies
 - Early reflections level relative to room effect
 - Room effect level at mid frequencies

Those interested in finding more out about ambient reverb presets should see the [FMOD documentation on the topic][1]. For most developers however, the `ReverbType` names are descriptive enough to be able to use this setting without advanced knowledge.


  [1]: https://www.fmod.com/docs/api/content/generated/FMOD_REVERB_PRESETS.html

## Code Samples

### Dynamic Reverb System

The code in this sample, when ran from a `LocalScript`, will change the `AmbientReverb` property of `SoundService` when the player is inside a `BasePart` tagged using `CollectionService`.

To add or remove tags and reverb types, change the entries in the 'reverbTags' table.
```lua
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local SoundService = game:GetService("SoundService")

local localPlayer = Players.LocalPlayer

-- define tags
local reverbTags = {
	["reverb_Cave"] = Enum.ReverbType.Cave
}

-- collect parts and group them by tag
local parts = {}
for reverbTag, reverbType in pairs(reverbTags) do
	for _, part in pairs(CollectionService:GetTagged(reverbTag)) do
		parts[part] = reverbType
	end
end

-- function to check if a position is within a part's extents
local function positionInPart(part, position)
	local extents = part.Size / 2
	local offset = part.CFrame:pointToObjectSpace(position)
	return offset.x < extents.x
		and offset.y < extents.y
		and offset.z < extents.z
end

local reverbType = SoundService.AmbientReverb

while true do 
	wait()
	if not localPlayer then
		return
	end

	local character = localPlayer.Character

	-- default to no reverb
	local newReverbType = Enum.ReverbType.NoReverb

	if character and character.PrimaryPart then
		local position = character.PrimaryPart.Position

		-- go through all the indexed parts
		for part, type in pairs(parts) do
			-- see if the character is within them
			if positionInPart(part, position) then
				-- if so, pick that reverb type
				newReverbType = type
				break
			end
		end
	end

	-- set the reverb type if it has changed
	if newReverbType ~= reverbType then
		SoundService.AmbientReverb = newReverbType
		reverbType = newReverbType
	end
end
```
 */
	AmbientReverb: Enum.ReverbType;
	/** The number of studs to be considered a meter by `SoundService` when calculating 3D `Sound` volume attenuation.

By default, the DistanceFactor is 3.33. This means, for the purposes of volume attenuation, a meter is considered 3.33 studs. The greater the DistanceFactor, the more gradually sound will attenuate.

```lua
local SoundService = game:GetService("SoundService")
SoundService.DistanceFactor = 1 -- 1 meter = 1 stud
SoundService.DistanceFactor = 10 -- 1 meter = 10 studs
```


Developers are advised to only change this property if their game uses a different scale. For example, when using larger custom characters, developers may want to reduce the DistanceFactor. In all other cases, `Sound` settings such as `RollOffMode` should be used instead.

Those looking to find out more about how 3D sound in Roblox works, should consult the [FMOD documentation][1].


  [1]: https://www.fmod.com/docs/api/content/generated/overview/3dsound.html */
	DistanceFactor: number;
	/** This property determines the degree to with a 3D `Sound`s pitch varies due to the Doppler effect.

The Doppler effect describes a phenomenon whereby the pitch of a sound changes as the source and observer of the sound move further away, or closer together. The Doppler effect can often be seen in real life, such as when a car with a siren drives past.

Increasing this value exaggerates the impact of the Doppler effect, whereas decreasing it minimizes it. By default, the value of this property is 1.

```lua
local SoundService = game:GetService("SoundService")
SoundService.DopplerScale = 1 -- default 
SoundService.DopplerScale = 2 -- exaggerated Doppler effect
SoundService.DopplerEffect = 0.5 -- subdued Doppler effect
```


Note the Doppler effect has no impact on 2D `Sound`s, (`Sound`s not parented to a `BasePart` or `Attachment`).

Developers wishing to learn more about the different settings Roblox's sound engine uses should consult the [FMOD documentation][1].


  [1]: https://www.fmod.com/docs/api/content/generated/overview/3dsound.html */
	DopplerScale: number;
	/** This `SoundService` property determines whether or not `Sound` playback will replicate from the client to the server and onto other clients.

* When **RespectFilteringEnabled** is set to false (default), sounds played by a client will replicate to the server and play for other clients.

* When **RespectFilteringEnabled** is set to true, sound playback will not replicate from client-side scripts (`LocalScripts`)
. */
	RespectFilteringEnabled: boolean;
	/** Sets how fast 3D `Sound` volume attenuates, or 'rolls off'.

Note, this property only applies to `Sound`s whose `RollOffMode` property is set to 'Inverse' or 'InverseTapered'. 'Linear' and 'LinearSquare' `RollOffMode`s use a different attenuation model which is not influenced by this property. This property also has no impact on 2D sounds (`Sound`s not parented to a `BasePart` or `Attachment`).

The higher the RolloffScale, the more rapidly a 3D sound's volume will attenuate as the distance between the listener and the sound increases. 

By default the roll off scale is set to 1, which simulates the real world.

```lua
local SoundService = game:GetService("SoundService")
SoundService.RolloffScale = 1 -- attenuation simulates real world
SoundService.RolloffScale = 2 -- sound attenuates twice as fast as the real world
```


Developers wishing to learn more about the different settings Roblox's sound engine uses should consult the [FMOD documentation][1].


  [1]: https://www.fmod.com/docs/api/content/generated/overview/3dsound.html */
	RolloffScale: number;
	/** GetListener returns `SoundService`s current listener type and what is set as listener.

The first result returned is the `ListenerType` of the listener, the second result is dependent on the listener type.

 - Camera ListenerType - Does not return a listener object as `CurrentCamera` is always used
 - CFrame ListenerType - Returns the `CFrame` used in `SetListener`
 - ObjectPosition ListenerType - Returns the `BasePart` used in `SetListener`
 - ObjectCFrame ListenerType - Returns the `BasePart` used in `SetListener`

The listener can be changed using `SetListener`.

```lua
local SoundService = game:GetService("SoundService")
SoundService:SetListener(Enum.ListenerType.CFrame, CFrame.new(0, 0, 0))
local listenerType, listener = SoundService:GetListener()
print(listenerType, listener)
```


## What is a listener?

The `SoundService`'s listener determines the point from which audio in the game is being 'heard' by the player. For 3D `Sound`s (`Sound`s parented to a `BasePart` or `Attachment`) the listener influences the volume and left/right balance of a playing sound. Listeners have no influence on the playback of 2D `Sound`s as they have no position of emission.

By default, the listener is set to the `CurrentCamera`. However, a range of different types of listeners can be used.
@returns The current `Enum/ListenerType` and what the listener has been set to. Dependent on `Enum/ListenerType` the listener could be a `BasePart`, a `DataType/CFrame` or nil. */
	GetListener():
		| [Enum.ListenerType.Camera, undefined]
		| [Enum.ListenerType.CFrame, CFrame]
		| [Enum.ListenerType.ObjectCFrame, BasePart]
		| [Enum.ListenerType.ObjectPosition, BasePart];
	/** Plays a `Sound` locally, meaning the sound will only be heard by the client calling this function, regardless of where it's parented to. This function is most useful for playing a `Sound` locally in the Studio client, for instance in a `Script` for a `Intro to custom plugin`
.

## Code Samples

### Play Local Sound

This sample creates and plays a sound locally when a button in a custom Studio plugin is pressed.
```lua
local SoundService = game:GetService("SoundService")

-- Create custom plugin button
local toolbar = plugin:CreateToolbar("Empty Script Adder")
local newScriptButton = toolbar:CreateButton("Add Script", "Create an empty Script", "rbxassetid://1507949215")

local function playLocalSound(soundId)
	-- Create a sound
	local sound = Instance.new("Sound")
	sound.SoundId = soundId
	-- Play the sound locally
	SoundService:PlayLocalSound(sound)
	-- Once the sound has finished, destroy it
	sound.Ended:Wait()
	sound:Destroy()
end

local function onNewScriptButtonClicked()
	-- Create new empty script
	local newScript = Instance.new("Script")
	newScript.Source = ""
	newScript.Parent = game:GetService("ServerScriptService")
	-- Call function to play local sound
	playLocalSound("")  -- Insert audio asset ID here
end

-- Connect plugin button to action function
newScriptButton.Click:Connect(onNewScriptButtonClicked)
```

@param sound The `Sound` to be played. */
	PlayLocalSound(sound: Sound): void;
	/** Sets the listener used by the client.

The first parameter is the `ListenerType` of the listener, the second paramater is dependent on the listener type.

 - Camera ListenerType - Does not return a listener object as `CurrentCamera` is always used
 - CFrame ListenerType - The `CFrame` to be used
 - ObjectPosition ListenerType - The `BasePart` to be used
 - ObjectCFrame ListenerType - The `BasePart` to be used

The listener can be retrieved using `GetListener`.

```lua
local SoundService = game:GetService("SoundService")
SoundService:SetListener(Enum.ListenerType.CFrame, CFrame.new(0, 0, 0))
local listenerType, listener = SoundService:GetListener()
print(listenerType, listener)
```


## What is a listener?

The `SoundService`'s listener determines the point from which audio in the game is being 'heard' by the player. For 3D `Sound`s (`Sound`s parented to a `BasePart` or `Attachment`) the listener influences the volume and left/right balance of a playing sound. Listeners have no influence on the playback of 2D `Sound`s as they have no position of emission.

By default, the listener is set to the `CurrentCamera`. However, a range of different types of listeners can be used.
@param listenerType The `Enum/ListenerType` of the listener.
@param listener Dependent on the `Enum/ListenerType`. `BasePart` for 'ObjectPosition' or 'ObjectCFrame', `DataType/CFrame` for 'CFrame', nil for 'Camera'. */
	SetListener(listenerType: CastsToEnum<Enum.ListenerType.Camera>): void;
	SetListener(listenerType: CastsToEnum<Enum.ListenerType.CFrame>, cframe: CFrame): void;
	SetListener(listenerType: CastsToEnum<Enum.ListenerType.ObjectCFrame>, basePart: BasePart): void;
	SetListener(listenerType: CastsToEnum<Enum.ListenerType.ObjectPosition>, basePart: BasePart): void;
}

/** Sparkles is one of several particle-emitting classes. Like other particle emitters of its kind, Sparkles objects emit particles when parented to a `BasePart` (such as a `Part`) or an `Attachment` within such a `BasePart`. Compared to the `ParticleEmitter` class, Sparkles lacks many different customization properties and special methods, such as `Lifetime` or `Emit`. It is useful to create a quick special effect in a pinch; for more detailed work it is preferable to use a `ParticleEmitter` instead.

![Sparkles emitting from a part](https://developer.roblox.com/assets/bltb4fd95f7dbbb308a/Sparkles.png)

When `Enabled` is toggled off, particles emit by this object will continue to render until their lifetime expires. When a Sparkles object's `Parent` is set to nil (and/or `Destroy`ed), all particles will instantly disappear. If this effect is not desired, try hiding the parent object at a far away position, then removing the Sparkles after a few seconds using `Debris` to give the last particles a chance to expire. This object does not have a `Clear` method, but it is possible to set the `Parent` to nil and back to the exact same object for the same effect.

Sparkles particles are only emit from the center of `BasePart` to which they are parented. Parenting a Sparkles object to an `Attachment` instead allows customization of the particles' start position.

## Code Samples

### Give Sparkles

The code sample below gives any new players sparkles that are colored the same as their torso color.
```lua
local Players = game.Players

local function onCharacterSpawned(character)
	local hrp = character:WaitForChild("HumanoidRootPart")
	-- Add sparkles that are colored to the player's torso color
	local sparkles = Instance.new("Sparkles")
	sparkles.Parent = hrp
	sparkles.SparkleColor = character:WaitForChild("Body Colors").TorsoColor.Color
	sparkles.Enabled = true
end

local function onPlayerAdded(player)
	player.CharacterAdded:Connect(onCharacterSpawned)
end

Players.PlayerAdded:Connect(onPlayerAdded)
```
 */
interface Sparkles extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Sparkles";
	/** The Color property determines the color of all the particles emit by a `Sparkles` object (both existing and future particles). It behaves similarly to `Color`, except that it is only one color and not a `ColorSequence`. Sparkles have a natural color sequence applied which is most apparent when this property is set to white; sparkles very faintly animate between a subtle green and red. Below, you can see two `Sparkles` objects with differing SparkleColor (the left is default, the right is white).

![Two Sparkles objects with differing SparkleColor](https://developer.roblox.com/assets/blt22f35a953a5b6687/Sparkles_SparkleColor.png)

It should be noted that sparkles have a partial `LightEmission` effect, so dark colors tend to render more transparent and white colors look very bright.

  


Note
----------
This property functions identically to `SparkleColor`.

## Code Samples

### Give Sparkles

The code sample below gives any new players sparkles that are colored the same as their torso color.
```lua
local Players = game.Players

local function onCharacterSpawned(character)
	local hrp = character:WaitForChild("HumanoidRootPart")
	-- Add sparkles that are colored to the player's torso color
	local sparkles = Instance.new("Sparkles")
	sparkles.Parent = hrp
	sparkles.SparkleColor = character:WaitForChild("Body Colors").TorsoColor.Color
	sparkles.Enabled = true
end

local function onPlayerAdded(player)
	player.CharacterAdded:Connect(onCharacterSpawned)
end

Players.PlayerAdded:Connect(onPlayerAdded)
```
The Color property determines the color of all the particles emit by a `Sparkles` object (both existing and future particles). It behaves similarly to `Color`, except that it is only one color and not a `ColorSequence`. Sparkles have a natural color sequence applied which is most apparent when this property is set to white; sparkles very faintly animate between a subtle green and red. Below, you can see two `Sparkles` objects with differing SparkleColor (the left is default, the right is white).

![Two Sparkles objects with differing SparkleColor](https://developer.roblox.com/assets/blt22f35a953a5b6687/Sparkles_SparkleColor.png)

It should be noted that sparkles have a partial `LightEmission` effect, so dark colors tend to render more transparent and white colors look very bright.

  


Note
----------
This property functions identically to `SparkleColor`.

## Code Samples

### Give Sparkles

The code sample below gives any new players sparkles that are colored the same as their torso color.
```lua
local Players = game.Players

local function onCharacterSpawned(character)
	local hrp = character:WaitForChild("HumanoidRootPart")
	-- Add sparkles that are colored to the player's torso color
	local sparkles = Instance.new("Sparkles")
	sparkles.Parent = hrp
	sparkles.SparkleColor = character:WaitForChild("Body Colors").TorsoColor.Color
	sparkles.Enabled = true
end

local function onPlayerAdded(player)
	player.CharacterAdded:Connect(onCharacterSpawned)
end

Players.PlayerAdded:Connect(onPlayerAdded)
```


Tags: Hidden, NotReplicated */
	Color: Color3;
	/** The Enabled property, much like `Enabled`, determines whether sparkle particles are emit. Any particles already emit will continue to render until their lifetime expires. This property is useful for keeping pre-made sparkle effects off until they are needed later. Since sparkle particles are destroyed when the `Sparkle` object's `Parent` is set to nil, this property is useful in allowing existing particles the opportunity to expire before destroying the Fire object altogether. See the function below.

```lua
local Debris = game:GetService("Debris")
local part = script.Parent
function stopSparkling(sparkles)
	sparkles.Enabled = false -- No more new particles
	Debris:AddItem(sparkles, 4) -- Remove the object after a delay (after existing particles have expired)
end
stopSparkling(part.Sparkles)
```

## Code Samples

### Give Sparkles

The code sample below gives any new players sparkles that are colored the same as their torso color.
```lua
local Players = game.Players

local function onCharacterSpawned(character)
	local hrp = character:WaitForChild("HumanoidRootPart")
	-- Add sparkles that are colored to the player's torso color
	local sparkles = Instance.new("Sparkles")
	sparkles.Parent = hrp
	sparkles.SparkleColor = character:WaitForChild("Body Colors").TorsoColor.Color
	sparkles.Enabled = true
end

local function onPlayerAdded(player)
	player.CharacterAdded:Connect(onCharacterSpawned)
end

Players.PlayerAdded:Connect(onPlayerAdded)
```
 */
	Enabled: boolean;
	/** The SparkleColor property determines the color of all the particles emit by a `Sparkles` object (both existing and future particles). It behaves similarly to `Color`, except that it is only one color and not a `ColorSequence`. Sparkles have a natural color sequence applied which is most apparent when this property is set to white; sparkles very faintly animate between a subtle green and red. Below, you can see two `Sparkles` objects with differing SparkleColor (the left is default, the right is white).

![Two Sparkles objects with differing SparkleColor](https://developer.roblox.com/assets/blt22f35a953a5b6687/Sparkles_SparkleColor.png)

It should be noted that sparkles have a partial `LightEmission` effect, so dark colors tend to render more transparent and white colors look very bright.

  



Note
----------
This property functions identically to `Color`.

## Code Samples

### Give Sparkles

The code sample below gives any new players sparkles that are colored the same as their torso color.
```lua
local Players = game.Players

local function onCharacterSpawned(character)
	local hrp = character:WaitForChild("HumanoidRootPart")
	-- Add sparkles that are colored to the player's torso color
	local sparkles = Instance.new("Sparkles")
	sparkles.Parent = hrp
	sparkles.SparkleColor = character:WaitForChild("Body Colors").TorsoColor.Color
	sparkles.Enabled = true
end

local function onPlayerAdded(player)
	player.CharacterAdded:Connect(onCharacterSpawned)
end

Players.PlayerAdded:Connect(onPlayerAdded)
```
 */
	SparkleColor: Color3;
}

/** An internal service that is responsible for the behavior or `SpawnLocation`s. Its functionality is not accessible to developers. */
interface SpawnerService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "SpawnerService";
}

/** StarterGear is a container that is automatically inserted into each `Player` when the player joins the game. When a player spawns, the contents of that player's StarterGear is copied into the player's `Backpack`. Additionally,  when a player connects to a game that permits gear, all of the appropriate gear `Tool` objects that the player owns are inserted into that player's StarterGear.

Unlike `StarterPack`, StarterGear is not a service but rather a child of each `Player` object -- this means that its contents are player-specific so that each player can have different `Tool`s within their `StarterGear`. It is not replicated to any client, including the owning player.

## Accessing StarterGear
Listening to the `PlayerAdded` event is useful for 

```lua
local Players = game:GetService("Players")

local toolExamplePrefab = Instance.new("Tool")
toolExamplePrefab.Name = "Example Tool"

-- Accessing StarterGear from Server Script
local function onPlayerAdded(player)
	-- Wait for the StarterGear to be added
	local starterGear = player:WaitForChild("StarterGear")
	-- Add a Tool to the StarterGear
	local toolExample = toolExamplePrefab:Clone()
	toolExample.Parent = starterGear
end

Players.PlayerAdded:connect(onPlayerAdded)
```


## Allowing Gear

Whether or not gear can be permitted is determined in a place's settings page under 'Permissions'. On the permissions page gear can be disabled and enabled by genre and type. To disable gear, ensure all the gear types are not selected. 

Individual gear can also be added to a game using the 'Add to game' feature in the Roblox catalog. This option can be found on the page of any gear that is on sale. When gear is added to a game in this manner it will appear under the 'Store' heading on the game's page. The owner of the game (group or user) receives a commission when gear is sold in this manner.

## Gameplay Considerations

Before adding any gear to a game, consider the implication of doing so. Gear includes `Script`s and allows the player to perform actions that the developer may not have considered. For example, a navigational gear may allow the player to access a part of the map the developer does not want to be accessed. Weapons allow players with gear to damage other players, possibly without the ability to retaliate. Always play-test games after adding gear to them to make sure there are no abuse cases. */
interface StarterGear extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StarterGear";
}

/** A service-level container whose contents are copied into each `Player`'s `Backpack` when the player spawns. It is generally used to hold `Tools`, but is sometimes used to hold `LocalScript`s to ensure that each player gets a copy. 

When a player's character spawns, the contents of the StarterPack and their `StarterGear` are copied into their `Backpack`. Once a character dies, the `Backpack` is removed and a new one is created -- populating it using the contents of `StarterPack` and `StarterGear`. 

The StarterPack is used to determine a set of `Tool`s that *all* players will spawn with. If a developer wants to ensure that certain `Tool`s are available to specific players, then they will need to parent the `Tool`s directly to the player's `Backpack` instead.

Note: while normally the contents of `StarterPack` are predefined, the contents can be changed while the game is running by adding and removing `Tool`s accordingly. These updates will pass onto a player's backpack when they respawn and their backpacks are reloaded. Changes to the StarterPack should be made by the server.

A tool can be added to the StarterPack using the following code.

    Tool.Parent = game:GetService("StarterPack")

## Code Samples

### Empty StarterPack

This simple function will remove all Tools from the StarterPack, whilst leaving other objects such as LocalScripts in place.
```lua
local StarterPack = game:GetService("StarterPack")

local function emptyStarterPack()
	for _, child in pairs(StarterPack:GetChildren()) do
		if child:IsA("Tool") then
			child:Destroy()
		end
	end
end
```
 */
interface StarterPack extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StarterPack";
}

/** A service which allows the defaults of properties in the `Player` object to be set. When a player enters the server, each property of the player object is set to the current value of the corresponding property in StarterPlayer.

Additionally, you may add four objects to this service:

* A `StarterPlayerScripts` instance, with scripts that run once for each player.
* A `StarterCharacterScripts` instance, with scripts to add to each player's character every time they spawn.
* A `Humanoid` instance named **StarterHumanoid**, which will be used as the default humanoid for each player's character.
* A `Model` instance named **StarterCharacter**, which will be used as the character model for all players

A typical structure may look something like this:
![StarterPlayer Tree](https://developer.roblox.com/assets/5b5b57ba7eac3e673d5e5700/StarterPlayerTree.png)

## Code Samples

### Displaying a Humanoid's Health and Name

This example demonstrates how to set a `Humanoid`'s `DisplayerDistanceType`, `HealthDisplayDistance`, and `NameDisplayDistance` properties. These properties determine how a  humanoid's healthbar and name are rendered for a player.

First, we change the DisplayDistanceType to Viewer using `HumanoidDisplayDistanceType`. When set to viewer, the humanoid's Name and healthbar will be displayed based on the distance settings of the humanoid viewing them.

Then, the humanoid's HealthDisplayDistance is set to 0. Setting the property to 0 hides the healthbar completely. It is not displayed at any distance.

Finally, the humanoid's NameDisplayDistance is set to 100. This means that the humanoid's name will be visible to other humanoid's within 100 studs.

This example should work as expected when placed inside a `Script` that is a child of the humanoid.
```lua
local humanoid = script.Parent

humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
humanoid.HealthDisplayDistance = 0
humanoid.NameDisplayDistance = 100
```

### Setting a Player's Replication Focus

This example creates a new `BasePart` and sets the `Player`'s `ReplicationFocus` to that part.

This demonstrates the functionality of the ReplicationFocus property. You can easily change the part that the focus is set to to change the replication focus.
```lua
local part = Instance.new("Part")
part.Parent = game.Workspace
part.Name = "ReplicationFocusPart"
part.Anchored = true

local player = game.Players.LocalPlayer
player.ReplicationFocus = part
```

### Setting Camera Zoom Distance

​The example demonstrates how to set a player's camera minimum and maximum zoom distance.

In this example, we set the `CameraMinZoomDistance` and `CameraMaxZoomDistance` to set the min and max distance in studs a player's camera can be from their character.

Note that since the example attempts to set the CameraMinZoomDistance to be greater than the CameraMaxZoomDistance, the CameraMinZoomDistance value will be decreased and set to the value of the max zoom distance.

To change the default min and max zoom distance values for a player when they first enter the game, you can change the `CameraMinZoomDistance` and `CameraMaxZoomDistance` properties.
```lua
local player = game.Players.LocalPlayer

player.CameraMaxZoomDistance = 50
player.CameraMinZoomDistance = 75
```
 */
interface StarterPlayer extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StarterPlayer";
	/** The AllowCustomAnimations `StarterPlayer` property describes the current game's permission levels regarding custom avatar `Animation`s from the website.

As such, this value cannot be changed from within the game. It can only be changed by changing the game's permission levels within the game's setting's page on the website.

This property is not intended for use in the game.The AllowCustomAnimations `StarterPlayer` property describes the current game's permission levels regarding custom avatar `Animation`s from the website.

As such, this value cannot be changed from within the game. It can only be changed by changing the game's permission levels within the game's setting's page on the website.

This property is not intended for use in the game.

Tags: Hidden */
	readonly AllowCustomAnimations: boolean;
	/** The AutoJumpEnabled property sets whether the character will automatically jump when hitting an obstacle on a mobile device. 

This property is copied from the `StarterPlayer` to a `Player` when they join the game. Following that. the value of this property is copied to `AutoJumpEnabled` property of the `Character`s `Humanoid` on spawn. In other words, it is possible to set the auto-jump behavior on a per-character, per-player and per-game basis using these three properties.

## Code Samples

### Auto-Jump Toggle

This code sample is meant for a TextButton. It allows the player to toggle the auto-jumping behavior while on a mobile device.
```lua
local player = game.Players.LocalPlayer
local button = script.Parent

local function update()
	-- Update button text
	if player.AutoJumpEnabled then
		button.Text = "Auto-Jump is ON"
	else
		button.Text = "Auto-Jump is OFF"
	end
	-- Reflect the property in the player's character, if they have one
	if player.Character then
		local human = player.Character:FindFirstChild("Humanoid")
		if human then
			human.AutoJumpEnabled = player.AutoJumpEnabled
		end
	end
end

local function onActivated()
	-- Toggle auto-jump
	player.AutoJumpEnabled = not player.AutoJumpEnabled
	-- Update everything else
	update()
end
button.Activated:connect(onActivated)
update()

```
 */
	AutoJumpEnabled: boolean;
	/** The CameraMaxZoomDistance `StarterPlayer` property sets the maximum distance in studs the camera can be from the character with the default cameras. 

This property sets the default value of `CameraMaxZoomDistance` for each player who joins the game. If this value is set to a lower value than `CameraMinZoomDistance` it will be increased to CameraMinZoomDistance.

## Code Samples

### Setting Camera Zoom Distance

​The example demonstrates how to set a player's camera minimum and maximum zoom distance.

In this example, we set the `CameraMinZoomDistance` and `CameraMaxZoomDistance` to set the min and max distance in studs a player's camera can be from their character.

Note that since the example attempts to set the CameraMinZoomDistance to be greater than the CameraMaxZoomDistance, the CameraMinZoomDistance value will be decreased and set to the value of the max zoom distance.

To change the default min and max zoom distance values for a player when they first enter the game, you can change the `CameraMinZoomDistance` and `CameraMaxZoomDistance` properties.
```lua
local player = game.Players.LocalPlayer

player.CameraMaxZoomDistance = 50
player.CameraMinZoomDistance = 75
```
 */
	CameraMaxZoomDistance: number;
	/** The CameraMinZoonDistance `StarterPlayer` property sets the minimum distance in studs the camera can be from the character with the default cameras. 

This property sets the default value of `CameraMinZoomDistance` for each player who joins the game. If this value is set to a higher value than `CameraMaxZoomDistance` it will be decreased to CameraMaxZoomDistance.

## Code Samples

### Setting Camera Zoom Distance

​The example demonstrates how to set a player's camera minimum and maximum zoom distance.

In this example, we set the `CameraMinZoomDistance` and `CameraMaxZoomDistance` to set the min and max distance in studs a player's camera can be from their character.

Note that since the example attempts to set the CameraMinZoomDistance to be greater than the CameraMaxZoomDistance, the CameraMinZoomDistance value will be decreased and set to the value of the max zoom distance.

To change the default min and max zoom distance values for a player when they first enter the game, you can change the `CameraMinZoomDistance` and `CameraMaxZoomDistance` properties.
```lua
local player = game.Players.LocalPlayer

player.CameraMaxZoomDistance = 50
player.CameraMinZoomDistance = 75
```
 */
	CameraMinZoomDistance: number;
	/** The CameraMode `StarterPlayer` property sets whether cameras will be locked to first person or not when a player joins the game. 

Sets the default value for `CameraMode` for each player in the game.

The camera has two modes:
 1. First person
 2. Third person

The `CameraMode` Enum is used to set CameraMode, and determines when first and third person cameras should be used.

First-person
------------
In first-person mode, the player's camera is zoomed all the way in. Unless there is a visible GUI present with the `/GuiButton/Modal` property set to *true*, the mouse will be locked and the user's camera will turn as the mouse moves.
![First Person CameraMode](https://developer.roblox.com/assets/5ade20a13a314ce34a0f6878/CameraMode_FirstPerson.jpg)

Third-person
------------
In third-person mode, the character can be seen in the camera. While in third-person mode on Roblox:

* You may right-click and drag to rotate your camera, or use the arrow keys at the bottom right-hand corner of the screen. 
* When you move your mouse, your camera does not change (unless you move the mouse to the end of the screen). 
* When you press any of the arrow keys, the user's character will face in the corresponding arrow key's direction. 
* You can zoom in and out freely. 

Third-person is the default camera setting.
![Third Person CameraMode](https://developer.roblox.com/assets/5ade20afbaed3a514c3722c4/CameraMode_ThirdPerson.jpg)

## Code Samples

### Playing in Third Person

This example demonstrates how to change the character's CameraMode to third person using the Classic value of the `CameraMode` enum.
```lua
local player = game.Players.LocalPlayer

player.CameraMode = Enum.CameraMode.Classic
```

### Playing in First Person

This example demonstrates how to change the character's CameraMode to first person using the LockFirstPerson value of the `CameraMode` enum.
```lua
local player = game.Players.LocalPlayer

player.CameraMode = Enum.CameraMode.LockFirstPerson
```
 */
	CameraMode: Enum.CameraMode;
	/** [LACKS DOCUMENTATION] */
	CharacterJumpHeight: number;
	/** [LACKS DOCUMENTATION] */
	CharacterJumpPower: number;
	/** [LACKS DOCUMENTATION] */
	CharacterMaxSlopeAngle: number;
	/** [LACKS DOCUMENTATION] */
	CharacterUseJumpPower: boolean;
	/** [LACKS DOCUMENTATION] */
	CharacterWalkSpeed: number;
	/** The DevCameraOcclusionMode `StarterPlayer` property sets how the default camera handles objects between the camera and the player. 

This is the default property for players joining the game. It can be changed for individual players by settings the `DevComputerOcclusionMode`.

The default value is *Zoom* (0): The camera will zoom in until there is nothing between the player and camera.

See `DevCameraOcclusionMode` for the different occlusion modes available. Sets how the default camera handles objects between the camera and the player. */
	DevCameraOcclusionMode: Enum.DevCameraOcclusionMode;
	/** The DevComputerCameraMovementMode `StarterPlayer` property lets the developer overwrite the player's camera mode if the player is on a computer. 

This is the default property for players joining the game. It can be changed for individual players by settings the `DevComputerCameraMode`.

If set to **UserChoice** then the player's camera movement mode will be determined by whatever the player set in the game settings. Otherwise, the mode will be set based on this property.

See `DevComputerCameraMovementMode` for the different camera modes available.

## Note
This property has no affect on players not on a computer.

## Code Samples

### Setting a Player's Camera Movement Mode (Desktop)

The example demonstrates how to set a player's camera movement mode for players on a computer.

In this example, we set the camera movement mode to Classic via the `DevComputerCameraMovementMode` enum. This means that the camera of players on touch enabled devices will track the player but will not automatically rotate if the player walks left or right.
```lua
local player = game.Players.LocalPlayer

-- Set the player's camera movement mode on computers to classic
player.DevComputerCameraMode = Enum.DevComputerCameraMovementMode.Classic
```
 */
	DevComputerCameraMovementMode: Enum.DevComputerCameraMovementMode;
	/** The DevComputerMovementMove `StarterPlayer` property lets the developer overwrite the player's movement mode if the player is on a computer.

This is the default property for players joining the game. It can be changed for individual players by settings the `DevComputerMovementMode`.

If set to **UserChoice** then the player's movement mode will be determined by whatever the player set in the game settings. Otherwise, the mode will be set based on this property.

See `DevComputerMovementMode` for the different movement modes available. Lets developer overwrite the player's movement mode if the player is on a computer.

## Note
This property has no affect on players not on a computer.

## Code Samples

### Setting a Player's Movement Mode (Desktop)

The example demonstrates how to set the movement mode for players on computers.

In this example, we set the movement mode to KeyboardMouse via the `DevComputerMovementMode` enum. This means that players on computers control their characters using their keyboard and mouse.
```lua
local player = game.Players.LocalPlayer

-- Set the player's movement mode on computers to keyboard and mouse
player.DevComputerMovementMode = Enum.DevComputerMovementMode.KeyboardMouse
```
 */
	DevComputerMovementMode: Enum.DevComputerMovementMode;
	/** The DevTouchCameraMovementMode `StarterPlayer` property lets the developer overwrite the player's camera mode if the player is on a touch device. 

This is the default property for players joining the game. It can be changed for individual players by settings the `DevTouchCameraMode`.

If set to **UserChoice** then the player's camera movement mode will be determined by whatever the player set in the game settings. Otherwise, the mode will be set based on this property.

See `DevTouchCameraMovementMode` for the different camera modes available.

## Note
This property has no affect players not on a mobile device.

## Code Samples

### Setting a Player's Camera Movement Mode (Touch)

The example demonstrates how to set a player's camera movement mode.

In this example, we set the camera movement mode to Classic via the `DevTouchCameraMovementMode` enum. This means that the camera of players on touch enabled devices will track the player but will not automatically rotate if the player walks left or right.
```lua
local player = game.Players.LocalPlayer

-- Set the player's camera movement mode on mobile devices to classic
player.DevTouchCameraMovementMode = Enum.DevTouchCameraMovementMode.Classic
```
 */
	DevTouchCameraMovementMode: Enum.DevTouchCameraMovementMode;
	/** The DevTouchMovementMode `StarterPlayer` property lets the developer overwrite the player's movement mode if the player is on a touch device.

This is the default property for players joining the game. It can be changed for individual players by settings the `DevTouchMovementMode`.

If set to **UserChoice** then the player's movement mode will be determined by whatever the player set in the game settings. Otherwise, the mode will be set based on this property.

See `DevTouchMovementMode` for the different movement modes available. Lets developer overwrite the player's movement mode if the player is on a touch device.

## Note
This property has no affect on players not on a touch enabled device.

## Code Samples

### Setting a Player's Movement Mode (Touch)

The example demonstrates how to set the movement mode for players on touch enabled devices.

In this example, we set the movement mode to Thumbstick via the `DevTouchMovementMode` enum. This means that players on touch enabled devices be able to move via a virtual thumbstick on their screen.
```lua
local player = game.Players.LocalPlayer

-- Set the player's movement mode on mobile devices to a virtual thumbstick
player.DevTouchMovementMode = Enum.DevTouchMovementMode.Thumbstick
```
 */
	DevTouchMovementMode: Enum.DevTouchMovementMode;
	/** The EnableMouseLockOption `StarterPlayer` property determines if a player can toggle mouse lock by default. 

Mouselock will lock the player's cursor to the center of the screen. Moving the mouse will rotate the `Camera` and `Player` will move relative to the current rotation of the camera. 

This property sets the value of `DevEnableMouseLock`.

## Code Samples

### Enabling a Player's Mouse Lock

The example demonstrates how to enable and disabled whether a player can lock their mouse.

In this example, we set the use a while true loop to toggle the state of the DevEnabledMouseLock property between *true* and *false* every 5 seconds. While this example has little practical use, it demos how to change the property via a `LocalScript`.
```lua
local player = game.Players.LocalPlayer

while true do
	player.DevEnableMouseLock = not player.DevEnableMouseLock
	wait(5)
end
```
 */
	EnableMouseLockOption: boolean;
	/** The HealthDisplayDistance `StarterPlayer` property sets the distance in studs at which this player will see other `Humanoid`’s health bars. If set to 0, the health bars will not be displayed. This property is set to 100 studs by default.

To change the display distance for a player once they join the game, you can set the `HealthDisplayDistance` property.

## Note
If a Humanoid's health bar is visible, you can set the display type using `DisplayDistanceType`. */
	HealthDisplayDistance: number;
	/** The LoadCharacterAppearance `StarterPlayer` property sets whether or not the appearance of a player's character should be loaded. 

This property sets the default value of `CanLoadCharacterAppearance` for each player who joins the game.

Setting this to *false* results in the player having no clothes (including hats), body colors, body packages or anything else related to the appearance of the player. By default, this property is set to *true*.

Setting this to *true* results in the player loading the appearance corresponding to the player's `CharacterAppearanceId`. */
	LoadCharacterAppearance: boolean;
	/** Sets the distance at which this player will see other Humanoid’s names. If set to 0, names are hidden.

The NameDisplayDistance `StarterPlayer` property sets the distance in studs at which this player will see other `Humanoid`’s names. If set to 0, names are hidden. This property is set to 100 studs by default.

To change the display distance for a player once they join the game, you can set the `NameDisplayDistance` property.

## Note
If a Humanoid's name is visible, you can set the display type using `DisplayDistanceType`. */
	NameDisplayDistance: number;
}

interface RbxInternalDerivesFromStarterPlayerScripts extends RbxInternalInstance {}
/** The StarterPlayerScripts is a container object located within the `StarterPlayer` service. It contains `LocalScript`s and other objects to be copied to the `PlayerScripts` container once when a `Player` joins the game. For example, if you want to create special effects on the client when certain conditions are met, you can place a `LocalScript` within this object to do that.

This object is also a good place for `LocalScript`s that define additional inputs with `ContextActionService`. For inputs that are only relevant when a player has spawned in, you can use `BindAction` when the `LocalPlayer` character spawns. Then, use `UnbindAction` when they die or despawn. 

When a game is run, this object will also house the default multi-platform Roblox control scripts for the camera and character. If `LocalScript`s named "CameraScript" or "ControlScript" are placed within this folder, they will **replace** the Roblox defaults for those scripts respectively. You can add empty LocalScripts for each of these to simply disable them altogether. This is useful for games that do not follow the usual control paradigms of a 3rd person game. */
interface StarterPlayerScripts extends RbxInternalDerivesFromStarterPlayerScripts {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StarterPlayerScripts";
}


/** The StarterCharacterScripts class stores scripts to be parented in a player's [Character](https://developer.roblox.com/api-reference/property/Player/Character "Character"), when they spawn.
Unlike scripts stored in the [PlayerScripts](https://developer.roblox.com/api-reference/class/PlayerScripts "PlayerScripts") folder, these scripts will not persist when the player respawns.


If a script named **Animate**, **Sound** or **Health** is placed in this folder, they will replace the default scripts that are added to each [Character](https://developer.roblox.com/api-reference/property/Player/Character "Character")
 that is created. */
interface StarterCharacterScripts extends RbxInternalDerivesFromStarterPlayerScripts {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StarterCharacterScripts";
}

/** Stats is a service that provides real-time performance information about the current running game instance. Its primary purpose is to provide developers with an end point to measure where resources are being consumed, as well as how much memory is being consumed overall. 

The service also stores a tree of `StatsItem`, which can have their values read by plugins. */
interface Stats extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Stats";
	/** ContactsCount describes how many parts are currently in contact with each other, such that one of the two parts are being physically simulated, and thus can be recognized by the `GetTouchingParts` method.ContactsCount describes how many parts are currently in contact with each other, such that one of the two parts are being physically simulated, and thus can be recognized by the `GetTouchingParts` method.

Tags: ReadOnly, NotReplicated */
	readonly ContactsCount: number;
	/** In a networked game, DataReceiveKbps describes roughly how many kilobytes of data are being received by the current instance, per second.

If from the server’s perspective, this represents the total amount of data being received from the clients connected to the server.
If from a client’s perspective, this represents the total amount of data being received from the server.In a networked game, DataReceiveKbps describes roughly how many kilobytes of data are being received by the current instance, per second.

If from the server’s perspective, this represents the total amount of data being received from the clients connected to the server.
If from a client’s perspective, this represents the total amount of data being received from the server.

Tags: ReadOnly, NotReplicated */
	readonly DataReceiveKbps: number;
	/** In a networked game, DataSendKbps describes roughly how many kilobytes of data are being sent by the current instance, per second.

If from the server’s perspective, this represents the total amount of data being sent to the clients connected to the server.
If from a client’s perspective, this represents the total amount of data being sent to the server.In a networked game, DataSendKbps describes roughly how many kilobytes of data are being sent by the current instance, per second.

If from the server’s perspective, this represents the total amount of data being sent to the clients connected to the server.
If from a client’s perspective, this represents the total amount of data being sent to the server.

Tags: ReadOnly, NotReplicated */
	readonly DataSendKbps: number;
	/** The HeartbeatTimeMs property is a a measurement of the total amount of time it takes long it takes for Roblox to update all of its Task Scheduler jobs, in milliseconds. If this value is high, then it means one of the tasks are hogging up a lot of resources.The HeartbeatTimeMs property is a a measurement of the total amount of time it takes long it takes for Roblox to update all of its Task Scheduler jobs, in milliseconds. If this value is high, then it means one of the tasks are hogging up a lot of resources.

Tags: ReadOnly, NotReplicated */
	readonly HeartbeatTimeMs: number;
	/** InstanceCount is a read-only measurement of how many `Instance` are currently in memory.

This includes the `DataModel`, its descendants, as well as any object created with `Instance.new` which is still present in memory.InstanceCount is a read-only measurement of how many `Instance` are currently in memory.

This includes the `DataModel`, its descendants, as well as any object created with `Instance.new` which is still present in memory.

Tags: ReadOnly, NotReplicated */
	readonly InstanceCount: number;
	/** A measurement of how many physically simulated components are currently moving in the game world.A measurement of how many physically simulated components are currently moving in the game world.

Tags: ReadOnly, NotReplicated */
	readonly MovingPrimitivesCount: number;
	/** PhysicsReceiveKbps is a measurement of roughly how many kilobytes of physics data are being received by the current instance, per second.
If from the server’s perspective, this represents the total amount of physics data being received from the clients connected to the server.
If from a client’s perspective, this represents the total amount of physics data being received from the server.PhysicsReceiveKbps is a measurement of roughly how many kilobytes of physics data are being received by the current instance, per second.
If from the server’s perspective, this represents the total amount of physics data being received from the clients connected to the server.
If from a client’s perspective, this represents the total amount of physics data being received from the server.

Tags: ReadOnly, NotReplicated */
	readonly PhysicsReceiveKbps: number;
	/** PhysicsSendKbps describes roughly how many kilobytes of physics data are being sent by the current instance, per second.
If from the server’s perspective, this represents the total amount of physics data being sent to the clients connected to the server.
If from a client’s perspective, this represents the total amount of physics data being sent to the server.PhysicsSendKbps describes roughly how many kilobytes of physics data are being sent by the current instance, per second.
If from the server’s perspective, this represents the total amount of physics data being sent to the clients connected to the server.
If from a client’s perspective, this represents the total amount of physics data being sent to the server.

Tags: ReadOnly, NotReplicated */
	readonly PhysicsSendKbps: number;
	/** A measurement of how long it takes for the physics engine to update its current state, in milliseconds.

If this value is high, then it means the game instance is under stress from the physics simulations taking place.A measurement of how long it takes for the physics engine to update its current state, in milliseconds.

If this value is high, then it means the game instance is under stress from the physics simulations taking place.

Tags: ReadOnly, NotReplicated */
	readonly PhysicsStepTimeMs: number;
	/** A measurement of how many physically simulated components currently exist in the game world.A measurement of how many physically simulated components currently exist in the game world.

Tags: ReadOnly, NotReplicated */
	readonly PrimitivesCount: number;
	/** Returns the number of megabytes that are being consumed in the specified _DeveloperMemoryTag_
 category. */
	GetMemoryUsageMbForTag(tag: CastsToEnum<Enum.DeveloperMemoryTag>): number;
	/** Returns the total amount of memory being consumed by the current game session, in megabytes. */
	GetTotalMemoryUsageMb(): number;
}

interface RbxInternalStatsItem extends RbxInternalInstance {}
/** A StatsItem is an internal measurement item that is created by the engine to benchmark many of the backend components of Roblox.
It cannot be created using `Instance.new`, but its value can be read by plugins. They can be found stored inside of the `Stats` service. */
type StatsItem = RunningAverageItemDouble | RunningAverageItemInt | RunningAverageTimeIntervalItem | TotalCountTimeIntervalItem;

/** A special type of `StatsItem` which measures the runtime average of an internal **double** value. */
interface RunningAverageItemDouble extends RbxInternalStatsItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RunningAverageItemDouble";
}

/** A special type of `StatsItem` which measures the runtime average of an internal integer value.
As of right now, this StatsItem goes unused. */
interface RunningAverageItemInt extends RbxInternalStatsItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RunningAverageItemInt";
}

/** A special type of `StatsItem` which measures a runtime average time interval.
As of right now, this StatsItem goes unused. */
interface RunningAverageTimeIntervalItem extends RbxInternalStatsItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RunningAverageTimeIntervalItem";
}

/** A special type of [StatsItem](https://developer.roblox.com/api-reference/class/StatsItem "StatsItem")
 which measures a total-count-over-time interval.
As of right now, this StatsItem goes unused. */
interface TotalCountTimeIntervalItem extends RbxInternalStatsItem {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TotalCountTimeIntervalItem";
}

interface StopWatchReporter extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StopWatchReporter";
}

/** The Studio object is a settings object that is exclusive to Roblox Studio. It can be found in Roblox Studio's settings under the Studio tab. */
interface Studio extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Studio";
	/** If set to true, Roblox Studio will attempt to transfer script changes that were made during a Play Solo session to the opened place. */
	["Always Save Script Changes"]: boolean;
	/** If set to true, the hover selection box that is shown when mousing over selectable objects in the `Workspace` will flash between `Hover Over Color` and `Select Color` based on the `Hover Animate Speed`. */
	["Animate Hover Over"]: boolean;

	["Attach Debugger To"]: Enum.DEPRECATED_DebuggerDataModelPreference;
	/** If set to true, the script editor will automatically indent when a new stack is created in the script. */
	["Auto Indent"]: boolean;

	["Auto-Recovery Enabled"]: boolean;

	["Auto-Recovery Interval (Minutes)"]: number;

	["Auto-Recovery Path"]: QDir;
	/** Specifies the background color of Roblox Studio's script editor. */
	["Background Color"]: Color3;
	/** Sets the scrolling mode of the _Advanced Objects_
 tab in Roblox Studio. */
	["Basic Objects Display Mode"]: Enum.ListDisplayMode;
	/** Sets the color of built-in functions and keywords in the script editor. */
	["Built-in Function Color"]: Color3;
	/** Sets how many studs the camera will move forward or backwards when using the mouse wheel. */
	["Camera Mouse Wheel Speed"]: number;
	/** Sets the speed in studs/sec that the camera moves while holding down Shift with the movement keys. */
	["Camera Shift Speed"]: number;
	/** Sets the speed in studs/sec that the camera moves when movement keys are pressed. */
	["Camera Speed"]: number;

	["Camera Zoom to Mouse Position"]: boolean;
	/** If set to true, the output will be automatically cleared when game sessions are switched. */
	["Clear Output On Start"]: boolean;
	/** Specifies the color of comments in Roblox Studio's script editor. */
	["Comment Color"]: Color3;
	/** Specifies the default prompt directory that will be opened when the user activates the _Execute Script_
 button in Roblox Studio. */
	DefaultScriptFileDir: QDir;
	/** If set to true, deprecated objects will be shown in the Advanced Objects window, as well as the Object Browser. */
	DeprecatedObjectsShown: boolean;
	/** A 4 digit code that can be used by Roblox's mobile pairing app to connect to your instance of Roblox Studio on the local network. */
	["Device Pairing Code"]: number;

	["Disable Accurate Play Solo"]: boolean;
	/** If set to true, the bounding box of a selection will be used for collision detection while dragging, instead of each individual part being checked.
This makes the dragger perform smoother, but with notably less precision. */
	["Drag Multiple Parts As Single Part"]: boolean;
	/** When set to true, the script editor and command bar will show an autocomplete menu while writing. */
	["Enable Autocomplete"]: boolean;

	["Enable CoreScript Debugger"]: boolean;
	/** Specifies the color of the wavy underline shown when malformed code is detected in the script editor. */
	["Error Color"]: Color3;
	/** Sets the highlight color of matches in the script editor's Find Selection operation (Ctrl+F). */
	["Find Selection Background Color"]: Color3;
	/** Specifies the font used in the script editor. */
	Font: QFont;
	/** Specifies how frequently the hover animation flashes when the mouse is hovering over a selectable object in the `Workspace`. */
	["Hover Animate Speed"]: Enum.HoverAnimateSpeed;
	/** Specifies the color that the hover selection box uses. */
	["Hover Over Color"]: Color3;
	/** Sets the text color of built-in Lua keywords. */
	["Keyword Color"]: Color3;

	Language: Enum.LanguagePreference;
	/** Sets the thickness of the `PrimaryPart` selection adornee.
This value is constrained between 0 and 0.05 */
	["Line Thickness"]: number;
	/** Specifies whether or not the [Lua Debugger](https://developer.roblox.com/articles/Lua-debugger "Lua Debugger")
 feature is enabled. */
	LuaDebuggerEnabled: boolean;

	readonly LuaDebuggerEnabledAtStartup: boolean;
	/** Sets the highlight color of double-clicked variables in the script editor. */
	["Matching Word Background Color"]: Color3;
	/** The maximum number of lines that can be displayed in the output. */
	["Maximum Output Lines"]: number;
	/** Specifies the color of numbers in Roblox Studio's script editor. */
	["Number Color"]: Color3;
	/** If set to true, audio being played will only be heard if the game window is being focused on. */
	["Only Play Audio from Window in Focus"]: boolean;
	/** Sets the text color of operator characters in the script editor. */
	["Operator Color"]: Color3;
	/** Specifies the font used by the output. */
	["Output Font"]: QFont;
	/** Sets the layout mode of the output. */
	["Output Layout Mode"]: Enum.OutputLayoutMode;
	/** If set to true, the `OverrideCoreScriptsDir` will be used for CoreScripts in Roblox Studio, instead of the default `rbxasset://scripts`
 directory. */
	OverrideCoreScripts: boolean;
	/** The directory used when overriding core scripts.
This should point to a clone of [Roblox's CoreScript GitHub repository](https://github.com/ROBLOX/Core-Scripts)
. */
	OverrideCoreScriptsDir: QDir;
	/** Sets the highest permission level that APIs have to have in order to be shown in the Object Browser.
See `PermissionLevelShown` for more info. */
	PermissionLevelShown: Enum.PermissionLevelShown;
	/** The directory where local plugins are stored. */
	PluginsDir: QDir;
	/** **(OBSOLETE)** */
	["Preprocessor Color"]: Color3;
	/** The directory where recent saves are stored in. */
	RecentSavesDir: QDir;
	/** Scales how much rendering will be throttled when the game window isn't being focused on.
In practice, this property isn't very well understood, and is probably intended for internal use only. */
	["Render Throttle Percentage"]: number;
	/** When set to true, Roblox Studio shortcuts will take priority over inputs being captured in the game window. */
	["Respect Studio shortcuts when game has focus"]: boolean;

	RuntimeUndoBehavior: Enum.RuntimeUndoBehavior;
	/** The time (in seconds) a script can wait to be resumed before timing out. */
	ScriptTimeoutLength: number;
	/** The color of the selection box used with object selections in the `Workspace` */
	["Select Color"]: Color3;
	/** Sets the color of the `PrimaryPart` selection box. */
	["Select/Hover Color"]: Color3;
	/** Sets the background color of selected text in the script editor. */
	["Selection Background Color"]: Color3;
	/** Sets the text color of selected text in the script editor. */
	["Selection Color"]: Color3;
	/** An unused Roblox Studio setting that does not appear to have any functionality. */
	["Server Audio Behavior"]: Enum.ServerAudioBehavior;
	/** If set to true, the `CoreGui` will be visible in the Explorer while the game is running. */
	["Show Core GUI in Explorer while Playing"]: boolean;
	/** If set to true, basic diagnostic information is shown in the bottom right. */
	["Show Diagnostics Bar"]: boolean;

	["Show Hidden Objects in Explorer"]: boolean;
	/** If set to true, hovering over an object in the `Workspace` will show a selection box. */
	["Show Hover Over"]: boolean;
	/** When set to true, the navigation mesh used by the `PathfindingService` will be visualized. */
	["Show Navigation Mesh"]: boolean;
	/** When set to true, the `PluginGuiService` will be shown in Roblox Studio's explorer. */
	["Show Plugin GUI Service in Explorer"]: boolean;
	/** If set to true, certain internal error messages regarding the QT framework that Roblox uses will be shown in the output. */
	["Show QT warnings in output"]: boolean;

	["Show plus button on hover in Explorer"]: boolean;
	/** Specifies the color of strings in the script editor. */
	["String Color"]: Color3;
	/** Specifies how many spaces are used to represent a tab in the script editor. */
	["Tab Width"]: number;
	/** Specifies the color of normal text in the script editor. */
	["Text Color"]: Color3;
	/** If set to true, text in the script editor will be wrapped. */
	["Text Wrapping"]: boolean;
	/** The Theme property is used to get/set the current `StudioTheme` used by `Studio`.

This is intended for use within `Plugins`, but will also execute in the Command Line. You can access the function via:
```lua
settings().Studio.Theme
```

For instance, if you would like to print the current Studio theme:
```lua
print("The current Studio theme is:", settings().Studio.Theme)
``` */
	Theme?: StudioTheme;
	/** Specifies the color scheme of Roblox Studio. */
	readonly ["UI Theme"]: Enum.UITheme;
	/** Specifies the color of the wavy underline shown when the script analyzer picks up a problem that should be addressed in the script editor. */
	["Warning Color"]: Color3;
}

interface StudioService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StudioService";
	/** [LACKS DOCUMENTATION]

Tags: ReadOnly, NotReplicated */
	readonly ActiveScript?: Instance;
}

interface StudioTheme extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StudioTheme";
}

/** TaskScheduler is a read-only settings class responsible for the Task Scheduler  feature.
Can be found in Roblox Studio's settings with the name *Task Scheduler*. */
interface TaskScheduler extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TaskScheduler";
	/** The average time divided by the average interval of the duty cycle.The average time divided by the average interval of the duty cycle.

Tags: ReadOnly, NotReplicated */
	readonly SchedulerDutyCycle: number;
	/** The current average rate of the task scheduler.The current average rate of the task scheduler.

Tags: ReadOnly, NotReplicated */
	readonly SchedulerRate: number;
	/** The specified thread pooling configuration for the task scheduler. */
	ThreadPoolConfig: Enum.ThreadPoolConfig;
	/** The current size of the thread pool.The current size of the thread pool.

Tags: ReadOnly, NotReplicated */
	readonly ThreadPoolSize: number;
}

/** The `Team` class represents a faction in a Roblox place. The only valid parent for a Team is in the `Teams` service. Teams offer a range of features that are useful to developers that can be divided into two rough groups:

* Features that work 'out of the box'
* Features developers can program into their game.

**Built-in Team Behavior **

The following functionality of Teams exists by default and does not require the developer to program any custom behavior.

 - When part of a Team, the name above a `Player`'s character `Model` will be colored to the `TeamColor`
 - Changing `TeamColor` will cause `Team` to switch to the Team with the corresponding `TeamColor`
 - When using the default player list users will be grouped and displayed together as a team
 - Setting `Neutral` to true will cause the `Player` to be disassociated with the team, however, it will not change `Team` or `TeamColor`
 - When a `Player` joins a game, they will be allocated to the team with `AutoAssignable` set to true that has the fewest players. If no auto assignable team is available, `Neutral` will be set to true
 - When `Neutral` is set to false, only players whose `TeamColor` matches `TeamColor` can spawn on that `SpawnLocation`
 - When `AllowTeamChangeOnTouch` is set to true, a `Player`'s `TeamColor` will change to `TeamColor` when their character touches the `SpawnLocation`

**Optional Extended Team Behaviors**

Many developers chose to add the following features to teams in their own code.

 - Implement checks in weapon code to prevent friendly fire. 
 - Implement checks in doors or other features that allow only certain teams to use them
 - Periodically reassign teams to maintain team balance

## Code Samples

### Simple Team Rebalance

This code sample includes a simple example of how to re-balance teams. When Team.AutoAssignable is set to true players will be added to Teams in a balanced fashion. However as Players leave the game this can lead to unbalanced teams as players are not reallocated. This code keeps track of the number of players in each team and, when players leave will check to see if the teams need re-balancing.
```lua
local Teams = game:GetService("Teams")

-- create two teams
local redTeam = Instance.new("Team", Teams)
redTeam.TeamColor = BrickColor.new("Bright red")
redTeam.AutoAssignable = true
redTeam.Name = "Red Team"

local blueTeam = Instance.new("Team", Teams)
blueTeam.TeamColor = BrickColor.new("Bright blue")
blueTeam.AutoAssignable = true
blueTeam.Name = "Blue Team"

-- start counting the number of players on each team
local numberRed, numberBlue = 0, 0

local function playerAdded(team)
	-- increase the team's count by 1
	if team == redTeam then
		numberRed = numberRed + 1 
	elseif team == blueTeam then
		numberBlue = numberBlue + 1
	end	
end

local function playerRemoved(team)
	-- decrease the team's count by 1
	if team == redTeam then
		numberRed = numberRed - 1 
	elseif team == blueTeam then
		numberBlue = numberBlue - 1
	end	

	-- check if the teams are unbalanced
	local bigTeam, smallTeam = nil, nil
	if (numberRed - numberBlue) > 2 then
		bigTeam = redTeam
		smallTeam = blueTeam
	elseif (numberBlue - numberRed) > 2 then 
		bigTeam = blueTeam
		smallTeam = redTeam
	end

	if bigTeam then	
		-- pick a random player
		local playerList = bigTeam:GetPlayers()
		local player = playerList[math.random(1, #playerList)]

		-- check the player exists
		if player then
			-- change the player's team
			player.TeamColor = smallTeam.TeamColor 
			-- respawn the player
			player:LoadCharacter()
		end
	end
end

-- listen for players being added / removed
blueTeam.PlayerAdded:Connect(function(player)
	playerAdded(blueTeam)
end)

blueTeam.PlayerRemoved:Connect(function(player)
	playerRemoved(blueTeam)
end)

redTeam.PlayerAdded:Connect(function(player)
	playerAdded(redTeam)
end)

redTeam.PlayerRemoved:Connect(function(player)
	playerRemoved(redTeam)
end)

```

### Team Only Door

The following code sample will create a door in the Workspace that can only be walked through by Players on the Bright red team.
```lua
local Players = game:GetService("Players")

local door = Instance.new("Part")
door.Anchored = true 
door.Size = Vector3.new(7, 10, 1)
door.Position = Vector3.new(0, 5, 0)
door.Parent = game.Workspace

local debounce = false 

door.Touched:Connect(function(hit)
	if not debounce then
		debounce = true
		if hit then
			local player = Players:GetPlayerFromCharacter(hit.Parent)
			if player and player.TeamColor == BrickColor.new("Bright red") then
				door.Transparency = 0.5
				door.CanCollide = false 
				wait(3)
				door.Transparency = 0
				door.CanCollide = true
			end
		end
		wait(0.5)
		debounce = false
	end
end)
```

### Team Kill Check

This code sample includes a quick function that can be added to weapons in a place to prevent them from team killing. It will return false when the two players are on different teams or if either of them is neutral.
```lua
function checkTeamKill(playerAttack, playerVictim)
	if playerAttack.Team ~= playerVictim.Team or playerAttack.Neutral or playerVictim.Neutral then
		return false 
	end
	return true
end

```
 */
interface Team extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Team";
	/** This property determines whether `Player`s will be automatically placed onto the `Team` when joining. If multiple teams have this property set to true, Roblox will attempt to even the teams out when `Player`s are added. 

When a `Player` joins a game they will be assigned to the `Team` with `AutoAssignable` set to true that has the fewest players. If no such team is available, `Neutral` will be set to true.

Note whilst using this property will help even out teams when players are added, it will not do anything when players are removed. For this reason developers may wish to implement their own team balancing system.

## Code Samples

### Simple Team Rebalance

This code sample includes a simple example of how to re-balance teams. When Team.AutoAssignable is set to true players will be added to Teams in a balanced fashion. However as Players leave the game this can lead to unbalanced teams as players are not reallocated. This code keeps track of the number of players in each team and, when players leave will check to see if the teams need re-balancing.
```lua
local Teams = game:GetService("Teams")

-- create two teams
local redTeam = Instance.new("Team", Teams)
redTeam.TeamColor = BrickColor.new("Bright red")
redTeam.AutoAssignable = true
redTeam.Name = "Red Team"

local blueTeam = Instance.new("Team", Teams)
blueTeam.TeamColor = BrickColor.new("Bright blue")
blueTeam.AutoAssignable = true
blueTeam.Name = "Blue Team"

-- start counting the number of players on each team
local numberRed, numberBlue = 0, 0

local function playerAdded(team)
	-- increase the team's count by 1
	if team == redTeam then
		numberRed = numberRed + 1 
	elseif team == blueTeam then
		numberBlue = numberBlue + 1
	end	
end

local function playerRemoved(team)
	-- decrease the team's count by 1
	if team == redTeam then
		numberRed = numberRed - 1 
	elseif team == blueTeam then
		numberBlue = numberBlue - 1
	end	

	-- check if the teams are unbalanced
	local bigTeam, smallTeam = nil, nil
	if (numberRed - numberBlue) > 2 then
		bigTeam = redTeam
		smallTeam = blueTeam
	elseif (numberBlue - numberRed) > 2 then 
		bigTeam = blueTeam
		smallTeam = redTeam
	end

	if bigTeam then	
		-- pick a random player
		local playerList = bigTeam:GetPlayers()
		local player = playerList[math.random(1, #playerList)]

		-- check the player exists
		if player then
			-- change the player's team
			player.TeamColor = smallTeam.TeamColor 
			-- respawn the player
			player:LoadCharacter()
		end
	end
end

-- listen for players being added / removed
blueTeam.PlayerAdded:Connect(function(player)
	playerAdded(blueTeam)
end)

blueTeam.PlayerRemoved:Connect(function(player)
	playerRemoved(blueTeam)
end)

redTeam.PlayerAdded:Connect(function(player)
	playerAdded(redTeam)
end)

redTeam.PlayerRemoved:Connect(function(player)
	playerRemoved(redTeam)
end)

```
 */
	AutoAssignable: boolean;
	/** This property sets the color of the `Team`. Determines the `TeamColor` property of players who are a member of the team.

A lot of Roblox's default team functionality is based on the team color, rather than the name or object. For example, `SpawnLocation`s can be assigned to a team via `TeamColor`. For this reason it is recommended that developers ensure each `Team` has a unique TeamColor.

Any player which is a part of a team will have their name color changed to the team's TeamColor property. They will also be put underneath the team heading on the player list.

## Code Samples

### Team Only Door

The following code sample will create a door in the Workspace that can only be walked through by Players on the Bright red team.
```lua
local Players = game:GetService("Players")

local door = Instance.new("Part")
door.Anchored = true 
door.Size = Vector3.new(7, 10, 1)
door.Position = Vector3.new(0, 5, 0)
door.Parent = game.Workspace

local debounce = false 

door.Touched:Connect(function(hit)
	if not debounce then
		debounce = true
		if hit then
			local player = Players:GetPlayerFromCharacter(hit.Parent)
			if player and player.TeamColor == BrickColor.new("Bright red") then
				door.Transparency = 0.5
				door.CanCollide = false 
				wait(3)
				door.Transparency = 0
				door.CanCollide = true
			end
		end
		wait(0.5)
		debounce = false
	end
end)
```
 */
	TeamColor: BrickColor;
	/** Returns a list of `Player`s who are assigned to the `Team`. A `Player` is considered assigned if their `Team` property is equal to the `Team` and `Neutral` is false.

This function has a number of potential uses, including counting the number of players on a `Team` or giving every `Player` on a `Team` a `Tool`.

## Code Samples

### Teams GetTeams

The example below prints the number of players on each Team.
```lua
-- count how many players are on each team
local teams = game:GetService("Teams"):GetTeams()
for _, team in pairs(teams) do
    local players = team:GetPlayers()
    print("Team " .. team.Name .. " has " .. #players .. " players")
end
```

@returns An array of `Player`s in the `Team`. */
	GetPlayers(): Array<Player>;
	/** Fires whenever a `Player` is assigned to the `Team`. A player is considered assigned if their `Team` property is equal to the `Team` and `Neutral` is false.

This event is team specific and will only fire when a `Player` joints the specific `Team`. Any function connected to this event will be passed the `Player` object of the player who joined the team. For example:

    Team.PlayerAdded:Connect(function(player)
    	print(player.Name.." has joined the team")
    end)

## Code Samples

### Simple Team Rebalance

This code sample includes a simple example of how to re-balance teams. When Team.AutoAssignable is set to true players will be added to Teams in a balanced fashion. However as Players leave the game this can lead to unbalanced teams as players are not reallocated. This code keeps track of the number of players in each team and, when players leave will check to see if the teams need re-balancing.
```lua
local Teams = game:GetService("Teams")

-- create two teams
local redTeam = Instance.new("Team", Teams)
redTeam.TeamColor = BrickColor.new("Bright red")
redTeam.AutoAssignable = true
redTeam.Name = "Red Team"

local blueTeam = Instance.new("Team", Teams)
blueTeam.TeamColor = BrickColor.new("Bright blue")
blueTeam.AutoAssignable = true
blueTeam.Name = "Blue Team"

-- start counting the number of players on each team
local numberRed, numberBlue = 0, 0

local function playerAdded(team)
	-- increase the team's count by 1
	if team == redTeam then
		numberRed = numberRed + 1 
	elseif team == blueTeam then
		numberBlue = numberBlue + 1
	end	
end

local function playerRemoved(team)
	-- decrease the team's count by 1
	if team == redTeam then
		numberRed = numberRed - 1 
	elseif team == blueTeam then
		numberBlue = numberBlue - 1
	end	

	-- check if the teams are unbalanced
	local bigTeam, smallTeam = nil, nil
	if (numberRed - numberBlue) > 2 then
		bigTeam = redTeam
		smallTeam = blueTeam
	elseif (numberBlue - numberRed) > 2 then 
		bigTeam = blueTeam
		smallTeam = redTeam
	end

	if bigTeam then	
		-- pick a random player
		local playerList = bigTeam:GetPlayers()
		local player = playerList[math.random(1, #playerList)]

		-- check the player exists
		if player then
			-- change the player's team
			player.TeamColor = smallTeam.TeamColor 
			-- respawn the player
			player:LoadCharacter()
		end
	end
end

-- listen for players being added / removed
blueTeam.PlayerAdded:Connect(function(player)
	playerAdded(blueTeam)
end)

blueTeam.PlayerRemoved:Connect(function(player)
	playerRemoved(blueTeam)
end)

redTeam.PlayerAdded:Connect(function(player)
	playerAdded(redTeam)
end)

redTeam.PlayerRemoved:Connect(function(player)
	playerRemoved(redTeam)
end)

```
 */
	readonly PlayerAdded: RBXScriptSignal<(player: Player) => void>;
	/** Fires whenever a `Player` is removed from a `Team`. This can be due to the `Player` leaving the game, `Neutral` being set to true or the `Player` joining a different team.

This event is team specific and will only fire when a `Player` leaves the specific `Team`. Any function connected to this event will be passed the `Player` object of the player who left the team. For example:

    Team.PlayerRemoved:Connect(function(player)
    	print(player.Name.." has left the team")
    end)

## Code Samples

### Simple Team Rebalance

This code sample includes a simple example of how to re-balance teams. When Team.AutoAssignable is set to true players will be added to Teams in a balanced fashion. However as Players leave the game this can lead to unbalanced teams as players are not reallocated. This code keeps track of the number of players in each team and, when players leave will check to see if the teams need re-balancing.
```lua
local Teams = game:GetService("Teams")

-- create two teams
local redTeam = Instance.new("Team", Teams)
redTeam.TeamColor = BrickColor.new("Bright red")
redTeam.AutoAssignable = true
redTeam.Name = "Red Team"

local blueTeam = Instance.new("Team", Teams)
blueTeam.TeamColor = BrickColor.new("Bright blue")
blueTeam.AutoAssignable = true
blueTeam.Name = "Blue Team"

-- start counting the number of players on each team
local numberRed, numberBlue = 0, 0

local function playerAdded(team)
	-- increase the team's count by 1
	if team == redTeam then
		numberRed = numberRed + 1 
	elseif team == blueTeam then
		numberBlue = numberBlue + 1
	end	
end

local function playerRemoved(team)
	-- decrease the team's count by 1
	if team == redTeam then
		numberRed = numberRed - 1 
	elseif team == blueTeam then
		numberBlue = numberBlue - 1
	end	

	-- check if the teams are unbalanced
	local bigTeam, smallTeam = nil, nil
	if (numberRed - numberBlue) > 2 then
		bigTeam = redTeam
		smallTeam = blueTeam
	elseif (numberBlue - numberRed) > 2 then 
		bigTeam = blueTeam
		smallTeam = redTeam
	end

	if bigTeam then	
		-- pick a random player
		local playerList = bigTeam:GetPlayers()
		local player = playerList[math.random(1, #playerList)]

		-- check the player exists
		if player then
			-- change the player's team
			player.TeamColor = smallTeam.TeamColor 
			-- respawn the player
			player:LoadCharacter()
		end
	end
end

-- listen for players being added / removed
blueTeam.PlayerAdded:Connect(function(player)
	playerAdded(blueTeam)
end)

blueTeam.PlayerRemoved:Connect(function(player)
	playerRemoved(blueTeam)
end)

redTeam.PlayerAdded:Connect(function(player)
	playerAdded(redTeam)
end)

redTeam.PlayerRemoved:Connect(function(player)
	playerRemoved(redTeam)
end)

```
 */
	readonly PlayerRemoved: RBXScriptSignal<(player: Player) => void>;
}

/** The Teams service holds a game's `Team` objects. `Team` objects must be parented to the Teams service.

Teams offer a range of features that are useful to developers. These can broadly be divided into features that work out-of-the-box and features developers can program into their game.

**Built-in team behaviour**
The following functionality of Teams exists by default and does not require the developer to program any custom behaviour.

 - When part of a Team, the name above a `Player`'s character `Model` will be colored to the `TeamColor`
 - Changing `TeamColor` will cause `Team` switch to the Team with the corresponding `TeamColor`
 - When using the default player list users will be grouped and displayed by team
 - Setting `Neutral` to true will cause the `Player` to be dis-associated with the team, but will not change `Team` or `TeamColor`
 - When a `Player` joins a game, they will be allocated to the team with `AutoAssignable` set to true that has the fewest players. If no auto assignable team is available, `Neutral` will be set to true
 - When `Neutral` is set to false, only players whose `TeamColor` matches `TeamColor` can spawn on that `SpawnLocation`
 - When `AllowTeamChangeOnTouch` is set to true, a `Player`'s `TeamColor` will change to `TeamColor` when their character touches the `SpawnLocation`

**Optional extended team behavior**
Many developers chose to add the following features to teams in their own code.

 - Implement checks for team in weapon code to prevent team killing 
 - Implement doors or other features that only certain teams can use
 - Periodically reassign teams to maintain team balance

## Code Samples

### Simple Team Rebalance

This code sample includes a simple example of how to re-balance teams. When Team.AutoAssignable is set to true players will be added to Teams in a balanced fashion. However as Players leave the game this can lead to unbalanced teams as players are not reallocated. This code keeps track of the number of players in each team and, when players leave will check to see if the teams need re-balancing.
```lua
local Teams = game:GetService("Teams")

-- create two teams
local redTeam = Instance.new("Team", Teams)
redTeam.TeamColor = BrickColor.new("Bright red")
redTeam.AutoAssignable = true
redTeam.Name = "Red Team"

local blueTeam = Instance.new("Team", Teams)
blueTeam.TeamColor = BrickColor.new("Bright blue")
blueTeam.AutoAssignable = true
blueTeam.Name = "Blue Team"

-- start counting the number of players on each team
local numberRed, numberBlue = 0, 0

local function playerAdded(team)
	-- increase the team's count by 1
	if team == redTeam then
		numberRed = numberRed + 1 
	elseif team == blueTeam then
		numberBlue = numberBlue + 1
	end	
end

local function playerRemoved(team)
	-- decrease the team's count by 1
	if team == redTeam then
		numberRed = numberRed - 1 
	elseif team == blueTeam then
		numberBlue = numberBlue - 1
	end	

	-- check if the teams are unbalanced
	local bigTeam, smallTeam = nil, nil
	if (numberRed - numberBlue) > 2 then
		bigTeam = redTeam
		smallTeam = blueTeam
	elseif (numberBlue - numberRed) > 2 then 
		bigTeam = blueTeam
		smallTeam = redTeam
	end

	if bigTeam then	
		-- pick a random player
		local playerList = bigTeam:GetPlayers()
		local player = playerList[math.random(1, #playerList)]

		-- check the player exists
		if player then
			-- change the player's team
			player.TeamColor = smallTeam.TeamColor 
			-- respawn the player
			player:LoadCharacter()
		end
	end
end

-- listen for players being added / removed
blueTeam.PlayerAdded:Connect(function(player)
	playerAdded(blueTeam)
end)

blueTeam.PlayerRemoved:Connect(function(player)
	playerRemoved(blueTeam)
end)

redTeam.PlayerAdded:Connect(function(player)
	playerAdded(redTeam)
end)

redTeam.PlayerRemoved:Connect(function(player)
	playerRemoved(redTeam)
end)

```

### Team Only Door

The following code sample will create a door in the Workspace that can only be walked through by Players on the Bright red team.
```lua
local Players = game:GetService("Players")

local door = Instance.new("Part")
door.Anchored = true 
door.Size = Vector3.new(7, 10, 1)
door.Position = Vector3.new(0, 5, 0)
door.Parent = game.Workspace

local debounce = false 

door.Touched:Connect(function(hit)
	if not debounce then
		debounce = true
		if hit then
			local player = Players:GetPlayerFromCharacter(hit.Parent)
			if player and player.TeamColor == BrickColor.new("Bright red") then
				door.Transparency = 0.5
				door.CanCollide = false 
				wait(3)
				door.Transparency = 0
				door.CanCollide = true
			end
		end
		wait(0.5)
		debounce = false
	end
end)
```

### Team Kill Check

This code sample includes a quick function that can be added to weapons in a place to prevent them from team killing. It will return false when the two players are on different teams or if either of them is neutral.
```lua
function checkTeamKill(playerAttack, playerVictim)
	if playerAttack.Team ~= playerVictim.Team or playerAttack.Neutral or playerVictim.Neutral then
		return false 
	end
	return true
end

```
 */
interface Teams extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Teams";
	/** The GetTeam function returns a table containing the game's `Team` objects. 

Note this will only return Team objects that are directly parented to the `Teams` service. For this reason it is recommended developers only parent `Team` objects to the `Teams` service and not to other `Instance`s (or to each other).

## Code Samples

### Teams GetTeams

The example below prints the number of players on each Team.
```lua
-- count how many players are on each team
local teams = game:GetService("Teams"):GetTeams()
for _, team in pairs(teams) do
    local players = team:GetPlayers()
    print("Team " .. team.Name .. " has " .. #players .. " players")
end
```

@returns An array of `Team`s in the game. */
	GetTeams(): Array<Team>;
}

/** The TeleportService is responsible for transporting `Players` between `places` and servers.

‘Teleporting’ in Roblox, describes the transportation of `Players` between different places and servers. TeleportService provides a range of functions allowing single or groups of users to be teleported. As Roblox `Multi Place games` can contain multiple places, you can use the TeleportService to teleport players between different levels.

## Which teleport function should I use?
A variety of teleportation functions are available and are all suitable for different circumstances:

 - `Teleport` for teleporting a single `Player` to a place 
 - `TeleportToSpawnByName` for teleporting a single `Player` to a place, spawning at a particular `SpawnLocation`
 - `TeleportToPlaceInstance` for teleporting a single `Player` to a specific server instance in a place that is part of the same game
 - `TeleportPartyAsync` for teleporting a group of `Players` to one server in a place that is part of the same game
 - `TeleportToPrivateServer` for teleporting a group of `Players` to a reserved server created using `ReserveServer`

## Code Samples

### TeleportService:Teleport

The code below will teleport a player to Crossroads, assuming it's in a LocalScript.
```lua

game:GetService('TeleportService'):Teleport(1818)

```
 */
interface TeleportService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TeleportService";
	/** This function returns the *customLoadingScreen* the `LocalPlayer` arrived into the place with.

Note, the *customLoadingScreen* will not be used if the destination place is in a different game.

## Loading screen

During a teleport, whilst the destination place is loading, the *customLoadingScreen* is parented to the `CoreGui`. Once the place has loaded the `loading screen` is `parented` to *nil*. 

If you wish to preserve the *customLoadingScreen* and perform your own transitions, you will need to parent it to the `LocalPlayer’s` `PlayerGui`. For an example of this, see the code sample below.

## Code Samples

### Handling a Teleport Loading GUI

The following code, when placed inside a `LocalScript` in `ReplicatedFirst` will preserve a custom teleport loading screen for five seconds before destroying it.
```lua
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local ReplicatedFirst = game:GetService("ReplicatedFirst")

local customLoadingScreen = TeleportService:GetArrivingTeleportGui()
if customLoadingScreen then
    local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    ReplicatedFirst:RemoveDefaultLoadingScreen()
    customLoadingScreen.Parent = playerGui
    -- animate screen here
    wait(5)
    -- destroy screen
    customLoadingScreen:Destroy()
end

```

@returns The *customLoadingScreen* the `Players/LocalPlayer|LocalPlayer` arrived into the place with */
	/** @rbxts client */
	GetArrivingTeleportGui(): ScreenGui | GuiMain | undefined;
	/** This function returns the *teleportData* the `LocalPlayer` arrived into the place with. It can only be used on the client and can be called at any time.

For example, the following snippet would send the `PlaceId` and `JobId` in a dictionary:

```lua
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local teleportData = {
	placeId = game.PlaceId,
	jobId = game.JobId
}
TeleportService:Teleport(placeId, player, teleportData)
```


This data could then be retrieved upon arrival using the GetLocalPlayerTeleportData function as follows:

```lua
local TeleportService = game:GetService("TeleportService")

local teleportData = TeleportService:GetLocalPlayerTeleportData()
if teleportData then
	local placeId = teleportData.placeId
	local jobId = teleportData.JobId
end)
```


If no *teleportData* was set in the teleportation function this function will return *nil*.

Note this function will not return teleportation settings set using `SetTeleportSetting`, to retrieve these settings use `GetTeleportSetting`.
@returns The *teleportData* the `Players/LocalPlayer` arrived into the place with */
	/** @rbxts client */
	GetLocalPlayerTeleportData(): unknown;
	/** This function retrieves a teleport setting saved using `SetTeleportSetting` using the given key.

This method is intended for use on the client only and should not be used on the server.

Teleport settings are preserved across teleportations within the same game. This means data can be saved using `SetTeleportSetting` in one place and retrieved using GetTeleportSetting in another place the user has been teleported to.

For example, in a game that allowed crouching you could save whether the user is currently crouching prior to teleporting as a teleport setting. This could then be retrieved in the destination place after the teleportation:

```lua
local TeleportService = game:GetService("TeleportService")

local isCrouching =  TeleportService:GetTeleportSetting("isCrouching")
```


If no teleport setting exists under the given key, this function will return *nil*.

## Differences from GlobalDataStores

Although they share some similarities, there are some key differences between teleport settings and datastores:

 - `SetAsync` stores the data on Roblox servers whereas SetTeleportSetting stores the data locally
 - Data stored in a `GlobalDataStore` is preserved after the user leaves the game universe whereas teleport settings are not
 - `GlobalDataStores` can only be accessed on the server, whereas teleport settings can only be accessed on the client 
 - `GlobalDataStores` have usage limits, whereas teleport settings do not

In general teleport settings should be used to preserve client side information within a single play session across different places in a game. `GlobalDataStores` should be used to save important player data that needs to be accessed across player sessions.

## Teleport settings and security
As teleport settings are stored locally, it is possible they can be manipulated by malicious users. This risk can be mitigated by employing server side validation, for more information on this please see the article on `Game Security`.
@param setting The key the value was stored under using `TeleportService/SetTeleportSetting`
@returns The value stored under the given key */
	/** @rbxts client */
	GetTeleportSetting(setting: string): unknown;
	/** This function sets the custom `teleport GUI` that will be shown to the local user during teleportation, prior to the teleport being invoked. 

Note, the `teleport GUI` will not be used if the destination place is in a different game. It will also not persist across multiple teleports and will need to be set prior to each one.

This function should only be used on the client. If the teleportation function is called from the server (as is the case with `TeleportPartyAsync`) then this function should be called on the client prior to this. One way of doing this is listening to a `RemoteEvent` that fires several seconds before teleportation.

```lua
-- Client

local TeleportService = game:GetService("TeleportService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer
local teleportGui = Instance.new("ScreenGui") -- for demonstration purposes

-- this RemoteEvent needs to be created on the server and fired before teleporting
local teleportEvent = ReplicatedStorage:WaitForChild("TeleportPrepare")

-- set the teleport gui so we are ready
TeleportService:SetTeleportGui(teleportGui)

teleportEvent.OnClientEvent:Connect(function()
	-- show the gui prior to the teleport
	local playerGui = localPlayer:WaitForChild("PlayerGui")
	teleportGui.Parent = playerGui
end)
```


## Loading screen

During a teleport, whilst the destination place is loading, the *customLoadingScreen* is parented to the `CoreGui`. Once the place has loaded the `loading screen` is `parented` to *nil*. 


This `ScreenGui` can be fetched at the destination place using `GetArrivingTeleportGui`, allowing you to parent it to the `PlayerGui` and perform your own transitions. 

You are advised to also `parent` the `ScreenGui` to the `PlayerGui` in the start place whilst the teleport is initiating.

## Code Samples

### Teleporting the local player

This snippet demonstrates how `TeleportService` can be used to teleport the `LocalPlayer` from the client. 

It also shows how `SetTeleportGui` can be used to define a custom loading GUI. Note, this `ScreenGui` will need to be retrieved at the destination place using `GetArrivingTeleportGui` and be parented to the `PlayerGui`.
```lua
local TeleportService = game:GetService("TeleportService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")

local placeId = 0 -- replace here
local loadingGui = ReplicatedStorage:FindFirstChild("LoadingGui") -- replace here

-- parent the loading gui for this place
loadingGui.Parent = playerGui

-- set the loading gui for the destination place
TeleportService:SetTeleportGui(loadingGui)

-- teleport the user
TeleportService:Teleport(placeId)

```

@param gui The loading `ScreenGui` that is to be displayed during teleportation

@returns This function does not return anything! */
	/** @rbxts client */
	SetTeleportGui(gui: ScreenGui): void;
	/** This function stores a value under a given key that persists across all teleportations in the same game.

This method is intended for use on the client only and should not be used on the server.

The stored value can later be retrieved using `GetTeleportSetting`. This will work in the current place and any subsequent places the `LocalPlayer` teleports to, provided they are in the same game.

For example, in a game that allowed crouching you could save whether the user is currently crouching prior to teleporting as a teleport setting:

```lua
local TeleportService = game:GetService("TeleportService")

local isCrouching = false
TeleportService:SetTeleportSetting("isCrouching", isCrouching)
```


The stored value can take one of the following forms: 
 - A table without mixed keys (all strings or all integers) 
 - A string
 - A number
 - A bool

If data is already stored under the given key, the previous value will be overwritten by the new value.

## Differences from GlobalDataStores

Although they share some similarities, there are some key differences between teleport settings and datastores:

 - `SetAsync` stores the data on Roblox servers whereas SetTeleportSetting stores the data locally
 - Data stored in a `GlobalDataStore` is preserved after the user leaves the game universe whereas teleport settings are not
 - `GlobalDataStores` can only be accessed on the server, whereas teleport settings can only be accessed on the client 
 - `GlobalDataStores` have usage limits, whereas teleport settings do not

In general teleport settings should be used to preserve client side information within a single play session across different places in a game. `GlobalDataStores` should be used to save important player data that needs to be accessed across player sessions.

## Teleport settings and security
As teleport settings are stored locally, it is possible they can be manipulated by malicious users. This risk can be mitigated by employing server side validation, for more information on this please see the article on `Game Security`.
@param setting The key to store the *value* under. This key can be used to retrieve the value using `TeleportService/GetTeleportSetting`

@param value The value to store */
	/** @rbxts client */
	SetTeleportSetting(setting: string, value: RbxInternalTeleportData): void;
	/** This function teleports a `Player` to the place associated with the given *placeId*.

Teleport can be called both from the client and the server (see examples below).

When teleporting from the client, as only the `LocalPlayer` can be teleported, no *player* argument is required. 

You may only teleport players to places within the same game or active start places for other games. 

## Teleport data

A *teleportData* parameter can be specified. This is data the client will transmit to the destination place and can be retrieved using `GetLocalPlayerTeleportData`.

The *teleportData* can take any of the following forms:
 - A table without mixed keys (all keys are strings or integers)
 - A string
 - A number
 - A bool

As the *teleportData* is transmitted by the client it is not secure. For this reason it should only be used for local settings and not sensitive items (such as the users’ score or in-game currency).

If you need teleport data to persist across multiple teleports, you can use `SetTeleportSetting` and `GetTeleportSetting`.

## Loading screen

A *customLoadingScreen* argument can be specified. This is a `ScreenGui` that is copied (without scripts) into the `CoreGui` of the destination place. 

Note, `SetTeleportGui` is the preferred alternative to the *customLoadingScreen* argument as it can be called prior to the teleport.

The loading `ScreenGui` can be obtained in the destination place using `GetArrivingTeleportGui`, where developers can parent it to the `PlayerGui`. It will not be used if the destination place is in a different game.

## Teleport failure
In some circumstances a teleport may fail. This can be due to the developer configuring the teleport incorrectly or issues with Roblox’s servers.

 - If a teleportation request is rejected the `TeleportInitFailed` event will fire the error message and a `TeleportResult` enumerator describing the issue
 - Teleports can fail ‘in transit’, after the user has left the server, due to issues with Roblox’s servers. In this case the user will be shown an error message and be required to rejoin the game

## Alternative teleport functions
Before using Teleport, you should check to see if an alternative teleport function is more suitable:

 - `TeleportToSpawnByName` is used to teleport a player to a place and spawn them at a specific `SpawnLocation`
 - `TeleportPartyAsync` is used to teleport a group of players together to the same server
 - `TeleportToPlaceInstance` is used to teleport a player to a specific server in a place
 - `TeleportToPrivateServer` is used to teleport a player to a reserved server created using `ReserveServer`

For more information on how to teleport players, see the `Teleporting Between Places` tutorial.

## Code Samples

### Teleporting from the server

This snippet demonstrates how `TeleportService` can be used to teleport a `Player` from the server.
```lua
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")

local placeId = 0 -- replace here
local userId = 1 -- replace with player's userId

-- find the player
local player = Players:GetPlayerByUserId(userId)

-- teleport the player
TeleportService:Teleport(placeId, player)
```

### Teleporting the local player

This snippet demonstrates how `TeleportService` can be used to teleport the `LocalPlayer` from the client. 

It also shows how `SetTeleportGui` can be used to define a custom loading GUI. Note, this `ScreenGui` will need to be retrieved at the destination place using `GetArrivingTeleportGui` and be parented to the `PlayerGui`.
```lua
local TeleportService = game:GetService("TeleportService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")

local placeId = 0 -- replace here
local loadingGui = ReplicatedStorage:FindFirstChild("LoadingGui") -- replace here

-- parent the loading gui for this place
loadingGui.Parent = playerGui

-- set the loading gui for the destination place
TeleportService:SetTeleportGui(loadingGui)

-- teleport the user
TeleportService:Teleport(placeId)

```

@param placeId The ID of the place to teleport to
@param player The `Player` to teleport, if this function is being called from the client this defaults to the `Players/LocalPlayer`
@param teleportData Optional data to be passed to the destination place. Can be retrieved using `TeleportService/GetLocalPlayerTeleportData`
@param customLoadingScreen Optional custom loading screen to be placed in the `CoreGui` at the destination place. Can be retrieved using `TeleportService/GetArrivingTeleportGui` */
	Teleport(
		placeId: number,
		player?: Player,
		teleportData?: RbxInternalTeleportData,
		customLoadingScreen?: ScreenGui | GuiMain,
	): void;
	/** This function teleports a `Player` to the place instance associated with the given *placeId* and *instanceId*. It can only be used to teleport to places in the same game.

The *placeId* is the `PlaceId` of the server and the *instanceId* is the `JobId`.

This function can not be used to teleport `Players` to servers created using `ReserveServer` (reserved servers). For this, see `TeleportToPrivateServer`. 

## Spawn name

An optional *spawnName* parameter can be provided, which will cause the `Player` to initially spawn at the `SpawnLocation` of that name in the destination place. The `SpawnLocation` must be valid for the `Player` to spawn on. For example, it must be `neutral` or set to the same `TeamColor` as the `Team` the `Player` will be assigned to upon joining the game.

## Teleport data

A *teleportData* parameter can be specified. This is data the client will transmit to the destination place and can be retrieved using `GetLocalPlayerTeleportData`.

The *teleportData* can take any of the following forms:
 - A table without mixed keys (all keys are strings or integers)
 - A string
 - A number
 - A bool

As the *teleportData* is transmitted by the client it is not secure. For this reason it should only be used for local settings and not sensitive items (such as the users’ score or in-game currency).

If you need teleport data to persist across multiple teleports, you can use `SetTeleportSetting` and `GetTeleportSetting`.

## Loading screen

A *customLoadingScreen* argument can be specified. This is a `ScreenGui` that is copied (without scripts) into the `CoreGui` of the destination place. 

Note, `SetTeleportGui` is the preferred alternative to the *customLoadingScreen* argument as it can be called prior to the teleport.

The loading `ScreenGui` can be obtained in the destination place using `GetArrivingTeleportGui`, where developers can parent it to the `PlayerGui`.

## Teleport failure
In some circumstances a teleport may fail. This can be due to the developer configuring the teleport incorrectly or issues with Roblox’s servers.

 - If a teleportation request is rejected the `TeleportInitFailed` event will fire the error message and a `TeleportResult` enumerator describing the issue
 - Teleports can fail ‘in transit’, after the user has left the server, due to issues with Roblox’s servers. In this case the user will be shown an error message and be required to rejoin the game

For more information on how to teleport players, see the `Teleporting Between Places` tutorial.

## Code Samples

### Following Another Player

The code sample below, when placed inside a `Script` within `ServerScriptService`, will teleport a player who's following another player to the associated place/server. Note that this will not work if the player being followed is in a reserved server.
```lua
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

Players.PlayerAdded:Connect(function(player)
	-- Is this player following anyone?
	local followId = player.FollowUserId
	-- If so, find out where they are
	if followId and followId ~= 0 then
		local success, errorMessage, placeId, jobId = pcall(function()
			return TeleportService:GetPlayerPlaceInstanceAsync(followId)
		end)
		if success then
			-- Teleport player
			TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
		end
	else
		warn("Player " .. player.UserId .. " is not following another player!")
	end
end)
```

@param placeId The ID of the place to teleport to
@param instanceId The `DataMode/JobId` of the server instance to teleport to
@param player The `Player` to teleport, if this function is being called from the client this defaults to the `Players/LocalPlayer`
@param spawnName Optional name of the `SpawnLocation` to spawn at
@param teleportData Optional data to be passed to the destination place. Can be retrieved using `TeleportService/GetLocalPlayerTeleportData`
@param customLoadingScreen Optional custom loading screen to be placed in the `CoreGui` at the destination place. Can be retrieved using `TeleportService/GetArrivingTeleportGui` */
	TeleportToPlaceInstance(
		placeId: number,
		instanceId: string,
		player?: Player,
		spawnName?: string,
		teleportData?: RbxInternalTeleportData,
		customLoadingScreen?: ScreenGui | GuiMain,
	): void;
	/** This function teleports one of more `Players` to a reserved server created using `ReserveServer`.

The *reservedServerAccessCode* parameter is the access code returned by `ReserveServer`. 

TeleportToPrivateServer can only be called on the server.

## Spawn name

An optional *spawnName* parameter can be provided, which will cause the `Players` to initially spawn at the `SpawnLocation` of that name in the destination place. The `SpawnLocation` must be valid for the `Players` to spawn on. For example, it must be `neutral` or set to the same `TeamColor` as the `Team` the `Players` will be assigned to upon joining the game.

## Teleport data

A *teleportData* parameter can be specified. This is data the clients will transmit to the destination place and can be retrieved using `GetLocalPlayerTeleportData`.

The *teleportData* can take any of the following forms:
 - A table without mixed keys (all keys are strings or integers)
 - A string
 - A number
 - A bool

As the *teleportData* is transmitted by the client it is not secure. For this reason it should only be used for local settings and not sensitive items (such as the users’ score or in-game currency).

If you need teleport data to persist across multiple teleports, you can use `SetTeleportSetting` and `GetTeleportSetting`.

## Loading screen

A *customLoadingScreen* argument can be specified. This is a `ScreenGui` that is copied (without scripts) into the `CoreGui` of the destination place. 

You are advised to instead set the loading screen on the client using `SetTeleportGui`. The loading `ScreenGui` should also be parented to the `Player’s` `PlayerGui` a few seconds before the teleport to ensure a smooth transition using a `RemoteEvent`. For an example of this see `SetTeleportGui`

The loading `ScreenGui` can be obtained in the destination place using `GetArrivingTeleportGui`, where developers can parent it to the `PlayerGui`.

## Teleport failure
In some circumstances a teleport may fail. This can be due to the developer configuring the teleport incorrectly or issues with Roblox’s servers.

 - If a teleportation request is rejected the `TeleportInitFailed` event will fire the error message and a `TeleportResult` enumerator describing the issue
 - Teleports can fail ‘in transit’, after the user has left the server, due to issues with Roblox’s servers. In this case the user will be shown an error message and be required to rejoin the game

For more information on how to teleport players, see the `Teleporting Between Places` tutorial.

## Code Samples

### TeleportService: Teleport to a Reserved Server via Chat

The following code would reserve one server, if it hasn't be reserved before. Whenever someone says "reserved" he/she will be teleported to the private server.
```lua
local TS = game:GetService("TeleportService")
local Players = game:GetService("Players")
local DSS = game:GetService("DataStoreService")
local DS = DSS:GetGlobalDataStore()
 
-- Get the saved code
local code = DS:GetAsync("ReservedServer")
if type(code) ~= "string" then -- None saved, create one
	code = TS:ReserveServer(game.PlaceId)
	DS:SetAsync("ReservedServer",code)
end
 
local function Joined(plr)
	-- Everytime they chat, we want to know
	plr.Chatted:Connect(function(msg)
		if msg == "reserved" then -- Aha, that's our cue
			TS:TeleportToPrivateServer(game.PlaceId,code,{plr})
		end
	end)
end
 
-- Connect all current and future players
Players.PlayerAdded:Connect(Joined)
for k,v in pairs(Players:GetPlayers()) do
	Joined(v)
end
```

### TeleportService: Teleport to a Reserved Server

The following code would send everyone in the current game to a reserved server. Since reserved servers can only be joined by using `/TeleportService/TeleportToPrivateServer`, nobody will join the reserved server afterwards.

Mind that, since everyone will be teleported, the current server will (probably) shutdown as nobody would be left in it.
```lua
local TS = game:GetService("TeleportService")
local Players = game:GetService("Players")

local code = TS:ReserveServer(game.PlaceId) -- Returns a code
local players = Players:GetPlayers() -- Get a list of all players

TS:TeleportToPrivateServer(game.PlaceId,code,players) -- Actually teleport the players
-- You could add extra arguments to this function: spawnName, teleportData and customLoadingScreen
```

@param placeId The ID of the place to teleport to
@param reservedServerAccessCode The reserved server access code returned by `TeleportService/ReserveServer`
@param players An array of `Player|Players` to teleport
@param spawnName Optional name of the `SpawnLocation` to spawn at
@param teleportData Optional data to be passed to the destination place. Can be retrieved using `TeleportService/GetLocalPlayerTeleportData`
@param customLoadingScreen Optional custom loading screen to be placed in the `CoreGui` at the destination place. Can be retrieved using `TeleportService/GetArrivingTeleportGui` */
	TeleportToPrivateServer(
		placeId: number,
		reservedServerAccessCode: string,
		players: Array<Player>,
		spawnName?: string,
		teleportData?: RbxInternalTeleportData,
		customLoadingScreen?: ScreenGui | GuiMain,
	): void;
	/** This function behaves the same as `Teleport` with the exception that it includes a *spawnName* parameter, causing the `Player` to spawn at the `SpawnLocation` of that name at the destination place.

The `SpawnLocation` must be valid for the `Player` to spawn on. For example, it must be `neutral` or set to the same `TeamColor` as the `Team` the `Player` will be assigned to upon joining the game.

The `Player` will still spawn at the correct `SpawnLocation` even the teleport is to a place in a different universe. The spawn will also be correct if `CharacterAutoLoads` is false in the destination place and the `Character` is loaded manually using `LoadCharacter`.

The teleportation will only affect the `SpawnLocation` used initially. If the `Player` respawns again subsequently it will not necessarily be at this `SpawnLocation`.

For more information about teleporting please see `Teleport` or the `Teleporting Between Places` tutorial.

## Code Samples

### TeleportService:TeleportToSpawnByName

This code will teleport a player to Crossroads, and if there is a spawn named "TeleportSpawn" then the player would spawn on it. This assumes it's being used in a `/LocalScript`.
```lua

game:GetService('TeleportService'):TeleportToSpawnByName(1818, "TeleportSpawn")

```

@param placeId The ID of the place to teleport to
@param spawnName The name of the `SpawnLocation` to spawn at
@param player The `Player` to teleport, if this function is being called from the client this defaults to the `Players/LocalPlayer`
@param teleportData Optional data to be passed to the destination place. Can be retrieved using `TeleportService/GetLocalPlayerTeleportData`
@param customLoadingScreen Optional custom loading screen to be placed in the `CoreGui` at the destination place. Can be retrieved using `TeleportService/GetArrivingTeleportGui` */
	TeleportToSpawnByName(
		placeId: number,
		spawnName: string,
		player?: Player,
		teleportData?: any,
		customLoadingScreen?: ScreenGui | GuiMain,
	): void;
	/** This function returns the `PlaceId` and `JobId` of the server the user with the given `UserId` is in provided it is in the same game as the current place.

`TeleportToPlaceInstance` can then be called with this information to allow a user to join the target user’s server.

This function returns the following values:

| # | Name | Type | Description |
| --- | --- | --- | --- |
| 1 | success | bool | A bool indicating if the user was found in the same game universe |
| 2 | error | string | An error message in the event of the lookup failing |
| 3 | placeId | int64 | The `PlaceId` of the server the user is in |
| 4 | instanceId | string | The `JobId` of the server the user is in |


## Caveats
You should be aware of the following limitations when using this function:

 - This function can only be called by the server
 - This function may fail to return the correct information if the user is teleporting
 - It is possible for this function to throw an error, hence developers should wrap it in a pcall (see example below)
 - As this function returns the `JobId` of the server and not the access code returned by `ReserveServer` the id returned is not appropriate for use with reserved servers

## See also
 - For the `PlaceIds` and `JobIds` of a `Player’s` friends, use `GetFriendsOnline`

## Code Samples

### Following Another Player

The code sample below, when placed inside a `Script` within `ServerScriptService`, will teleport a player who's following another player to the associated place/server. Note that this will not work if the player being followed is in a reserved server.
```lua
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

Players.PlayerAdded:Connect(function(player)
	-- Is this player following anyone?
	local followId = player.FollowUserId
	-- If so, find out where they are
	if followId and followId ~= 0 then
		local success, errorMessage, placeId, jobId = pcall(function()
			return TeleportService:GetPlayerPlaceInstanceAsync(followId)
		end)
		if success then
			-- Teleport player
			TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
		end
	else
		warn("Player " .. player.UserId .. " is not following another player!")
	end
end)
```

@param userId The `Player/UserId` of the `Player`
@returns See the table above */
	/** @rbxts server */
	GetPlayerPlaceInstanceAsync(userId: number): LuaTuple<[boolean, string, number, string]>;
	/** This function returns an access code that can be used to teleport players to a reserved server, along with the `PrivateServerId` for it.

ReserveServer can only be called on the server.

## Reserved Servers
The following are characteristics of reserved servers:

 - They can only be accessed using `TeleportToPrivateServer`, with the access code ReserveServer returns
 - A game server is started when the access code is first used
 - No more than one game server instance can exist at any time for each access code
 - Access codes remain valid indefinitely, meaning reserved servers can still be joined if no game server is running (in this case a new game server will be started)
 
You can see if the current server is a reserved server by using the following code:

```lua
local isReserved = game.PrivateServerId ~= "" and game.PrivateServerOwnerId == 0
```


The `PrivateServerId` is constant across all server instances associated with the server access code, the `JobId` is not.

## Code Samples

### TeleportService: Teleport to a Reserved Server via Chat

The following code would reserve one server, if it hasn't be reserved before. Whenever someone says "reserved" he/she will be teleported to the private server.
```lua
local TS = game:GetService("TeleportService")
local Players = game:GetService("Players")
local DSS = game:GetService("DataStoreService")
local DS = DSS:GetGlobalDataStore()
 
-- Get the saved code
local code = DS:GetAsync("ReservedServer")
if type(code) ~= "string" then -- None saved, create one
	code = TS:ReserveServer(game.PlaceId)
	DS:SetAsync("ReservedServer",code)
end
 
local function Joined(plr)
	-- Everytime they chat, we want to know
	plr.Chatted:Connect(function(msg)
		if msg == "reserved" then -- Aha, that's our cue
			TS:TeleportToPrivateServer(game.PlaceId,code,{plr})
		end
	end)
end
 
-- Connect all current and future players
Players.PlayerAdded:Connect(Joined)
for k,v in pairs(Players:GetPlayers()) do
	Joined(v)
end
```

### TeleportService: Teleport to a Reserved Server

The following code would send everyone in the current game to a reserved server. Since reserved servers can only be joined by using `/TeleportService/TeleportToPrivateServer`, nobody will join the reserved server afterwards.

Mind that, since everyone will be teleported, the current server will (probably) shutdown as nobody would be left in it.
```lua
local TS = game:GetService("TeleportService")
local Players = game:GetService("Players")

local code = TS:ReserveServer(game.PlaceId) -- Returns a code
local players = Players:GetPlayers() -- Get a list of all players

TS:TeleportToPrivateServer(game.PlaceId,code,players) -- Actually teleport the players
-- You could add extra arguments to this function: spawnName, teleportData and customLoadingScreen
```

@param placeId The `DataModel/PlaceId` of the place the reserved server is being created for
@returns The server access code required by `TeleportService/TeleportToPrivateServer` and the `DataModel/PrivateServerId` for the reserved server */
	/** @rbxts server */
	ReserveServer(placeId: number): LuaTuple<[string, string]>;
	/** This function teleports a group of `Players` to the same server instance in the given place. It returns the `JobId` of the server instance the players were teleported to.

This function can only be called from the server.

You may only use this function to teleport to a place in the same game. This function can not teleport more than 50 `Players` in a single party.

Currently this function may not work reliably when teleporting `Players` to the same place they are currently in.

## Teleport data

A *teleportData* parameter can be specified. This is data the clients will transmit to the destination place and can be retrieved using `GetLocalPlayerTeleportData`.

The *teleportData* can take any of the following forms:
 - A table without mixed keys (all keys are strings or integers)
 - A string
 - A number
 - A bool

As the *teleportData* is transmitted by the client it is not secure. For this reason it should only be used for local settings and not sensitive items (such as the users’ score or in-game currency).

## Loading screen

A *customLoadingScreen* argument can be specified. This is a `ScreenGui` that is copied (without scripts) into the `CoreGui` of the destination place. It can be retrieved at the destination place using `GetArrivingTeleportGui` and will not be used if the destination place is in a different game.

You are advised to instead set the loading screen on the client using `SetTeleportGui`. The loading `ScreenGui` should also be parented to the `Players'` `PlayerGuis` a few seconds before the teleport to ensure a smooth transition using a `RemoteEvent`. For an example of this see `SetTeleportGui`.

## Teleport failure
In some circumstances a teleport may fail. This can be due to the developer configuring the teleport incorrectly or issues with Roblox’s servers.

 - If a teleportation request is rejected the `TeleportInitFailed` event will fire the error message and a `TeleportResult` enumerator describing the issue
 - Teleports can fail ‘in transit’, after the user has left the server, due to issues with Roblox’s servers. In this case the user will be shown an error message and be required to rejoin the game

## See also
 - `GetJoinData` to get the `UserIds` of `Players` teleported together

## Code Samples

### Teleport all players in the server

This code sample is an example of how `TeleportPartyAsync` can be used to teleport a group of `Players`.

In this case, all `Players` will be teleported to the specified *placeId* as a party. The `JobId` of the destination server is then printed.
```lua
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")

local placeId = 0 -- replace
local playerList = Players:GetPlayers()

local success, result = pcall(function()
    return TeleportService:TeleportPartyAsync(placeId, playerList)
end)

if success then
    local jobId = result
    print("Players teleported to "..jobId)
else
    warn(result)
end
```

@param placeId The ID of the place to teleport to
@param players An array containing the `Player|Players` to teleport
@param teleportData Optional data to be passed to the destination place. Can be retrieved using `TeleportService/GetLocalPlayerTeleportData`
@param customLoadingScreen Optional custom loading screen to be placed in the `CoreGui` at the destination place. Can be retrieved using `TeleportService/GetArrivingTeleportGui`
@returns The `DataModel/JobId` of the server instance the `Player|Players` were teleported to */
	TeleportPartyAsync(
		placeId: number,
		players: Array<Player>,
		teleportData?: RbxInternalTeleportData,
		customLoadingScreen?: ScreenGui | GuiMain,
	): string;
	/** This function fires when the `LocalPlayer` enters the place following a teleport. The *teleportData* and *customLoadingScreen* are provided as arguments.

When fetching *teleportData* and the *customLoadingScreen* you are advised to use `GetLocalPlayerTeleportData` and `GetArrivingTeleportGui` instead. This is because these functions can be called immediately without having to wait for this event to fire.

This event should be connected immediately in a `LocalScript` parented to `ReplicatedFirst`. Otherwise, when the connection is made the event may have already fired.

## Loading screen

During a teleport, whilst the destination place is loading, the *customLoadingScreen* is parented to the `CoreGui`. Once the place has loaded the `loading screen` is `parented` to *nil*. 

If you wish to preserve the *customLoadingScreen* and perform your own transitions, you will need to parent it to the `LocalPlayer’s` `PlayerGui`. For example, using the following code inside a `LocalScript` in `ReplicatedFirst`:

```lua
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local ReplicatedFirst = game:GetService("ReplicatedFirst")

TeleportService.LocalPlayerArrivedFromTeleport:Connect(function(customLoadingScreen, teleportData)
	local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
	ReplicatedFirst:RemoveDefaultLoadingScreen()

	customLoadingScreen.Parent = playerGui
	-- animate screen here
	wait(5)
	-- destroy screen
	customLoadingScreen:Destroy()
end)
```


Note, the *customLoadingScreen* will not be used if the destination place is in a different game. */
	readonly LocalPlayerArrivedFromTeleport: RBXScriptSignal<
		(loadingGui: ScreenGui | GuiMain, dataTable?: unknown) => void
	>;
	/** This event fires if a request to teleport (from a function such as `Teleport`) fails and the player does not leave the current place server.

It is fired on both the client and the server. 

It includes a *teleportResult* argument (a `TeleportResult` enum) describing the reason the teleport failed along with the error message that is displayed to the user.

It is possible for teleportation to fail after the `Player` has left the place due to Roblox server issues. This event will not fire in this case and the user will be disconnected and required to rejoin.

## TeleportResult
The `TeleportResult` indicates the state of the teleport which can be one of several enum values:
| Name | Value | Description |
| --- | --- | --- |
| Success 0 | Teleport successful |
| ServerWasFull 1 | Teleport failed because the destination server was full |
| Failure 2 | Teleport failed |


## See also
  - `Teleport`
  - `TeleportPartyAsync`
  - `TeleportToPrivateServer`
  - `TeleportToPlaceInstance`
  - `TeleportToSpawnByName`

## Code Samples

### Reattempt Failed Teleport

This code sample includes a function that will reattempt a teleport if Roblox servers are busy or an unexpected failure has occurred. It should be ran on the client.
```lua
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer

local function localTeleportWithRetry(placeId, retryTime)
    local connection
    connection = TeleportService.TeleportInitFailed:Connect(function(player, teleportResult, errorMessage)
        if player == localPlayer then
            print("Teleport failed, TeleportResult: "..teleportResult.Name)
            -- check the teleportResult to ensure it is appropriate to retry
            if teleportResult == Enum.TeleportResult.Failiure or teleportResult == Enum.TeleportResult.Flooded then
                -- disconnect the connection
                connection:Disconnect()
                -- retry in retryTime seconds
                delay(retryTime, function()
                    print("Reattempting teleport")
                    TeleportService:Teleport(placeId)
                end)
            end
        end
    end)
    TeleportService:Teleport(placeId)
end

-- usage example:
local placeId = 1818 -- Crossroads
localTeleportWithRetry(placeId, 5)

```
 */
	readonly TeleportInitFailed: RBXScriptSignal<
		(player: Player, teleportResult: Enum.TeleportResult, errorMessage: string) => void
	>;
}

/** A TerrainRegion is a snapshot of `Terrain` retrieved from the [CopyRegion](https://developer.roblox.com/api-reference/function/Terrain/CopyRegion "CopyRegion") method. Can be later pasted into the Terrain using [PasteRegion](https://developer.roblox.com/api-reference/function/Terrain/PasteRegion "PasteRegion")
. */
interface TerrainRegion extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TerrainRegion";
	/** The size of this TerrainRegion in cells.The size of this TerrainRegion in cells.

Tags: ReadOnly, NotReplicated */
	readonly SizeInCells: Vector3;
}

/** The TestService is a service used by Roblox internally to run analytical tests on their engine.
It makes it possible to write sophisticated tests right inside a game.


## Macros

Scripts that are executed inside of the TestService (via `Run`) have access to special macros that directly invoke functions under the TestService. Macros are essentially substitutions for large blocks of code that shouldn't need to be rewritten each time you want to call them.

### RBX_CHECK
This macro does tests with calls to the `Check` function.

| Macro | Test Condition |
| --- | --- |
| RBX_CHECK(cond) | cond == true |
| RBX_CHECK_MESSAGE(cond, failMsg) | cond == true |
| RBX_CHECK_THROW(CODE) | pcall(function () CODE end) == false |
| RBX_CHECK_NO_THROW(CODE) | pcall(function () CODE end) == true |
| RBX_CHECK_EQUAL(a,b) | a == b |
| RBX_CHECK_NE(a,b) | a ~= b |
| RBX_CHECK_GE(a,b) | a >= b |
| RBX_CHECK_LE(a,b) | a  b |
| RBX_CHECK_LT(a,b) | a < b |

### RBX_REQUIRE
This macro does tests with calls to the `Require` function.

| Macro | Test Condition |
| --- | --- |
| RBX_REQUIRE(cond) | cond == true |
| RBX_REQUIRE_MESSAGE(cond, failMsg) | cond == true |
| RBX_REQUIRE_THROW(CODE) | pcall(function () CODE end) == false |
| RBX_REQUIRE_NO_THROW(CODE) | pcall(function () CODE end) == true |
| RBX_REQUIRE_EQUAL(a,b) | a == b |
| RBX_REQUIRE_NE(a,b) | a ~= b |
| RBX_REQUIRE_GE(a,b) | a >
= b |
| RBX_REQUIRE_LE(a,b) | a  b |
| RBX_REQUIRE_LT(a,b) | a < b |

### RBX_WARN
This macro does tests with calls to the `Warn` function.

| Macro | Test Condition |
| --- | --- |
| RBX_WARN(cond) | cond == true |
| RBX_WARN_MESSAGE(cond, failMsg) | cond == true |
| RBX_WARN_THROW(CODE) | pcall(function () CODE end) == false |
| RBX_WARN_NO_THROW(CODE) | pcall(function () CODE end) == true |
| RBX_WARN_EQUAL(a,b) | a == b |
| RBX_WARN_NE(a,b) | a ~= b |
| RBX_WARN_GE(a,b) | a >
= b |
| RBX_WARN_LE(a,b) | a  b |
| RBX_WARN_LT(a,b) | a < b |

### Additional Macros

| Macro | Description |
| --- | --- |
| RBX_ERROR(msg) | Directly calls the `Error` function. |
| RBX_FAIL(msg) | Directly calls the `Fail` function. |
| RBX_MESSAGE(msg) | Directly calls the `Message` function. |


## See Also

* [Speeding Roblox Development with Continuous Testing](http://blog.roblox.com/2012/04/speeding-roblox-development-with-continuous-testing) */
interface TestService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TestService";
	/** If set to true, the game will start running when the TestService's `Run` method is called. */
	AutoRuns: boolean;
	/** A description of the test being executed. */
	Description: string;
	/** Measures how many errors have been recorded in the test session.Measures how many errors have been recorded in the test session.

Tags: ReadOnly, NotReplicated */
	readonly ErrorCount: number;
	/** When set to true, the TestService will be executed when using the _Run_ action in Roblox Studio.

## Notes

* If the `NumberOfPlayers` property is set to a value above 0, running the game will open `NumberOfPlayers + 1` studio windows, where one window is a server, and the rest are players connected to that server.
	* Try to keep this value within a rational range (1 to 8 players at most), or else your computer's CPU will get overloaded. */
	ExecuteWithStudioRun: boolean;
	/** Sets whether or not the physics engine should be throttled to 30 FPS while the test is being ran. */
	Is30FpsThrottleEnabled: boolean;
	/** Sets whether or not the physics environment should be throttled while running this test. */
	IsPhysicsEnvironmentalThrottled: boolean;
	/** Sets whether or not physics objects will be allowed to fall asleep while the test simulation is running. */
	IsSleepAllowed: boolean;
	/** The number of players expected in this test, if any. */
	NumberOfPlayers: number;
	/** Sets a specific amount of additional latency experienced by players during the test session. */
	SimulateSecondsLag: number;
	/** Measures how many test calls have been recorded in the test session.Measures how many test calls have been recorded in the test session.

Tags: ReadOnly, NotReplicated */
	readonly TestCount: number;
	/** The maximum amount of time that tests are allowed to run for. */
	Timeout: number;
	/** Measures how many warning calls have been recorded in the test session.Measures how many warning calls have been recorded in the test session.

Tags: ReadOnly, NotReplicated */
	readonly WarnCount: number;
	/** If condition is true, prints "Check passed: ", followed by description to the output, in blue text. Otherwise, prints "Check failed: ", again, followed by description, but in red text.

## Code Samples

### TestService:Check

This code would print Check failed: example to the output, in red text.
```lua

game:GetService('TestService'):Check(false, "example")

```
 */
	Check(condition: boolean, description: string, source?: Instance, line?: number): void;
	/** Prints "Test checkpoint: 
", followed by text
, to the output, in blue text.

## Code Samples

### TestService:Checkpoint

This code would print Test checkpoint: example to the output, in blue text.
```lua

game:GetService('TestService'):Checkpoint("example")

```
 */
	Checkpoint(text: string, source?: Instance, line?: number): void;
	/** Prints Testing Done
 to the output, in blue text.

## Code Samples

### TestService:Done

This code would print Testing Done to the output, in blue text.
```lua

game:GetService('TestService'):Done()

```
 */
	Done(): void;
	/** Prints a red message to the output, prefixed by `TestService: `
.

## Code Samples

### TestService:Error

This will print TestService: "This is an error" to the output.
```lua

game:GetService("TestService"):Error("this is an error")

```
 */
	Error(description: string, source?: Instance, line?: number): void;
	/** Indicates a fatal error in a TestService run.
If this is called inside of a script running inside of the TestService, this will initiate a [breakpoint](https://developer.roblox.com/articles/Lua-debugger "Lua Debugger") on the line that invoked the error. */
	Fail(description: string, source?: Instance, line?: number): void;
	/** Prints Test message
, followed by text
 to the output, in blue text.

## Code Samples

### TestService:Message

This code would print Test message: example to the output, in blue text.
```lua

game:GetService('TestService'):Message("example")

```
 */
	Message(text: string, source?: Instance, line?: number): void;
	/** If `condition` is true, prints `Require passed: `, followed by `description`, to the output in blue text. Otherwise, prints `Require failed. Test ended: `, followed by `description`, to the output in red text.

## Code Samples

### TestService:Require

This code would print Require passed: example to the output, in blue text.
```lua

game:GetService('TestService'):Require(false, "example")

```
 */
	Require(condition: boolean, description: string, source?: Instance, line?: number): void;
	/** If condition is true, prints Warning passed: , followed by description, to the output, in blue text. Otherwise, prints Warning: , followed by description
, to the output, in yellow text.

## Code Samples

### TestService:Warn

This code would print "Warning: this action is invalid" to the output, in yellow text.
```lua

game:GetService('TestService'):Warn(false, "this action is invalid")

```
 */
	Warn(condition: boolean, description: string, source?: Instance, line?: number): void;
	/** [LACKS DOCUMENTATION] */
	isFeatureEnabled(name: string): boolean;
	/** Fired when the server should collect a conditional test result. */
	readonly ServerCollectConditionalResult: RBXScriptSignal<(condition: boolean, text: string, script: Instance, line: number) => void>;
	/** Fired when the server should collect a test result. */
	readonly ServerCollectResult: RBXScriptSignal<(text: string, script: Instance, line: number) => void>;
}

/** Represents the result of a call to `FilterStringAsync`.
Used to distribute a filtered string accordingly. */
interface TextFilterResult extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TextFilterResult";
	/** The GetChatForUserAsync  function returns the text in a properly filtered manner for the specified `UserId`. This should be used in the context of chats between players, although there are some other cases where text filtering is required.

This function returns the string appropriate for sending and displaying to a target user (specified by *toUserId*) from the original sender using the least restrictive filtering appropriate for the target user, with `Chat` privacy settings of both users enforced. This string should only be shown to the target user, as it might not be appropriate for all users.

This method throws an error if the two users are not allowed to chat (that is, if `CanUserChatAsync` would return false for the given sender and receiver). If this method throws the string should not be displayed to the user. In addition, this function will throw an error if CanUserChatAsync would return false, so CanUserChatAsync should be called first to check.

This function currently throws an error if the user with the id *toUserId* is not online on the current server. 

If text can be used for real-time or near real-time communication it should use this method.

This function will return immediately in most cases. The only time it will yield is if the target user is offline or has just joined the server and their filtering info is not yet loaded.

## Code Samples

### TextFilterResult:GetChatForUserAsync

This example sets up a widget that allows a player to send a message to another. Such a widget needs at least two scripts: a local script to handle input and displaying messages, and a script to filter the messages on the server. Because this example has a player sending a message to another specific player, the GetChatForUserAsync function should be used.

A working example can be found [here][1].


  [1]: https://www.roblox.com/games/1076221107/Message-Passing-With-Filtering-Example
```lua
-- ===============
-- LocalScript
-- ===============
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local screen = playerGui:WaitForChild("MessageScreen")
local sendMessageEvent = ReplicatedStorage:WaitForChild("SendPrivateMessage")
 
-- GUI elements for send frame
local sendFrame = screen:WaitForChild("SendFrame")
local recipientField = sendFrame:WaitForChild("Recipient")
local writeMessageField = sendFrame:WaitForChild("Message")
local sendButton = sendFrame:WaitForChild("Send")
 
-- GUI elements for receive frame
local receiveFrame = screen:WaitForChild("ReceiveFrame")
local senderField = receiveFrame:WaitForChild("From")
local readMessageField = receiveFrame:WaitForChild("Message")
 
-- Called when send button is clicked
local function onSendClicked()
	-- Try to find the recipient. Only want to send message if recipient exists
	local recipient = Players:FindFirstChild(recipientField.Text)
	local message = writeMessageField.Text
	if recipient and message ~= "" then
		-- Send the message
		sendMessageEvent:FireServer(recipient, message)
		-- Clean up send frame
		recipientField.Text = ""
		writeMessageField.Text = ""
	end	
end
 
-- Called when send message event fires meaning this client got a message
local function onReceiveMessage(sender, message)
	-- Populate fields of receive frame with the sender and message
	senderField.Text = sender.Name
	readMessageField.Text = message
end
 
-- Bind event functions
sendButton.MouseButton1Click:Connect(onSendClicked)
sendMessageEvent.OnClientEvent:Connect(onReceiveMessage)

-- ===============
-- Server Script
-- ===============
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TextService = game:GetService("TextService")
 
local sendMessageEvent = ReplicatedStorage.SendPrivateMessage
 
local function getTextObject(message, fromPlayerId)
	local textObject
	local success, errorMessage = pcall(function()
		textObject = TextService:FilterStringAsync(message, fromPlayerId)
	end)
	if success then
		return textObject
	end
	return false
end
 
local function getFilteredMessage(textObject, toPlayerId)
	local filteredMessage
	local success, errorMessage = pcall(function()
		filteredMessage = textObject:GetChatForUserAsync(toPlayerId)
	end)
	if success then
		return filteredMessage
	end
	return false
end
 
-- Called when client sends a message
local function onSendMessage(sender, recipient, message)
	if message ~= "" then
		-- Filter the incoming message and send the filtered message
		local messageObject = getTextObject(message, sender.UserId)
 
		if messageObject then
			local filteredMessage = getFilteredMessage(messageObject, recipient.UserId)
			sendMessageEvent:FireClient(recipient, sender, message)
		end
	end
end
 
sendMessageEvent.OnServerEvent:Connect(onSendMessage)
```

@param toUserId Id of the user being chatted.
@returns Filtered text stringThe GetChatForUserAsync  function returns the text in a properly filtered manner for the specified `UserId`. This should be used in the context of chats between players, although there are some other cases where text filtering is required.

This function returns the string appropriate for sending and displaying to a target user (specified by *toUserId*) from the original sender using the least restrictive filtering appropriate for the target user, with `Chat` privacy settings of both users enforced. This string should only be shown to the target user, as it might not be appropriate for all users.

This method throws an error if the two users are not allowed to chat (that is, if `CanUserChatAsync` would return false for the given sender and receiver). If this method throws the string should not be displayed to the user. In addition, this function will throw an error if CanUserChatAsync would return false, so CanUserChatAsync should be called first to check.

This function currently throws an error if the user with the id *toUserId* is not online on the current server. 

If text can be used for real-time or near real-time communication it should use this method.

This function will return immediately in most cases. The only time it will yield is if the target user is offline or has just joined the server and their filtering info is not yet loaded.

## Code Samples

### TextFilterResult:GetChatForUserAsync

This example sets up a widget that allows a player to send a message to another. Such a widget needs at least two scripts: a local script to handle input and displaying messages, and a script to filter the messages on the server. Because this example has a player sending a message to another specific player, the GetChatForUserAsync function should be used.

A working example can be found [here][1].


  [1]: https://www.roblox.com/games/1076221107/Message-Passing-With-Filtering-Example
```lua
-- ===============
-- LocalScript
-- ===============
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
 
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local screen = playerGui:WaitForChild("MessageScreen")
local sendMessageEvent = ReplicatedStorage:WaitForChild("SendPrivateMessage")
 
-- GUI elements for send frame
local sendFrame = screen:WaitForChild("SendFrame")
local recipientField = sendFrame:WaitForChild("Recipient")
local writeMessageField = sendFrame:WaitForChild("Message")
local sendButton = sendFrame:WaitForChild("Send")
 
-- GUI elements for receive frame
local receiveFrame = screen:WaitForChild("ReceiveFrame")
local senderField = receiveFrame:WaitForChild("From")
local readMessageField = receiveFrame:WaitForChild("Message")
 
-- Called when send button is clicked
local function onSendClicked()
	-- Try to find the recipient. Only want to send message if recipient exists
	local recipient = Players:FindFirstChild(recipientField.Text)
	local message = writeMessageField.Text
	if recipient and message ~= "" then
		-- Send the message
		sendMessageEvent:FireServer(recipient, message)
		-- Clean up send frame
		recipientField.Text = ""
		writeMessageField.Text = ""
	end	
end
 
-- Called when send message event fires meaning this client got a message
local function onReceiveMessage(sender, message)
	-- Populate fields of receive frame with the sender and message
	senderField.Text = sender.Name
	readMessageField.Text = message
end
 
-- Bind event functions
sendButton.MouseButton1Click:Connect(onSendClicked)
sendMessageEvent.OnClientEvent:Connect(onReceiveMessage)

-- ===============
-- Server Script
-- ===============
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TextService = game:GetService("TextService")
 
local sendMessageEvent = ReplicatedStorage.SendPrivateMessage
 
local function getTextObject(message, fromPlayerId)
	local textObject
	local success, errorMessage = pcall(function()
		textObject = TextService:FilterStringAsync(message, fromPlayerId)
	end)
	if success then
		return textObject
	end
	return false
end
 
local function getFilteredMessage(textObject, toPlayerId)
	local filteredMessage
	local success, errorMessage = pcall(function()
		filteredMessage = textObject:GetChatForUserAsync(toPlayerId)
	end)
	if success then
		return filteredMessage
	end
	return false
end
 
-- Called when client sends a message
local function onSendMessage(sender, recipient, message)
	if message ~= "" then
		-- Filter the incoming message and send the filtered message
		local messageObject = getTextObject(message, sender.UserId)
 
		if messageObject then
			local filteredMessage = getFilteredMessage(messageObject, recipient.UserId)
			sendMessageEvent:FireClient(recipient, sender, message)
		end
	end
end
 
sendMessageEvent.OnServerEvent:Connect(onSendMessage)
```

@param toUserId Id of the user being chatted.
@returns Filtered text string

Tags: Yields */
	GetChatForUserAsync(toUserId: number): string;
	/** Returns the text in a properly filtered manner for all users.Returns the text in a properly filtered manner for all users.

Tags: Yields */
	GetNonChatStringForBroadcastAsync(): string;
	/** Returns the text in a properly filtered manner for the specified `UserId`. This should be used in the context of non-chat text that another user can see, such as the name of a pet.Returns the text in a properly filtered manner for the specified `UserId`. This should be used in the context of non-chat text that another user can see, such as the name of a pet.

Tags: Yields */
	GetNonChatStringForUserAsync(toUserId: number): string;
}

/** The TextService is a service internally responsible for handling the display of text in the game.

This class has two member functions,

The `GetTextSize` function gives developers the ability to calculate the space required for a specific text string with specified formatting, returning a `Vector2` pixel size.

The `FilterStringAsync` function is required to properly filter user specified text (such as chat messages or other inputs) in the interests of user safety. Developers not using the Roblox default `Chat`, or allowing users to otherwise input text must use this function.

For more information on text filtering please see [this article][1].


  [1]: http://robloxdev.com/articles/Text-and-Chat-Filtering */
interface TextService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TextService";
	/** Computes the `Vector2` dimensions (in pixels) that will be taken up with text when using the specified formatting parameters and size constraints.

Note, the fontSize parameter will not accept the `FontSize` Enum. Instead the integer size corresponding with the `FontSize` Enum should be used. This is not equal to the value of the `FontSize` Enum. For example, for *Size11* font, the integer *11* should be used.

This function is a useful alternative to the `TextBounds` property of the `TextLabel` and `TextButton` objects. Using the `TextBounds` property to calculate the dimensions text requires is often impractical as it requires a `TextLabel` object to be created.

With GetTextSize, the dimensions required by a particular text string in a particular `TextLabel` or `TextButton` can be calculated before any object is created or text property set.

Developers are recommended to add a pixel of padding to the result to ensure no text is cut off.
@param string The string for which the text size is to be calculated.
@param fontSize The integer representing the font size used.
@param font The font used.
@param frameSize The `TextLabel/AbsoluteSize` of the text object to be used. Required to compute how the text will wrap.
@returns The size of the space required, in pixels, by the string with the specified formatting. */
	GetTextSize(string: string, fontSize: number, font: CastsToEnum<Enum.Font>, frameSize: Vector2): Vector2;
	/** The FilterStringAsync function filters a string being received from a user, using the `TextService`, and returns a `TextFilterResult` which can be used to distribute the correctly filtered text accordingly.

## Usage

This method should be called once each time a user submits a message. Do not cache the results of this function and re-use them for separate messages. If a user submits the same text multiple times this method must be called again each time the message is sent. If the results are cached and reused spam detection and many forms of context-aware filtering will be broken and potentially put user safety at risk. Games that improperly use cached results may face moderation.

However, it is encouraged to keep these result objects to display the same message to users who join the server later. For example: this can be used to safely and efficiently implement a server chat log that always uses the least restrictive filtering for users who join later, or for efficiently displaying text like a pet name to a user who joins the game after the pet was first spawned and name filtered.

The optional `TextFilterContext` parameter will not impact the filtered result of the query. This value will be used to improve Roblox's text filtering.

Private text is anything that is seen only by specific players, rather than every player. For example, if the chat is seen by a single player, or by a selected group of players, then the chat is considered private. Chat for teams or chat that is potentially visible to a wider group, such as the server, is considered public. If you are unsure what your text qualifies as, leave the optional field blank.

## Notes

 - This method always yields to make a text filtering service call
 - This method may throw if there is a service error that can not be resolved. If this function throws an error please do not retry the request; this method implements it’s own retry logic internally. If this method fails do not display the text to any user.
 - This method currently throws if *fromUserId* is not online on the current server. We plan to support users who are offline or on a different server in the future.
@param stringToFilter The text to be filtered.
@param fromUserId The userId of the player filtering the text.
@param textContext The context that the filtered message will be used in. The default is PrivateChat.
@returns Can be used to distribute the correctly filtered text accordingly. */
	FilterStringAsync(
		stringToFilter: string,
		fromUserId: number,
		textContext?: CastsToEnum<Enum.TextFilterContext>,
	): TextFilterResult | undefined;
}

/** An internal service that is used to handle third-party related users.
This service only works on consoles, and is only intended to be used by Roblox. */
interface ThirdPartyUserService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ThirdPartyUserService";
}

/** An internal service responsible for scheduling timed events. It is used by the `Debris` class. Its functionality can not be accessed by developers. */
interface TimerService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TimerService";
}

/** An internal service responsible for touch inputs on mobile devices. */
interface TouchInputService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TouchInputService";
}

/** An internal object used by networking and replication code to transmit `Touched` and `TouchEnded` events.

The TouchTransmitter object named 'TouchInterest' is created and parented to a `BasePart` when the `Touched` or `TouchEnded` events are listened (connected) to.

Removing the TouchTransmitter will prevent the touched events from working. The TouchTransmitter object can also be removed exclusively on the client (when `FilteringEnabled` is set to true). This will prevent collisions from models the client has network ownership of (such as the player's character) from registering.

Note, in almost all circumstances developers should disconnect the connection using `Disconnect` method rather than removing the TouchTransmitter. Otherwise the connection will not be cleaned up which can cause performance issues over time.

## Code Samples

### TouchTransmitter

This sample demonstrates how a `TouchTransmitter` object is created when the `Touched` or `TouchEnded` events are connected to. Also demonstrates what happened when the `TouchTransmitter` is destroyed.
```lua
    local part = Instance.new("Part")
    part.Anchored = true 
    part.Position = Vector3.new(0, 1, 0)
    part.Parent = workspace
    
    part.Touched:Connect(function()
    	print("part touched!")
    end)
    
    local touchTransmitter = part:WaitForChild("TouchInterest")
    if touchTransmitter then
    	print("removing TouchTransmitter!")
    	touchTransmitter:Destroy()
    end
```
 */
interface TouchTransmitter extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TouchTransmitter";
}

/** The Trail object is used to create a trail like an effect between two points. As the points move through space a texture is drawn on the plane the points define. This is commonly used to create effects to help visualize movements like tracer trails behind projectiles, footprints, tire tracks, and many other similar effects.

![A diagram explaining the Trail object.](https://developer.roblox.com/assets/5b3c158168a9cd0a78be548e/TrailSegments2.png)
![An example usage of the Trail object.](https://developer.roblox.com/assets/5b3bf11cca8406e05d8a0c3d/Trail.gif)

When a Trail is active it will record the position of it's `Attachment0` every frame. It then connects these positions to where the attachments were in the previous frame, creating a polygon. That polygon is then filled in with the Trail's `Color` and `Texture` (if that Texture exists). Each segment drawn in this way will eventually fade based on the TrailEffect's `Lifetime`.

# Creating Trails

In order for a Trail to work properly, it must be a descendant of the `Workspace` and its attachment properties (`Attachment0` and `Attachment1`) must be set to two unique Attachments. Once this has been done the effect will create a trail as soon as either of its attachments moves.

![Basic Trail](https://developer.roblox.com/assets/5b3bf0d568a9cd0a78be5462/BasicTrail.gif)

It is common practice to either store the Trail in the `BasePart` containing the effect's attachments, or as a child of a `Folder` in the Workspace with other effects objects.

## Code Samples

### Creating a Part With a Basic Trail

This example demos the functionality of trails. 

In order to do this, we must first create a `BasePart`, *part*, which will be the parent of the trail.

Then, we create two attachments, *attachment0* and *attachment1*, both parented to *part*. The positions of these two attachments, more importantly the distance between them, determines where the trail is drawn as *part* moves.

For these attachments to create a trail as described, we create a new Trail and parent it to *part*. We then connect *attachment0* to `Attachment0` and *attachment1* to `Attachment1`. 

In this example, we set the `Color` to a fade between blue and white using a `ColorSequence`. For more info on how to set a trail's color in a script, see the `Color`'s documentation.

Finally, to demo the alignment the example relies on `TweenService`'s `Create` to move *part* back and forth. As the part moves, the trail is drawn.
```lua
-- Create a new BasePart
local part = Instance.new("Part")
part.Parent = game.Workspace
part.Anchored = true
part.Position = Vector3.new(0,5,0)

-- Create 2 attachments
local attachment0 = Instance.new("Attachment")
attachment0.Name = "Attachment0"
attachment0.Parent = part
attachment0.Position = Vector3.new(-2,0,0)

local attachment1 = Instance.new("Attachment")
attachment1.Name = "Attachment1"
attachment1.Parent = part
attachment1.Position = Vector3.new(2,0,0)

-- Create a new Trail
local trail = Instance.new("Trail")
trail.Parent = part
trail.Attachment0 = attachment0
trail.Attachment1 = attachment1
color1 = Color3.new(15/255,127/255,254/255)
color2 = Color3.new(255/255,255/255,255/255)
trail.Color = ColorSequence.new(color1, color2)

-- Tween part to display trail
local TweenService = game:GetService("TweenService")

local dir = 15
while true do
	dir = dir*-1
	local goal = {}
	goal.Position = part.Position + Vector3.new(0,0,dir)
 
	local tweenInfo = TweenInfo.new(5)
	local tween = TweenService:Create(part, tweenInfo, goal)
 	tween:Play()

	wait(5)
end
```
 */
interface Trail extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Trail";
	/** A `Trail` starts drawing its segments at the positions of its `Attachment0` and ***Attachment1**. 

When the Trail is `Enabled` it will record the positions of its attachments every frame. It will connect these positions to the positions of the attachments on the previous frame. This creates a polygon that is then filled in by the Trail's `Color` and `Texture` (if that Texture exists).

When created a Trail will not have any Attachments set by default. These will need to be set in order for the effect to work.

Changing the Attachments of a Trail while a trail is drawing will remove all of the segments the trail has already drawn.

## Code Samples

### Creating a Part With a Basic Trail

This example demos the functionality of trails. 

In order to do this, we must first create a `BasePart`, *part*, which will be the parent of the trail.

Then, we create two attachments, *attachment0* and *attachment1*, both parented to *part*. The positions of these two attachments, more importantly the distance between them, determines where the trail is drawn as *part* moves.

For these attachments to create a trail as described, we create a new Trail and parent it to *part*. We then connect *attachment0* to `Attachment0` and *attachment1* to `Attachment1`. 

In this example, we set the `Color` to a fade between blue and white using a `ColorSequence`. For more info on how to set a trail's color in a script, see the `Color`'s documentation.

Finally, to demo the alignment the example relies on `TweenService`'s `Create` to move *part* back and forth. As the part moves, the trail is drawn.
```lua
-- Create a new BasePart
local part = Instance.new("Part")
part.Parent = game.Workspace
part.Anchored = true
part.Position = Vector3.new(0,5,0)

-- Create 2 attachments
local attachment0 = Instance.new("Attachment")
attachment0.Name = "Attachment0"
attachment0.Parent = part
attachment0.Position = Vector3.new(-2,0,0)

local attachment1 = Instance.new("Attachment")
attachment1.Name = "Attachment1"
attachment1.Parent = part
attachment1.Position = Vector3.new(2,0,0)

-- Create a new Trail
local trail = Instance.new("Trail")
trail.Parent = part
trail.Attachment0 = attachment0
trail.Attachment1 = attachment1
color1 = Color3.new(15/255,127/255,254/255)
color2 = Color3.new(255/255,255/255,255/255)
trail.Color = ColorSequence.new(color1, color2)

-- Tween part to display trail
local TweenService = game:GetService("TweenService")

local dir = 15
while true do
	dir = dir*-1
	local goal = {}
	goal.Position = part.Position + Vector3.new(0,0,dir)
 
	local tweenInfo = TweenInfo.new(5)
	local tween = TweenService:Create(part, tweenInfo, goal)
 	tween:Play()

	wait(5)
end
```
 */
	Attachment0?: Attachment;
	/** A `Trail` starts drawing its segments at the positions of its **Attachment0** and `Attachment1`. 

When the Trail is `Enabled` it will record the positions of its attachments every frame. It will connect these positions to the positions of the attachments on the previous frame. This creates a polygon that is then filled in by the Trail's `Color` and `Texture` (if that Texture exists).

When created a Trail will not have any Attachments set by default. These will need to be set in order for the effect to work.

Changing the Attachments of a Trail while a trail is drawing will remove all of the segments the trail has already drawn.

## Code Samples

### Creating a Part With a Basic Trail

This example demos the functionality of trails. 

In order to do this, we must first create a `BasePart`, *part*, which will be the parent of the trail.

Then, we create two attachments, *attachment0* and *attachment1*, both parented to *part*. The positions of these two attachments, more importantly the distance between them, determines where the trail is drawn as *part* moves.

For these attachments to create a trail as described, we create a new Trail and parent it to *part*. We then connect *attachment0* to `Attachment0` and *attachment1* to `Attachment1`. 

In this example, we set the `Color` to a fade between blue and white using a `ColorSequence`. For more info on how to set a trail's color in a script, see the `Color`'s documentation.

Finally, to demo the alignment the example relies on `TweenService`'s `Create` to move *part* back and forth. As the part moves, the trail is drawn.
```lua
-- Create a new BasePart
local part = Instance.new("Part")
part.Parent = game.Workspace
part.Anchored = true
part.Position = Vector3.new(0,5,0)

-- Create 2 attachments
local attachment0 = Instance.new("Attachment")
attachment0.Name = "Attachment0"
attachment0.Parent = part
attachment0.Position = Vector3.new(-2,0,0)

local attachment1 = Instance.new("Attachment")
attachment1.Name = "Attachment1"
attachment1.Parent = part
attachment1.Position = Vector3.new(2,0,0)

-- Create a new Trail
local trail = Instance.new("Trail")
trail.Parent = part
trail.Attachment0 = attachment0
trail.Attachment1 = attachment1
color1 = Color3.new(15/255,127/255,254/255)
color2 = Color3.new(255/255,255/255,255/255)
trail.Color = ColorSequence.new(color1, color2)

-- Tween part to display trail
local TweenService = game:GetService("TweenService")

local dir = 15
while true do
	dir = dir*-1
	local goal = {}
	goal.Position = part.Position + Vector3.new(0,0,dir)
 
	local tweenInfo = TweenInfo.new(5)
	local tween = TweenService:Create(part, tweenInfo, goal)
 	tween:Play()

	wait(5)
end
```
 */
	Attachment1?: Attachment;
	/** The color of a `Trail` can be set with the effect's Color property. This property determines what color the segments of the trail will have through their `Lifetime`. 

Color is a `ColorSequence`, which means that the segments in a trail can shift between several colors. Note that if the color for a trail changes after some of the trail segments have been drawn, all of the old segments will be updated to match the new colors.

If a trail has a `Texture` then the Color property will tint that texture. 

![Trails with tinted textures](https://developer.roblox.com/assets/5b3d38bb79099e4b58a7880a/TrailTextureColor.png)

Any transparent components of a texture will not be tinted.

## Code Samples

### Changing a Trail Color As It Is Drawing

This example changes the color of the trail as it is being drawn. Initially, the color of the trail is set to blue (`Color3.new(0,255,255)`). After waiting for *1.5* seconds, the color of the trail is set to red (`Color3.new(255,0,0)`).

The gif below displays what the output of the example should look like.

![Trail color switch from blue to red.](https://developer.roblox.com/assets/5b3d3b7e5928634658e3e132/TextureColorSwitch.gif)
```lua
local trailEffect = script.Parent
 
local firstColor = Color3.new(0, 255, 255)
local secondColor = Color3.new(255, 0, 0)
 
local firstSequence = ColorSequence.new(firstColor)
local secondSequence = ColorSequence.new(secondColor)
 
trailEffect.Color = firstSequence
 
wait(1.5)
 
trailEffect.Color = secondSequence
```

### Creating a Trail with a Color Gradient

This example creates a Trail with a gradient color. This means that the color at one end of the trail is different than the color at the opposite end of the trail, and both colors blend together as they get closer to the middle of the trail.

In order to create this effect, we must use a `ColorSequence` with two different colors. In our example, we use *blue* and *red* as the `startColor` and `endColor`.

The gif below shows what the output of this example should look like.

![Texture color gradient using blue and red.](https://developer.roblox.com/assets/5b3d3c60cfc846f95726bc53/TextureColorGradient.gif)
```lua
local trailEffect = script.Parent
  
local startColor = Color3.new(255, 0, 0)
local endColor = Color3.new(0, 0, 255)
  
local sequence = ColorSequence.new(startColor, endColor)
  
trailEffect.Color = sequence
```
 */
	Color: ColorSequence;
	/** The Enabled property determines whether a Trail will be drawn or not. This Enabled property defaults to true.

When enabled is true, the trail will create segments between the current position of its `Attachment0` and the position of the attachments in the last frame. 

If enabled is set to false while a trail is drawing no new segments will be drawn, but any existing segments will be cleaned up naturally when they reach the end of their `Lifetime`. If you would like to clean up any existing segments, you can use the `Clear` function at the same time.

## Code Samples

### Clearing and Disabling a Trail

This example explains how to both clear a trail's drawn segments and disable the trail to prevent new segments from being drawn. New segments will not be drawn until the trails `Enabled` property is set to `true`.

In order for this example to be properly demonstrated, we must first create a `BasePart` that will be the parent of our trail.

Then, we create two attachments, *attachment0* and *attachment1*, both parented to *part*. The positions of these two attachments, more importantly the distance between them, determines where the trail is drawn as *part* moves.

For these attachments to create a trail as described, we create a new Trail and parent it to *part*. We then connect *attachment0* to `Attachment0` and *attachment1* to `Attachment1`. 

To demo that the `Clear` function erases any existing trail segments, the example relies on `TweenService`'s `Create` to move *part* back and forth to constantly draw a trail. Every 3 seconds of this motion, the trail segments are cleared and the trail is toggled between disabled and enabled. 

In order for the example to work properly, the example implements a function named `tweenPart` that tweens the part back and forth `15` studs.
```lua
-- The function that tweens the part back and forth 15 studs
local dir = 15
local TweenService = game:getService("TweenService")
function tweenPart(part)
	dir = dir*-1
	local goal = {}
	goal.Position = part.Position + Vector3.new(0,0,dir)
 
	local tweenInfo = TweenInfo.new(5)
	local tween = TweenService:Create(part, tweenInfo, goal)
 	tween:Play()

	wait(5)
end

-- Create a new BasePart
local part = Instance.new("Part")
part.Parent = game.Workspace
part.Anchored = true
part.Position = Vector3.new(0,5,0)

-- Create 2 attachments
local attachment0 = Instance.new("Attachment")
attachment0.Name = "Attachment0"
attachment0.Parent = part
attachment0.Position = Vector3.new(-2,0,0)

local attachment1 = Instance.new("Attachment")
attachment1.Name = "Attachment1"
attachment1.Parent = part
attachment1.Position = Vector3.new(2,0,0)

-- Create a new Trail
local trail = Instance.new("Trail")
trail.Parent = part
trail.Attachment0 = attachment0
trail.Attachment1 = attachment1
color1 = Color3.new(15/255,127/255,254/255)
color2 = Color3.new(255/255,255/255,255/255)
trail.Color = ColorSequence.new(color1, color2)

-- Tween part, clear trail segments, and toggle trail between enabled/disabled
while true do
	tweenPart(part)
	trail:Clear()
	trail.Enabled = not trail.Enabled
end
```
 */
	Enabled: boolean;
	/** The FaceCamera property determines whether the `Trail` is always drawn facing the camera. The default value is false.

If set to true, the trail textures will always face the camera. If set to false, the texture will be drawn in the direction of the distance between the trail's `Attachment0` and `Attachment1`.

Note that changing this property immediately affects all existing and future trail segments. This means that all existing and new segments will adjust to face the player's camera or the direction of the attachments according to the property's new state.

## FaceCamera Enabled ##
![Demonstrating a trail with the FaceCamera property set to true.](https://developer.roblox.com/assets/5b4525f2cbdac88b0b7f3359/TrailFacingCamera.gif)

    local trail = script.Parent
    trail.FaceCamera = true


## FaceCamera Disabled ##
![Demonstrating a trail with the FaceCamera property set to false.](https://developer.roblox.com/assets/5b452622c321297a0b1bc184/TrailNotFacingCamera.gif)

    local trail = script.Parent
    trail.FaceCamera = false

## Code Samples

### Setting a Trail's FaceCamera Property

This example demos the functionality of the FaceEnabled property.

In order to do this, we must first create a `BasePart`, *part*, which will be the parent of the trail.

Then, we create two attachments, *attachment0* and *attachment1*, both parented to *part*. The positions of these two attachments, more importantly the distance between them, determines where the trail is drawn as *part* moves.

For these attachments to create a trail as described, we create a new Trail and parent it to *part*. We then connect *attachment0* to `Attachment0` and *attachment1* to `Attachment1`. 

In this example, we initially set the FaceCamera property to *true*. Then, every 5 seconds we toggle the property to the opposite state so that the property switches between *true* and *false* every few seconds. When the property is enabled (*true*), you can rotate your camera around the trail to demonstrate how the trail's segments always face the player's camera.

Finally, to demo the property the example relies on `TweenService`'s `Create` to move *part* back and forth. As the part moves, the trail is drawn.
```lua
-- Create a new BasePart
local part = Instance.new("Part")
part.Parent = game.Workspace
part.Anchored = true
part.Position = Vector3.new(0,5,0)

-- Create 2 attachments
local attachment0 = Instance.new("Attachment")
attachment0.Name = "Attachment0"
attachment0.Parent = part
attachment0.Position = Vector3.new(-2,0,0)

local attachment1 = Instance.new("Attachment")
attachment1.Name = "Attachment1"
attachment1.Parent = part
attachment1.Position = Vector3.new(2,0,0)

-- Create a new Trail
local trail = Instance.new("Trail")
trail.Parent = part
trail.Attachment0 = attachment0
trail.Attachment1 = attachment1
trail.FaceCamera = true

-- Tween part to display trail
local TweenService = game:GetService("TweenService")

local dir = 15
while true do
	dir = dir*-1

	trail.FaceCamera = not trail.FaceCamera

	local goal = {}
	goal.Position = part.Position + Vector3.new(0,0,dir)
 
	local tweenInfo = TweenInfo.new(5)
	local tween = TweenService:Create(part, tweenInfo, goal)
 	tween:Play()

	wait(5)
end
```
 */
	FaceCamera: boolean;
	/** The Lifetime property determines how long each segment in its `Trail` will last in seconds. Once a segment is drawn, it will wait for the given lifetime (measured in seconds) and then will disappear. The lifetime property defaults to 2 seconds, but can be set anywhere between 0.01 and 20.

The lifetime of a trail is also used by that effect's `Color` and `Transparency` properties to determine how each segment is drawn. Both of these properties are sequences, meaning that they define their values at certain keypoints in the segement's lifetime and then interpolate between the values as the segment ages.

If a trail's lifetime changes while there are still segments that the trail has drawn, these segments will immediately behave as if they always had the new lifetime. This means that if they have existed for longer than the lifetime they will be removed immediately. */
	Lifetime: number;
	/** The LightEmission `Trail` property sets how much the `Colors` of the trail are blended with the colors behind them. LightEmission uses additive blending to combine the colors, meaning the RGB values of the colors are added together to determine the displayed color. This addition is weighted by the value of LightEmission.

When changed this property instantly affects all particles owned by the emitter, both current and future particles.

Note
----------
This property is not related to the dynamic lighting engine of Roblox. If you need your trail to emit light, it is recommended to create parts with `PointLight` that follow the path of the trail.

## Code Samples

### Creating a Trail that Emits Light

This example demos the functionality of the light emission property of the trail object. 

In order to do this, we must first create a `BasePart`, *part*, which will be the parent of the trail.

Then, we create two attachments, *attachment0* and *attachment1*, both parented to *part*. The positions of these two attachments, more importantly the distance between them, determines where the trail is drawn as *part* moves.

For these attachments to create a trail as described, we create a new Trail and parent it to *part*. We then connect *attachment0* to `Attachment0` and *attachment1* to `Attachment1`. 

In this example, we set the light emission to 1, the maximum possible value on a scale from 0 to 1. While this example does not create a part, containing a `PointLight`, that follows the trail around, it is recommended to do so.

Finally, to demo the trail's light emission,  the example relies on `TweenService`'s `Create` to move *part* back and forth. As the part moves, the trail is drawn.
```lua
-- Create a new BasePart
local part = Instance.new("Part")
part.Parent = game.Workspace
part.Anchored = true
part.Position = Vector3.new(0,5,0)

-- Create 2 attachments
local attachment0 = Instance.new("Attachment")
attachment0.Name = "Attachment0"
attachment0.Parent = part
attachment0.Position = Vector3.new(-2,0,0)

local attachment1 = Instance.new("Attachment")
attachment1.Name = "Attachment1"
attachment1.Parent = part
attachment1.Position = Vector3.new(2,0,0)

-- Create a new Trail
local trail = Instance.new("Trail")
trail.Parent = part
trail.Attachment0 = attachment0
trail.Attachment1 = attachment1
trail.LightEmission = 1

-- Tween part to display trail
local TweenService = game:GetService("TweenService")

local dir = 15
while true do
	dir = dir*-1
	local goal = {}
	goal.Position = part.Position + Vector3.new(0,0,dir)
 
	local tweenInfo = TweenInfo.new(5)
	local tween = TweenService:Create(part, tweenInfo, goal)
 	tween:Play()

	wait(5)
end
```
 */
	LightEmission: number;
	/** The LightInfluence property sets how much the trail is influenced by the lighting around it. The property can be set to a value from 0 to 1, with 1 being the most influenced and 0 be the least influenced.

## Code Samples

### Setting a Trail's Light Influence

This example demos the trail's light influence property.

In order to do this, we must first set `Lighting`'s `Brightness` to 0. This is done to create a better demo lighting to demo the differences in the trail's appearance when the light influence property changes.

Next, we create a `BasePart`, *part*, which will be the parent of the trail.

Then, we create two attachments, *attachment0* and *attachment1*, both parented to *part*. The positions of these two attachments, more importantly the distance between them, determines where the trail is drawn as *part* moves.

For these attachments to create a trail as described, we create a new Trail and parent it to *part*. We then connect *attachment0* to `Attachment0` and *attachment1* to `Attachment1`. 

In this example, we initially set the LightInfluence property to *1*. Then, every 5 seconds we increment the property so that it toggles between *0* and *1*. When the value is *0*, the trail appears much brighter because it is not influenced by Lighting's low brightness as compared to when the value is *1*.

Finally, to demo the property the example relies on `TweenService`'s `Create` to move *part* back and forth. As the part moves, the trail is drawn.
```lua
-- Set Lighting's brightness to 0
game.Lighting.Brightness = 0

-- Create a new BasePart
local part = Instance.new("Part")
part.Parent = game.Workspace
part.Anchored = true
part.Position = Vector3.new(0,5,0)

-- Create 2 attachments
local attachment0 = Instance.new("Attachment")
attachment0.Name = "Attachment0"
attachment0.Parent = part
attachment0.Position = Vector3.new(-2,0,0)

local attachment1 = Instance.new("Attachment")
attachment1.Name = "Attachment1"
attachment1.Parent = part
attachment1.Position = Vector3.new(2,0,0)

-- Create a new Trail
local trail = Instance.new("Trail")
trail.Parent = part
trail.Attachment0 = attachment0
trail.Attachment1 = attachment1
trail.LightInfluence = 1

-- Tween part to display trail
local TweenService = game:GetService("TweenService")

local dir = 15
local influence = 1
while true do
	dir = dir*-1

	influence = influence*-1
	trail.LightInfluence = trail.LightInfluence+influence

	local goal = {}
	goal.Position = part.Position + Vector3.new(0,0,dir)
 
	local tweenInfo = TweenInfo.new(5)
	local tween = TweenService:Create(part, tweenInfo, goal)
 	tween:Play()

	wait(5)
end
```
 */
	LightInfluence: number;
	/** The MinLength of a `Trail` determines the maximum length of each of the segments in the trail.

Note that changing MaxLength will only affect new segments that are drawn – any old segments that have already been drawn will maintain their current length.

This value can be any number greater than or equal to 0, and defaults to 0. If the property is set to 0, the maximum length will be infinity - meaning that the trail will not have a maximum length.

Please note that, even if this property is 0, or another large number, the trail is still constrained by its `Lifetime`. Old segments will be erased if they reach the end of their lifetime, even if the trail is shorter than the maximum length. Be sure to set both properties fittingly.

This property can also be used alongside the `MinLength` property, which determines the minimum length trail must before before it is drawn.

![Demonstration of trail length.](https://developer.roblox.com/assets/5b3d57948fbd570b783cc4df/TrailMinLength.gif) */
	MaxLength: number;
	/** The MinLength of a `Trail` determines the minimum length of each of the segments in the trail.

If neither of the trail's `Attachment0` or `Attachment1` have moved at least the minimum length in studs, then no new segments will be created and the endpoints of the current segment will be moved to the current position of the attachments. 

Note that changing MinLength will only affect new segments that are drawn – any old segments that have already been drawn will maintain their current length.

This value can be any number greater than or equal to 0, and defaults to 0.1.

This property can also be used alongside the `MaxLength` property, which determines the maximum length trail may be before its oldest segments are erased.

![Minimum length of a trail's segment in studs.](https://developer.roblox.com/assets/5b3d57948fbd570b783cc4df/TrailMinLength.gif)

## Code Samples

### Setting a Trail's Minimum Length

This example alternates between setting a trail's minimum length of a trail to `10` studs and `0.1` studs every 3 seconds. 

To best display the change in minimum trail length, we first set the `Lifetime` of the trail to 4. This means that the trail drawn will disappear 4 seconds after it is drawn.

In order for this example to work as expected, the script containing this code must be a child of the trail. If you would like to place the code in a script that is not the child of the trail, you must change the `trail` value to point to the location of the trail object in the game.
```lua
local trail = script.Parent
 
trail.Lifetime = 4
 
while wait(3) do
    trail.MinLength = 10
    wait(3)
    trail.MinLength = 0.1
end
```
 */
	MinLength: number;
	/** The Texture property is the texture to draw on a `Trail`'s segments. This property sets which image asset to use for the texture. This is set the same way as textures in other objects, such as `ImageLabel` or `ParticleEmitter`. The simplest way to set this property is to use an image uploaded to the Game Explorer (this requires the current place to be Published to Roblox). 

If a texture is not provided, then just the `Color` of the Trail will be used. With a texture, the trail will draw the texture as its attachments move. 

![A trail with a pawprint texture.](https://developer.roblox.com/assets/5b3d51c779099e4b58a78818/TrailTexture.gif)

Textures can be displayed in a variety of different ways based on the trail's `TextureMode` and `TextureLength` properties.

## Code Samples

### Creating a Trail With a Pawprint Texture

This example adds a [pawprints][1] texture to a trail object. In order for a trail to have a texture, the Texture property must be set to the asset link of a roblox image.


  [1]: https://www.roblox.com/library/909814149/Paw-Prints
```lua
local trail = script.Parent
local textureId = "rbxassetid://909814149"
trail.Texture = textureId
```
 */
	Texture: string;
	/** This property determines how `Texture`s are drawn by `Trail`. The behavior of TextureLength is determined by the `TextureMode` of its trail.

If the TextureLength is changed after its trail has drawn some of its segments, the new length will only be applied to new segments being drawn -- old segments will be unaffected. 

This value can be any number greater than 0 and defaults to 1. */
	TextureLength: number;
	/** A `Trail`'s TextureMode property determines how the effect's `Texture` (if any) is drawn. The behavior of the texture in each mode is also very much dependent on the effect's `TextureLength` property. Note that changing an effect's TextureMode after some of the trail has been drawn will affect all of the previously drawn segments.

TextureMode defaults to *Stretch*

##Stretch
Stretch is the default TextureMode for Trails. In this mode the texture will be tiled a number of times equal to the number defined by TextureLength. It will stretch these tiles evenly to fit the entire length of the drawn trail. For example, if TextureLength is set to 4 then the texture will always repeat 4 times in the trail, no matter how long or short the trail is.

![Demonstrating a trail texture using the stretch mode.](https://developer.roblox.com/assets/5b3fe640cbdac88b0b7f2df2/TrailStretch.gif)

##Wrap
In the Wrap mode, the texture will start at the attachment points and will move as the attachments move. As soon as the attachments have moved a number of studs equal to the TextureLength, then the texture will repeat. The longer the trail is, the more times the texture will repeat.

![Demonstrating a trail texture using the wrap mode.](https://developer.roblox.com/assets/5b3fe686b496a3810b47f28e/TrailWrap.gif)

##Static
In the Static mode, the texture will start at the initial position of the trail and will be drawn as the attachments move. Once the attachments move a number of studs equal to the TextureLength, then the texture will repeat.

![Demonstrating a trail texture using the static mode.](https://developer.roblox.com/assets/5b3fe6ad277066700b7c3b05/TrailStatic.gif) */
	TextureMode: Enum.TextureMode;
	/** The Transparency property of a `Trail` sets how transparent the segments of the trail are over the trail's `Lifetime`. This value is a `NumberSequence`, meaning it can be a static value or can change throughout the lifetime of the trail segments.

The values in the NumberSequence can be any number, but the effective range of transparency is 0 (completely opaque) to 1 (completely see-through). The Transparency property for TrailEffects defaults to 0.5. */
	Transparency: NumberSequence;
	/** The WidthScale property is a `NumberSequence` that scales the width of the `Trail` over the course of its lifetime. 

This property can range from `0` to `1`. The value of the property influences the width of the trail by setting the trail's width to the product of:

    (distance between trail's attachment0 and attachment1 in studs) * (the value of WidthScale)
For example, if the trail's attachments are 2 stud's apart, and the value of this property is 0.5, the trail's width will be 1 stud and the trail will be centered in between the two attachments.

If you would like to hide the trail entirely, consider setting `Enabled` to false. */
	WidthScale: NumberSequence;
	/** The Clear function clears the segments of the `Trail`. This means that any trail that has been drawn will be erased when this function is called, even if that segment's `Lifetime` duration has not yet been reached.

While this is less noticeable for trails with shorter lifetimes, this is useful when cleaning up trails that have a longer lifetime, or for cases where the trail is removed when a certain game action occurs.

Note
----------

Calling this function will only affect old segments that have already been done. It will not affect the drawing of any new trail segments after this function call. If you would like to clear existing trail segments, and temporarily prevent new segments from being drawn, consider toggling the trail's `Enabled` property to false at the same time.

## Code Samples

### Clearing and Disabling a Trail

This example explains how to both clear a trail's drawn segments and disable the trail to prevent new segments from being drawn. New segments will not be drawn until the trails `Enabled` property is set to `true`.

In order for this example to be properly demonstrated, we must first create a `BasePart` that will be the parent of our trail.

Then, we create two attachments, *attachment0* and *attachment1*, both parented to *part*. The positions of these two attachments, more importantly the distance between them, determines where the trail is drawn as *part* moves.

For these attachments to create a trail as described, we create a new Trail and parent it to *part*. We then connect *attachment0* to `Attachment0` and *attachment1* to `Attachment1`. 

To demo that the `Clear` function erases any existing trail segments, the example relies on `TweenService`'s `Create` to move *part* back and forth to constantly draw a trail. Every 3 seconds of this motion, the trail segments are cleared and the trail is toggled between disabled and enabled. 

In order for the example to work properly, the example implements a function named `tweenPart` that tweens the part back and forth `15` studs.
```lua
-- The function that tweens the part back and forth 15 studs
local dir = 15
local TweenService = game:getService("TweenService")
function tweenPart(part)
	dir = dir*-1
	local goal = {}
	goal.Position = part.Position + Vector3.new(0,0,dir)
 
	local tweenInfo = TweenInfo.new(5)
	local tween = TweenService:Create(part, tweenInfo, goal)
 	tween:Play()

	wait(5)
end

-- Create a new BasePart
local part = Instance.new("Part")
part.Parent = game.Workspace
part.Anchored = true
part.Position = Vector3.new(0,5,0)

-- Create 2 attachments
local attachment0 = Instance.new("Attachment")
attachment0.Name = "Attachment0"
attachment0.Parent = part
attachment0.Position = Vector3.new(-2,0,0)

local attachment1 = Instance.new("Attachment")
attachment1.Name = "Attachment1"
attachment1.Parent = part
attachment1.Position = Vector3.new(2,0,0)

-- Create a new Trail
local trail = Instance.new("Trail")
trail.Parent = part
trail.Attachment0 = attachment0
trail.Attachment1 = attachment1
color1 = Color3.new(15/255,127/255,254/255)
color2 = Color3.new(255/255,255/255,255/255)
trail.Color = ColorSequence.new(color1, color2)

-- Tween part, clear trail segments, and toggle trail between enabled/disabled
while true do
	tweenPart(part)
	trail:Clear()
	trail.Enabled = not trail.Enabled
end
```
 */
	Clear(): void;
}

/** The **Translator** is an object used for getting display-ready localized text from a `LocalizationTable`. The source of the `LocaleId` property, the set of tables it will search, and order it will search them in depends on which method was used to create the Translator instance. */
interface Translator extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Translator";
	/** Describes the language that the Translator will translate to, as a locale-id.Describes the language that the Translator will translate to, as a locale-id.

Tags: ReadOnly, NotReplicated */
	readonly LocaleId: string;
	/** Returns the localized text string in a `LocalizationTable` based on its `Translator` locale, by key. The optional **args** table is used for filling format parameters in the matching text entry.

Note that this method will throw an error in the following cases:

* If none of the `LocalizationTables` available to this `Translator` include a value for the given key.
* If the `localization format format string` for the key uses numbered parameters and **args** is not an array.
* If the `localization format format string` uses named parameters and **args** is not a table of key-value pairs.
* If **args**
 is missing values for parameters that are used in the matching `localization format format string`.

See `utilizing localization Utilizing Localization APIs` for more details and usage examples of this function.
@param key The **Key** value to look up and translate.
@param args If the **Source** text and translations contain `articles/localization format strings|format strings`, a Lua table of values **or** <span class="text-nowrap">key-value</span> pairs, depending on whether the format strings are numbered or named. */
	FormatByKey(key: string, args?: any): string;
	/** Returns the localized text string in a `LocalizationTable` based on its `Translator` locale. This string will be in the context of the provided object, given the provided **Source** text.

See `utilizing localization Utilizing Localization APIs` for more details and usage examples of this function.

## Context OverridesIn some cases, duplicate **Source** strings may have completely different translations in other languages. For example, the English noun "Screen" can indicate both a computer screen and a window screen, but the Spanish translations are completely different:

| A | B | C | D | E |
| Key | Context | **Source** | Example | **es** |
|  |  | Screen |  | Pantalla |
|  |  | Screen |  | Mosquitero |
|  |  |  |  |  |

In these cases, the first argument to this function — a valid in-game
 `Instance`&nbsp;&mdash; can be used as a "tie&nbsp;breaker" when multiple GUI objects use the same source string. To implement this, specify the "path" to the `Instance` you'd like to override as the **Context** value of the translation data:

| A | B | C | D | E |
| Key | **Context** | Source | Example | es |
|  | workspace.ComputerScreen.SurfaceGui.TextLabel | Screen |  | Pantalla |
|  |  | Screen |  | Mosquitero |
|  |  |  |  |  |


Then, when calling this function in a script, pass the same `Instance` as the first argument, followed by the **Source** lookup text as the second argument:

```lua
local LocalizationService = game:GetService("LocalizationService")

local success, translator = pcall(function()
	return LocalizationService:GetTranslatorForPlayerAsync(game.Players.LocalPlayer)
end)

if success then
	local trans = translator:Translate(workspace.ComputerScreen.SurfaceGui.TextLabel, "Screen")
	print(trans)
else
	warn("Cannot load translator for player!")
end
```
@param context A valid <span class="text-nowrap">in-game</span> `Instance` to use for <a href="#translate-context-overrides">context&nbsp;override</a> as outlined above. Note that this argument can be arbitrary, for example `game`, if you don't require a context override.
@param text The **Source** text to look up and translate. */
	Translate(context: Instance, text: string): string;
}

interface RbxInternalTweenBase extends RbxInternalInstance {
	/** Read only property that shows the current playback `PlaybackState` of the `Tween`. PlaybackState is an Enum type variable with the following possible values.

 - Delayed - The tween is waiting to repeat due to the DelayTime property of the Tween's `TweenInfo`
 - Playing - The tween is playing normally
 - Paused - The tween has been paused 
 - Completed - The tween has completed successfully 
 - Cancelled - The tween has been cancelled

## Code Samples

### Tween PlaybackState

In this example a part is rotated by a Tween back and forth several times. The TweenInfo in this case is configured to make the tween repeat twice after the first playback and pause between each playback. A function is connected to when the tween’s PlaybackState changes. When run, this function will fire whenever the tween starts, pauses between playback, and ends.
```lua
local TweenService = game:GetService("TweenService")
 
local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local goal = {}
goal.Orientation = Vector3.new(0, 90, 0)
 
local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 2, true, 0.5)
 
local tween = TweenService:Create(part, tweenInfo, goal)
 
local function onPlaybackChanged()
	print("Tween status has changed to:", tween.PlaybackState)
end
 
local playbackChanged = tween:GetPropertyChangedSignal("PlaybackState")
playbackChanged:Connect(onPlaybackChanged)
 
tween:Play()
```
Read only property that shows the current playback `PlaybackState` of the `Tween`. PlaybackState is an Enum type variable with the following possible values.

 - Delayed - The tween is waiting to repeat due to the DelayTime property of the Tween's `TweenInfo`
 - Playing - The tween is playing normally
 - Paused - The tween has been paused 
 - Completed - The tween has completed successfully 
 - Cancelled - The tween has been cancelled

## Code Samples

### Tween PlaybackState

In this example a part is rotated by a Tween back and forth several times. The TweenInfo in this case is configured to make the tween repeat twice after the first playback and pause between each playback. A function is connected to when the tween’s PlaybackState changes. When run, this function will fire whenever the tween starts, pauses between playback, and ends.
```lua
local TweenService = game:GetService("TweenService")
 
local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local goal = {}
goal.Orientation = Vector3.new(0, 90, 0)
 
local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 2, true, 0.5)
 
local tween = TweenService:Create(part, tweenInfo, goal)
 
local function onPlaybackChanged()
	print("Tween status has changed to:", tween.PlaybackState)
end
 
local playbackChanged = tween:GetPropertyChangedSignal("PlaybackState")
playbackChanged:Connect(onPlaybackChanged)
 
tween:Play()
```


Tags: ReadOnly, NotReplicated */
	readonly PlaybackState: Enum.PlaybackState;
	/** The Cancel function halts playback of its `Tween` and resets the tween variables. If `Play` is called again the `Tween`'s properties will resume interpolating towards their destination but, as the tween variables have been reset, take the full length of the animation to do so.

Only the tween variables are reset, not the properties being changed by the tween. This means if you cancel a tween half way through its animation the properties will not reset to their original values. Where Cancel differs from `Pause` is that once resumed, it will take the full duration of the tween to complete the animation.

## Code Samples

### Tween Cancel

This sample demonstrates the impact of cancelling a tween.

A part is instanced in the Workspace and a tween is set up to move it along the Y axis. Mid way through the tween, it is cancelled. It can be observed here that the part does not return to its original position, but when it is resumed it takes the full length of the tween (5 seconds) to complete.

This is the key difference TweenBase:Pause() and TweenBase:Cancel().
```lua
local TweenService = game:GetService("TweenService")
 
local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local goal = {}
goal.Position = Vector3.new(0, 50, 0)

local tweenInfo = TweenInfo.new(5)
 
local tween = TweenService:Create(part, tweenInfo, goal)
 
tween:Play()
wait(2.5)
tween:Cancel()

local playTick = tick()
tween:Play()

tween.Completed:Wait()

local timeTaken = tick() - playTick
print("Tween took "..tostring(timeTaken).." secs to complete")

-- The tween will take 5 seconds to complete as the tween variables have been reset by tween:Cancel()
```
 */
	Cancel(): void;
	/** The Pause function halts playback of its `Tween`. However the progress variables of the tween will not be reset, meaning that when `Play` is called again the tween will resume playback from the moment it was paused. 

If a developer wishes to reset the progress variables of the tween, they should use `Cancel`.

This means a tween paused half way through its animation will take half of its duration to complete when resumed.

## Code Samples

### Pausing a Tween

This sample demonstrates how the playback of a tween can be paused and resumed.

A part is instanced in the Workspace and a tween is setup that will move it 50 studs along the X axis. However during playback the tween is briefly paused, then resumed. To further illustrate this the BrickColor of the part changes from red to green whilst it is paused.
```lua
local TweenService = game:GetService("TweenService")
 
local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.BrickColor = BrickColor.new("Bright green")
part.Parent = game.Workspace
 
local goal = {}
goal.Position = Vector3.new(50, 10, 0)
 
local tweenInfo = TweenInfo.new(10, Enum.EasingStyle.Linear)
 
local tween = TweenService:Create(part, tweenInfo, goal)
 
tween:Play()
 
wait(3)
part.BrickColor = BrickColor.new("Bright red")
tween:Pause()
 
wait(2)
part.BrickColor = BrickColor.new("Bright green")
tween:Play()
```
 */
	Pause(): void;
	/** The Play function starts the playback of its `Tween`. Note that if a tween has already begun calling Play will have no effect unless the tween has finished or has been stopped (either by `Cancel` or `Pause`).

Multiple tweens can be played on the same object at the same time, but they must not be animating the same property. If two tweens attempt to modify the same property, the initial tween will be cancelled and overwritten by the most recent tween (see examples).

## Code Samples

### Tween Conflict

This code sample includes a demonstration of tween conflict. A part is instanced in the Workspace, and two tweens are created that attempt to move the part in conflicting directions.

When both tweens are played, the first tween is cancelled and overwritten by the second tween. This can be seen as the part moves along the Y axis as opposed to the Z axis.

To further demonstrate this, connections have been made for both tweens to the Tween.Completed event. Upon playing the tweens, the following is printed.

    tween1: Enum.PlaybackState.Cancelled
    tween2: Enum.PlaybackState.Completed

These prints show that the first tween was cancelled (firing the Completed event) immediately upon the second tween being played. The second tween then went on to play until completion.
```lua
local TweenService = game:GetService("TweenService")

local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local tweenInfo = TweenInfo.new(5)

-- create two conflicting tweens (both trying to animate part.Position)
local tween1 = TweenService:Create(part, tweenInfo, {Position = Vector3.new(0, 10, 20)})
local tween2 = TweenService:Create(part, tweenInfo, {Position = Vector3.new(0, 30, 0)})

-- listen for their completion status
tween1.Completed:Connect(function(playbackState)
	print("tween1: "..tostring(playbackState))
end)
tween2.Completed:Connect(function(playbackState)
	print("tween2: "..tostring(playbackState))
end)

-- try to play them both
tween1:Play()
tween2:Play()
```

### Tween Creation

In this example a Tween is created to animate the position and color of a Part. Because the position and color are part of the same tween, they will change at the exact same rate and will reach their goal at the same time.
```lua
local TweenService = game:GetService("TweenService")
 
local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Color = Color3.new(1, 0, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local goal = {}
goal.Position = Vector3.new(10, 10, 0)
goal.Color = Color3.new(0, 1, 0)
 
local tweenInfo = TweenInfo.new(5)
 
local tween = TweenService:Create(part, tweenInfo, goal)
 
tween:Play()
```
 */
	Play(): void;
	/** The Completed event of a `Tween` fires when the tween finishes playing. This will happen either when the tween naturally finishes playing, or if it is stopped with `Cancel`.

A function connected to this event will be passed the PlaybackState of the tween when it finished to give indication about why the tween ended. If the tween finishes naturally the status will be Completed, if cancelled then the state will be Cancelled. Note that calling `Pause` will not fire the Completed event.

## Code Samples

### Tween Conflict

This code sample includes a demonstration of tween conflict. A part is instanced in the Workspace, and two tweens are created that attempt to move the part in conflicting directions.

When both tweens are played, the first tween is cancelled and overwritten by the second tween. This can be seen as the part moves along the Y axis as opposed to the Z axis.

To further demonstrate this, connections have been made for both tweens to the Tween.Completed event. Upon playing the tweens, the following is printed.

    tween1: Enum.PlaybackState.Cancelled
    tween2: Enum.PlaybackState.Completed

These prints show that the first tween was cancelled (firing the Completed event) immediately upon the second tween being played. The second tween then went on to play until completion.
```lua
local TweenService = game:GetService("TweenService")

local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local tweenInfo = TweenInfo.new(5)

-- create two conflicting tweens (both trying to animate part.Position)
local tween1 = TweenService:Create(part, tweenInfo, {Position = Vector3.new(0, 10, 20)})
local tween2 = TweenService:Create(part, tweenInfo, {Position = Vector3.new(0, 30, 0)})

-- listen for their completion status
tween1.Completed:Connect(function(playbackState)
	print("tween1: "..tostring(playbackState))
end)
tween2.Completed:Connect(function(playbackState)
	print("tween2: "..tostring(playbackState))
end)

-- try to play them both
tween1:Play()
tween2:Play()
```

### Verifying a Tween has Completed

This code sample includes an example of how Tween.Completed can be used to determine if a Tween has been successfully completed, or cancelled.

In this case a part is instanced and tweened towards 0, 0, 0. Once the tween has completed, if the final PlaybackState is Completed then the part will explode. Were the tween to be cancelled prior to completion, the explosion would not be created.

This method can be used to link tweens to other effects, or even chain several tweens to play after each other.
```lua
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

local part = Instance.new("Part")
part.Position = Vector3.new(0, 50, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local goal = {}
goal.Position = Vector3.new(0, 0, 0)
 
local tweenInfo = TweenInfo.new(3)
 
local tween = TweenService:Create(part, tweenInfo, goal)

tween.Completed:Connect(function(playbackState)
	if playbackState == Enum.PlaybackState.Completed then
		local explosion = Instance.new("Explosion")
		explosion.Position = part.Position 
		explosion.Parent = game.Workspace 
		part:Destroy()
		Debris:AddItem(explosion, 2)
	end
end)
 
tween:Play()
```

### Tween Completed

In this example the walkspeed of any player joining the game will be slowed to 0 over 10 seconds using a Tween. The Completed event is used to reset the walkspeed after the Tween has finished playing.
```lua
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
 
local SLOW_DURATION = 10
 
local function slowCharacter(humanoid)
	local goal = {}
	goal.WalkSpeed = 0
 
	local tweenInfo = TweenInfo.new(SLOW_DURATION)	
 
	local tweenSpeed = TweenService:Create(humanoid, tweenInfo, goal)
 
	tweenSpeed:Play()
 
	return tweenSpeed
end
 
local function onCharacterAdded(character)
	local humanoid = character:WaitForChild("Humanoid")
	local initialSpeed = humanoid.WalkSpeed
	local tweenSpeed = slowCharacter(humanoid)
	tweenSpeed.Completed:Wait()
	humanoid.WalkSpeed = initialSpeed
end
 
local function onPlayerAdded(player)
	player.CharacterAdded:Connect(onCharacterAdded)
end
 
Players.PlayerAdded:Connect(onPlayerAdded)
```
 */
	readonly Completed: RBXScriptSignal<(playbackState: Enum.PlaybackState) => void>;
}
/** The base class for in-between interpolation handlers. */
type TweenBase = Tween;

/** Tweens are used to interpolate the properties of instances. The Tween object itself controls the playback of the interpolation. Creating and configuring tweens is done with the `Create` function. This is the only way to create tweens. Instance.new cannot be used for this particular object.

Note that while the configuration of a tween can be accessed after a tween has been created, it can not be modified. If new goals are needed for interpolation, a new tween must be created. Further information on how to create Tweens can be found on the `TweenService` page.

Multiple tweens can be played on the same object at the same time, but they must not be animating the same property. If two tweens attempt to modify the same property, the initial tween will be cancelled and overwritten by the most recent tween (see examples).

Although other methods exist for tweening objects, such as `TweenSizeAndPosition`, Tweens allows multiple properties to be modified and for the animation to be paused and cancelled at any point.

## Code Samples

### Tween Conflict

This code sample includes a demonstration of tween conflict. A part is instanced in the Workspace, and two tweens are created that attempt to move the part in conflicting directions.

When both tweens are played, the first tween is cancelled and overwritten by the second tween. This can be seen as the part moves along the Y axis as opposed to the Z axis.

To further demonstrate this, connections have been made for both tweens to the Tween.Completed event. Upon playing the tweens, the following is printed.

    tween1: Enum.PlaybackState.Cancelled
    tween2: Enum.PlaybackState.Completed

These prints show that the first tween was cancelled (firing the Completed event) immediately upon the second tween being played. The second tween then went on to play until completion.
```lua
local TweenService = game:GetService("TweenService")

local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local tweenInfo = TweenInfo.new(5)

-- create two conflicting tweens (both trying to animate part.Position)
local tween1 = TweenService:Create(part, tweenInfo, {Position = Vector3.new(0, 10, 20)})
local tween2 = TweenService:Create(part, tweenInfo, {Position = Vector3.new(0, 30, 0)})

-- listen for their completion status
tween1.Completed:Connect(function(playbackState)
	print("tween1: "..tostring(playbackState))
end)
tween2.Completed:Connect(function(playbackState)
	print("tween2: "..tostring(playbackState))
end)

-- try to play them both
tween1:Play()
tween2:Play()
```

### Tween Creation

In this example a Tween is created to animate the position and color of a Part. Because the position and color are part of the same tween, they will change at the exact same rate and will reach their goal at the same time.
```lua
local TweenService = game:GetService("TweenService")
 
local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Color = Color3.new(1, 0, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local goal = {}
goal.Position = Vector3.new(10, 10, 0)
goal.Color = Color3.new(0, 1, 0)
 
local tweenInfo = TweenInfo.new(5)
 
local tween = TweenService:Create(part, tweenInfo, goal)
 
tween:Play()
```
 */
interface Tween extends RbxInternalTweenBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Tween";
	/** The Instance property of a `Tween` points to the `Instance` whose properties are being interpolated by the tween. As with all `Tween` properties, the Instance property is read only. If a developer wants to tween a different instance they must create a new `Tween` using `Create`.

## Code Samples

### Tween Instance

This code sample includes a simple function that will return true if the instance of a tween is a Part.
```lua
local function isInstanceAPart(tween)
	local instance = tween.Instance
	return instance:IsA("BasePart")
end
```
The Instance property of a `Tween` points to the `Instance` whose properties are being interpolated by the tween. As with all `Tween` properties, the Instance property is read only. If a developer wants to tween a different instance they must create a new `Tween` using `Create`.

## Code Samples

### Tween Instance

This code sample includes a simple function that will return true if the instance of a tween is a Part.
```lua
local function isInstanceAPart(tween)
	local instance = tween.Instance
	return instance:IsA("BasePart")
end
```


Tags: ReadOnly, NotReplicated */
	readonly Instance?: Instance;
	/** Read-only property that includes information on how the interpolation of the `Tween` is to be carried out, using the `TweenInfo` data type. The TweenInfo data type includes a range of properties that can be used to achieve various styles of animation, including reversing and looping `Tween`s (see examples). 

As with all `Tween` properties, the TweenInfo property is read only. If a developer wants to modify the TweenInfo of a Tween they must create a new `Tween` using `Create`.

## Code Samples

### TweenInfo Examples

An example of the range of different interpolation effects that can be used in Tweens.
```lua
-- A TweenInfo with all default parameters
local default = TweenInfo.new() 
 
-- A TweenInfo with its time set to 0.5 seconds.
local timeChanged = TweenInfo.new(0.5) 
 
-- A TweenInfo with its easing style set to Back.
local easingStyled = TweenInfo.new(0.5, Enum.EasingStyle.Back) 
 
-- A TweenInfo with its easing direction set to In.
local easingDirected = TweenInfo.new(0.5, Enum.EasingStyle.Back,  Enum.EasingDirection.In) 
 
-- A TweenInfo that repeats itself 4 times.
local repeated = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In, 4) 
 
-- A TweenInfo that reverses its interpolation after reaching its goal.
local reverses = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In, 4, true)

-- A TweenInfo that loops indefinitely.
local reverses = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In, -1, true)
 
-- A TweenInfo with a delay of 1 second between each interpolation.
local delayed = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In, 4, true, 1)
```

### Looping a Tween

This code sample includes an example of how a looped tween can be created.

A part is instanced in the Workspace, and a Tween is created using TweenService:Create that is set to animate it's position along the Y axis. The looped effect is achieved by modifying the TweenInfo used in TweenService:Create. Specifically, when RepeatCount is set to be less than 0 the tween will play indefinitely. Also, setting Reverses to true will cause the tween to play in reverse once it has reached it's destination. In combination this creates a looped effect.

The correct way to make a tween play indefinitely is to set RepeatCount to -1. Developers should avoid using large numbers (or math.huge) as a substitute as this is unstable and may stop working at any point.
```lua
local TweenService = game:GetService("TweenService")

local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local tweenInfo = TweenInfo.new(
	2, -- Time
	Enum.EasingStyle.Linear, -- EasingStyle
	Enum.EasingDirection.Out, -- EasingDirection
	-1, -- RepeatCount (when less than zero the tween will loop indefinitely)
	true, -- Reverses (tween will reverse once reaching it's goal)
	0 -- DelayTime
)

local tween = TweenService:Create(part, tweenInfo, {Position = Vector3.new(0, 30, 0)})

tween:Play()
wait(10)
tween:Cancel() -- cancel the animation after 10 seconds
```
Read-only property that includes information on how the interpolation of the `Tween` is to be carried out, using the `TweenInfo` data type. The TweenInfo data type includes a range of properties that can be used to achieve various styles of animation, including reversing and looping `Tween`s (see examples). 

As with all `Tween` properties, the TweenInfo property is read only. If a developer wants to modify the TweenInfo of a Tween they must create a new `Tween` using `Create`.

## Code Samples

### TweenInfo Examples

An example of the range of different interpolation effects that can be used in Tweens.
```lua
-- A TweenInfo with all default parameters
local default = TweenInfo.new() 
 
-- A TweenInfo with its time set to 0.5 seconds.
local timeChanged = TweenInfo.new(0.5) 
 
-- A TweenInfo with its easing style set to Back.
local easingStyled = TweenInfo.new(0.5, Enum.EasingStyle.Back) 
 
-- A TweenInfo with its easing direction set to In.
local easingDirected = TweenInfo.new(0.5, Enum.EasingStyle.Back,  Enum.EasingDirection.In) 
 
-- A TweenInfo that repeats itself 4 times.
local repeated = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In, 4) 
 
-- A TweenInfo that reverses its interpolation after reaching its goal.
local reverses = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In, 4, true)

-- A TweenInfo that loops indefinitely.
local reverses = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In, -1, true)
 
-- A TweenInfo with a delay of 1 second between each interpolation.
local delayed = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.In, 4, true, 1)
```

### Looping a Tween

This code sample includes an example of how a looped tween can be created.

A part is instanced in the Workspace, and a Tween is created using TweenService:Create that is set to animate it's position along the Y axis. The looped effect is achieved by modifying the TweenInfo used in TweenService:Create. Specifically, when RepeatCount is set to be less than 0 the tween will play indefinitely. Also, setting Reverses to true will cause the tween to play in reverse once it has reached it's destination. In combination this creates a looped effect.

The correct way to make a tween play indefinitely is to set RepeatCount to -1. Developers should avoid using large numbers (or math.huge) as a substitute as this is unstable and may stop working at any point.
```lua
local TweenService = game:GetService("TweenService")

local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local tweenInfo = TweenInfo.new(
	2, -- Time
	Enum.EasingStyle.Linear, -- EasingStyle
	Enum.EasingDirection.Out, -- EasingDirection
	-1, -- RepeatCount (when less than zero the tween will loop indefinitely)
	true, -- Reverses (tween will reverse once reaching it's goal)
	0 -- DelayTime
)

local tween = TweenService:Create(part, tweenInfo, {Position = Vector3.new(0, 30, 0)})

tween:Play()
wait(10)
tween:Cancel() -- cancel the animation after 10 seconds
```


Tags: ReadOnly, NotReplicated */
	readonly TweenInfo: TweenInfo;
}

/** Tweens are used to interpolate the properties of instances. These can be used to create animations for various Roblox objects. Almost any numeric property can be tweened using TweenService. Note that only specific types of properties can be used with TweenService. The types of properties that can be tweened are:

 - number 
 - bool
 - `CFrame`
 - `Rect`
 - `Color3`
 - `UDim`
 - `UDim2`
 - `Vector2`
 - `Vector2int16`
 - `Vector3`

TweenService has just one function, `Create`, which takes information about the animation and generates the `Tween` object which can be used to play the animation. Note that `Tween`s can animate multiple properties at the same time.

Details on how the interpolation of the tween is to be carried out are given in the tweenInfo parameter of `Create`. The `TweenInfo` data type includes a range of properties that can be used to achieve various styles of animation, including reversing and looping `Tween`s (see examples). 

Multiple tweens can be played on the same object at the same time, but they must not be animating the same property. If two tweens attempt to modify the same property, the initial tween will be cancelled and overwritten by the most recent tween (see examples).

Although other methods exist for tweening objects, such as `TweenSizeAndPosition`, TweenService allows multiple properties to be modified and for the animation to be paused and cancelled at any point.

## Code Samples

### Tween Conflict

This code sample includes a demonstration of tween conflict. A part is instanced in the Workspace, and two tweens are created that attempt to move the part in conflicting directions.

When both tweens are played, the first tween is cancelled and overwritten by the second tween. This can be seen as the part moves along the Y axis as opposed to the Z axis.

To further demonstrate this, connections have been made for both tweens to the Tween.Completed event. Upon playing the tweens, the following is printed.

    tween1: Enum.PlaybackState.Cancelled
    tween2: Enum.PlaybackState.Completed

These prints show that the first tween was cancelled (firing the Completed event) immediately upon the second tween being played. The second tween then went on to play until completion.
```lua
local TweenService = game:GetService("TweenService")

local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local tweenInfo = TweenInfo.new(5)

-- create two conflicting tweens (both trying to animate part.Position)
local tween1 = TweenService:Create(part, tweenInfo, {Position = Vector3.new(0, 10, 20)})
local tween2 = TweenService:Create(part, tweenInfo, {Position = Vector3.new(0, 30, 0)})

-- listen for their completion status
tween1.Completed:Connect(function(playbackState)
	print("tween1: "..tostring(playbackState))
end)
tween2.Completed:Connect(function(playbackState)
	print("tween2: "..tostring(playbackState))
end)

-- try to play them both
tween1:Play()
tween2:Play()
```

### Pausing a Tween

This sample demonstrates how the playback of a tween can be paused and resumed.

A part is instanced in the Workspace and a tween is setup that will move it 50 studs along the X axis. However during playback the tween is briefly paused, then resumed. To further illustrate this the BrickColor of the part changes from red to green whilst it is paused.
```lua
local TweenService = game:GetService("TweenService")
 
local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.BrickColor = BrickColor.new("Bright green")
part.Parent = game.Workspace
 
local goal = {}
goal.Position = Vector3.new(50, 10, 0)
 
local tweenInfo = TweenInfo.new(10, Enum.EasingStyle.Linear)
 
local tween = TweenService:Create(part, tweenInfo, goal)
 
tween:Play()
 
wait(3)
part.BrickColor = BrickColor.new("Bright red")
tween:Pause()
 
wait(2)
part.BrickColor = BrickColor.new("Bright green")
tween:Play()
```

### Looping a Tween

This code sample includes an example of how a looped tween can be created.

A part is instanced in the Workspace, and a Tween is created using TweenService:Create that is set to animate it's position along the Y axis. The looped effect is achieved by modifying the TweenInfo used in TweenService:Create. Specifically, when RepeatCount is set to be less than 0 the tween will play indefinitely. Also, setting Reverses to true will cause the tween to play in reverse once it has reached it's destination. In combination this creates a looped effect.

The correct way to make a tween play indefinitely is to set RepeatCount to -1. Developers should avoid using large numbers (or math.huge) as a substitute as this is unstable and may stop working at any point.
```lua
local TweenService = game:GetService("TweenService")

local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local tweenInfo = TweenInfo.new(
	2, -- Time
	Enum.EasingStyle.Linear, -- EasingStyle
	Enum.EasingDirection.Out, -- EasingDirection
	-1, -- RepeatCount (when less than zero the tween will loop indefinitely)
	true, -- Reverses (tween will reverse once reaching it's goal)
	0 -- DelayTime
)

local tween = TweenService:Create(part, tweenInfo, {Position = Vector3.new(0, 30, 0)})

tween:Play()
wait(10)
tween:Cancel() -- cancel the animation after 10 seconds
```

### Tween Creation

In this example a Tween is created to animate the position and color of a Part. Because the position and color are part of the same tween, they will change at the exact same rate and will reach their goal at the same time.
```lua
local TweenService = game:GetService("TweenService")
 
local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Color = Color3.new(1, 0, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local goal = {}
goal.Position = Vector3.new(10, 10, 0)
goal.Color = Color3.new(0, 1, 0)
 
local tweenInfo = TweenInfo.new(5)
 
local tween = TweenService:Create(part, tweenInfo, goal)
 
tween:Play()
```
 */
interface TweenService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "TweenService";
	/** The Create function of `TweenService` creates a new Tween. The function takes three arguments: the object to tween, the `TweenInfo` to use, and a table containing the properties to tween and the values to tween to.

Tweens are used to interpolate the properties of instances. These can be used to create animations for various Roblox objects. Almost any numeric property can be tweened using `TweenService`. 

The propertyTable parameter that is passed in needs to be a dictionary where the keys are the string names of the property (e.g. “Position”, “Transparency”, “Color”, etc), and the value is the value the property needs to be at the end of the tween. Note that only specific types of properties can be used with `TweenService`, but multiple properties can be animated in the same tween. The types of properties that can be tweened are:

 - number 
 - bool
 - `CFrame`
 - `Rect`
 - `Color3`
 - `UDim`
 - `UDim2`
 - `Vector2`
 - `Vector2int16`
 - `Vector3`

The `Tween` created using this function is unique to the object given as the instance parameter. If a developer wishes to apply the same tween effect to another instance, another `Tween` will need to be created.

Details on how the interpolation of the tween is to be carried out are given in the tweenInfo parameter. The `TweenInfo` data type includes a range of properties that can be used to achieve various styles of animation, including reversing and looping `Tween`s (see examples).

## Code Samples

### Looping a Tween

This code sample includes an example of how a looped tween can be created.

A part is instanced in the Workspace, and a Tween is created using TweenService:Create that is set to animate it's position along the Y axis. The looped effect is achieved by modifying the TweenInfo used in TweenService:Create. Specifically, when RepeatCount is set to be less than 0 the tween will play indefinitely. Also, setting Reverses to true will cause the tween to play in reverse once it has reached it's destination. In combination this creates a looped effect.

The correct way to make a tween play indefinitely is to set RepeatCount to -1. Developers should avoid using large numbers (or math.huge) as a substitute as this is unstable and may stop working at any point.
```lua
local TweenService = game:GetService("TweenService")

local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local tweenInfo = TweenInfo.new(
	2, -- Time
	Enum.EasingStyle.Linear, -- EasingStyle
	Enum.EasingDirection.Out, -- EasingDirection
	-1, -- RepeatCount (when less than zero the tween will loop indefinitely)
	true, -- Reverses (tween will reverse once reaching it's goal)
	0 -- DelayTime
)

local tween = TweenService:Create(part, tweenInfo, {Position = Vector3.new(0, 30, 0)})

tween:Play()
wait(10)
tween:Cancel() -- cancel the animation after 10 seconds
```

### Tween Creation

In this example a Tween is created to animate the position and color of a Part. Because the position and color are part of the same tween, they will change at the exact same rate and will reach their goal at the same time.
```lua
local TweenService = game:GetService("TweenService")
 
local part = Instance.new("Part")
part.Position = Vector3.new(0, 10, 0)
part.Color = Color3.new(1, 0, 0)
part.Anchored = true
part.Parent = game.Workspace
 
local goal = {}
goal.Position = Vector3.new(10, 10, 0)
goal.Color = Color3.new(0, 1, 0)
 
local tweenInfo = TweenInfo.new(5)
 
local tween = TweenService:Create(part, tweenInfo, goal)
 
tween:Play()
```

@param instance The `Instance` whose properties are to be tweened.
@param tweenInfo The `DataType/TweenInfo` to be used.
@param propertyTable A dictionary of properties, and their target values, to be tweened.
@returns The `Tween` created. */
	Create<T extends Instances[keyof Instances]>(
		instance: T,
		tweenInfo: TweenInfo,
		propertyTable: Partial<FilterMembers<T, Tweenable>>,
	): Tween;

	GetValue(alpha: number, easingStyle: CastsToEnum<Enum.EasingStyle>, easingDirection: CastsToEnum<Enum.EasingDirection>): number;
}

interface RbxInternalUIBase extends RbxInternalInstance {}
/** UIBase is the base class for UI layout and constraint classes. */
type UIBase = UIComponent;

interface RbxInternalUIComponent extends RbxInternalUIBase {}
/** A base class for UI constraint and layout classes, inherits from `UiBase`. */
type UIComponent = UIConstraint | UILayout | UIPadding | UIScale;

interface RbxInternalUIConstraint extends RbxInternalUIComponent {}
/** The base class for UI constraint classes. */
type UIConstraint = UIAspectRatioConstraint | UISizeConstraint | UITextSizeConstraint;

/** A UIAspectRatioConstraint ensures that the parent UI element (`GuiObject`) maintains a particular aspect ratio even if its size is set as a percentage of its parent. If an object with this constraint is also under the control of a `UILayout` such as `UIGridLayout`, then the constraint controls the objects size and overwrites any size the layout would apply.

When applied to a GuiObject, the UIAspectRatioConstraint will make sure that the objects ratio is maintained by the value defined in `AspectRatio`. The `AspectType` sets what determines the maximum size of the object. When set to `FitWithinMaxSize`, the constraint will make the object the maximum size it can be within the `/GuiObject` of the element. When set to ScaleWithParentSize, the elements maximum size will be the size of the parent while still maintaining the aspect ratio. Finally, the `DominantAxis` will determine which axis to use when setting the new size of the element. */
interface UIAspectRatioConstraint extends RbxInternalUIConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UIAspectRatioConstraint";
	/** AspectRatio determines the width-to-height ratio to maintain. To flip the ratio to height-to-width, take the inverse (divide 1 by the number or raise to the -1st power). This value must be greater than zero. Below, a white `Frame` is placed within the a black `Frame` with two different width-to-height ratios.

![A width-to-height ratio of 0.8](https://developer.roblox.com/assets/bltb4147bb1d3de0224/UIAspectRatioConstraint_Ratio_0.8.png)![A width-to-height ratio of 1.25](https://developer.roblox.comundefined)


  
  [2]: https://images.contentstack.io/v3/assets/blt309cc8bfb280dcec/blt9874bdf1824f7688/5af8c4f8a3fbc195609fc267/UIAspectRatioConstraint_Ratio_1.25.png */
	AspectRatio: number;
	/** AspectType determines what limits the maximum size of the element.

   - When set to FitWithinMaxSize, the constraint will make the object the maximum size it can be within its own `AbsoluteSize`.
  - When set to ScaleWithParentSize, the UI element's maximum size will be the size of the parent while still maintaining the aspect ratio.. */
	AspectType: Enum.AspectType;
	/** DominantAxis determines which axis to use when setting the new size of the UI element if it would otherwise exceed the size of the parent. */
	DominantAxis: Enum.DominantAxis;
}

/** The UISizeConstraint ensures a `GuiObject` does not become larger or smaller than the `MaxSize` and `MinSize`. 

For example, if the MaxSize is set to `{200, 200}` and the MinSize is set to `{100, 100}`, then the constrained GuiObject cannot scale to be larger than 200 pixels wide and 200 pixels tall or smaller than 100 pixels wide and 100 pixels tall.

If the object with this constraint is also under the control of a `UILayout` such as `UIGridLayout`, then the constraint determines the objects size and overwrites any size the layout would apply.

A UISizeConstraint can be applied to a GuiObject by parenting it to that object. */
interface UISizeConstraint extends RbxInternalUIConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UISizeConstraint";
	/** The largest size in pixels the object is allowed to be. The X and Y of this value must be greater than or equal to the corresponding components of `MinSize`. */
	MaxSize: Vector2;
	/** The smallest size in pixels the object is allowed to be. The X and Y of this value must be less than or equal to the corresponding components of `MaxSize`. */
	MinSize: Vector2;
}

/** Ensures a `GuiObject` with text (such as a `TextLabel` or `TextButton` does let the font size of its text become larger or smaller than the `MaxTextSize` and `MinTextSize`.

A UITextSizeConstraint can be applied to a GuiObject by parenting it to that object. */
interface UITextSizeConstraint extends RbxInternalUIConstraint {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UITextSizeConstraint";
	/** (default 1000)
The largest size in pixels the font is allowed to be. This value must be set larger than or equal to `MinTextSize`.The largest size in pixels the font is allowed to be. */
	MaxTextSize: number;
	/** (default 1)
The smallest size in pixels the font is allowed to be. This value must be set less than or equal to `MaxTextSize`.The smallest size in pixels the font is allowed to be. */
	MinTextSize: number;
}

interface RbxInternalUILayout extends RbxInternalUIComponent {}
/** The base class for UI layout classes. */
type UILayout = UIGridStyleLayout;

interface RbxInternalUIGridStyleLayout extends RbxInternalUILayout {
	/** The AbsoluteContentSize property of a `UIGridStyleLayout` shows how much space the elements of the grid are taking up, including any padding created by the grid. This property is particularly useful to size containers of grids such as `Frame`s and Frame to make sure they aren't any larger than the grid itself.

It updates as soon as it's read. It won't fire a changed event immediately after the UI has changed, but if the value is read it will be up to date. A `Changed` event should fire on the next render step.

## Code Samples

### Tracking AbsoluteContentSize Changes

In this example a UIGridLayout is created inside of a `ScrollingFrame`. To make sure the `CanvasSize` is exactly the size it needs to be to contain the grid, a function is connected to the grids `GetPropertyChangedSignal` to listen for when the AbsoluteContentSize of the grid changes, and sets the canvas size accordingly.
```lua
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local screen = Instance.new("ScreenGui")
screen.Parent = playerGui

local scrollingFrame = Instance.new("ScrollingFrame")
scrollingFrame.Parent = screen
scrollingFrame.AnchorPoint = Vector2.new(0.5, 0.5)
scrollingFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
scrollingFrame.Size = UDim2.new(0, 412, 0, 300)

local grid = Instance.new("UIGridLayout")
grid.CellPadding = UDim2.new(0, 0, 0, 0)
grid.CellSize = UDim2.new(0, 100, 0, 100)
grid.Parent = scrollingFrame

local function onContentSizeChanged()
	local absoluteSize = grid.AbsoluteContentSize
	scrollingFrame.CanvasSize = UDim2.new(0, absoluteSize.X, 0, absoluteSize.Y)
end

grid:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(onContentSizeChanged)

for x = 1, 10 do
	for y = 1, 4 do
		local button = Instance.new("TextButton")
		button.Text = x .. ", " .. y
		button.Parent = scrollingFrame
	end
end
```
The AbsoluteContentSize property of a `UIGridStyleLayout` shows how much space the elements of the grid are taking up, including any padding created by the grid. This property is particularly useful to size containers of grids such as `Frame`s and Frame to make sure they aren't any larger than the grid itself.

It updates as soon as it's read. It won't fire a changed event immediately after the UI has changed, but if the value is read it will be up to date. A `Changed` event should fire on the next render step.

## Code Samples

### Tracking AbsoluteContentSize Changes

In this example a UIGridLayout is created inside of a `ScrollingFrame`. To make sure the `CanvasSize` is exactly the size it needs to be to contain the grid, a function is connected to the grids `GetPropertyChangedSignal` to listen for when the AbsoluteContentSize of the grid changes, and sets the canvas size accordingly.
```lua
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local screen = Instance.new("ScreenGui")
screen.Parent = playerGui

local scrollingFrame = Instance.new("ScrollingFrame")
scrollingFrame.Parent = screen
scrollingFrame.AnchorPoint = Vector2.new(0.5, 0.5)
scrollingFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
scrollingFrame.Size = UDim2.new(0, 412, 0, 300)

local grid = Instance.new("UIGridLayout")
grid.CellPadding = UDim2.new(0, 0, 0, 0)
grid.CellSize = UDim2.new(0, 100, 0, 100)
grid.Parent = scrollingFrame

local function onContentSizeChanged()
	local absoluteSize = grid.AbsoluteContentSize
	scrollingFrame.CanvasSize = UDim2.new(0, absoluteSize.X, 0, absoluteSize.Y)
end

grid:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(onContentSizeChanged)

for x = 1, 10 do
	for y = 1, 4 do
		local button = Instance.new("TextButton")
		button.Text = x .. ", " .. y
		button.Parent = scrollingFrame
	end
end
```


Tags: ReadOnly, NotReplicated */
	readonly AbsoluteContentSize: Vector2;
	/** The FillDirection property determines the axis in which UI elements are laid out. Horizontal will arrange elements from left to right, while Vertical will arrange from top to bottom. To reverse elements (for instance, arrange right to left) you will need to reverse the sorting. This can be done by negating the child UI elements' `LayoutOrder` values when `SortOrder` is set to LayoutOrder.

## Code Samples

### UIGridLayout Fill Directions and Alignments

This code sample showcases the different alignments and fill directions that a UIGridLayout may use by iterating over the three enums using for loops.
```lua
-- Place me in a UIListLayout
local uiGridLayout = script.Parent

while true do
	for k, fillDirection in pairs(Enum.FillDirection:GetEnumItems()) do
		uiGridLayout.FillDirection = fillDirection
		for k2, verticalAlignment in pairs(Enum.VerticalAlignment:GetEnumItems()) do
			uiGridLayout.VerticalAlignment = verticalAlignment
			for k3, horizontalAlignment in pairs(Enum.HorizontalAlignment:GetEnumItems()) do
				uiGridLayout.HorizontalAlignment = horizontalAlignment
				wait(1)
			end
		end
	end
end

```
 */
	FillDirection: Enum.FillDirection;
	/** The HorizontalAlignment property determines the X-axis alignment of the laid-out grid of UI elements, much like `TextXAlignment` does with `Text`.

## Code Samples

### UIGridLayout Fill Directions and Alignments

This code sample showcases the different alignments and fill directions that a UIGridLayout may use by iterating over the three enums using for loops.
```lua
-- Place me in a UIListLayout
local uiGridLayout = script.Parent

while true do
	for k, fillDirection in pairs(Enum.FillDirection:GetEnumItems()) do
		uiGridLayout.FillDirection = fillDirection
		for k2, verticalAlignment in pairs(Enum.VerticalAlignment:GetEnumItems()) do
			uiGridLayout.VerticalAlignment = verticalAlignment
			for k3, horizontalAlignment in pairs(Enum.HorizontalAlignment:GetEnumItems()) do
				uiGridLayout.HorizontalAlignment = horizontalAlignment
				wait(1)
			end
		end
	end
end

```
 */
	HorizontalAlignment: Enum.HorizontalAlignment;
	/** The SortOrder property determines the next UI element to be placed in a layout. For Name, a simple alphabetic sort is used on the Name property of the child UI elements. For LayoutOrder, a low-to-high sort is used on the `LayoutOrder` property of child UI elements. If two share the same `LayoutOrder`, whichever was added sooner to the parent object takes precedence. An easy way to reverse the sorting order is to negate LayoutOrder.

## Code Samples

### UI Sort Order

This code sample demonstrates sorting data using `SortOrder` and `LayoutOrder`.
```lua
-- Place in a script in a UIListLayout
local uiGridLayout = script.Parent

-- Some data to work with
local scores = {
	["Player1"] = 2048;
	["Ozzypig"] = 1337;
	["Shedletsky"] = 1250;
	["Builderman"] = 1000;  
}

-- Build a scoreboard
for name, score in pairs(scores) do
	local tl = Instance.new("TextLabel")
	tl.Text = name .. ": " .. score
	tl.Parent = script.Parent
	tl.LayoutOrder = -score -- We want higher scores first, so negate for descending order
	tl.Name = name
	tl.Size = UDim2.new(0, 200, 0, 50)
	tl.Parent = uiGridLayout.Parent
end

while true do
	-- The name is the player's name
	uiGridLayout.SortOrder = Enum.SortOrder.Name
	uiGridLayout:ApplyLayout()
	wait(2)
	-- Since we set the LayoutOrder to the score, this will sort by descending score!
	uiGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
	uiGridLayout:ApplyLayout()
	wait(2)
end
```
 */
	SortOrder: Enum.SortOrder;
	/** The VerticalAlignment property determines the Y-axis alignment of the laid-out grid of UI elements, much like `TextYAlignment` does with `Text`.

## Code Samples

### UIGridLayout Fill Directions and Alignments

This code sample showcases the different alignments and fill directions that a UIGridLayout may use by iterating over the three enums using for loops.
```lua
-- Place me in a UIListLayout
local uiGridLayout = script.Parent

while true do
	for k, fillDirection in pairs(Enum.FillDirection:GetEnumItems()) do
		uiGridLayout.FillDirection = fillDirection
		for k2, verticalAlignment in pairs(Enum.VerticalAlignment:GetEnumItems()) do
			uiGridLayout.VerticalAlignment = verticalAlignment
			for k3, horizontalAlignment in pairs(Enum.HorizontalAlignment:GetEnumItems()) do
				uiGridLayout.HorizontalAlignment = horizontalAlignment
				wait(1)
			end
		end
	end
end

```
 */
	VerticalAlignment: Enum.VerticalAlignment;
}
/** The base class for grid style UI layouts. */
type UIGridStyleLayout = UIGridLayout | UIListLayout | UIPageLayout | UITableLayout;

/** A UIGridLayout (not to be confused with the abstract `UIGridStyleLayout` from which this class inherits) lays out sibling UI elements in multiple rows within the parent UI element, adding elements to a row one-by-one until the next element would not fit. It then continues adding elements in the next row. A UIGridLayout will take UI elements' `Size` and `Position` under control. While under control, these UI elements' properties will not be editable in the Properties window.

![A UIGridLayout arranging inventory slots in a grid](https://developer.roblox.com/assets/bltb9ddab50d7fdebee/UIGridLayout.png)

By default, it lays out elements from left-to-right, top-to-bottom in **alphabetical** order, but this can be changed to use elements' `LayoutOrder` by changing `SortOrder` to LayoutOrder. A UIListLayout will automatically re-layout elements when elements are added/removed, or if a relevant property changes: `LayoutOrder` or `Name`. This can be triggered manually by calling `ApplyLayout`, though this is typically not necessary.

The actual cell sizes are the same for all cells. A UIGridLayout will respect UI constraints placed with it, such as a `UISizeConstraint`. It is possible to limit the number of elements per row using `FillDirectionMaxCells`. If set to 1, it is possible to create a single row of elements (as each element would be positioned in its own row).

This layout is appropriate when line breaks are OK after arbitrary cells. For example, a set of inventory spaces is a good use of this layout. If building a table of values in which a line break is not appropriate in the middle of tabular data, it might be a better idea to use a `UITableLayout` instead. */
interface UIGridLayout extends RbxInternalUIGridStyleLayout {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UIGridLayout";
	/** (default {0, 5},{0, 5})
Determines how much space there is between elements in the grid. As with all UDim2s, this space can be both in a percentage of the parent container's size and raw pixel offset.Determines how much space there is between elements in the grid. */
	CellPadding: UDim2;
	/** (default {0, 100},{0, 100})
Determines the size of each element in the grid. As with all UDim2s, this size can be both in a percentage of the parent container's size and raw pixel offset.

If the element being size has a `UIConstraint` then the size will be determined by the constraint, not the grid.Determines the size of each element in the grid. */
	CellSize: UDim2;
	/** FillDirectionMaxCells determines the number of cells in the grid that can be used before continuing on the next row/column (whether this is a row or column is dependent on `FillDirection`). This value must be non-negative.

  - If set to zero, there is no maximum number of cells that may appear in one row/column except for how many can fit within the parent UI element.
  - If set to one, this creates a list similar to those created by `UIListLayout`. */
	FillDirectionMaxCells: number;
	/** StartCorner (`StartCorner`) determines from which corner the grid starts laying out UI elements. The grid continues in the `FillDirection`, filling elements one by one until `FIllDirectionMaxCells` cells have been laid out in that row/column or if all the parent UI element's space has been occupied by previous cells.

![UIGridLayout with a StartCorner of BottomRight](https://developer.roblox.com/assets/bltb27258f9e16b81e2/UIGridLayout_StartCorner.png)

Above, the potion is the first `ImageLabel`, followed by the gem and the sword. The UIGridLayout is using a `StartCorner` of BottomRight. The `FillDirection` is Horizontal. */
	StartCorner: Enum.StartCorner;
}

/** A UIListLayout lays out sibling UI elements in a single row within the parent UI element, either horizontally or vertically. Each sibling UI element retains its original `Size`, but its `Position` will be taken under control by the UIListLayout. While under control, the Position property of sibling UI elements will not be editable in the Properties window.

By default, it lays out elements from top to bottom in **alphabetical** order, but this can be changed to use elements' `LayoutOrder` by changing `SortOrder` to LayoutOrder. A UIListLayout will automatically re-layout elements when elements are added/removed, or if a relevant property changes: `LayoutOrder`, `Name` or `Size`. This can be triggered manually by calling `ApplyLayout`, though this is typically not necessary.

Since each property that changes how elements are laid out will re-apply the layout, it's recommended to set the `Parent` property last so that the layout is only applied once. Similarly, since adding more UI elements will also re-apply the layout, add the UIListLayout last so it doesn't recalculate positions after each element.

This class is perhaps the simplest of all `UIGridStyleLayout` classes. It saves time by skipping the step of setting each UI element's Position. In the simplest case, laying out UI elements in a column can be as simple as a single line of code:

```lua
Instance.new("UIListLayout", guiObject).SortOrder = Enum.SortOrder.Layout
```


The above line is a useful shorthand when adding a single object to a parent and setting one property. For multiple properties, use a variable:

```lua
local uiListLayout = Instance.new("UIListLayout")
uiListLayout.SortOrder = Enum.SortOrder.Layout
uiListLayout.FillDirection = Enum.FillDirection.Horizontal
uiListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
uiListLayout.Parent = guiObject -- Do this last!
```

## Code Samples

### UI Scale Demo

This code sample creates some images of a lock and scales them using UIScale. It lays them out suing a UIListLayout.
```lua
-- Lay out the images in a list
Instance.new("UIListLayout", script.Parent).SortOrder = Enum.SortOrder.LayoutOrder

-- Create some images of varying sizes using UIScale objects
for size = .2, 1.5, .2 do
	local image = Instance.new("ImageLabel")
	image.Image = "rbxassetid://284402752" -- an image of a Lock
	image.Parent = script.Parent
	image.Size = UDim2.new(0, 100, 0, 100)
	-- Scale the image by adding a UIScale with the size
	--  Note: this is a shorthand since we don't need a reference to the UIScale
	Instance.new("UIScale", image).Scale = size
end
```

### Show All Fonts

This code sample renders a list of all the available fonts.
```lua
local frame = script.Parent

-- Create a TextLabel displaying each font
for i, font in pairs(Enum.Font:GetEnumItems()) do
	local tl = Instance.new("TextLabel")
	tl.Name = font.Name
	-- Set the text properties
	tl.Text = font.Name
	tl.Font = font
	-- Some rendering properties
	tl.TextSize = 24
	tl.TextXAlignment = Enum.TextXAlignment.Left
	-- Size the frame equal to the height of the text
	tl.Size = UDim2.new(1, 0, 0, tl.TextSize)
	-- Add to the parent frame
	tl.Parent = frame
end

-- Layout the frames in a list (if they aren't already)
if not frame:FindFirstChildOfClass("UIListLayout") then
	Instance.new("UIListLayout", frame)
end

```

### UI Sort Order

This code sample demonstrates sorting data using `SortOrder` and `LayoutOrder`.
```lua
-- Place in a script in a UIListLayout
local uiGridLayout = script.Parent

-- Some data to work with
local scores = {
	["Player1"] = 2048;
	["Ozzypig"] = 1337;
	["Shedletsky"] = 1250;
	["Builderman"] = 1000;  
}

-- Build a scoreboard
for name, score in pairs(scores) do
	local tl = Instance.new("TextLabel")
	tl.Text = name .. ": " .. score
	tl.Parent = script.Parent
	tl.LayoutOrder = -score -- We want higher scores first, so negate for descending order
	tl.Name = name
	tl.Size = UDim2.new(0, 200, 0, 50)
	tl.Parent = uiGridLayout.Parent
end

while true do
	-- The name is the player's name
	uiGridLayout.SortOrder = Enum.SortOrder.Name
	uiGridLayout:ApplyLayout()
	wait(2)
	-- Since we set the LayoutOrder to the score, this will sort by descending score!
	uiGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
	uiGridLayout:ApplyLayout()
	wait(2)
end
```
 */
interface UIListLayout extends RbxInternalUIGridStyleLayout {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UIListLayout";
	/** Determines the amount of free space between each element.
Can be set either using scale (Percentage of parent's size in the current direction) or offset (a static spacing value, similar to pixel size).Determines the amount of free space between each element. */
	Padding: UDim;
}

/** Creates a paged viewing window, like the home screen of a mobile device. You can use a UIPageLayout by parenting it to a GuiObject. The UIPageLayout will then apply itself to all of its GuiObject siblings. */
interface UIPageLayout extends RbxInternalUIGridStyleLayout {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UIPageLayout";
	/** Whether or not to animate transitions between pages. */
	Animated: boolean;
	/** Whether or not the page layout wraps around at the ends. */
	Circular: boolean;
	/** The page that is either currently being displayed or is the target of the current animation. */
	readonly CurrentPage?: GuiObject;
	/** The easing direction to use when performing an animation. */
	EasingDirection: Enum.EasingDirection;
	/** The easing style to use when performing an animation. */
	EasingStyle: Enum.EasingStyle;
	/** Controls the overrides of NextSelection{Up,Down,Left,Right}. Defaults to true. */
	GamepadInputEnabled: boolean;
	/** Determines the amount that pages are separated from each other by.
Can be set either using scale (Percentage of parent's size in the current direction) or offset (a static spacing value, similar to pixel size).Determines the amount that pages are separated from each other by. */
	Padding: UDim;
	/** Controls the use of scroll wheel, in case that it is intended for something else. Defaults to true. */
	ScrollWheelInputEnabled: boolean;
	/** Controls touch scrolling, in case this is a non-interactive layout. Defaults to true. */
	TouchInputEnabled: boolean;
	/** The length of the animation. */
	TweenTime: number;
	/** If the _page_
 is in the UIPageLayout, then it sets `CurrentPage` to it and animates to it. If the circular layout is enabled, it will take the shortest path to this page. */
	JumpTo(page: GuiObject): void;
	/** If the index is &gt;= 0 and less than the size of the layout, this method acts like `JumpTo`. If it's out of bounds and circular is set, it will animate the full distance between the in-bounds index of `CurrentPage` and the new index. */
	JumpToIndex(index: number): void;
	/** Sets `CurrentPage` to the page after the current page and animates to it, or does nothing if there isn't a next page. */
	Next(): void;
	/** Sets `CurrentPage` to the page before the current page and animates to it, or does nothing if there isn't a previous page. */
	Previous(): void;
	/** Fires when a page comes into view, and is going to be rendered. */
	readonly PageEnter: RBXScriptSignal<(page: GuiObject) => void>;
	/** Fires when a page leaves view, and will not be rendered. */
	readonly PageLeave: RBXScriptSignal<(page: GuiObject) => void>;
	/** Fires when an animation to `CurrentPage` is completed without being canceled, and the view stops scrolling. */
	readonly Stopped: RBXScriptSignal<(currentPage: GuiObject) => void>;
}

/** A UITableLayout lays out sibling UI elements as rows in a table. Child UI elements (the table cells) of these rows are then arranged in columns (within rows). Each cell within a row has the same height, and each cell within a column has the same width. The hierarchy in the explorer should look like this (`Frame`s are yellow rows, `TextLabel`s are cells)

![Hierarchy of UI elements used with a UITableLayout](https://developer.roblox.com/assets/bltad6d3e2ee82def82/UITableLayout_Hierarchy.png)![UITableLayout result](https://developer.roblox.comundefined)

By changing the `FillDirection`, sibling UI elements can act as columns instead.

When applied, a UITableLayout will take control of sibling and cell elements' `Size` and `Position`. Changing these in the Properties window is still possible will not produce any effect.

Dimensions of the cells in the resulting table are controlled by the parent UI element's dimensions. Unless `FillEmptySpaceColumns` or `FillEmptySpaceRows` is enabled, the cell dimensions will be that of the parent UI element (and thus tables with more than one cell extend outside of their parent).

Cells will continue to respect `UISizeConstraint` objects within them. In other words, setting `MinSize` on `UISizeConstraint`s within the header cells can determine the size of the rest of the cells. If `MaxSize` restricts a cell's size from filling the allotted space (i.e. another row/column is wider than it), it will align to the top-left.


  
  [2]: https://images.contentstack.io/v3/assets/blt309cc8bfb280dcec/bltff6ce5d154eee764/5af89441d951a7d46014aa05/UITableLayout_Padding.png

## Code Samples

### Build UI Table

This code sample builds a table of 4 rows, the first having headers. It does this using some for-loops and a `UITableLayout`. The widths of each column are set using `UISizeConstraint`s.
```lua
local frame = script.Parent

-- Table data
local headerWidth = {200, 80, 80}
local headers = {
	"Name",     "Job",    "Cash"}
local data = {
	{"Bob",     "Waiter",   100},
	{"Lisa",    "Police",   200},
	{"George",  "-",         50},
}

-- First, build the table layout
local uiTableLayout = Instance.new("UITableLayout")
uiTableLayout.FillDirection = Enum.FillDirection.Vertical
uiTableLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
uiTableLayout.VerticalAlignment = Enum.VerticalAlignment.Center
uiTableLayout.FillEmptySpaceColumns = false
uiTableLayout.FillEmptySpaceRows = false
uiTableLayout.Padding = UDim2.new(0, 5, 0, 5)
uiTableLayout.SortOrder = Enum.SortOrder.LayoutOrder
frame.Size = UDim2.new(0, 0, 0, 40) -- The Size of the parent frame is the cell size
uiTableLayout.Parent = frame

-- Next, create column headers
local headerFrame = Instance.new("Frame", frame)
headerFrame.Name = "Headers"
for i = 1, #headers do
	local headerText = headers[i]
	local headerCell = Instance.new("TextLabel", headerFrame)
	headerCell.Text = headerText
	headerCell.Name = headerText
	headerCell.LayoutOrder = i
	local headerSize = Instance.new("UISizeConstraint")
	headerSize.MinSize = Vector2.new(headerWidth[i], 0)
	headerSize.Parent = headerCell
end

-- Finally, add data rows by iterating over each row and the columns in that row
for row = 1, #data do
	local rowData = data[row]
	local rowFrame = Instance.new("Frame", frame)
	rowFrame.Name = "Row" .. row
	for col = 1, #data[row] do
		local cellData = rowData[col]
		local cell = Instance.new("TextLabel", rowFrame)
		cell.Text = cellData
		cell.Name = headers[col]
		cell.TextXAlignment = Enum.TextXAlignment.Left
		if tonumber(cellData) then -- If this cell is a number, right-align it instead
			cell.TextXAlignment = Enum.TextXAlignment.Right
		end
		cell.ClipsDescendants = true
	end
end

```
 */
interface UITableLayout extends RbxInternalUIGridStyleLayout {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UITableLayout";
	/** FillEmptySpaceColumns determines whether cells' X size are set such that the entire horizontal space of the parent UI element is used. Enabling this is useful for making sure your table takes up a more easily predictable amount of horizontal space (the X-axis size of the parent UI element). It is still possible that a `UISizeConstraint` applied to cells will cause underflow/overflow.

When enabling this property, the column widths will be approximately equal to the parent's `AbsoluteSize`.X component divided by the number of columns (not accounting for padding or other factors).

## Code Samples

### Build UI Table

This code sample builds a table of 4 rows, the first having headers. It does this using some for-loops and a `UITableLayout`. The widths of each column are set using `UISizeConstraint`s.
```lua
local frame = script.Parent

-- Table data
local headerWidth = {200, 80, 80}
local headers = {
	"Name",     "Job",    "Cash"}
local data = {
	{"Bob",     "Waiter",   100},
	{"Lisa",    "Police",   200},
	{"George",  "-",         50},
}

-- First, build the table layout
local uiTableLayout = Instance.new("UITableLayout")
uiTableLayout.FillDirection = Enum.FillDirection.Vertical
uiTableLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
uiTableLayout.VerticalAlignment = Enum.VerticalAlignment.Center
uiTableLayout.FillEmptySpaceColumns = false
uiTableLayout.FillEmptySpaceRows = false
uiTableLayout.Padding = UDim2.new(0, 5, 0, 5)
uiTableLayout.SortOrder = Enum.SortOrder.LayoutOrder
frame.Size = UDim2.new(0, 0, 0, 40) -- The Size of the parent frame is the cell size
uiTableLayout.Parent = frame

-- Next, create column headers
local headerFrame = Instance.new("Frame", frame)
headerFrame.Name = "Headers"
for i = 1, #headers do
	local headerText = headers[i]
	local headerCell = Instance.new("TextLabel", headerFrame)
	headerCell.Text = headerText
	headerCell.Name = headerText
	headerCell.LayoutOrder = i
	local headerSize = Instance.new("UISizeConstraint")
	headerSize.MinSize = Vector2.new(headerWidth[i], 0)
	headerSize.Parent = headerCell
end

-- Finally, add data rows by iterating over each row and the columns in that row
for row = 1, #data do
	local rowData = data[row]
	local rowFrame = Instance.new("Frame", frame)
	rowFrame.Name = "Row" .. row
	for col = 1, #data[row] do
		local cellData = rowData[col]
		local cell = Instance.new("TextLabel", rowFrame)
		cell.Text = cellData
		cell.Name = headers[col]
		cell.TextXAlignment = Enum.TextXAlignment.Left
		if tonumber(cellData) then -- If this cell is a number, right-align it instead
			cell.TextXAlignment = Enum.TextXAlignment.Right
		end
		cell.ClipsDescendants = true
	end
end

```
 */
	FillEmptySpaceColumns: boolean;
	/** FillEmptySpaceRows determines whether cells' Y size are set such that the entire vertical space of the parent UI element is used. Enabling this is useful for making sure your table takes up a more easily predictable amount of vertical space (the Y-axis size of the parent UI element). It is still possible that a `UISizeConstraint` applied to cells will cause underflow/overflow.

When enabling this property, the row heights will be approximately equal to the parent's `AbsoluteSize`.Y component divided by the number of rows (not accounting for padding or other factors).

## Code Samples

### Build UI Table

This code sample builds a table of 4 rows, the first having headers. It does this using some for-loops and a `UITableLayout`. The widths of each column are set using `UISizeConstraint`s.
```lua
local frame = script.Parent

-- Table data
local headerWidth = {200, 80, 80}
local headers = {
	"Name",     "Job",    "Cash"}
local data = {
	{"Bob",     "Waiter",   100},
	{"Lisa",    "Police",   200},
	{"George",  "-",         50},
}

-- First, build the table layout
local uiTableLayout = Instance.new("UITableLayout")
uiTableLayout.FillDirection = Enum.FillDirection.Vertical
uiTableLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
uiTableLayout.VerticalAlignment = Enum.VerticalAlignment.Center
uiTableLayout.FillEmptySpaceColumns = false
uiTableLayout.FillEmptySpaceRows = false
uiTableLayout.Padding = UDim2.new(0, 5, 0, 5)
uiTableLayout.SortOrder = Enum.SortOrder.LayoutOrder
frame.Size = UDim2.new(0, 0, 0, 40) -- The Size of the parent frame is the cell size
uiTableLayout.Parent = frame

-- Next, create column headers
local headerFrame = Instance.new("Frame", frame)
headerFrame.Name = "Headers"
for i = 1, #headers do
	local headerText = headers[i]
	local headerCell = Instance.new("TextLabel", headerFrame)
	headerCell.Text = headerText
	headerCell.Name = headerText
	headerCell.LayoutOrder = i
	local headerSize = Instance.new("UISizeConstraint")
	headerSize.MinSize = Vector2.new(headerWidth[i], 0)
	headerSize.Parent = headerCell
end

-- Finally, add data rows by iterating over each row and the columns in that row
for row = 1, #data do
	local rowData = data[row]
	local rowFrame = Instance.new("Frame", frame)
	rowFrame.Name = "Row" .. row
	for col = 1, #data[row] do
		local cellData = rowData[col]
		local cell = Instance.new("TextLabel", rowFrame)
		cell.Text = cellData
		cell.Name = headers[col]
		cell.TextXAlignment = Enum.TextXAlignment.Left
		if tonumber(cellData) then -- If this cell is a number, right-align it instead
			cell.TextXAlignment = Enum.TextXAlignment.Right
		end
		cell.ClipsDescendants = true
	end
end

```
 */
	FillEmptySpaceRows: boolean;
	/** MajorAxis determines whether sibling UI elements are treated as rows or columns. Below, the left uses a `TableMajorAxis` of RowMajor, and the right uses ColumnMajor.

![Row major](https://developer.roblox.com/assets/bltff6ce5d154eee764/UITableLayout_Padding.png)![Column major](https://developer.roblox.comundefined)

**Note: it seems that this property isn't making noticeable changes, and rather its behavior is determined by `FillDirection` instead.**


  
  [2]: https://images.contentstack.io/v3/assets/blt309cc8bfb280dcec/bltd94eef328b68fed5/5af8b0b0fb3ef84362f407ca/UITableLayout_FillDirection.png

## Code Samples

### Build UI Table

This code sample builds a table of 4 rows, the first having headers. It does this using some for-loops and a `UITableLayout`. The widths of each column are set using `UISizeConstraint`s.
```lua
local frame = script.Parent

-- Table data
local headerWidth = {200, 80, 80}
local headers = {
	"Name",     "Job",    "Cash"}
local data = {
	{"Bob",     "Waiter",   100},
	{"Lisa",    "Police",   200},
	{"George",  "-",         50},
}

-- First, build the table layout
local uiTableLayout = Instance.new("UITableLayout")
uiTableLayout.FillDirection = Enum.FillDirection.Vertical
uiTableLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
uiTableLayout.VerticalAlignment = Enum.VerticalAlignment.Center
uiTableLayout.FillEmptySpaceColumns = false
uiTableLayout.FillEmptySpaceRows = false
uiTableLayout.Padding = UDim2.new(0, 5, 0, 5)
uiTableLayout.SortOrder = Enum.SortOrder.LayoutOrder
frame.Size = UDim2.new(0, 0, 0, 40) -- The Size of the parent frame is the cell size
uiTableLayout.Parent = frame

-- Next, create column headers
local headerFrame = Instance.new("Frame", frame)
headerFrame.Name = "Headers"
for i = 1, #headers do
	local headerText = headers[i]
	local headerCell = Instance.new("TextLabel", headerFrame)
	headerCell.Text = headerText
	headerCell.Name = headerText
	headerCell.LayoutOrder = i
	local headerSize = Instance.new("UISizeConstraint")
	headerSize.MinSize = Vector2.new(headerWidth[i], 0)
	headerSize.Parent = headerCell
end

-- Finally, add data rows by iterating over each row and the columns in that row
for row = 1, #data do
	local rowData = data[row]
	local rowFrame = Instance.new("Frame", frame)
	rowFrame.Name = "Row" .. row
	for col = 1, #data[row] do
		local cellData = rowData[col]
		local cell = Instance.new("TextLabel", rowFrame)
		cell.Text = cellData
		cell.Name = headers[col]
		cell.TextXAlignment = Enum.TextXAlignment.Left
		if tonumber(cellData) then -- If this cell is a number, right-align it instead
			cell.TextXAlignment = Enum.TextXAlignment.Right
		end
		cell.ClipsDescendants = true
	end
end

```
 */
	MajorAxis: Enum.TableMajorAxis;
	/** Padding will position elements with extra space between them. This can be done using Scale or Offset components of UDim2. Negative values can bring elements closer together. When non-zero, the sibling UI elements may be visible between the cells contained within them. In the image below, you can see the padding of 5 pixels applied between the cells (and the sibling UI elements acting as rows in yellow).

![UITableLayout with padding between cells](https://developer.roblox.com/assets/bltff6ce5d154eee764/UITableLayout_Padding.png)

## Code Samples

### Build UI Table

This code sample builds a table of 4 rows, the first having headers. It does this using some for-loops and a `UITableLayout`. The widths of each column are set using `UISizeConstraint`s.
```lua
local frame = script.Parent

-- Table data
local headerWidth = {200, 80, 80}
local headers = {
	"Name",     "Job",    "Cash"}
local data = {
	{"Bob",     "Waiter",   100},
	{"Lisa",    "Police",   200},
	{"George",  "-",         50},
}

-- First, build the table layout
local uiTableLayout = Instance.new("UITableLayout")
uiTableLayout.FillDirection = Enum.FillDirection.Vertical
uiTableLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
uiTableLayout.VerticalAlignment = Enum.VerticalAlignment.Center
uiTableLayout.FillEmptySpaceColumns = false
uiTableLayout.FillEmptySpaceRows = false
uiTableLayout.Padding = UDim2.new(0, 5, 0, 5)
uiTableLayout.SortOrder = Enum.SortOrder.LayoutOrder
frame.Size = UDim2.new(0, 0, 0, 40) -- The Size of the parent frame is the cell size
uiTableLayout.Parent = frame

-- Next, create column headers
local headerFrame = Instance.new("Frame", frame)
headerFrame.Name = "Headers"
for i = 1, #headers do
	local headerText = headers[i]
	local headerCell = Instance.new("TextLabel", headerFrame)
	headerCell.Text = headerText
	headerCell.Name = headerText
	headerCell.LayoutOrder = i
	local headerSize = Instance.new("UISizeConstraint")
	headerSize.MinSize = Vector2.new(headerWidth[i], 0)
	headerSize.Parent = headerCell
end

-- Finally, add data rows by iterating over each row and the columns in that row
for row = 1, #data do
	local rowData = data[row]
	local rowFrame = Instance.new("Frame", frame)
	rowFrame.Name = "Row" .. row
	for col = 1, #data[row] do
		local cellData = rowData[col]
		local cell = Instance.new("TextLabel", rowFrame)
		cell.Text = cellData
		cell.Name = headers[col]
		cell.TextXAlignment = Enum.TextXAlignment.Left
		if tonumber(cellData) then -- If this cell is a number, right-align it instead
			cell.TextXAlignment = Enum.TextXAlignment.Right
		end
		cell.ClipsDescendants = true
	end
end

```
 */
	Padding: UDim2;
}

/** Applies padding to the borders of the GuiObject that this is parented to. */
interface UIPadding extends RbxInternalUIComponent {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UIPadding";
	/** The padding to apply on the bottom side relative to the parent's normal size. */
	PaddingBottom: UDim;
	/** The padding to apply on the left side relative to the parent's normal size. */
	PaddingLeft: UDim;
	/** The padding to apply on the right side relative to the parent's normal size. */
	PaddingRight: UDim;
	/** The padding to apply on the top side relative to the parent's normal size. */
	PaddingTop: UDim;
}

/** A UIScale object simply contains a number that is used to multiply the `AbsoluteSize` of the parent UI element. This number is stored in `Scale`.

## Code Samples

### UI Scale Demo

This code sample creates some images of a lock and scales them using UIScale. It lays them out suing a UIListLayout.
```lua
-- Lay out the images in a list
Instance.new("UIListLayout", script.Parent).SortOrder = Enum.SortOrder.LayoutOrder

-- Create some images of varying sizes using UIScale objects
for size = .2, 1.5, .2 do
	local image = Instance.new("ImageLabel")
	image.Image = "rbxassetid://284402752" -- an image of a Lock
	image.Parent = script.Parent
	image.Size = UDim2.new(0, 100, 0, 100)
	-- Scale the image by adding a UIScale with the size
	--  Note: this is a shorthand since we don't need a reference to the UIScale
	Instance.new("UIScale", image).Scale = size
end
```
 */
interface UIScale extends RbxInternalUIComponent {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UIScale";
	/** The Scale property determines the multiplier used on the parent UI element's `AbsoluteSize`. When set to 0.5, an AbsoluteSize of {0, 200}, {0, 50} becomes {0, 100}, {0, 25}. Similarly, when set to 2, such an AbsoluteSize would become {0, 400}, {0, 100}.

## Code Samples

### UI Scale Demo

This code sample creates some images of a lock and scales them using UIScale. It lays them out suing a UIListLayout.
```lua
-- Lay out the images in a list
Instance.new("UIListLayout", script.Parent).SortOrder = Enum.SortOrder.LayoutOrder

-- Create some images of varying sizes using UIScale objects
for size = .2, 1.5, .2 do
	local image = Instance.new("ImageLabel")
	image.Image = "rbxassetid://284402752" -- an image of a Lock
	image.Parent = script.Parent
	image.Size = UDim2.new(0, 100, 0, 100)
	-- Scale the image by adding a UIScale with the size
	--  Note: this is a shorthand since we don't need a reference to the UIScale
	Instance.new("UIScale", image).Scale = size
end
```
 */
	Scale: number;
}

/** The UserGameSettings is a singleton class found inside of the `UserSettings` singleton. It holds various persistent settings relating to how the user wants to control their camera, and their character.

You can access this object from a `LocalScript` via:

```
UserSettings():GetService("UserGameSettings")
```


This object is intended to be used on the client only, as it serves no purpose on the server. It will also reflect your own settings when testing in Roblox Studio.

## Code Samples

### UserGameSettings Listener

A basic example that shows how you can listen to changes in the user's settings.
With this code pasted into a LocalScript running in the StarterPlayerScripts, you can change settings in Roblox's game menu, and see their values appear in the output as detected changes.
```lua
local GameSettings = UserSettings().GameSettings

local function onGameSettingChanged(nameOfSetting)
	-- Fetch the value of this setting through a pcall to make sure we can retrieve it.
	-- Sometimes the event fires with properties that LocalScripts can't access.	
	local canGetSetting,setting = pcall(function ()
		return GameSettings[nameOfSetting]
	end)
	
	if canGetSetting then
		print("Your " .. nameOfSetting .. " has changed to: " .. tostring(setting))
	end
end

GameSettings.Changed:Connect(onGameSettingChanged)
```
 */
interface UserGameSettings extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UserGameSettings";
	/** The camera movement mode currently in-use by the client. */
	ComputerCameraMovementMode: Enum.ComputerCameraMovementMode;
	/** The movement type in-use by the client via Computer input. */
	ComputerMovementMode: Enum.ComputerMovementMode;
	/** Toggles whether or not the client can use the Mouse Lock Switch mode. */
	ControlMode: Enum.ControlMode;
	/** Describes how sensitive the camera is when using a gamepad. */
	GamepadCameraSensitivity: number;
	/** A [float](https://wiki.roblox.com/index.php?title=Float "Float")
 between 0 and 1 representing the volume of the game's client. */
	MasterVolume: number;
	/** A [float](https://developer.roblox.com/articles/Numbers "Float")
 representing the sensitivity of the client's mouse. */
	MouseSensitivity: number;
	/** [LACKS DOCUMENTATION] */
	RCCProfilerRecordFrameRate: number;
	/** [LACKS DOCUMENTATION] */
	RCCProfilerRecordTimeFrame: number;
	/** Controls how the client's character is rotated. */
	RotationType: Enum.RotationType;
	/** The graphics quality level set by the client. */
	SavedQualityLevel: Enum.SavedQualitySetting;
	/** The camera type in-use by the client while on a mobile device. */
	TouchCameraMovementMode: Enum.TouchCameraMovementMode;
	/** The type of controls being used by the client on a mobile device. */
	TouchMovementMode: Enum.TouchMovementMode;
	/** Returns the camera's Y-invert value. */
	GetCameraYInvertValue(): number;
	/** Returns true if the specified _onboardingId_
 has been recorded as complete via `SetOnboardingCompleted`. */
	GetOnboardingCompleted(onboardingId: string): boolean;
	/** Returns true if the user's Roblox window is in full screen mode. */
	InFullScreen(): boolean;
	/** Returns true if the client's game session is in Roblox Studio. */
	InStudioMode(): boolean;
	/** If called, Roblox toggles the menu option to invert the user's camera y axis. */
	SetCameraYInvertVisible(): void;
	/** If called, Roblox toggles the menu option to control the camera sensitivity with gamepads. */
	SetGamepadCameraSensitivityVisible(): void;
	/** Records that the user has finished the specified _onboardingId_ .

Currently, this function only accepts ["DynamicThumbstick"](https://developer.roblox.com/articles/String "String"), and it is used to persistently track whether or not the player has finished the tutorial for the _Dynamic Thumbstick_
 control scheme. */
	SetOnboardingCompleted(onboardingId: string): void;
	/** Fires if the user's full screen mode is changed.
The event will only fire on desktop devices that can toggle full screen mode. The game will always be in full screen on mobile devices and consoles.

## Code Samples

### Full Screen Mode Detection

A LocalScript that demonstrates how you can detect whether a game is in full screen or not.
```lua
local GameSettings = UserSettings().GameSettings

local function checkFullScreenMode()
	local inFullscreen = GameSettings:InFullScreen()
	if inFullscreen then
		print("Full Screen mode enabled!")
	else
		print("Full Screen mode disabled!")
	end
end

checkFullScreenMode()
GameSettings.FullscreenChanged:Connect(checkFullScreenMode)
```
 */
	readonly FullscreenChanged: RBXScriptSignal<(isFullscreen: boolean) => void>;
	/** Fired when the user's client switches between studio mode and in-game mode.
This gets fired periodically in Roblox Studio when a session starts. */
	readonly StudioModeChanged: RBXScriptSignal<(isStudioMode: boolean) => void>;
}

/** The `UserInputService` is a service used to detect and capture the different types of input available on a user’s device. 

The primary purpose of this service is to allow for games to cooperate with multiple forms of available input - such as gamepads, touch screens, and keyboards. It allows a `LocalScript` to perform different actions depending on the device, and in turn, helps developers provide the best experience for the end user. 

Some usages of this service include detecting user input when they interact with GUIs, tools, and other game instances. In order to detect user input, the service must look for a service event. For example, the service can detect events such as when the user touches the screen of a mobile device using `TouchStarted`, or connects a gamepad such as an Xbox controller to their device using `GamepadConnected`.

Since this service is client-side only, it will only work when used in a `LocalScript` or a `ModuleScript` required by a `LocalScript`. As UserInputService is client-side only, users in the game can only detect their own input - and not the input of others.

## See also 
 - `ContextActionService`, a service which allows you to bind functions to multiple user inputs

## Code Samples

### UserInputService

The following example demonstrates one of many usage examples of handling a UserInputService event.
```lua
-- We must get the UserInputService before we can use it
local UserInputService = game:GetService("UserInputService")

-- A sample function providing one usage of InputBegan
local function onInputBegan(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		print("The left mouse button has been pressed!")
	end
end

UserInputService.InputBegan:Connect(onInputBegan)
```
 */
interface UserInputService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "UserInputService";
	/** This property describes whether the the user’s device has an accelerometer

An accelerometer is a component found in most mobile devices that measures acceleration (change in speed).

For example, the following code snippet demonstrates how to check if the user's device has an accelerometer.
```lua
local userInputService = game:GetService("UserInputService")

local accelerometerEnabled = oserInputService.AccelerometerEnabled
if accelerometerEnabled then
	print("Accelerometer enabled!")
else
	print("Accelerometer not enabled!")
end
```


If the device has an enabled accelerometer, you can get it's current acceleration by using the `GetDeviceAcceleration` function or track when the device's acceleration changes by using the `DeviceAccelerationChanged` event.

As `UserInputService` is client-side only, this property can only be used in a `LocalScript`.

## Code Samples

### Create a Gyroscopic Camera

This example controls the player's `Camera` so that it matches the player's device orientation via using the device’s `gyroscope` and `accelerometer`.

The camera is positioned inside the player's head, and updated to move with the player and the user's device rotation, by executing the following line every `RenderStep`:
```lua
		camera.CFrame = CFrame.new(head.Position - Vector3.new(0,8,10)) * currentRotation
```


The code sample relies on the device's gyroscope to determine when the player rotates their device. It does so by connecting to the `DeviceRotationChanged` event. 

The code sample relies on the device’s accelerometer to retrieve the gravity vector used to determine the device's orientation (whether it is flipped upside down or not). To determine whether the device's orientation is upside down, the code sample uses the `DeviceGravityChanged` event.

Since the script places the camera inside the head to create a first-person camera, the limbs are made transparent by the `HideCharacter()` function so that the player does not see their `Character` when rotating the camera.

In order for this example to work as expected, it must be placed in a `LocalScript` and the user's device must have a gyroscope and an accelerometer.
```lua
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.CharacterAdded:wait()
local head = character:WaitForChild("Head")

local camera = game.Workspace.CurrentCamera
local currentRotation = camera.CFrame-- CFrame.new(Vector3.new(0,0,0), Vector3.new(0,0,0))
local lastInputFrame = nil
local upsideDown = false
 
wait()
 
local orientationSet = false
local function GravityChanged(gravity)
    if not orientationSet then
   	 upsideDown = (gravity.Position.X < -.5 or gravity.Position.Z > .5)
 
   	 orientationSet = true
    end
end
 
local function RotationChanged(rotation, rotCFrame)
	if orientationSet then
	if not lastInputFrame then
		lastInputFrame = rotCFrame
	end
 
	local delta = rotCFrame * lastInputFrame:inverse()
	local x,y,z = delta:toEulerAnglesXYZ()
	if upsideDown then
		delta = CFrame.Angles(-x, y, z)
	else
		delta = CFrame.Angles(x, -y, z)
	end
	currentRotation = currentRotation * delta
 
	lastInputFrame = rotCFrame
	end
end

local function HideCharacter()
	for _, limb in pairs (character:GetChildren()) do
		if limb:IsA("Part") then
			limb.Transparency = 1
		end
	end
end

local function UpdateCamera()
	local camera = game.Workspace.CurrentCamera
	camera.CoordinateFrame = currentRotation
	camera.Focus = CFrame.new(currentRotation * Vector3.new(0,0,-10))
end

if UserInputService.GyroscopeEnabled then
	UserInputService.DeviceGravityChanged:Connect(GravityChanged)
	UserInputService.DeviceRotationChanged:Connect(RotationChanged)
	
	HideCharacter()
	
	RunService:BindToRenderStep("Camera", Enum.RenderPriority.Camera.Value, function()
		camera.CFrame = CFrame.new(head.Position - Vector3.new(0,8,10)) * currentRotation
		camera.Focus = CFrame.new(currentRotation * Vector3.new(0,0,-10))
	end)
end
```

### Move a Ball using the Accelerometer

This code adds a force on a part so that it falls in the direction of actual gravity relative to the user's device. This code can be seen in [this][1] uncopylocked place.

In order for this example to work as expected, it must be placed in a `LocalScript` and the user’s device must have an `accelerometer`.

  [1]: http://www.roblox.com/games/257601957/Gravity-Test
```lua
local UserInputService = game:GetService("UserInputService")

local Ball = game.Workspace.Ball
local RealGravity = Instance.new("BodyForce", Ball)
local AntiGravity = Instance.new("BodyForce", Ball)
AntiGravity.force = Vector3.new(0, 196.2 * Ball:GetMass(), 0)

local function MoveBall(gravity)
	RealGravity.force = gravity.Position * 196.2 * game.Workspace.Ball:GetMass()
end

if UserInputService.AccelerometerEnabled then
	UserInputService.DeviceGravityChanged:Connect(MoveBall)	
end
```
 */
	readonly AccelerometerEnabled: boolean;
	/** This property describes whether the device being used by a user has an available gamepad.

```lua
lua
local userInputService = game:GetService(“UserInputService”)

if userInputService.GamepadEnabled then
	print(“Gamepad enabled”)
else
	print(“Gamepad not enabled”)
end
```


If gamepads are available, you can use `GetConnectedGamepads` to retrieve a list of connected gamepads and `GetNavigationGamepads` to retrieve a list of connected gamepads that also controlnavigation GUIs.

As `UserInputService` is client-side only, this property can only be  used in a `LocalScript`.

See [this][1] page for articles on cross-platform development.

## See also
 - `GamepadConnected`
 - `GamepadDisconnected`
 - `GetConnectedGamepads`
 - `GetNavigationGamepads`
 - `SetNavigationGamepad`
 - `IsNavigationGamepad`
 - `IsGamepadButtonDown`
 - `GetSupportedGamepadKeyCodes`
 - `GetGamepadState`
 - `GetGamepadConnected`
 - `GamepadSupports`

[1]: /learn-roblox/cross-platform

## Code Samples

### How to Use the Right Gamepad for Input

The following code sample is used in the default gamepad script, so if you are using the default controls you do not need to worry about this. If you are creating a custom script for handling gamepad controls, this is a good template for retrieving which `gamepad enum` you should use as the primary gamepad controller.

This code looks for the lowest numbered `navigation gamepad`, and if no navigation gamepad is found, finds the lowest numbered `connected gamepad`. If there is no connected gamepad, we default to gamepad1. This ensures at least some gamepad will be able to do controls.
```lua
local UserInputService = game:GetService("UserInputService")

local activeGamepad = nil
function GetActiveGamepad()
	local activateGamepad = nil
	local navigationGamepads = {}
	
	navigationGamepads = UserInputService:GetNavigationGamepads()
	
	if #navigationGamepads > 1 then
		for i = 1, #navigationGamepads do
			if activateGamepad == nil then
				activateGamepad = navigationGamepads[i]
			elseif navigationGamepads[i].Value < activateGamepad.Value then
				activateGamepad = navigationGamepads[i]
			end
		end
	else
		local connectedGamepads = {}
		
		connectedGamepads = UserInputService:GetConnectedGamepads()
		
		if #connectedGamepads > 0 then
			for i = 1, #connectedGamepads do
				if activateGamepad == nil then
					activateGamepad = connectedGamepads[i]
				elseif connectedGamepads[i].Value < activateGamepad.Value then
					activateGamepad = connectedGamepads[i]
				end
			end
		end
		if activateGamepad == nil then -- nothing is connected, at least set up for gamepad1
			activateGamepad = Enum.UserInputType.Gamepad1
		end
	end

	return activateGamepad
end

if UserInputService.GamepadEnabled then
	activeGamepad = GetActiveGamepad()
end
```
 */
	readonly GamepadEnabled: boolean;
	/** This property describes whether the user's device has a gyroscope. I

A gyroscope is an component found in most mobile devices that detects orientation and rotational speed.

If a user's device has a gyroscope, you can use incorporate it into your game using the `GetDeviceRotation` function and `DeviceRotationChanged` event.

```lua
local UserInputService = game:GetService("UserInputService")

local gyroIsEnabled = UserInputService.GyroscopeEnabled
if (gyroIsEnabled) then
	print("Gyroscope is enabled!")
else
	print("Gyroscope is not enabled!")
end
```


As `UserInputService` is client-side only, this property can only be used in a `LocalScript`.

See [this][1] page for articles on cross-platform development.

[1]: /learn-roblox/cross-platform

## Code Samples

### Create a Gyroscopic Camera

This example controls the player's `Camera` so that it matches the player's device orientation via using the device’s `gyroscope` and `accelerometer`.

The camera is positioned inside the player's head, and updated to move with the player and the user's device rotation, by executing the following line every `RenderStep`:
```lua
		camera.CFrame = CFrame.new(head.Position - Vector3.new(0,8,10)) * currentRotation
```


The code sample relies on the device's gyroscope to determine when the player rotates their device. It does so by connecting to the `DeviceRotationChanged` event. 

The code sample relies on the device’s accelerometer to retrieve the gravity vector used to determine the device's orientation (whether it is flipped upside down or not). To determine whether the device's orientation is upside down, the code sample uses the `DeviceGravityChanged` event.

Since the script places the camera inside the head to create a first-person camera, the limbs are made transparent by the `HideCharacter()` function so that the player does not see their `Character` when rotating the camera.

In order for this example to work as expected, it must be placed in a `LocalScript` and the user's device must have a gyroscope and an accelerometer.
```lua
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.CharacterAdded:wait()
local head = character:WaitForChild("Head")

local camera = game.Workspace.CurrentCamera
local currentRotation = camera.CFrame-- CFrame.new(Vector3.new(0,0,0), Vector3.new(0,0,0))
local lastInputFrame = nil
local upsideDown = false
 
wait()
 
local orientationSet = false
local function GravityChanged(gravity)
    if not orientationSet then
   	 upsideDown = (gravity.Position.X < -.5 or gravity.Position.Z > .5)
 
   	 orientationSet = true
    end
end
 
local function RotationChanged(rotation, rotCFrame)
	if orientationSet then
	if not lastInputFrame then
		lastInputFrame = rotCFrame
	end
 
	local delta = rotCFrame * lastInputFrame:inverse()
	local x,y,z = delta:toEulerAnglesXYZ()
	if upsideDown then
		delta = CFrame.Angles(-x, y, z)
	else
		delta = CFrame.Angles(x, -y, z)
	end
	currentRotation = currentRotation * delta
 
	lastInputFrame = rotCFrame
	end
end

local function HideCharacter()
	for _, limb in pairs (character:GetChildren()) do
		if limb:IsA("Part") then
			limb.Transparency = 1
		end
	end
end

local function UpdateCamera()
	local camera = game.Workspace.CurrentCamera
	camera.CoordinateFrame = currentRotation
	camera.Focus = CFrame.new(currentRotation * Vector3.new(0,0,-10))
end

if UserInputService.GyroscopeEnabled then
	UserInputService.DeviceGravityChanged:Connect(GravityChanged)
	UserInputService.DeviceRotationChanged:Connect(RotationChanged)
	
	HideCharacter()
	
	RunService:BindToRenderStep("Camera", Enum.RenderPriority.Camera.Value, function()
		camera.CFrame = CFrame.new(head.Position - Vector3.new(0,8,10)) * currentRotation
		camera.Focus = CFrame.new(currentRotation * Vector3.new(0,0,-10))
	end)
end
```
 */
	readonly GyroscopeEnabled: boolean;
	/** This property describes whether the user’s device has a keyboard available. This property is *true* when the user's device has an available keyboard, and *false* when it does not.

It can be used to determine whether the user has an available keyboard - which can be important if you want to check if you can use `IsKeyDown` or `GetKeysPressed` to check for keyboard input.

As `UserInputService` is client-side only, this property can only be used in a `LocalScript`.

## Code Samples

### Check if Keyboard is Enabled

This example prints "The user's device has an available keyboard!" if **KeyboardEnabled** is *true* and "The user's device does not have an available keyboard!" if **KeyboardEnabled** is *false*.
```lua
local UserInputService = game:GetService("UserInputService")

if (UserInputService.KeyboardEnabled) then
	print("The user's device has an available keyboard!")
else
	print("The user's device does not have an available keyboard!")
end
```
 */
	readonly KeyboardEnabled: boolean;
	/** The ModalEnabled property toggles whether Roblox's mobile controls are hidden on a player's mobile device. The default value of this property is *false*. The controls are hidden when set to *true*, and not hidden when set to *false*. See the images below for examples.

![ModalEnabled = false](https://developer.roblox.com/assets/5c2d53a7be5779ad1a894d50/UISModalEnabledFalse.png)

![ModalEnabled = true](https://developer.roblox.com/assets/5c2d54601e85fe011cdd73c8/UISModalEnabledTrue.png)

This property can be used when you want to hide or display Roblox's mobile controls for a player.

Even if mobile controls are hidden for a player on a mobile device, other UserInputService events such as `InputBegan` and `TouchSwipe` can still be used to process other forms of user input on mobile devices with an enabled touch screen (see the main UserInputService class page for a full list).

Since `UserInputService` only runs client-side, this property will only work when used in a `LocalScript`.

##See Also
The tutorial on disabling parts of the game interface, found [here][3], provides excellent documentation on using this property.


  
  
  [3]: https://www.robloxdev.com/articles/Disabling-Parts-of-Game-Interface

## Code Samples

### UserInputService.ModalEnabled

This example toggles between hiding and showing the user's Roblox mobile controls every 5 seconds.
```lua
local UserInputService = game:GetService("UserInputService")

while true do
	UserInputService.ModalEnabled = not UserInputService.ModalEnabled
	wait(5)
end
```
 */
	ModalEnabled: boolean;
	/** This property sets how the user's mouse behaves based on the `MouseBehavior` Enum. The default value is Enum.MouseBehavior.Default.

It can be set to three values:

 1. *Default*: The mouse moves freely around the user’s screen.
 2. *LockCenter*: The mouse is locked, and cannot move from, the center of the user’s screen.
 3. *LockCurrentPosition*: The mouse is locked, and cannot move from, it’s current position on the user’s screen at the time of locking.

The value of this property does not affect the sensitivity of events tracking mouse movement. For example, `GetMouseDelta` returns the same `Vector2` screen position in pixels regardless of whether the mouse is locked or able to move freely around the user’s screen. As a result, default scripts like those controlling the camera are not impacted by this property.

This property is overridden if a `GuiButton` with `Modal` enabled is `Visible` unless the player’s right mouse button is down.

Note that, if the mouse is locked, `InputChanged` will still fire when the player moves the mouse and will pass in the Delta that the mouse attempted to move by. Additionally, if the player is kicked from the game, the mouse will be forcefully unlocked.

As `UserInputService` is client-side only, this property can only be used in a `LocalScript`.

## Code Samples

### Create a Binoculars Script

This example creates a binoculars script that decreases the player’s `FieldOfView` and `MouseDeltaSensitivity` when a player with a `MouseEnabled` left mouse clicks. The script also points the player’s `Camera` towards the `Vector3` world position of the mouse click determined by the `Mouse’s` `Mouse.Hit.p` property.

When the player left mouse clicks again, the player’s camera reverts back to the a custom `CameraType` with the same field of view and `CFrame` as before the player zoomed in with the script.

While the player uses the binoculars, the script locks the player’s mouse to the center of the screen by setting the player’s `MouseBehavior` to LockCenter. The player’s camera moves when the player moves their mouse according to the `InputObject.Delta` property passed by `InputChanged` indicating the mouse’s `Vector2` change in screen position.

In order for this example to work as expected, it should be placed in a `LocalScript`.
```lua
local UserInputService = game:GetService("UserInputService")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.CharacterAdded:Wait()
local head = character:WaitForChild("Head", false)

local mouse = player:GetMouse()

local zoomed = false
local camera = game.Workspace.CurrentCamera
local target = nil
local originalProperties =
{
	FieldOfView = nil,
	_CFrame = nil,
	MouseBehavior = nil,
	MouseDeltaSensitivity = nil
}

local AngleX,TargetAngleX = 0,0
local AngleY,TargetAngleY = 0,0

-- Reset camera back to CFrame and FieldOfView before zoom
local function ResetCamera()
	target = nil
	camera.CameraType = Enum.CameraType.Custom
	camera.CFrame = originalProperties._CFrame
	camera.FieldOfView = originalProperties.FieldOfView
	
	UserInputService.MouseBehavior = originalProperties.MouseBehavior
	UserInputService.MouseDeltaSensitivity = originalProperties.MouseDeltaSensitivity
end

local function ZoomCamera()
	-- Allow camera to be changed by script
	camera.CameraType = Enum.CameraType.Scriptable
		
	-- Store camera properties before zoom
	originalProperties._CFrame = camera.CFrame
	originalProperties.FieldOfView = camera.FieldOfView
	originalProperties.MouseBehavior = UserInputService.MouseBehavior
	originalProperties.MouseDeltaSensitivity = UserInputService.MouseDeltaSensitivity

	-- Zoom camera
	target = mouse.Hit.p
	local eyesight = head.Position
	camera.CFrame = CFrame.new(eyesight, target)
	camera.Focus = CFrame.new(target)
	camera.FieldOfView = 10
	
	-- Lock and slow down mouse
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	UserInputService.MouseDeltaSensitivity = 1
	
	-- Reset zoom angles
	AngleX,TargetAngleX = 0,0
	AngleY,TargetAngleY = 0,0
end

-- Toggle camera zoom/unzoom
local function MouseClick()
	if zoomed then
		-- Unzoom camera
		ResetCamera()
	else
		-- Zoom in camera
		ZoomCamera()
	end
	
	zoomed = not zoomed
end

local cameraRotation = Vector2.new(0,math.rad(-60))
local function MouseMoved(input)
	if zoomed then
		local sensitivity = 0.6		-- anything higher would make looking up and down harder; recommend anything between 0~1
		local smoothness = 0.05		-- recommend anything between 0~1

		local delta = Vector2.new(input.Delta.x/sensitivity,input.Delta.y/sensitivity) * smoothness

		local X = TargetAngleX - delta.y
		local Y = TargetAngleY - delta.x
		TargetAngleX = (X >= 80 and 80) or (X <= -80 and -80) or X
		TargetAngleY = (Y >= 80 and 80) or (Y <= -80 and -80) or Y
		
		AngleX = AngleX + (TargetAngleX - AngleX) *0.35
		AngleY = AngleY + (TargetAngleY - AngleY) *0.15
		
		camera.CFrame = CFrame.new(head.Position, target)
		* CFrame.Angles(0,math.rad(AngleY),0)
		* CFrame.Angles(math.rad(AngleX),0,0)
	end
end

local function InputBegan(input, gameProcessedEvent)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		MouseClick()
	end
end

local function InputChanged(input, gameProcessedEvent)
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		MouseMoved(input)
	end
end

if UserInputService.MouseEnabled then
	UserInputService.InputBegan:Connect(InputBegan)
	UserInputService.InputChanged:Connect(InputChanged)
end
```

### Create a Custom CameraScript

By default, Roblox relies on a `LocalScript`, described [here][1], to control the user’s camera. However, this script can be overridden with a custom *CameraScript*. The example below demonstrates how to create a custom script to control the user’s camera using many of the `UserInputService` events.

The script is broken into two parts:

 1. Mobile camera events, which rely on touch events
 2. Non-mobile camera events, which rely on keyboard input and tracking the user’s movement

First, the camera script needs utility functions to setup the camera and set its `CameraType` to *Scriptable* so that the script can control the camera. It also needs a function to update the camera when it moves, rotates, and zooms.

Using touch events allows us to track user input as they interact with the touchscreen on their mobile device. These events allow us to handle camera movement, rotation, and zoom.

The second half of the code sample adds camera support for players on desktop devices. When input begans, the function Input() checks that the state of the input is `Enum.UserInputState.Begin` to ignore all keypress inputs other than when the user first presses a key down. When the user presses *I* and *O* the camera zooms in and out. When the presses down and moves their left mouse button, the script `locks` the player’s mouse by changing the `MouseBehavior` property. The camera rotates according to the mouse’s `change in screen position`. When the player moves their character, the camera moves with them.

All of the parts discussed above are combined and shown in the code sample below.
```lua
-- ========================================
-- GLOBAL VARIABLES
-- ========================================
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- The camera used by the LocalPlayer
local camera = game.Workspace.CurrentCamera

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")
local playerPosition = torso.Position

local default_CameraPosition = torso.Position
local default_CameraRotation = Vector2.new(0,math.rad(-60))
local default_CameraZoom = 15

local cameraPosition = default_CameraPosition
local cameraRotation = default_CameraRotation
local cameraZoom = default_CameraZoom

local cameraRotationBounds = {math.rad(-81),math.rad(20)}
local cameraZoomBounds = nil --{10,200}
local touchDragSpeed = 0.15
local cameraSpeed = 0.1
local cameraRotateSpeed = 10
local cameraMouseRotateSpeed = 0.25
local cameraTouchRotateSpeed = 10
-- ========================================
-- ========================================





-- ========================================
-- UTILITY FUNCTIONS
-- ========================================
local function SetCameraMode()
camera.CameraType = "Scriptable"
camera.FieldOfView = 80
camera.CameraSubject = nil
end

local function UpdateCamera()
SetCameraMode()
local cameraRotationCFrame = CFrame.Angles(0, cameraRotation.X, 0)*CFrame.Angles(cameraRotation.Y, 0, 0)
camera.CFrame = cameraRotationCFrame + cameraPosition + cameraRotationCFrame*Vector3.new(0, 0, cameraZoom)
camera.Focus = camera.CFrame - Vector3.new(0, camera.CFrame.p.Y, 0)
end
-- ========================================
-- ========================================




-- ========================================
-- MOBILE CAMERA EVENTS
-- ========================================
-- Events used to control the camera for players using a mobile device

-- ====================
-- CAMERA MOVE
-- ====================
-- Fired by UserInputService.TouchPan
local lastTouchTranslation = nil
local function TouchMove(touchPositions, totalTranslation, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = totalTranslation - lastTouchTranslation
	cameraPosition = cameraPosition + Vector3.new(difference.X, 0, difference.Y)
		UpdateCamera()
	end
	lastTouchTranslation = totalTranslation
end

-- ====================
-- CAMERA ROTATE
-- ====================
-- Fired by UserInputService.TouchRotate
local lastTouchRotation = nil
local function TouchRotate(touchPositions, rotation, velocity, state)
if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
local difference = rotation - lastTouchRotation
cameraRotation = cameraRotation + Vector2.new(-difference,0)*math.rad(cameraTouchRotateSpeed*cameraRotateSpeed)
		UpdateCamera()
	end
lastTouchRotation = rotation
end

-- ====================
-- CAMERA ZOOM
-- ====================
-- Fired by UserInputService.TouchPinch
local lastTouchScale = nil
local function TouchZoom(touchPositions, scale, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = scale - lastTouchScale
		cameraZoom = cameraZoom * (1 + difference)
		if cameraZoomBounds ~= nil then
			cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
		else
			cameraZoom = math.max(cameraZoom, 0)
end
		UpdateCamera()
	end
	lastTouchScale = scale
end

local function Input()
	UpdateCamera()
end
-- ========================================





-- ========================================
-- NON-MOBILE CAMERA EVENTS
-- ========================================

local function Input(inputObject)
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		if inputObject.UserInputState == Enum.UserInputState.Begin then						
			-- ====================
			-- CAMERA ZOOM
			-- ====================
			-- (I) Zoom In
			if inputObject.KeyCode == Enum.KeyCode.I then
			 	cameraZoom = cameraZoom - 15
			elseif inputObject.KeyCode == Enum.KeyCode.O then
				cameraZoom = cameraZoom + 15
			end
		
			-- (O) Zoom Out
			if cameraZoomBounds ~= nil then
				cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
			else
				cameraZoom = math.max(cameraZoom, 0)
			end
			
			UpdateCamera()
		end
	end
	
	-- ====================
	-- CAMERA ROTATE
	-- ====================
	local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
	if pressed then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		local rotation = userInputService:GetMouseDelta()
		cameraRotation = cameraRotation + rotation*math.rad(cameraMouseRotateSpeed)
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end

-- ====================
-- CAMERA MOVE
-- ====================
local function PlayerChanged()
	local movement = torso.Position - playerPosition
	cameraPosition = cameraPosition + movement
	playerPosition = torso.Position
		
	UpdateCamera()
end
-- ========================================
-- ========================================






-- ========================================
-- DEVICE CHECK
-- ========================================
-- Determine whether the user is on a mobile device

if UserInputService.TouchEnabled then
	-- The user is on a mobile device, use Touch events
UserInputService.TouchPan:Connect(TouchMove)
UserInputService.TouchRotate:Connect(TouchRotate)
UserInputService.TouchPinch:Connect(TouchZoom)
else
	
	-- The user is not on a mobile device use Input events
UserInputService.InputBegan:Connect(Input)
UserInputService.InputChanged:Connect(Input)
UserInputService.InputEnded:Connect(Input)

	-- Camera controlled by player movement
	wait(2)
	RunService:BindToRenderStep("PlayerChanged", Enum.RenderPriority.Camera.Value-1, PlayerChanged)
end	
-- ========================================
-- ========================================
```
 */
	MouseBehavior: Enum.MouseBehavior;
	/** This property determines the sensitivity of the user’s `Mouse`.

The sensitivity determines the extent to which a movement of the physical mouse translates to a movement of the mouse in-game. This can be used to adjusted how sensitive events tracking mouse movement, like `GetMouseDelta`, are to mouse movement.

This property does not affect the movement of the mouse icon. Nor does it affect the *Camera Sensitivity* setting found in the *Settings* tab of the client’s *Settings* menu, which also adjusts the sensitivity of events tracking mouse movement.

This property has a maximum value of 10 and a minimum value of 0. A lower value corresponds to lower sensitivity, and a higher value to higher sensitivity. 

When sensitivity is 0, events that track the mouse’s movement will still fire but all parameters and properties indicating the change in mouse position will return `Vector2.new()`, or `Vector3.new()` in the case of `InputObject.Delta`. For example, `GetMouseDelta` will always return (0, 0).

## Code Samples

### Create a Binoculars Script

This example creates a binoculars script that decreases the player’s `FieldOfView` and `MouseDeltaSensitivity` when a player with a `MouseEnabled` left mouse clicks. The script also points the player’s `Camera` towards the `Vector3` world position of the mouse click determined by the `Mouse’s` `Mouse.Hit.p` property.

When the player left mouse clicks again, the player’s camera reverts back to the a custom `CameraType` with the same field of view and `CFrame` as before the player zoomed in with the script.

While the player uses the binoculars, the script locks the player’s mouse to the center of the screen by setting the player’s `MouseBehavior` to LockCenter. The player’s camera moves when the player moves their mouse according to the `InputObject.Delta` property passed by `InputChanged` indicating the mouse’s `Vector2` change in screen position.

In order for this example to work as expected, it should be placed in a `LocalScript`.
```lua
local UserInputService = game:GetService("UserInputService")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.CharacterAdded:Wait()
local head = character:WaitForChild("Head", false)

local mouse = player:GetMouse()

local zoomed = false
local camera = game.Workspace.CurrentCamera
local target = nil
local originalProperties =
{
	FieldOfView = nil,
	_CFrame = nil,
	MouseBehavior = nil,
	MouseDeltaSensitivity = nil
}

local AngleX,TargetAngleX = 0,0
local AngleY,TargetAngleY = 0,0

-- Reset camera back to CFrame and FieldOfView before zoom
local function ResetCamera()
	target = nil
	camera.CameraType = Enum.CameraType.Custom
	camera.CFrame = originalProperties._CFrame
	camera.FieldOfView = originalProperties.FieldOfView
	
	UserInputService.MouseBehavior = originalProperties.MouseBehavior
	UserInputService.MouseDeltaSensitivity = originalProperties.MouseDeltaSensitivity
end

local function ZoomCamera()
	-- Allow camera to be changed by script
	camera.CameraType = Enum.CameraType.Scriptable
		
	-- Store camera properties before zoom
	originalProperties._CFrame = camera.CFrame
	originalProperties.FieldOfView = camera.FieldOfView
	originalProperties.MouseBehavior = UserInputService.MouseBehavior
	originalProperties.MouseDeltaSensitivity = UserInputService.MouseDeltaSensitivity

	-- Zoom camera
	target = mouse.Hit.p
	local eyesight = head.Position
	camera.CFrame = CFrame.new(eyesight, target)
	camera.Focus = CFrame.new(target)
	camera.FieldOfView = 10
	
	-- Lock and slow down mouse
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	UserInputService.MouseDeltaSensitivity = 1
	
	-- Reset zoom angles
	AngleX,TargetAngleX = 0,0
	AngleY,TargetAngleY = 0,0
end

-- Toggle camera zoom/unzoom
local function MouseClick()
	if zoomed then
		-- Unzoom camera
		ResetCamera()
	else
		-- Zoom in camera
		ZoomCamera()
	end
	
	zoomed = not zoomed
end

local cameraRotation = Vector2.new(0,math.rad(-60))
local function MouseMoved(input)
	if zoomed then
		local sensitivity = 0.6		-- anything higher would make looking up and down harder; recommend anything between 0~1
		local smoothness = 0.05		-- recommend anything between 0~1

		local delta = Vector2.new(input.Delta.x/sensitivity,input.Delta.y/sensitivity) * smoothness

		local X = TargetAngleX - delta.y
		local Y = TargetAngleY - delta.x
		TargetAngleX = (X >= 80 and 80) or (X <= -80 and -80) or X
		TargetAngleY = (Y >= 80 and 80) or (Y <= -80 and -80) or Y
		
		AngleX = AngleX + (TargetAngleX - AngleX) *0.35
		AngleY = AngleY + (TargetAngleY - AngleY) *0.15
		
		camera.CFrame = CFrame.new(head.Position, target)
		* CFrame.Angles(0,math.rad(AngleY),0)
		* CFrame.Angles(math.rad(AngleX),0,0)
	end
end

local function InputBegan(input, gameProcessedEvent)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		MouseClick()
	end
end

local function InputChanged(input, gameProcessedEvent)
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		MouseMoved(input)
	end
end

if UserInputService.MouseEnabled then
	UserInputService.InputBegan:Connect(InputBegan)
	UserInputService.InputChanged:Connect(InputChanged)
end
```
 */
	MouseDeltaSensitivity: number;
	/** This property describes whether the user’s device has a mouse available.  This property is *true* when the user's device has an available mouse, and *false* when it does not.

```lua
local UserInputService = game:GetService("UserInputService")

if (UserInputService.MouseEnabled) then
	print("The user's device has an available mouse!")
else
	print("The user's device does not have an available mouse!")
end
```


It is  important to check this before using `UserInputService` mouse functions such as `GetMouseLocation`.

As `UserInputService` is client-side only, this property can only be used in a `LocalScript`.

## See also
 - `MouseBehavior`
 - `MouseDeltaSensitivity`
 - `MouseIconEnabled`
 - `GetMouseLocation`
 - `GetMouseDelta`
 - `GetMouseButtonsPressed`

## Code Samples

### Create a Binoculars Script

This example creates a binoculars script that decreases the player’s `FieldOfView` and `MouseDeltaSensitivity` when a player with a `MouseEnabled` left mouse clicks. The script also points the player’s `Camera` towards the `Vector3` world position of the mouse click determined by the `Mouse’s` `Mouse.Hit.p` property.

When the player left mouse clicks again, the player’s camera reverts back to the a custom `CameraType` with the same field of view and `CFrame` as before the player zoomed in with the script.

While the player uses the binoculars, the script locks the player’s mouse to the center of the screen by setting the player’s `MouseBehavior` to LockCenter. The player’s camera moves when the player moves their mouse according to the `InputObject.Delta` property passed by `InputChanged` indicating the mouse’s `Vector2` change in screen position.

In order for this example to work as expected, it should be placed in a `LocalScript`.
```lua
local UserInputService = game:GetService("UserInputService")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.CharacterAdded:Wait()
local head = character:WaitForChild("Head", false)

local mouse = player:GetMouse()

local zoomed = false
local camera = game.Workspace.CurrentCamera
local target = nil
local originalProperties =
{
	FieldOfView = nil,
	_CFrame = nil,
	MouseBehavior = nil,
	MouseDeltaSensitivity = nil
}

local AngleX,TargetAngleX = 0,0
local AngleY,TargetAngleY = 0,0

-- Reset camera back to CFrame and FieldOfView before zoom
local function ResetCamera()
	target = nil
	camera.CameraType = Enum.CameraType.Custom
	camera.CFrame = originalProperties._CFrame
	camera.FieldOfView = originalProperties.FieldOfView
	
	UserInputService.MouseBehavior = originalProperties.MouseBehavior
	UserInputService.MouseDeltaSensitivity = originalProperties.MouseDeltaSensitivity
end

local function ZoomCamera()
	-- Allow camera to be changed by script
	camera.CameraType = Enum.CameraType.Scriptable
		
	-- Store camera properties before zoom
	originalProperties._CFrame = camera.CFrame
	originalProperties.FieldOfView = camera.FieldOfView
	originalProperties.MouseBehavior = UserInputService.MouseBehavior
	originalProperties.MouseDeltaSensitivity = UserInputService.MouseDeltaSensitivity

	-- Zoom camera
	target = mouse.Hit.p
	local eyesight = head.Position
	camera.CFrame = CFrame.new(eyesight, target)
	camera.Focus = CFrame.new(target)
	camera.FieldOfView = 10
	
	-- Lock and slow down mouse
	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	UserInputService.MouseDeltaSensitivity = 1
	
	-- Reset zoom angles
	AngleX,TargetAngleX = 0,0
	AngleY,TargetAngleY = 0,0
end

-- Toggle camera zoom/unzoom
local function MouseClick()
	if zoomed then
		-- Unzoom camera
		ResetCamera()
	else
		-- Zoom in camera
		ZoomCamera()
	end
	
	zoomed = not zoomed
end

local cameraRotation = Vector2.new(0,math.rad(-60))
local function MouseMoved(input)
	if zoomed then
		local sensitivity = 0.6		-- anything higher would make looking up and down harder; recommend anything between 0~1
		local smoothness = 0.05		-- recommend anything between 0~1

		local delta = Vector2.new(input.Delta.x/sensitivity,input.Delta.y/sensitivity) * smoothness

		local X = TargetAngleX - delta.y
		local Y = TargetAngleY - delta.x
		TargetAngleX = (X >= 80 and 80) or (X <= -80 and -80) or X
		TargetAngleY = (Y >= 80 and 80) or (Y <= -80 and -80) or Y
		
		AngleX = AngleX + (TargetAngleX - AngleX) *0.35
		AngleY = AngleY + (TargetAngleY - AngleY) *0.15
		
		camera.CFrame = CFrame.new(head.Position, target)
		* CFrame.Angles(0,math.rad(AngleY),0)
		* CFrame.Angles(math.rad(AngleX),0,0)
	end
end

local function InputBegan(input, gameProcessedEvent)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		MouseClick()
	end
end

local function InputChanged(input, gameProcessedEvent)
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		MouseMoved(input)
	end
end

if UserInputService.MouseEnabled then
	UserInputService.InputBegan:Connect(InputBegan)
	UserInputService.InputChanged:Connect(InputChanged)
end
```
 */
	readonly MouseEnabled: boolean;
	/** This property determines whether the `Mouse’s` icon is visible When *true* the mouse’s icon is visible, when *false* it is not.

For example, the code snippet below hides the mouse's icon.
```lua
local userInputService = game:GetService("UserInputService")

userInputService.MouseIconEnabled = false
```


As `UserInputService` is client-side only, this property can only be used in a `LocalScript`.

## Code Samples

### Hide Mouse During Keyboard Input

This example hides the mouse icon while the player beings using their keyboard, such as to chat or enter text into a `TextBox`. The mouse icon reappears when the user resumes mouse input.

This uses the `LastInputType` event to determine when the user begins keyboard input and mouse input - based on the value of the `lastInputType` argument.

In order for this example to work as expected, it should be placed in a `LocalScript`.
```lua
local UserInputService = game:GetService("UserInputService")

local mouseInput =
{
	Enum.UserInputType.MouseButton1,
	Enum.UserInputType.MouseButton2,
	Enum.UserInputType.MouseButton3,
	Enum.UserInputType.MouseMovement,
	Enum.UserInputType.MouseWheel	
}

local keyboard = Enum.UserInputType.Keyboard

local function ToggleMouse(lastInputType)
	if lastInputType == keyboard then
		UserInputService.MouseIconEnabled = false
		return
	end
	
	for i, mouse in pairs (mouseInput) do
		if lastInputType == mouse then
			UserInputService.MouseIconEnabled = true
			return
		end
	end
end

UserInputService.LastInputTypeChanged:Connect(ToggleMouse)
```
 */
	MouseIconEnabled: boolean;
	/** This property describes the position of the on-screen keyboard in pixels. The keyboard’s position is `Vector2.new(0, 0)` when it is not `visible`.

The code snippet below prints the position of the keyboard.

```lua
local userInputService = game:GetService("UserInputService")
print(userInputService.OnScreenKeyboardPosition)
```


As `UserInputService` is client-side only, this property can only be used in a `LocalScript`.

![On screen keyboard](https://developer.roblox.com/assets/5bce5dd5edb71a1476d19609/ClientKeyboard.png)

## See also
 - `OnScreenKeyboardVisible`
 - `OnScreenKeyboardSize`

## Code Samples

### UserInputService.OnScreenKeyboardPosition

This example prints the position of the player's on-screen keyboard.
```lua
local UserInputService = game:GetService("UserInputService")

print(UserInputService.OnScreenKeyboardPosition)
```
 */
	readonly OnScreenKeyboardPosition: Vector2;
	/** This property describes the size of the on-screen keyboard in pixels. The keyboard’s size is `Vector2.new(0, 0)` when it is not `visible`.

The code snippet below prints the size of the keyboard.

```lua
local userInputService = game:GetService("UserInputService")
print(userInputService.OnScreenKeyboardSize)
```


As `UserInputService` is client-side only, this property can only be used in a `LocalScript`.

![On screen keyboard](https://developer.roblox.comundefined)

## See also
 - `OnScreenKeyboardVisible`
 - `OnScreenKeyboardPosition`


  [1]: https://images.contentstack.io/v3/assets/bltc2ad39afa86662c8/bltd883fb9830c26628/5bce5c708e52425c44bf870e/Screenshot_(6).png */
	readonly OnScreenKeyboardSize: Vector2;
	/** This property describes whether an on-screen keyboard is currently visible on the user's screen. 

The code snippet below prints whether the keyboard is visible.

```lua
local userInputService = game:GetService("UserInputService")

local keyboardIsVisible = userInputService.OnScreenKeyboardIsVisible
if (keyboardIsVisible) then
	print("On-screen keyboard is visible!")
else
	print("On-screen keyboard is not visible!")
end
```


As `UserInputService` is client-side only, this property can only be used in a `LocalScript`.

![On screen keyboard](https://developer.roblox.com/assets/5bce5dd5edb71a1476d19609/ClientKeyboard.png)

## See also
 - `OnScreenKeyboardSize`
 - `OnScreenKeyboardPosition` */
	readonly OnScreenKeyboardVisible: boolean;
	/** This property describes whether the user’s current device has a touch screen available.

The property is used to determine if the user's device has a touch screen, and therefore if touch events will fire. If TouchEnabled is true, you can use UserInputService events such as `TouchStarted` and `TouchEnded` to track when a user starts and stops touching the screen of their device.

The code snippet below prints whether the user's device has a touch screen.

```lua
local userInputService = game:GetService("UserInputService")

if userInputService.TouchEnabled then
	print("The user's device has a touchscreen!")
else
	print("The user's device does not have a touchscreen!")
end
```


See [this][1] page for articles on cross-platform development.

[1]: /learn-roblox/cross-platform

## See also
 - `TouchTap`
 - `TouchLongPress`
 - `TouchMoved`
 - `TouchPan`
 - `TouchPinch`
 - `TouchRotate`
 - `TouchSwipe`
 - `TouchStarted`
 - `TouchEnded`

## Code Samples

### Create a Custom CameraScript

By default, Roblox relies on a `LocalScript`, described [here][1], to control the user’s camera. However, this script can be overridden with a custom *CameraScript*. The example below demonstrates how to create a custom script to control the user’s camera using many of the `UserInputService` events.

The script is broken into two parts:

 1. Mobile camera events, which rely on touch events
 2. Non-mobile camera events, which rely on keyboard input and tracking the user’s movement

First, the camera script needs utility functions to setup the camera and set its `CameraType` to *Scriptable* so that the script can control the camera. It also needs a function to update the camera when it moves, rotates, and zooms.

Using touch events allows us to track user input as they interact with the touchscreen on their mobile device. These events allow us to handle camera movement, rotation, and zoom.

The second half of the code sample adds camera support for players on desktop devices. When input begans, the function Input() checks that the state of the input is `Enum.UserInputState.Begin` to ignore all keypress inputs other than when the user first presses a key down. When the user presses *I* and *O* the camera zooms in and out. When the presses down and moves their left mouse button, the script `locks` the player’s mouse by changing the `MouseBehavior` property. The camera rotates according to the mouse’s `change in screen position`. When the player moves their character, the camera moves with them.

All of the parts discussed above are combined and shown in the code sample below.
```lua
-- ========================================
-- GLOBAL VARIABLES
-- ========================================
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- The camera used by the LocalPlayer
local camera = game.Workspace.CurrentCamera

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")
local playerPosition = torso.Position

local default_CameraPosition = torso.Position
local default_CameraRotation = Vector2.new(0,math.rad(-60))
local default_CameraZoom = 15

local cameraPosition = default_CameraPosition
local cameraRotation = default_CameraRotation
local cameraZoom = default_CameraZoom

local cameraRotationBounds = {math.rad(-81),math.rad(20)}
local cameraZoomBounds = nil --{10,200}
local touchDragSpeed = 0.15
local cameraSpeed = 0.1
local cameraRotateSpeed = 10
local cameraMouseRotateSpeed = 0.25
local cameraTouchRotateSpeed = 10
-- ========================================
-- ========================================





-- ========================================
-- UTILITY FUNCTIONS
-- ========================================
local function SetCameraMode()
camera.CameraType = "Scriptable"
camera.FieldOfView = 80
camera.CameraSubject = nil
end

local function UpdateCamera()
SetCameraMode()
local cameraRotationCFrame = CFrame.Angles(0, cameraRotation.X, 0)*CFrame.Angles(cameraRotation.Y, 0, 0)
camera.CFrame = cameraRotationCFrame + cameraPosition + cameraRotationCFrame*Vector3.new(0, 0, cameraZoom)
camera.Focus = camera.CFrame - Vector3.new(0, camera.CFrame.p.Y, 0)
end
-- ========================================
-- ========================================




-- ========================================
-- MOBILE CAMERA EVENTS
-- ========================================
-- Events used to control the camera for players using a mobile device

-- ====================
-- CAMERA MOVE
-- ====================
-- Fired by UserInputService.TouchPan
local lastTouchTranslation = nil
local function TouchMove(touchPositions, totalTranslation, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = totalTranslation - lastTouchTranslation
	cameraPosition = cameraPosition + Vector3.new(difference.X, 0, difference.Y)
		UpdateCamera()
	end
	lastTouchTranslation = totalTranslation
end

-- ====================
-- CAMERA ROTATE
-- ====================
-- Fired by UserInputService.TouchRotate
local lastTouchRotation = nil
local function TouchRotate(touchPositions, rotation, velocity, state)
if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
local difference = rotation - lastTouchRotation
cameraRotation = cameraRotation + Vector2.new(-difference,0)*math.rad(cameraTouchRotateSpeed*cameraRotateSpeed)
		UpdateCamera()
	end
lastTouchRotation = rotation
end

-- ====================
-- CAMERA ZOOM
-- ====================
-- Fired by UserInputService.TouchPinch
local lastTouchScale = nil
local function TouchZoom(touchPositions, scale, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = scale - lastTouchScale
		cameraZoom = cameraZoom * (1 + difference)
		if cameraZoomBounds ~= nil then
			cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
		else
			cameraZoom = math.max(cameraZoom, 0)
end
		UpdateCamera()
	end
	lastTouchScale = scale
end

local function Input()
	UpdateCamera()
end
-- ========================================





-- ========================================
-- NON-MOBILE CAMERA EVENTS
-- ========================================

local function Input(inputObject)
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		if inputObject.UserInputState == Enum.UserInputState.Begin then						
			-- ====================
			-- CAMERA ZOOM
			-- ====================
			-- (I) Zoom In
			if inputObject.KeyCode == Enum.KeyCode.I then
			 	cameraZoom = cameraZoom - 15
			elseif inputObject.KeyCode == Enum.KeyCode.O then
				cameraZoom = cameraZoom + 15
			end
		
			-- (O) Zoom Out
			if cameraZoomBounds ~= nil then
				cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
			else
				cameraZoom = math.max(cameraZoom, 0)
			end
			
			UpdateCamera()
		end
	end
	
	-- ====================
	-- CAMERA ROTATE
	-- ====================
	local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
	if pressed then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		local rotation = userInputService:GetMouseDelta()
		cameraRotation = cameraRotation + rotation*math.rad(cameraMouseRotateSpeed)
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end

-- ====================
-- CAMERA MOVE
-- ====================
local function PlayerChanged()
	local movement = torso.Position - playerPosition
	cameraPosition = cameraPosition + movement
	playerPosition = torso.Position
		
	UpdateCamera()
end
-- ========================================
-- ========================================






-- ========================================
-- DEVICE CHECK
-- ========================================
-- Determine whether the user is on a mobile device

if UserInputService.TouchEnabled then
	-- The user is on a mobile device, use Touch events
UserInputService.TouchPan:Connect(TouchMove)
UserInputService.TouchRotate:Connect(TouchRotate)
UserInputService.TouchPinch:Connect(TouchZoom)
else
	
	-- The user is not on a mobile device use Input events
UserInputService.InputBegan:Connect(Input)
UserInputService.InputChanged:Connect(Input)
UserInputService.InputEnded:Connect(Input)

	-- Camera controlled by player movement
	wait(2)
	RunService:BindToRenderStep("PlayerChanged", Enum.RenderPriority.Camera.Value-1, PlayerChanged)
end	
-- ========================================
-- ========================================
```
 */
	readonly TouchEnabled: boolean;
	/** This property describes whether the user is using a virtual reality (VR) device. 

If a VR device is enabled, you can interact with its location and movement through functions such as `GetUserCFrame``. You can also react to VR device movement using the `UserCFrameChanged` event.

```lua
local userInputService = game:GetService("UserInputService")

local isUsingVR = userInputService.VREnabled
if (isUsingVR) then
	print("User is using a VR headset!")
else
	print("User is not using a VR headset!")
end
```


As `UserInputService` isclient-side only, this property can only be used in a `LocalScript`.

See [this][1] article for VR best practices.

## See also 
 - `VRService`
 - `HeadLocked`
 - `GetUserCFrame`
 -  `UserCFrameChanged`

 [1]: /articles/Virtual-Reality-Best-Practices

## Code Samples

### VR Head Tracking

This example demonstrates how to implement a head tracking script that mirrors the movement of a virtual reality (VR) headset (the user’s actual head) to their in-game `character’s` head. 

The example first check if the user is using a VR device by checking the value of the `VREnabled` property. This example only works if the user is using a VR headset.

To determine the initial `CFrame` of the character’s head, the code sample calls `GetUserCFrame` and passes `Enum.UserCFrame.Head` as the argument.

To update the head’s CFrame whenever the user’s VR headset moves, the example connects the `UserCFrameChanged` event to the *TrackHead()* function. When the event fires to indicate that a VR device moved, TrackHead() checks if the headset moved. If the headset moved, the function updates the CFrame of the character’s head to the `CFrame` *value* provided as an argument.

As the UserCFrame enum also tracks VR left and right hand devices, the concept of VR device tracking can be expanded to other character bodyparts.

In order for the example to work as expected, it must be placed in a `LocalScript`.
```lua
local UserInputService = game:GetService("UserInputService")

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local head = character:WaitForChild("Head")

local function TrackHead(inputType, value)
	if inputType == Enum.UserCFrame.Head then
		head.CFrame = value
	end
end

if UserInputService.VREnabled then
	-- Set the inital CFrame
	head.CFrame = UserInputService:GetUserCFrame(Enum.UserCFrame.Head)
	
	-- Track VR headset movement and mirror for character's head
	UserInputService.UserCFrameChanged:Connect(TrackHead)
end

```
 */
	readonly VREnabled: boolean;
	/** This function returns whether the given `UserInputType` gamepad supports a button corresponding with the given `/KeyCode`. This function is used to determine valid gamepad inputs.

To determine which `UserInputType` gamepads are connected, use `GetConnectedGamepads`.

As `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

See [this][1] page for articles on cross-platform development.

## See also
 - `GamepadConnected`
 - `GamepadDisconnected`
 - `GetConnectedGamepads`
 - `GetNavigationGamepads`
 - `SetNavigationGamepad`
 - `IsNavigationGamepad`
 - `IsGamepadButtonDown`
 - `GetSupportedGamepadKeyCodes`
 - `GetGamepadState`
 - `GetGamepadConnected`
 - `GamepadEnabled`

[1]: /learn-roblox/cross-platform

## Code Samples

### Binding Functions to Gamepad Controls

This example binds the `ButtonX` key to action if it is supported by *controller* (`Gamepad1`). If bound, pressing the X Button invokes the *action()* function, which prints “Action”.
```lua
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")

local controller = Enum.UserInputType.Gamepad1
local buttonX = Enum.KeyCode.ButtonX

local function isSupported(gamepad, keycode)
	return UserInputService:GamepadSupports(gamepad, keycode)
end

local function action()
	print("Action")
end

if isSupported(controller, buttonX) then
	ContextActionService:BindAction("sample action", action, false, buttonX)
end
```

@param gamepadNum The `Enum/UserInputType` of the gamepad
@param gamepadKeyCode The `Enum/KeyCode` of the button in question
@returns Whether the given gamepad supports a button corresponding with the given `Enum/KeyCode|KeyCode` */
	GamepadSupports(gamepadNum: CastsToEnum<Enum.UserInputType>, gamepadKeyCode: CastsToEnum<Enum.KeyCode>): boolean;
	/** This function returns an array of `UserInputType` gamepads currently connected. If no gamepads are connected, this array will be empty. Additionally, it only returns UserInputType objects that are gamepads. For instance, this event will return a connected Gamepad1 object but not a Keyboard object.

For example, the following code snippet retrieves the connected gamepads and stores them in a variable named *connectedGamepads*.

```lua
local userInputService = game:GetService("UserInputService")
local connectedGamepads = userInputService:GetConnectedGamepads()
```


To check if a specific gamepad is connected, use  `GetGamepadConnected`.

As `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

See [this][1] page for articles on cross-platform development.

## See also
 - `GamepadConnected`
 - `GamepadDisconnected`
 - `GetConnectedGamepads`
 - `GetNavigationGamepads`
 - `SetNavigationGamepad`
 - `IsNavigationGamepad`
 - `IsGamepadButtonDown`
 - `GetSupportedGamepadKeyCodes`
 - `GetGamepadState`
 - `GetGamepadConnected`
 - `GamepadSupports`
 - `GamepadEnabled`

[1]: /learn-roblox/cross-platform

## Code Samples

### How to Use the Right Gamepad for Input

The following code sample is used in the default gamepad script, so if you are using the default controls you do not need to worry about this. If you are creating a custom script for handling gamepad controls, this is a good template for retrieving which `gamepad enum` you should use as the primary gamepad controller.

This code looks for the lowest numbered `navigation gamepad`, and if no navigation gamepad is found, finds the lowest numbered `connected gamepad`. If there is no connected gamepad, we default to gamepad1. This ensures at least some gamepad will be able to do controls.
```lua
local UserInputService = game:GetService("UserInputService")

local activeGamepad = nil
function GetActiveGamepad()
	local activateGamepad = nil
	local navigationGamepads = {}
	
	navigationGamepads = UserInputService:GetNavigationGamepads()
	
	if #navigationGamepads > 1 then
		for i = 1, #navigationGamepads do
			if activateGamepad == nil then
				activateGamepad = navigationGamepads[i]
			elseif navigationGamepads[i].Value < activateGamepad.Value then
				activateGamepad = navigationGamepads[i]
			end
		end
	else
		local connectedGamepads = {}
		
		connectedGamepads = UserInputService:GetConnectedGamepads()
		
		if #connectedGamepads > 0 then
			for i = 1, #connectedGamepads do
				if activateGamepad == nil then
					activateGamepad = connectedGamepads[i]
				elseif connectedGamepads[i].Value < activateGamepad.Value then
					activateGamepad = connectedGamepads[i]
				end
			end
		end
		if activateGamepad == nil then -- nothing is connected, at least set up for gamepad1
			activateGamepad = Enum.UserInputType.Gamepad1
		end
	end

	return activateGamepad
end

if UserInputService.GamepadEnabled then
	activeGamepad = GetActiveGamepad()
end
```

@returns An array of `Enum/UserInputType|UserInputTypes` corresponding with the gamepads connected to the user’s device */
	GetConnectedGamepads(): Array<Enum.UserInputType>;
	/** The GetDeviceAcceleration function determines the current acceleration of the user's device. It returns an `InputObject` that describes the device's current acceleration.

In order for this to work, the user's device must have an enabled accelerometer. To check if a user's device has an enabled accelerometer, you can check the `AccelerometerEnabled` property.

If you want to track when the user's device's acceleration changes instead, you can use the `DeviceAccelerationChanged` event.

Since it only fires locally, it can only be used in a `LocalScript`.

## Code Samples

### Print Device Acceleration

This example checks if a user's device has an enabled accelerometer. If it does, the example prints the current acceleration of the device. If not, the example prints: 

> *Cannot get device acceleration because device does not have an enabled accelerometer!*
```lua
local UserInputService = game:GetService("UserInputService")

local accelerometerEnabled = UserInputServiceAccelerometerEnabled

if accelerometerEnabled then
	local acceleration = UserInputService:GetDeviceAcceleration().Position
	print(acceleration)
else
	print("Cannot get device acceleration because device does not have an enabled accelerometer!")
end 
```

@returns An InputObject that describes the device's current acceleration. */
	GetDeviceAcceleration(): InputObject;
	/** This function returns an `InputObject` describing the device's current gravity vector.

The gravity vector is determined by the device’s orientation relative to the real-world force of gravity. For instance, if a device is perfectly upright (portrait), the gravity vector is `Vector3.new(0, 0, -9.18)`. If the left side of the device is pointing down, the vector is Vector3.new(9.81, 0, 0). Finally, if the back of the device is pointing down, the vector is Vector3.new(0, -9.81, 0).

This function might be used to enable the user’s device to impact or control gravity within the game or move in-game objects such as a ball.

Gravity is only tracked for players using a device with an enabled gyroscope - such as a mobile device.

To check if a user's device has an enabled gyroscope, check the value of `GyroscopeEnabled`. If the device has an enabled gyroscope, you can also use the `DeviceGravityChanged` event to track when force of gravity on the user's device changes.

As `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

## Code Samples

### Moving Objects with the Gyroscope

Using the Gyroscope gives us the down direction for the player's device. We can use this to move objects in the game world. This example implements a level where the bubble will move along the Z axis depending on the device's current gryoscope position in Z.

An uncopylocked version of this example can be seen [here](http://www.roblox.com/ROBLOX-Level-Level-place?id=182617063).
```lua
-- Make variable for UserInputService
local UserInputService = game:GetService("UserInputService")
 
-- Make variables for game objects
local label = script.Parent
local bubble = game.Workspace.Bubble
local camera = game.Workspace.CurrentCamera
 
-- Fix camera above level
camera.CameraType = Enum.CameraType.Scriptable
camera.CoordinateFrame = CFrame.new(Vector3.new(0,20,0), Vector3.new(0,0,0))
 
-- Check if user's device supports accelerometer
if UserInputService.GyroscopeEnabled then
	-- Bind event to when gyroscope detects change
	UserInputService.DeviceGravityChanged:Connect(function(accel)
		-- Display accelerometer output to a TextLabel
		label.Text = string.format("%.2f", accel.Position.X) .. "\n" ..
					 string.format("%.2f", accel.Position.Y) .. "\n" ..
					 string.format("%.2f", accel.Position.Z)
		-- Move the bubble in the world based on the gyroscope data
		bubble.Position = Vector3.new(0, 1.8, - 8 * accel.Position.Z)
	end)
else
	-- Kindly turn away users who do not have an gyroscope
	local message = Instance.new("Message", game.Players.LocalPlayer.PlayerGui)
	message.Text = "This game only works on a device with a gyroscope."
end
```

@returns An `InputObject` that describes the device's current gravity vector */
	GetDeviceGravity(): InputObject;
	/** This function returns an `InputObject` and a `CFrame` describing the device's current rotation vector.

This is fired with an InputObject. The *Position* property of the input object is a `Enum.InputType.Gyroscope` that tracks the total rotation in each local device axis.

Device rotation can only be tracked on devices with a `gyroscope.

As this function fires locally, it can only be used in a `LocalScript`.

## Code Samples

### Print Device Rotation

This example prints the current CFrame of a players device. Note that this will only work as expected if the player's device has an enabled gyroscope. If not, the example prints: 

> *Cannot get device rotation because device does not have an enabled gyroscope!*
```lua
local UserInputService = game:GetService("UserInputService")

local gyroEnabled = UserInputService:GyroscopeEnabled()

if gyroEnabled then
	local inputObj, cframe = UserInputService:GetDeviceRotation()
	print("CFrame: {",cframe,"}")
else
	print("Cannot get device rotation because device does not have an enabled gyroscope!")
end
```

@returns A tuple containing two properties:

 1. The delta property describes the amount of rotation that last happened
 2. The CFrame is the device's current rotation relative to its default reference frame */
	GetDeviceRotation(): LuaTuple<[InputObject, CFrame]>;
	/** This function returns the `TextBox` the client is currently focused on. A TextBox can be manually selected by the user, or selection can be forced using the `CaptureFocus` function. If no TextBox is selected, this function will return *nil*.

As `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

## See also
 - `TextBoxFocused`
 - `TextBoxFocusReleased`
 - `CaptureFocus`
 - `IsFocused` 
 - `ReleaseFocus`

## Code Samples

### Ignore User Input When a TextBox Is Focused

This example demonstrates how to ignore user input when any `TextBox` is focused. When a player is not focusing on any TextBox, pressing the *jumpKey* (`J Key`) change’s their humanoid’s `state` to Jumping using the `ChangeState` function to make their character jump. 

When the player is focusing on any TextBox, the player will not jump. The example checks if any TextBox is focused by checking if the `GetFocusedTextbox` function returns `nil` instead of a TextBox instance.

This connects to the `StateChanged` event to determine when the player is jumping and prevent the player from using the jumpKey to jump while already jumping.
```lua
local UserInputService = game:GetService("UserInputService")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character
local humanoid = character:WaitForChild("Humanoid")

local jumpKey = Enum.KeyCode.J
local isJumping = false

local function InputBegan(input, gameProcessedEvent)
	local TextBoxFocused = UserInputService:GetFocusedTextBox()
	
	-- Ignore input event if player is focusing on a TextBox
	if TextBoxFocused then return end
	
	-- Make player jump when user presses jumpKey Key on Keyboard
	if (input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == jumpKey) then
		if not isJumping then
			isJumping = true
			humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end
end

local function StateChanged(oldState, newState)
	-- Prevent player from jumping again using jumpKey if already jumping
	if (newState == Enum.HumanoidStateType.Jumping) then
		isJumping = true
	-- Allow player to jump again after landing
	elseif (newState == Enum.HumanoidStateType.Landed) then
		isJumping = false
	end
end

UserInputService.InputBegan:Connect(InputBegan)
humanoid.StateChanged:Connect(StateChanged)
```

@returns The `TextBox` currently in focus, or *nil* if none are selected */
	GetFocusedTextBox(): TextBox | undefined;
	/** This function returns whether a gamepad with the given `UserInputType`  is connected to the client.

This can be used to check if a specific gamepad, such as *’Gamepad1’* is connected to the client's device.

To retrieve a list of all connected gamepads, use `GetConnectedGamepads`.

As `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

Check out this [article][2] to learn more about adding support for gamepad input into your game and [this][1] page for articles on cross-platform development.

## See also
 - `GamepadConnected`
 - `GamepadDisconnected`
 - `GetConnectedGamepads`
 - `GetNavigationGamepads`
 - `SetNavigationGamepad`
 - `IsNavigationGamepad`
 - `IsGamepadButtonDown`
 - `GetSupportedGamepadKeyCodes`
 - `GetGamepadState`
 - `GamepadSupports`
 - `GamepadEnabled`

  [1]: /learn-roblox/cross-platform
  [2]: /articles/Gamepad-Haptic-Feedback

## Code Samples

### Check Whether a Gamepad is Connected

This example returns whether `Gamepad1` is connected to the client. It will print *true* if Gamepad1 is connected and *false* if Gamepad1 is not connected.
```lua
local UserInputService = game:GetService("UserInputService")

local isConnected = UserInputService:GetGamepadConnected(Enum.UserInputType.Gamepad1)

if isConnected then
    print("Gamepad1 is connected to the client")
else
    print("Gamepad1 is not connected to the client")
end
```

@param gamepadNum The `Enum/UserInputType` of the gamepad in question
@returns Whether a gamepad associated with `Enum/UserInputType` is connected */
	GetGamepadConnected(gamepadNum: CastsToEnum<Enum.UserInputType>): boolean;
	/** The GetGamepadState function returns an array of `InputObjects` for each input on the gamepad with each input's last input state. You can iterate through the returned array to determine the last state of each valid input type for the gamepad.

To determine which `UserInputType` Gamepads are connected, you can use the `GetConnectedGamepads` function.

Since it only fires locally, it can only be used in a `LocalScript`.

## Code Samples

### UserInputService:GetGamepadState

This example returns and iterates through an array of the last input types for the *GamePad1*  `UserInputType`. The example's for loop prints the `UserInputState` of each returned input `InputObject`.
```lua
local UserInputService = game:GetService("UserInputService")

local inputs = UserInputService:GetGamepadState(Enum.UserInputType.Gamepad1)

for index, input in pairs (inputs) do
	print (input.UserInputState)
end
```

@param gamepadNum A `Enum/UserInputType` value corresponding to the gamepad you want to get the state of.
@returns Array of `InputObject`s. */
	GetGamepadState(gamepadNum: CastsToEnum<Enum.UserInputType>): Array<InputObject>;
	/** This function returns an array of `InputObjects` associated with the keys currently being pressed down.

This array can be iterated through to determine which keys are currently being pressed, using the `KeyCode` values.

To check if a specific key is being pressed, use `IsKeyDown`.

As `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

## Code Samples

### Double Jump Key Combo

This example demonstrates how to use the `GetKeysPressed` function to create a combo action where the player double jumps when the the player presses *actionKey* key (Left Shift) + Jump key (Spacebar).

The *actionKey* variable indicates which key, combined with the Jump key, needs to be pressed for the player to double jump.

When the player presses the Jump key, the `JumpRequest` event is invoked, which is connected to the script’s *jumpRequest* function. If the Left Shift key is pressed and the player is not already in the middle of a jump, this function sets the *canDoubleJump* boolean to *true*. 

The example connects the *stateChanged* function to the `StateChanged` event so that the function fires when their `humanoid’s state` changes. If the state changes from Jumping to Freefall, and the *canDoubleJump* boolean is *true*, the function makes the player jump again by setting their humanoid’s state back to Jumping using the `ChangeState` function
.
The example also uses the *canJump* boolean variable to determine when the player is in the middle of a jump. Without this variable, the player could press the *actionKey* + Jump Key (spacebar) to jump endlessly without landing. When the boolean is true, the player is not jumping. If the player is not jumping, *jumpRequest()* checks if the *actionKey* is pressed and sets *canJump* to false. When the player lands, *stateChanged()* sets the variable to true.
```lua
local UserInputService = game:GetService("UserInputService")

local Players = game.Players
local player = Players.LocalPlayer
local character = player.Character
local humanoid = character:WaitForChild("Humanoid")

local actionKey = Enum.KeyCode.LeftShift
local canJump = true
local canDoubleJump = false

local function jumpRequest()
	local keysPressed = UserInputService:GetKeysPressed()
	for _, key in ipairs(keysPressed) do
		if (key.KeyCode == actionKey and canJump) then
			canJump = false
			canDoubleJump = true
		end
	end
end

local function stateChanged(oldState, newState)
	-- Double jump during freefall if able to
	if (oldState == Enum.HumanoidStateType.Jumping and newState == Enum.HumanoidStateType.Freefall and canDoubleJump) then
		canDoubleJump = false
		wait(.2)
		humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
	end
	
	-- Allow player to jump again after they land
	if (oldState == Enum.HumanoidStateType.Freefall and newState == Enum.HumanoidStateType.Landed) then
		canJump = true
	end
end

UserInputService.JumpRequest:Connect(jumpRequest)
humanoid.StateChanged:Connect(stateChanged)
```

@returns An array of `InputObject|InputObjects` associated with the keys currently being pressed */
	GetKeysPressed(): Array<InputObject>;
	/** This function returns 'Enum/UserInputType` associated with the user’s most recent input.

For example, if the user’s previous input had been pressing the spacebar, the `UserInputType` returned would be *‘Keyboard’*.

The `LastInputTypeChanged` event can be used to track when the last `UserInputType` used by the user changes.

As `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

## Code Samples

### UserInputService:GetLastInputType

This example gets the `last input type` and indicates if it was keyboard input.
```lua
local UserInputService = game:GetService("UserInputService")

local lastInput = UserInputService:GetLastInputType()

if (lastInput == Enum.UserInputType.Keyboard) then
	print("Most recent input was via keyboard")
end
```

@returns The `Enum/UserInputType` associated with the user’s most recent input */
	GetLastInputType(): Enum.UserInputType;
	/** This function returns an array of `InputObjects` corresponding to the mouse buttons currently being pressed down.

Mouse buttons that are tracked by this function include:
| Name | Description |
| MouseButton1 | The left mouse button. |
| MouseButton2 | The right mouse button. |
| MouseButton3 | The middle mouse button. |


If the user is not pressing any mouse button down when the function is called, it will return an empty array.

As `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

## Code Samples

### Check which MouseButtons are Pressed

This example checks if the user pressed MouseButton1, MouseButton2, or both mouse buttons on `InputBegan`.

The example can be extended to behave differently depending on which mouse buttons are pressed.
```lua
local UserInputService = game:GetService("UserInputService")

-- InputBegan is a UserInputService event that fires when the player
-- begins interacting via a Human-User input device
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
-- Returns an array of the pressed MouseButtons
local buttons = UserInputService:GetMouseButtonsPressed()

	local m1Pressed, m2Pressed = false, false
	for _, button in pairs (buttons) do
		-- Check if MouseButton1 is pressed
		if (button.UserInputType.Name == "MouseButton1") then
			print("MouseButton1 is pressed")
			m1Pressed = true
		end

		-- Check if MouseButton2 is pressed
		if (button.UserInputType.Name == "MouseButton2") then
			print("MouseButton2 is pressed")
			m2Pressed = true
		end
		
		-- Check if both MouseButton1 and MouseButton2 are pressed
		if (m1Pressed and m2Pressed) then
			print("Both mouse buttons are pressed")
		end
	end
end)
```

@returns An array of `InputObject|InputObjects` corresponding to the mouse buttons currently being currently held down */
	GetMouseButtonsPressed(): Array<InputObject>;
	/** This function returns the change, in pixels, of the position of the player’s `Mouse` in the last rendered frame as a `Vector2`. This function only works if the mouse has been locked using the `UserInputService.MouseBehavior` property. If the mouse has not been locked, the returned `Vector2` values will be zero.

The sensitivity of the mouse, determined in the client’s settings and `MouseDeltaSensitivity`, will influence the result.

As `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

## Code Samples

### Create a Custom CameraScript

By default, Roblox relies on a `LocalScript`, described [here][1], to control the user’s camera. However, this script can be overridden with a custom *CameraScript*. The example below demonstrates how to create a custom script to control the user’s camera using many of the `UserInputService` events.

The script is broken into two parts:

 1. Mobile camera events, which rely on touch events
 2. Non-mobile camera events, which rely on keyboard input and tracking the user’s movement

First, the camera script needs utility functions to setup the camera and set its `CameraType` to *Scriptable* so that the script can control the camera. It also needs a function to update the camera when it moves, rotates, and zooms.

Using touch events allows us to track user input as they interact with the touchscreen on their mobile device. These events allow us to handle camera movement, rotation, and zoom.

The second half of the code sample adds camera support for players on desktop devices. When input begans, the function Input() checks that the state of the input is `Enum.UserInputState.Begin` to ignore all keypress inputs other than when the user first presses a key down. When the user presses *I* and *O* the camera zooms in and out. When the presses down and moves their left mouse button, the script `locks` the player’s mouse by changing the `MouseBehavior` property. The camera rotates according to the mouse’s `change in screen position`. When the player moves their character, the camera moves with them.

All of the parts discussed above are combined and shown in the code sample below.
```lua
-- ========================================
-- GLOBAL VARIABLES
-- ========================================
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- The camera used by the LocalPlayer
local camera = game.Workspace.CurrentCamera

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")
local playerPosition = torso.Position

local default_CameraPosition = torso.Position
local default_CameraRotation = Vector2.new(0,math.rad(-60))
local default_CameraZoom = 15

local cameraPosition = default_CameraPosition
local cameraRotation = default_CameraRotation
local cameraZoom = default_CameraZoom

local cameraRotationBounds = {math.rad(-81),math.rad(20)}
local cameraZoomBounds = nil --{10,200}
local touchDragSpeed = 0.15
local cameraSpeed = 0.1
local cameraRotateSpeed = 10
local cameraMouseRotateSpeed = 0.25
local cameraTouchRotateSpeed = 10
-- ========================================
-- ========================================





-- ========================================
-- UTILITY FUNCTIONS
-- ========================================
local function SetCameraMode()
camera.CameraType = "Scriptable"
camera.FieldOfView = 80
camera.CameraSubject = nil
end

local function UpdateCamera()
SetCameraMode()
local cameraRotationCFrame = CFrame.Angles(0, cameraRotation.X, 0)*CFrame.Angles(cameraRotation.Y, 0, 0)
camera.CFrame = cameraRotationCFrame + cameraPosition + cameraRotationCFrame*Vector3.new(0, 0, cameraZoom)
camera.Focus = camera.CFrame - Vector3.new(0, camera.CFrame.p.Y, 0)
end
-- ========================================
-- ========================================




-- ========================================
-- MOBILE CAMERA EVENTS
-- ========================================
-- Events used to control the camera for players using a mobile device

-- ====================
-- CAMERA MOVE
-- ====================
-- Fired by UserInputService.TouchPan
local lastTouchTranslation = nil
local function TouchMove(touchPositions, totalTranslation, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = totalTranslation - lastTouchTranslation
	cameraPosition = cameraPosition + Vector3.new(difference.X, 0, difference.Y)
		UpdateCamera()
	end
	lastTouchTranslation = totalTranslation
end

-- ====================
-- CAMERA ROTATE
-- ====================
-- Fired by UserInputService.TouchRotate
local lastTouchRotation = nil
local function TouchRotate(touchPositions, rotation, velocity, state)
if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
local difference = rotation - lastTouchRotation
cameraRotation = cameraRotation + Vector2.new(-difference,0)*math.rad(cameraTouchRotateSpeed*cameraRotateSpeed)
		UpdateCamera()
	end
lastTouchRotation = rotation
end

-- ====================
-- CAMERA ZOOM
-- ====================
-- Fired by UserInputService.TouchPinch
local lastTouchScale = nil
local function TouchZoom(touchPositions, scale, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = scale - lastTouchScale
		cameraZoom = cameraZoom * (1 + difference)
		if cameraZoomBounds ~= nil then
			cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
		else
			cameraZoom = math.max(cameraZoom, 0)
end
		UpdateCamera()
	end
	lastTouchScale = scale
end

local function Input()
	UpdateCamera()
end
-- ========================================





-- ========================================
-- NON-MOBILE CAMERA EVENTS
-- ========================================

local function Input(inputObject)
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		if inputObject.UserInputState == Enum.UserInputState.Begin then						
			-- ====================
			-- CAMERA ZOOM
			-- ====================
			-- (I) Zoom In
			if inputObject.KeyCode == Enum.KeyCode.I then
			 	cameraZoom = cameraZoom - 15
			elseif inputObject.KeyCode == Enum.KeyCode.O then
				cameraZoom = cameraZoom + 15
			end
		
			-- (O) Zoom Out
			if cameraZoomBounds ~= nil then
				cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
			else
				cameraZoom = math.max(cameraZoom, 0)
			end
			
			UpdateCamera()
		end
	end
	
	-- ====================
	-- CAMERA ROTATE
	-- ====================
	local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
	if pressed then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		local rotation = userInputService:GetMouseDelta()
		cameraRotation = cameraRotation + rotation*math.rad(cameraMouseRotateSpeed)
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end

-- ====================
-- CAMERA MOVE
-- ====================
local function PlayerChanged()
	local movement = torso.Position - playerPosition
	cameraPosition = cameraPosition + movement
	playerPosition = torso.Position
		
	UpdateCamera()
end
-- ========================================
-- ========================================






-- ========================================
-- DEVICE CHECK
-- ========================================
-- Determine whether the user is on a mobile device

if UserInputService.TouchEnabled then
	-- The user is on a mobile device, use Touch events
UserInputService.TouchPan:Connect(TouchMove)
UserInputService.TouchRotate:Connect(TouchRotate)
UserInputService.TouchPinch:Connect(TouchZoom)
else
	
	-- The user is not on a mobile device use Input events
UserInputService.InputBegan:Connect(Input)
UserInputService.InputChanged:Connect(Input)
UserInputService.InputEnded:Connect(Input)

	-- Camera controlled by player movement
	wait(2)
	RunService:BindToRenderStep("PlayerChanged", Enum.RenderPriority.Camera.Value-1, PlayerChanged)
end	
-- ========================================
-- ========================================
```

### Getting Mouse Delta

GetMouseDelta returns the current change in movement of the mouse as a Vector2, but only if the mouse is locked. If the mouse isn’t locked the values in the returned Vector2 will be zero. It measures any mouse movement in pixels from the last render step to the current render step. If the user has set their camera sensitivity to be higher or lower than 1 in the in-game menu this will affect the value returned by GetMouseDelta. The camera sensitivity is a multiplier to the amount the camera moves as a result of mouse input.
```lua
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
 
local function OnRenderStep()
    local delta = userInputService:GetMouseDelta()
    print("The mouse has moved", delta, "since the last step.")
end
 
RunService:BindToRenderStep("MeasureMouseMovement", Enum.RenderPriority.Input.Value, OnRenderStep)
```

@returns Change in movement of the mouse */
	GetMouseDelta(): Vector2;
	/** The GetMouseLocation function returns a `Vector2` of the current screen location of the player's `Mouse` in pixels.

**Note:** If the location of the mouse pointer is offscreen or the players device does not have a mouse, such as a gamepad or touchscreen, the value returned will be undetermined.

Since `UserInputService` only runs client-side, this function will only work when used in a `LocalScript`.

## Code Samples

### UserInputService:GetMouseLocation

GetMouseLocation returns a Vector2 of the current screen location of the player's mouse pointer in pixels. If the location of the mouse pointer is offscreen or the player’s device does not have a mouse the value returned will be undetermined.
```lua
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
 
-- Arbitrary wait to give user time to position mouse
wait(2) 
 
local mouseLocation = UserInputService:GetMouseLocation()
print("The mouse location is", mouseLocation)
```

@returns The current screen location of the mouse. */
	GetMouseLocation(): Vector2;
	/** This function returns an array of gamepad `UserInputTypes` that are connected and enabled for GUI navigation. This list is in descending order of priority, meaning it can be iterated over to determine which gamepad should have navigation control.

Whether a connected gamepad is a navigation gamepad only determines which gamepad(s) control the navigation GUIs. This does not influence navigation controls.

Since `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

## See also
 - `SetNavigationGamepad`, to enable or disable a gamepad for GUI navigation
 - `IsNavigationGamepad`, to verify if a gamepad is enabled for GUI navigation
 - `GetConnectedGamepads`, to return all gamepads connected regardless of GUI navigational control

## Code Samples

### How to Use the Right Gamepad for Input

The following code sample is used in the default gamepad script, so if you are using the default controls you do not need to worry about this. If you are creating a custom script for handling gamepad controls, this is a good template for retrieving which `gamepad enum` you should use as the primary gamepad controller.

This code looks for the lowest numbered `navigation gamepad`, and if no navigation gamepad is found, finds the lowest numbered `connected gamepad`. If there is no connected gamepad, we default to gamepad1. This ensures at least some gamepad will be able to do controls.
```lua
local UserInputService = game:GetService("UserInputService")

local activeGamepad = nil
function GetActiveGamepad()
	local activateGamepad = nil
	local navigationGamepads = {}
	
	navigationGamepads = UserInputService:GetNavigationGamepads()
	
	if #navigationGamepads > 1 then
		for i = 1, #navigationGamepads do
			if activateGamepad == nil then
				activateGamepad = navigationGamepads[i]
			elseif navigationGamepads[i].Value < activateGamepad.Value then
				activateGamepad = navigationGamepads[i]
			end
		end
	else
		local connectedGamepads = {}
		
		connectedGamepads = UserInputService:GetConnectedGamepads()
		
		if #connectedGamepads > 0 then
			for i = 1, #connectedGamepads do
				if activateGamepad == nil then
					activateGamepad = connectedGamepads[i]
				elseif connectedGamepads[i].Value < activateGamepad.Value then
					activateGamepad = connectedGamepads[i]
				end
			end
		end
		if activateGamepad == nil then -- nothing is connected, at least set up for gamepad1
			activateGamepad = Enum.UserInputType.Gamepad1
		end
	end

	return activateGamepad
end

if UserInputService.GamepadEnabled then
	activeGamepad = GetActiveGamepad()
end
```

@returns An array of `UserInputType|UserInputTypes` that can be used for GUI navigation, in descending order of priority */
	GetNavigationGamepads(): Array<Enum.UserInputType>;

	GetStringForKeyCode(keyCode: CastsToEnum<Enum.KeyCode>): string;
	/** This function returns an array of `KeyCodes` that the gamepad associated with the given `UserInputType` supports. 

This function can be used to determine which KeyCodes are supported and not supported by a connected gamepad. To determine if a specific KeyCode is supported, use `GamepadSupports`.

If called on a non existent, or non connected, gamepad, this function will return an empty array.

As `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

Check out this [article][2] to learn more about adding support for gamepad input into your game and [this][1] page for articles on cross-platform development.

## See also
 - `GamepadConnected`
 - `GamepadDisconnected`
 - `GetConnectedGamepads`
 - `GetNavigationGamepads`
 - `SetNavigationGamepad`
 - `IsNavigationGamepad`
 - `IsGamepadButtonDown`
 - `GetGamepadState`
 - `GetGamepadConnected`
 - `GamepadSupports`
 - `GamepadEnabled`

  [1]: /learn-roblox/cross-platform
  [2]: /articles/Gamepad-Haptic-Feedback

## Code Samples

### Binding Supported Gamepad KeyCodes

This example gets a list of navigation gamepads and a list of their supported `KeyCodes`. Then, it iterates through the supported KeyCode list and binds the *ButtonX* and *X* keys to functions if they are supported by a gamepad using the `ContextActionService`.

Check out this [article][1] to learn more about adding support for gamepad input into your game.

  [1]: /articles/Gamepad-Haptic-Feedback
```lua
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService(“ContextActionService”)

local function actionHandler(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin then 
		print("Action Handler: " .. actionName)
	end

	-- Since this function does not return anything, this handler will
	-- "sink" the input and no other action handlers will be called after
	-- this one.
end

local navGamepads = UserInputService:GetNavigationGamepads()
for _, gamepad in pairs(navGamepads) do
    local supportedKeyCodes = UserInputService:GetSupportedGamepadKeyCodes()

    for _, keycode in pairs(supportedKeyCodes) do
        if (keycode == Enum.KeyCode.ButtonX) then
            ContextActionService:BindAction(“SampleAction”, actionHandler, false, Enum.KeyCode.ButtonX)
        end
        if (keycode == Enum.KeyCode.X) then
            ContextActionService:BindAction(“SampleAction”, actionHandler, false, Enum.KeyCode.X)
        end
    end
end
```

@param gamepadNum The `Enum/UserInputType` of the gamepad
@returns An array of `Enum/KeyCode|KeyCodes` supported by the given gamepad */
	GetSupportedGamepadKeyCodes(gamepadNum: CastsToEnum<Enum.UserInputType>): Array<Enum.KeyCode>;
	/** The GetUserCFrame function returns a `CFrame` describing the position and orientation of a specified `UserCFrame` virtual reality (VR) device. If the specified device is not connected, the function returns `CFrame.new()`.

For example, the code snippet below prints the CFrame of the user’s VR headset.

```lua
local userInputService = game:GetService("UserInputService")
local cframe = userInputService:GetUserCFrame(Enum.UserCFrame.Head)

print(cframe)
```


By using the function, players can implement features such as re-positioning the user's in-game character corresponding to the location of a connected VR device. This can be done by changing the *CFrame* of the user's in-game body parts to match the *CFrame* of the specified VR device using `UserCFrame` and `CFrame` value arguments passed by the event.

## See also
 - `UserCFrameChanged`, an event which fires when the `CFrame` of a VR device changes
 - `VRService`, a service used to implement VR support

As this event only fires locally, it can only be used in a `LocalScript`.

## Code Samples

### VR Head Tracking

This example demonstrates how to implement a head tracking script that mirrors the movement of a virtual reality (VR) headset (the user’s actual head) to their in-game `character’s` head. 

The example first check if the user is using a VR device by checking the value of the `VREnabled` property. This example only works if the user is using a VR headset.

To determine the initial `CFrame` of the character’s head, the code sample calls `GetUserCFrame` and passes `Enum.UserCFrame.Head` as the argument.

To update the head’s CFrame whenever the user’s VR headset moves, the example connects the `UserCFrameChanged` event to the *TrackHead()* function. When the event fires to indicate that a VR device moved, TrackHead() checks if the headset moved. If the headset moved, the function updates the CFrame of the character’s head to the `CFrame` *value* provided as an argument.

As the UserCFrame enum also tracks VR left and right hand devices, the concept of VR device tracking can be expanded to other character bodyparts.

In order for the example to work as expected, it must be placed in a `LocalScript`.
```lua
local UserInputService = game:GetService("UserInputService")

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local head = character:WaitForChild("Head")

local function TrackHead(inputType, value)
	if inputType == Enum.UserCFrame.Head then
		head.CFrame = value
	end
end

if UserInputService.VREnabled then
	-- Set the inital CFrame
	head.CFrame = UserInputService:GetUserCFrame(Enum.UserCFrame.Head)
	
	-- Track VR headset movement and mirror for character's head
	UserInputService.UserCFrameChanged:Connect(TrackHead)
end

```

@param type The `Enum/UserCFrame` corresponding to the VR device
@returns A `DataType/CFrame` describing the position and orientation of the specified VR device */
	GetUserCFrame(type: CastsToEnum<Enum.UserCFrame>): CFrame;
	/** This functions allows a developer to quickly check if a particular button is pressed on a particular gamepad. It returns true if the `gamepad` has the specified `button` pressed down, otherwise it returns false.


## Valid UserInputTypes
The specified gamepad should be one of the following UserInputType enum values:
| Name |
| --- |
| Enum.UserInputType.Gamepad1-8< |  |

## Valid KeyCodes
The specified button should be one of the following KeyCodes enum values:

| Name |
| --- |
| Enum.KeyCode.ButtonX< |  |
| Enum.KeyCode.ButtonY< |  |
| Enum.KeyCode.ButtonA< |  |
| Enum.KeyCode.ButtonB< |  |
| Enum.KeyCode.ButtonR1< |  |
| Enum.KeyCode.ButtonL1< |  |
| Enum.KeyCode.ButtonR3< |  |
| Enum.KeyCode.ButtonL3< |  |
| Enum.KeyCode.ButtonStart< |  |
| Enum.KeyCode.ButtonSelect< |  |
| Enum.KeyCode.DPadLeft< |  |
| Enum.KeyCode.DPadRight< |  |
| Enum.KeyCode.DPadUp< |  |
| Enum.KeyCode.DPadDown< |  |


This can be used to check whether a specific button, such as A, is being held down. For example:

```lua
local UserInputService = game:GetService("UserInputService")

local button = Enum.KeyCode.ButtonA
local gamepad = Enum.UserInputType.Gamepad1

local isButtonHeld = UserInputService:IsGamepadButtonDown(gamepad, button)
```

Since `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

See [this][1] page for articles on cross-platform development.

## See also
 - `GamepadConnected`
 - `GamepadDisconnected`
 - `GetConnectedGamepads`
 - `GetNavigationGamepads`
 - `SetNavigationGamepad`
 - `IsNavigationGamepad`
 - `GetSupportedGamepadKeyCodes`
 - `GetGamepadState`
 - `GetGamepadConnected`
 - `GamepadSupports`
 - `GamepadEnabled`
 - `IsKeyDown` - A similar event with a different use: To check if a given `key` on a `keyboard` is pressed.

 [1]: /learn-roblox/cross-platform

## Code Samples

### Special Action on Gamepad Button Combo

This example uses the `IsGamepadButtonDown` function to create different behaviors when the `X gamepad button` is pressed than when a X button is not pressed when user input `begins`.

The local function *IsGamepadXDown()* returns whether the X gamepad button is down. This function checks if the X button is down for the *activeGamepad*, which is set by *GetActiveGamepad*. The *GetActiveGamepad()* fnction finds the lowest numbered `navigation gamepad`, `connected gamepad`, or `gamepad1` if there are no navigation or connected gamepads.
```lua
local UserInputService = game:GetService("UserInputService")

local activeGamepad = nil
local buttonX = Enum.KeyCode.ButtonX

local function IsGamepadXDown()
	if activeGamepad then
		return UserInputService:IsGamepadButtonDown(activeGamepad, buttonX)
	end
	
	return false
end

local function Input(input, gameProcessedEvent)
	if not IsGamepadXDown() then
		-- Normal event
	else
		-- X Button down event
	end
end

function GetActiveGamepad()
	local activateGamepad = nil
	local navigationGamepads = {}
	
	navigationGamepads = UserInputService:GetNavigationGamepads()
	
	if #navigationGamepads > 1 then
		for i = 1, #navigationGamepads do
			if activateGamepad == nil then
				activateGamepad = navigationGamepads[i]
			elseif navigationGamepads[i].Value < activateGamepad.Value then
				activateGamepad = navigationGamepads[i]
			end
		end
	else
		local connectedGamepads = {}
		
		connectedGamepads = UserInputService:GetConnectedGamepads()
		
		if #connectedGamepads > 0 then
			for i = 1, #connectedGamepads do
				if activateGamepad == nil then
					activateGamepad = connectedGamepads[i]
				elseif connectedGamepads[i].Value < activateGamepad.Value then
					activateGamepad = connectedGamepads[i]
				end
			end
		end
		if activateGamepad == nil then -- nothing is connected, at least set up for gamepad1
			activateGamepad = Enum.UserInputType.Gamepad1
		end
	end

	return activateGamepad
end

if UserInputService.GamepadEnabled then
	activeGamepad = GetActiveGamepad()
	UserInputService.InputBegan:Connect(Input)
end
```

@param gamepadNum The `Enum/UserInputType` of the given gamepad
@param gamepadKeyCode The `Enum\KeyCode` of the specified button
@returns Whether the specified gamepad button on the given gamepad is pressed is pressed */
	IsGamepadButtonDown(gamepadNum: CastsToEnum<Enum.UserInputType>, gamepadKeyCode: CastsToEnum<Enum.KeyCode>): boolean;
	/** This function returns  whether the user is holding down the key associated with the given `KeyCode`. It returns *true* if the specified key is pressed or *false* if it is not pressed.

This can be used to check if a specific key, such as the space bar, is being pressed. For example: 

```lua
local UserInputService = game:GetService("UserInputService")

local spaceHeld = UserInputService:IsKeyDown(Enum.KeyCode.Space)
```


To retrieve a list of all keys pressed by the user, use the `GetKeysPressed` function.

Since `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

## See also
 - `IsGamepadButtonDown` - A similar event with a different use: To check if a given `button` on a `gamepad` is pressed.

## Code Samples

### Special Action on Key Combo Press

This example uses the `IsKeyDown` function to create different behaviors when a shift key is held down than when a shift key is not held down when user input `begins`.

The local function *IsShiftKeyDown()* returns whether the left or right shift `keys` are pressed.
```lua
local UserInputService = game:GetService("UserInputService")

-- Shift keys
local shiftKeyL = Enum.KeyCode.LeftShift
local shiftKeyR = Enum.KeyCode.RightShift

-- Return whether left or right shift keys are down
local function IsShiftKeyDown()
	return UserInputService:IsKeyDown(shiftKeyL) or UserInputService:IsKeyDown(shiftKeyR)
end

-- Handle user input began differently depending on whether a shift key is pressed
local function Input(input, gameProcessedEvent)
	if not IsShiftKeyDown() then
		-- Normal input
	else
		-- Shift input
	end
end

UserInputService.InputBegan:Connect(Input)
```

@param keyCode The `Enum/KeyCode` of the the key
@returns Whether the specified key is being held down */
	IsKeyDown(keyCode: CastsToEnum<Enum.KeyCode>): boolean;
	/** This function takes a mouse button `UserInputType` and returns a bool that indicates whether it is currently pressed. 

The mouse button checked depends on the `UserInputType` value passed to the function as an argument. For example:

```lua
local UserInputService = game:GetService("UserInputService")
	
local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
```


Since `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

## Code Samples

### Create a Custom CameraScript

By default, Roblox relies on a `LocalScript`, described [here][1], to control the user’s camera. However, this script can be overridden with a custom *CameraScript*. The example below demonstrates how to create a custom script to control the user’s camera using many of the `UserInputService` events.

The script is broken into two parts:

 1. Mobile camera events, which rely on touch events
 2. Non-mobile camera events, which rely on keyboard input and tracking the user’s movement

First, the camera script needs utility functions to setup the camera and set its `CameraType` to *Scriptable* so that the script can control the camera. It also needs a function to update the camera when it moves, rotates, and zooms.

Using touch events allows us to track user input as they interact with the touchscreen on their mobile device. These events allow us to handle camera movement, rotation, and zoom.

The second half of the code sample adds camera support for players on desktop devices. When input begans, the function Input() checks that the state of the input is `Enum.UserInputState.Begin` to ignore all keypress inputs other than when the user first presses a key down. When the user presses *I* and *O* the camera zooms in and out. When the presses down and moves their left mouse button, the script `locks` the player’s mouse by changing the `MouseBehavior` property. The camera rotates according to the mouse’s `change in screen position`. When the player moves their character, the camera moves with them.

All of the parts discussed above are combined and shown in the code sample below.
```lua
-- ========================================
-- GLOBAL VARIABLES
-- ========================================
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- The camera used by the LocalPlayer
local camera = game.Workspace.CurrentCamera

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")
local playerPosition = torso.Position

local default_CameraPosition = torso.Position
local default_CameraRotation = Vector2.new(0,math.rad(-60))
local default_CameraZoom = 15

local cameraPosition = default_CameraPosition
local cameraRotation = default_CameraRotation
local cameraZoom = default_CameraZoom

local cameraRotationBounds = {math.rad(-81),math.rad(20)}
local cameraZoomBounds = nil --{10,200}
local touchDragSpeed = 0.15
local cameraSpeed = 0.1
local cameraRotateSpeed = 10
local cameraMouseRotateSpeed = 0.25
local cameraTouchRotateSpeed = 10
-- ========================================
-- ========================================





-- ========================================
-- UTILITY FUNCTIONS
-- ========================================
local function SetCameraMode()
camera.CameraType = "Scriptable"
camera.FieldOfView = 80
camera.CameraSubject = nil
end

local function UpdateCamera()
SetCameraMode()
local cameraRotationCFrame = CFrame.Angles(0, cameraRotation.X, 0)*CFrame.Angles(cameraRotation.Y, 0, 0)
camera.CFrame = cameraRotationCFrame + cameraPosition + cameraRotationCFrame*Vector3.new(0, 0, cameraZoom)
camera.Focus = camera.CFrame - Vector3.new(0, camera.CFrame.p.Y, 0)
end
-- ========================================
-- ========================================




-- ========================================
-- MOBILE CAMERA EVENTS
-- ========================================
-- Events used to control the camera for players using a mobile device

-- ====================
-- CAMERA MOVE
-- ====================
-- Fired by UserInputService.TouchPan
local lastTouchTranslation = nil
local function TouchMove(touchPositions, totalTranslation, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = totalTranslation - lastTouchTranslation
	cameraPosition = cameraPosition + Vector3.new(difference.X, 0, difference.Y)
		UpdateCamera()
	end
	lastTouchTranslation = totalTranslation
end

-- ====================
-- CAMERA ROTATE
-- ====================
-- Fired by UserInputService.TouchRotate
local lastTouchRotation = nil
local function TouchRotate(touchPositions, rotation, velocity, state)
if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
local difference = rotation - lastTouchRotation
cameraRotation = cameraRotation + Vector2.new(-difference,0)*math.rad(cameraTouchRotateSpeed*cameraRotateSpeed)
		UpdateCamera()
	end
lastTouchRotation = rotation
end

-- ====================
-- CAMERA ZOOM
-- ====================
-- Fired by UserInputService.TouchPinch
local lastTouchScale = nil
local function TouchZoom(touchPositions, scale, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = scale - lastTouchScale
		cameraZoom = cameraZoom * (1 + difference)
		if cameraZoomBounds ~= nil then
			cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
		else
			cameraZoom = math.max(cameraZoom, 0)
end
		UpdateCamera()
	end
	lastTouchScale = scale
end

local function Input()
	UpdateCamera()
end
-- ========================================





-- ========================================
-- NON-MOBILE CAMERA EVENTS
-- ========================================

local function Input(inputObject)
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		if inputObject.UserInputState == Enum.UserInputState.Begin then						
			-- ====================
			-- CAMERA ZOOM
			-- ====================
			-- (I) Zoom In
			if inputObject.KeyCode == Enum.KeyCode.I then
			 	cameraZoom = cameraZoom - 15
			elseif inputObject.KeyCode == Enum.KeyCode.O then
				cameraZoom = cameraZoom + 15
			end
		
			-- (O) Zoom Out
			if cameraZoomBounds ~= nil then
				cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
			else
				cameraZoom = math.max(cameraZoom, 0)
			end
			
			UpdateCamera()
		end
	end
	
	-- ====================
	-- CAMERA ROTATE
	-- ====================
	local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
	if pressed then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		local rotation = userInputService:GetMouseDelta()
		cameraRotation = cameraRotation + rotation*math.rad(cameraMouseRotateSpeed)
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end

-- ====================
-- CAMERA MOVE
-- ====================
local function PlayerChanged()
	local movement = torso.Position - playerPosition
	cameraPosition = cameraPosition + movement
	playerPosition = torso.Position
		
	UpdateCamera()
end
-- ========================================
-- ========================================






-- ========================================
-- DEVICE CHECK
-- ========================================
-- Determine whether the user is on a mobile device

if UserInputService.TouchEnabled then
	-- The user is on a mobile device, use Touch events
UserInputService.TouchPan:Connect(TouchMove)
UserInputService.TouchRotate:Connect(TouchRotate)
UserInputService.TouchPinch:Connect(TouchZoom)
else
	
	-- The user is not on a mobile device use Input events
UserInputService.InputBegan:Connect(Input)
UserInputService.InputChanged:Connect(Input)
UserInputService.InputEnded:Connect(Input)

	-- Camera controlled by player movement
	wait(2)
	RunService:BindToRenderStep("PlayerChanged", Enum.RenderPriority.Camera.Value-1, PlayerChanged)
end	
-- ========================================
-- ========================================
```

@param mouseButton The `Enum/UserInputType` of the mouse button
@returns Whether the given mouse button is currently held down */
	IsMouseButtonPressed(mouseButton: CastsToEnum<Enum.UserInputType>): boolean;
	/** This function returns *true* if the specified `UserInputType` Gamepad is allowed to control Navigation and Selection `GUIs`.

If you want to set a navigation gamepad, you can use `SetNavigationGamepad`. You can also use `GetNavigationGamepads` to get a list of all navigation gamepads.

For example, the code below checks if the gamepad1 is as a navigation gamepad:

```lua
local userInputService = game:GetService("UserInputService")

if (userInputService:IsNavigationGamepad(UserInputType.Gamepad1) then
	print("Gamepad is a navigation gamepad!")
else
	print("Gamepad is not a navigation gamepad!")
end
```


A list of all connected gamepads, regardless of navigation can be retrieved using`GetConnectedGamepads.

Since `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

See [this][1] page for articles on cross-platform development.

## See also
 - `GamepadConnected`
 - `GamepadDisconnected`
 - `GetConnectedGamepads`
 - `GetNavigationGamepads`
 - `SetNavigationGamepad`
 - `IsGamepadButtonDown`
 - `GetSupportedGamepadKeyCodes`
 - `GetGamepadState`
 - `GetGamepadConnected`
 - `GamepadSupports`
 - `GamepadEnabled`

[1]: /learn-roblox/cross-platform

## Code Samples

### How to Use the Right Gamepad for Input

The following code sample is used in the default gamepad script, so if you are using the default controls you do not need to worry about this. If you are creating a custom script for handling gamepad controls, this is a good template for retrieving which `gamepad enum` you should use as the primary gamepad controller.

This code looks for the lowest numbered `navigation gamepad`, and if no navigation gamepad is found, finds the lowest numbered `connected gamepad`. If there is no connected gamepad, we default to gamepad1. This ensures at least some gamepad will be able to do controls.
```lua
local UserInputService = game:GetService("UserInputService")

local activeGamepad = nil
function GetActiveGamepad()
	local activateGamepad = nil
	local navigationGamepads = {}
	
	navigationGamepads = UserInputService:GetNavigationGamepads()
	
	if #navigationGamepads > 1 then
		for i = 1, #navigationGamepads do
			if activateGamepad == nil then
				activateGamepad = navigationGamepads[i]
			elseif navigationGamepads[i].Value < activateGamepad.Value then
				activateGamepad = navigationGamepads[i]
			end
		end
	else
		local connectedGamepads = {}
		
		connectedGamepads = UserInputService:GetConnectedGamepads()
		
		if #connectedGamepads > 0 then
			for i = 1, #connectedGamepads do
				if activateGamepad == nil then
					activateGamepad = connectedGamepads[i]
				elseif connectedGamepads[i].Value < activateGamepad.Value then
					activateGamepad = connectedGamepads[i]
				end
			end
		end
		if activateGamepad == nil then -- nothing is connected, at least set up for gamepad1
			activateGamepad = Enum.UserInputType.Gamepad1
		end
	end

	return activateGamepad
end

if UserInputService.GamepadEnabled then
	activeGamepad = GetActiveGamepad()
end
```

@param gamepadEnum The `Enum/UserInputType` of the specified gamepad
@returns Whether the specified gamepad is a navigation gamepad */
	IsNavigationGamepad(gamepadEnum: CastsToEnum<Enum.UserInputType>): boolean;
	/** This function recenters the `CFrame` of the VR headset to the current orientation of the headset worn by the user. This means that the headset’s current orientation is set to `CFrame.new()`.

Use this function to to move the headset CFrame to the center of the play area if it seems to be at a weird offset.

This behaves identically to the `VRService` function, `RecenterUserHeadCFrame`.

Since `UserInputService` is client-side only, this function can only be used in a `LocalScript`.

## Code Samples

### UserInputService:RecenterUserHeadCFrame

This example fires the function to recenter the CFrame of the user's head to the current location of the VR headset being worn by the user.
```lua
local UserInputService = game:GetService("UserInputService")
UserInputService:RecenterUserHeadCFrame()
```
 */
	RecenterUserHeadCFrame(): void;
	/** The SetNavigationGamepad function sets whether the specified `UserInputType` gamepad can move the GUI navigator. A gamepad that is allowed to move the GUI navigator is considered a *navigation gamepad*.

If the *enabled* argument is passed as *true*, the Gamepad can move the GUI navigator. If the argument is *false*, the Gamepad can not move the GUI navigator.

If you want to check if a specified Gamepad is a set to be a navigation gamepad, you can use the `IsNavigationGamepad` function. You can also use the `GetNavigationGamepads` to retrieve a list of all navigation gamepads.

Since `UserInputService` is client-side only, this function can only be used in a  `LocalScript`.

See [this][1] page for articles on cross-platform development.

## See also
 - `GamepadConnected`
 - `GamepadDisconnected`
 - `GetConnectedGamepads`
 - `GetNavigationGamepads`
 - `IsNavigationGamepad`
 - `IsGamepadButtonDown`
 - `GetSupportedGamepadKeyCodes`
 - `GetGamepadState`
 - `GetGamepadConnected`
 - `GamepadSupports`
 - `GamepadEnabled`

[1]: /learn-roblox/cross-platform

## Code Samples

### UserInputService:SetNavigationGamepad

This example sets `Gamepad1` as a navigation gamepad by passing *Enum.UserInputType.Gamepad1* and *true* as arguments.
```lua
local UserInputService = game:GetService("UserInputService")

UserInputService:SetNavigationGamepad(EnumUserInputType.Gamepad1, true)
```

@param gamepadEnum The `Enum/UserInputType` of the specified gamepad
@param enabled Whether the specified gamepad can move the GUI navigator
@returns No return */
	SetNavigationGamepad(gamepadEnum: CastsToEnum<Enum.UserInputType>, enabled: boolean): void;
	/** The DeviceAccelerationChanged event fires when a user moves a device that has an accelerometer. 

An accelerometer is a component found in most mobile devices that measures acceleration (change in speed).

To determine whether a user's device has an accelerometer enabled, see`AccelerometerEnabled`.

This event can be used to track the movement of a device that has an accelerometer. A sample usage includes moving the player character when a mobile device accelerates.

Additionally, this event can be used along with `GetDeviceAcceleration` to determine the current movement of a user's device if the device has an accelerometer.

This event only fires locally - which means that only the player whose device moves can use the event and it will only work in a `LocalScript`.

## Code Samples

### Control Players Using the Accelerometer

This example uses the accelerometer to move the player character when a mobile device is accelerated. The character will will along the axis that the device was moved. This code can be seen in [this][1] uncopylocked place.

  [1]: http://www.roblox.com/games/257877593/Accel-Test
```lua
local UserInputService = game:GetService("UserInputService")
local sensitivity = .2
 
local player = game.Players.LocalPlayer
while not player.Character do wait() end
local humanoid = player.Character:WaitForChild("Humanoid")
 
local ready = true
local function ChangeAcceleration(acceleration)
    if ready then
   	 ready = false
   	 local accel = acceleration.Position
 
   	 if accel.Y >= sensitivity then
   		 humanoid.Jump = true
   	 end
 
   	 if accel.Z <= -sensitivity then
   		 humanoid:Move(Vector3.new(-1,0,0))
   	 end    
   	 if accel.Z >= sensitivity then
   		 humanoid:Move(Vector3.new(1,0,0))
   	 end    
   	 if accel.X <= -sensitivity then
   		 humanoid:Move(Vector3.new(0,0,1))
   	 end    
   	 if accel.X >= sensitivity then
   		 humanoid:Move(Vector3.new(0,0,-1))
   	 end    
   	 wait(1)
   	 ready = true
    end
End
UserInputService.DeviceAccelerationChanged:Connect(ChangeAcceleration)
```
 */
	readonly DeviceAccelerationChanged: RBXScriptSignal<(acceleration: InputObject) => void>;
	/** The DeviceGravityChanged event fires when the device’s gravity `vector` changes on a device that has an accelerometer. 

A device’s gravity vector represent the force of gravity on each of the device’s X, Y, and Z axes. While gravity never changes, the force it exerts on each axis changes when the device rotates and changes orientation. The force value exerted on each axis is a unit vector ranging from -1 to 1.

An accelerometer is a component found in most mobile devices that measures acceleration (change in speed).

This event can be used to determine the real-world direction of the force of gravity on a user's device. This even can then be used to simulate the force of gravity on a user's device within the game, such as on in-game objects (see example below).

To check if a user's device has an enabled accelerometer, see `AccelerometerEnabled`. If the device has an enabled accelerometer, you can use the `GetDeviceGravity` function to get the current force of gravity on the user's device.

## Code Samples

### Create a Gyroscopic Camera

This example controls the player's `Camera` so that it matches the player's device orientation via using the device’s `gyroscope` and `accelerometer`.

The camera is positioned inside the player's head, and updated to move with the player and the user's device rotation, by executing the following line every `RenderStep`:
```lua
		camera.CFrame = CFrame.new(head.Position - Vector3.new(0,8,10)) * currentRotation
```


The code sample relies on the device's gyroscope to determine when the player rotates their device. It does so by connecting to the `DeviceRotationChanged` event. 

The code sample relies on the device’s accelerometer to retrieve the gravity vector used to determine the device's orientation (whether it is flipped upside down or not). To determine whether the device's orientation is upside down, the code sample uses the `DeviceGravityChanged` event.

Since the script places the camera inside the head to create a first-person camera, the limbs are made transparent by the `HideCharacter()` function so that the player does not see their `Character` when rotating the camera.

In order for this example to work as expected, it must be placed in a `LocalScript` and the user's device must have a gyroscope and an accelerometer.
```lua
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.CharacterAdded:wait()
local head = character:WaitForChild("Head")

local camera = game.Workspace.CurrentCamera
local currentRotation = camera.CFrame-- CFrame.new(Vector3.new(0,0,0), Vector3.new(0,0,0))
local lastInputFrame = nil
local upsideDown = false
 
wait()
 
local orientationSet = false
local function GravityChanged(gravity)
    if not orientationSet then
   	 upsideDown = (gravity.Position.X < -.5 or gravity.Position.Z > .5)
 
   	 orientationSet = true
    end
end
 
local function RotationChanged(rotation, rotCFrame)
	if orientationSet then
	if not lastInputFrame then
		lastInputFrame = rotCFrame
	end
 
	local delta = rotCFrame * lastInputFrame:inverse()
	local x,y,z = delta:toEulerAnglesXYZ()
	if upsideDown then
		delta = CFrame.Angles(-x, y, z)
	else
		delta = CFrame.Angles(x, -y, z)
	end
	currentRotation = currentRotation * delta
 
	lastInputFrame = rotCFrame
	end
end

local function HideCharacter()
	for _, limb in pairs (character:GetChildren()) do
		if limb:IsA("Part") then
			limb.Transparency = 1
		end
	end
end

local function UpdateCamera()
	local camera = game.Workspace.CurrentCamera
	camera.CoordinateFrame = currentRotation
	camera.Focus = CFrame.new(currentRotation * Vector3.new(0,0,-10))
end

if UserInputService.GyroscopeEnabled then
	UserInputService.DeviceGravityChanged:Connect(GravityChanged)
	UserInputService.DeviceRotationChanged:Connect(RotationChanged)
	
	HideCharacter()
	
	RunService:BindToRenderStep("Camera", Enum.RenderPriority.Camera.Value, function()
		camera.CFrame = CFrame.new(head.Position - Vector3.new(0,8,10)) * currentRotation
		camera.Focus = CFrame.new(currentRotation * Vector3.new(0,0,-10))
	end)
end
```

### Move a Ball using the Accelerometer

This code adds a force on a part so that it falls in the direction of actual gravity relative to the user's device. This code can be seen in [this][1] uncopylocked place.

In order for this example to work as expected, it must be placed in a `LocalScript` and the user’s device must have an `accelerometer`.

  [1]: http://www.roblox.com/games/257601957/Gravity-Test
```lua
local UserInputService = game:GetService("UserInputService")

local Ball = game.Workspace.Ball
local RealGravity = Instance.new("BodyForce", Ball)
local AntiGravity = Instance.new("BodyForce", Ball)
AntiGravity.force = Vector3.new(0, 196.2 * Ball:GetMass(), 0)

local function MoveBall(gravity)
	RealGravity.force = gravity.Position * 196.2 * game.Workspace.Ball:GetMass()
end

if UserInputService.AccelerometerEnabled then
	UserInputService.DeviceGravityChanged:Connect(MoveBall)	
end
```
 */
	readonly DeviceGravityChanged: RBXScriptSignal<(gravity: InputObject) => void>;
	/** The DeviceRotationChanged event fires when a user rotates a device that has a gyroscope. 

A gyroscope is an component found in most mobile devices that detects orientation and rotational speed.

The event is useful when tracking the orientation of the device and how changes as the user rotates their device. To determine the current device rotation, you can use the `GetDeviceRotation` function.

To check if a user's device has an enabled gyroscope, and that this event will fire, see `GyroscopeEnabled`. 

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

## Code Samples

### Create a Gyroscopic Camera

This example controls the player's `Camera` so that it matches the player's device orientation via using the device’s `gyroscope` and `accelerometer`.

The camera is positioned inside the player's head, and updated to move with the player and the user's device rotation, by executing the following line every `RenderStep`:
```lua
		camera.CFrame = CFrame.new(head.Position - Vector3.new(0,8,10)) * currentRotation
```


The code sample relies on the device's gyroscope to determine when the player rotates their device. It does so by connecting to the `DeviceRotationChanged` event. 

The code sample relies on the device’s accelerometer to retrieve the gravity vector used to determine the device's orientation (whether it is flipped upside down or not). To determine whether the device's orientation is upside down, the code sample uses the `DeviceGravityChanged` event.

Since the script places the camera inside the head to create a first-person camera, the limbs are made transparent by the `HideCharacter()` function so that the player does not see their `Character` when rotating the camera.

In order for this example to work as expected, it must be placed in a `LocalScript` and the user's device must have a gyroscope and an accelerometer.
```lua
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.CharacterAdded:wait()
local head = character:WaitForChild("Head")

local camera = game.Workspace.CurrentCamera
local currentRotation = camera.CFrame-- CFrame.new(Vector3.new(0,0,0), Vector3.new(0,0,0))
local lastInputFrame = nil
local upsideDown = false
 
wait()
 
local orientationSet = false
local function GravityChanged(gravity)
    if not orientationSet then
   	 upsideDown = (gravity.Position.X < -.5 or gravity.Position.Z > .5)
 
   	 orientationSet = true
    end
end
 
local function RotationChanged(rotation, rotCFrame)
	if orientationSet then
	if not lastInputFrame then
		lastInputFrame = rotCFrame
	end
 
	local delta = rotCFrame * lastInputFrame:inverse()
	local x,y,z = delta:toEulerAnglesXYZ()
	if upsideDown then
		delta = CFrame.Angles(-x, y, z)
	else
		delta = CFrame.Angles(x, -y, z)
	end
	currentRotation = currentRotation * delta
 
	lastInputFrame = rotCFrame
	end
end

local function HideCharacter()
	for _, limb in pairs (character:GetChildren()) do
		if limb:IsA("Part") then
			limb.Transparency = 1
		end
	end
end

local function UpdateCamera()
	local camera = game.Workspace.CurrentCamera
	camera.CoordinateFrame = currentRotation
	camera.Focus = CFrame.new(currentRotation * Vector3.new(0,0,-10))
end

if UserInputService.GyroscopeEnabled then
	UserInputService.DeviceGravityChanged:Connect(GravityChanged)
	UserInputService.DeviceRotationChanged:Connect(RotationChanged)
	
	HideCharacter()
	
	RunService:BindToRenderStep("Camera", Enum.RenderPriority.Camera.Value, function()
		camera.CFrame = CFrame.new(head.Position - Vector3.new(0,8,10)) * currentRotation
		camera.Focus = CFrame.new(currentRotation * Vector3.new(0,0,-10))
	end)
end
```

### Move a Ball using the Accelerometer

This code adds a force on a part so that it falls in the direction of actual gravity relative to the user's device. This code can be seen in [this][1] uncopylocked place.

In order for this example to work as expected, it must be placed in a `LocalScript` and the user’s device must have an `accelerometer`.

  [1]: http://www.roblox.com/games/257601957/Gravity-Test
```lua
local UserInputService = game:GetService("UserInputService")

local Ball = game.Workspace.Ball
local RealGravity = Instance.new("BodyForce", Ball)
local AntiGravity = Instance.new("BodyForce", Ball)
AntiGravity.force = Vector3.new(0, 196.2 * Ball:GetMass(), 0)

local function MoveBall(gravity)
	RealGravity.force = gravity.Position * 196.2 * game.Workspace.Ball:GetMass()
end

if UserInputService.AccelerometerEnabled then
	UserInputService.DeviceGravityChanged:Connect(MoveBall)	
end
```
 */
	readonly DeviceRotationChanged: RBXScriptSignal<(rotation: InputObject, cframe: CFrame) => void>;
	/** The GamepadConnected event fires when a gamepad is connected to the client. 

Since a Roblox game supports multiple controllers, this event is useful when paired with the `GamepadDisconnected` event to track which controllers/gamepads are active. You can also use `GetNavigationGamepads` and `GetConnectedGamepads` to find the correct gamepad to use.

The following example demonstrates a usage example of a tracking when a gamepad is connected to the client.

```lua
local userInputService = game:GetService("UserInputService")

local function GamepadConnected(gamepad)
	print("Player has plugged controller: " .. tostring(gamepad))
end)

userInputService.GamepadConnected:Connect(GamepadDisconnected)
```


If you want to see which devices are connected, you can use the `GetConnectedGamepads` function.

As this event fires locally, it can only be used in a `LocalScript`.
See [this][1] page for articles on cross-platform development.

## See also
 - `GamepadDisconnected`
 - `GetConnectedGamepads`
 - `GetNavigationGamepads`
 - `SetNavigationGamepad`
 - `IsNavigationGamepad`
 - `IsGamepadButtonDown`
 - `GetSupportedGamepadKeyCodes`
 - `GetGamepadState`
 - `GetGamepadConnected`
 - `GamepadSupports`
 - `GamepadEnabled`

[1]: /learn-roblox/cross-platform

## Code Samples

### How to Use the Right Gamepad for Input

The following code sample is used in the default gamepad script, so if you are using the default controls you do not need to worry about this. If you are creating a custom script for handling gamepad controls, this is a good template for retrieving which `gamepad enum` you should use as the primary gamepad controller.

This code looks for the lowest numbered `navigation gamepad`, and if no navigation gamepad is found, finds the lowest numbered `connected gamepad`. If there is no connected gamepad, we default to gamepad1. This ensures at least some gamepad will be able to do controls.
```lua
local UserInputService = game:GetService("UserInputService")

local activeGamepad = nil
function GetActiveGamepad()
	local activateGamepad = nil
	local navigationGamepads = {}
	
	navigationGamepads = UserInputService:GetNavigationGamepads()
	
	if #navigationGamepads > 1 then
		for i = 1, #navigationGamepads do
			if activateGamepad == nil then
				activateGamepad = navigationGamepads[i]
			elseif navigationGamepads[i].Value < activateGamepad.Value then
				activateGamepad = navigationGamepads[i]
			end
		end
	else
		local connectedGamepads = {}
		
		connectedGamepads = UserInputService:GetConnectedGamepads()
		
		if #connectedGamepads > 0 then
			for i = 1, #connectedGamepads do
				if activateGamepad == nil then
					activateGamepad = connectedGamepads[i]
				elseif connectedGamepads[i].Value < activateGamepad.Value then
					activateGamepad = connectedGamepads[i]
				end
			end
		end
		if activateGamepad == nil then -- nothing is connected, at least set up for gamepad1
			activateGamepad = Enum.UserInputType.Gamepad1
		end
	end

	return activateGamepad
end

if UserInputService.GamepadEnabled then
	activeGamepad = GetActiveGamepad()
end
```
 */
	readonly GamepadConnected: RBXScriptSignal<(gamepadNum: Enum.UserInputType) => void>;
	/** The GamepadDisconnected event fires when a gamepad is disconnected. 

Since a Roblox game supports multiple controllers, this event is useful when paired with the `GamepadConnected` event to track which controllers/gamepads are active. You can also use `GetNavigationGamepads` and `GetConnectedGamepads` to find the correct gamepad to use.

The following example demonstrates a usage example of a tracking when a gamepad is disconnected from the client.

```lua
local userInputService = game:GetService("UserInputService")

local function GamepadDisconnected(gamepad)
	print("Player has unplugged controller: " .. tostring(gamepad))
end)

userInputService.GamepadDisconnected:Connect(GamepadDisconnected)
```


As this event fires locally, it can only be used in a `LocalScript`.

See [this][1] page for articles on cross-platform development.

## See also
 - `GamepadConnected`
 - `GetConnectedGamepads`
 - `GetNavigationGamepads`
 - `SetNavigationGamepad`
 - `IsNavigationGamepad`
 - `IsGamepadButtonDown`
 - `GetSupportedGamepadKeyCodes`
 - `GetGamepadState`
 - `GetGamepadConnected`
 - `GamepadSupports`
 - `GamepadEnabled`

[1]: /learn-roblox/cross-platform

## Code Samples

### How to Use the Right Gamepad for Input

The following code sample is used in the default gamepad script, so if you are using the default controls you do not need to worry about this. If you are creating a custom script for handling gamepad controls, this is a good template for retrieving which `gamepad enum` you should use as the primary gamepad controller.

This code looks for the lowest numbered `navigation gamepad`, and if no navigation gamepad is found, finds the lowest numbered `connected gamepad`. If there is no connected gamepad, we default to gamepad1. This ensures at least some gamepad will be able to do controls.
```lua
local UserInputService = game:GetService("UserInputService")

local activeGamepad = nil
function GetActiveGamepad()
	local activateGamepad = nil
	local navigationGamepads = {}
	
	navigationGamepads = UserInputService:GetNavigationGamepads()
	
	if #navigationGamepads > 1 then
		for i = 1, #navigationGamepads do
			if activateGamepad == nil then
				activateGamepad = navigationGamepads[i]
			elseif navigationGamepads[i].Value < activateGamepad.Value then
				activateGamepad = navigationGamepads[i]
			end
		end
	else
		local connectedGamepads = {}
		
		connectedGamepads = UserInputService:GetConnectedGamepads()
		
		if #connectedGamepads > 0 then
			for i = 1, #connectedGamepads do
				if activateGamepad == nil then
					activateGamepad = connectedGamepads[i]
				elseif connectedGamepads[i].Value < activateGamepad.Value then
					activateGamepad = connectedGamepads[i]
				end
			end
		end
		if activateGamepad == nil then -- nothing is connected, at least set up for gamepad1
			activateGamepad = Enum.UserInputType.Gamepad1
		end
	end

	return activateGamepad
end

if UserInputService.GamepadEnabled then
	activeGamepad = GetActiveGamepad()
end
```
 */
	readonly GamepadDisconnected: RBXScriptSignal<(gamepadNum: Enum.UserInputType) => void>;
	/** The InputBegan event fires when a user begins interacting via a Human-Computer Interface device (mouse button down, touch begin, keyboard button down, etc.). 

It can be used to track the beginning of user interaction, such as when a user first interacts with a GUI element, a gamepad, etc. It does not capture mouse wheel movements.

This event can be used along with `InputChanged` and `InputEnded` to track when user input begins, changes, and ends.

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

As this event only fires locally, it can only be used in a `LocalScript`.

## Code Samples

### Handling InputBegan

The following example demonstrates one of many usage examples of handling user input from InputBegan depending on its type.
```lua
-- In order to use the InputBegan event, the UserInputService service must be used
local UserInputService = game:GetService("UserInputService")

-- A sample function providing multiple usage cases for various types of user input
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyPressed = input.KeyCode
		print("A key is being pushed down! Key:",input.KeyCode)
	elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
		print("The left mouse button has been pressed down at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		print("The right mouse button has been pressed down at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Touch then
		print("A touchscreen input has started at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
		print("A button is being pressed on a gamepad! Button:",input.KeyCode)
	end

	if gameProcessed then
		print("\tThe game engine internally observed this input!")
	else
		print("\tThe game engine did not internally observe this input!")
	end
end)
```
 */
	readonly InputBegan: RBXScriptSignal<(input: InputObject, gameProcessedEvent: boolean) => void>;
	/** The InputChanged event fires when a user changes how they're interacting via a Human-Computer Interface device (Mouse button down, touch begin, keyboard button down, etc).

To ignore events that are automatically handled by Roblox, like scrolling in a `ScrollingFrame`, check the *gameProcessedEvent* argument is false. 
This event can be used along with `InputBegan` and `InputEnded` to track when user input begins, changes, and ends.

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

As this event only fires locally, it can only be used in a `LocalScript`.

## Code Samples

### Handling InputChanged

The following example demonstrates one of many usage examples of handling user input from InputChanged depending on its type.
```lua
-- In order to use the InputChanged event, the UserInputService service must be used
local userInputService = game:GetService("UserInputService")

-- Prints the current input position and the change (delta) in position
local function printMovement(input)
    print("\tPosition:",input.Position)
    print("\tMovement Delta:",input.Delta)
end
 
-- A sample function providing multiple usage cases for various types of user input
local function InputChanged(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
   	 print("The mouse has been moved!")
   	 printMovement(input)
    elseif input.UserInputType == Enum.UserInputType.MouseWheel then
   	 print("The mouse wheel has been scrolled!")
   	 print("\tWheel Movement:",input.Position.Z)
    elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
   	 if input.KeyCode == Enum.KeyCode.Thumbstick1 then
   		 print("The left thumbstick has been moved!")
   		 printMovement(input)
   	 elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
   		 print("The right thumbstick has been moved!")
   		 printMovement(input)
   	 elseif input.KeyCode == Enum.KeyCode.ButtonL2 then
   		 print("The pressure being applied to the left trigger has changed!")
   		 print("\tPressure:",input.Position.Z)
   	 elseif input.KeyCode == Enum.KeyCode.ButtonR2 then
   		 print("The pressure being applied to the right trigger has changed!")
   		 print("\tPressure:",input.Position.Z)
   	 end
    elseif input.UserInputType == Enum.UserInputType.Touch then
   	 print("The user's finger is moving on the screen!")
   	 printMovement(input)
    elseif input.UserInputType == Enum.UserInputType.Gyro then
   	 local rotInput,rotCFrame = UserInputService:GetDeviceRotation()
   	 local rotX,rotY,rotZ = rotCFrame:toEulerAnglesXYZ()
   	 local rot = Vector3.new(math.deg(rotX),math.deg(rotY),math.deg(rotZ))
   	 print("The rotation of the user's mobile device has been changed!")
   	 print("\tPosition",rotCFrame.p)
   	 print("\tRotation:",rot)
    elseif input.UserInputType == Enum.UserInputType.Accelerometer then
   	 print("The acceleration of the user's mobile device has been changed!")
   	 printMovement(input)
    end    
end

userInputService.InputChanged:Connect(InputChanged)
```
 */
	readonly InputChanged: RBXScriptSignal<(input: InputObject, gameProcessedEvent: boolean) => void>;
	/** The InputEnded event fires when a user stops interacting via a Human-Computer Interface device (Mouse button down, touch begin, keyboard button down, etc). This is useful when tracking when a user releases a keyboard key, mouse button, touchscreen input, etc.

This event can be used along with `InputBegan` and `InputChanged` to track when user input begins, changes, and ends.

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.


As this event only fires locally, it can only be used in a `LocalScript`.

## Code Samples

### Handling InputEnded

The following example demonstrates one of many usage examples of handling user input from InputEnded depending on its type.
```lua
-- In order to use the InputChanged event, the UserInputService service must be used
local UserInputService = game:GetService("UserInputService")
 
-- A sample function providing multiple usage cases for various types of user input
UserInputService.InputEnded:Connect(function(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		local keyPressed = input.KeyCode
		print("A key has been released! Key:",input.KeyCode)
	elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
		print("The left mouse button has been released at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		print("The right mouse button has been released at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Touch then
		print("A touchscreen input has been released at",input.Position)
	elseif input.UserInputType == Enum.UserInputType.Gamepad1 then
		print("A button has been released on a gamepad! Button:",input.KeyCode)
	end
	
	if gameProcessed then
		print("\tThe game engine internally observed this input!")
	else
		print("\tThe game engine did not internally observe this input!")
	end
end)
```
 */
	readonly InputEnded: RBXScriptSignal<(input: InputObject, gameProcessedEvent: boolean) => void>;
	/** The `UserInputService` JumpRequest event fires when there is a jump request from the client (i.e. when the client pressed the spacebar or [jump GUI button][2] on mobile).

This event fires whenever the user tries to make their `Character` jump. Default behavior responds to a jump request by setting the player’s `Jump` property to true, which makes the player’s character jump.

The event can be used to track every time a player wants to jump. Instead of using it to make a player jump, this should be used to change default jump behavior - such as disabling jumping.

For example, the code below prints "Jump" every time the player sends a jump request.
```lua
local userInputService = game:GetService("UserInputService")

function jumpRequest()
	print("Jump!")
end

userInputService.JumpRequest:Connect(JumpRequest)
```


Since this event fires multiple times for a single jump request, using a [debounce][1] is suggested.

If you would like to connect keys or buttons to other actions, consider using events such as `GetKeysPressed` and `InputBegan` or the `ContextActionService`.

As this event only fires locally, it can only be used in a `LocalScript`.

 [1]: /articles/Debounce
 [2]: /articles/Mobile-Controls

## Code Samples

### Disable Jumping

This code sample disables jumping for the `LocalPlayer` by setting the `Enum.HumanoidStateType.Jumping` state to false. Setting this state to false as soon as the user tries to jump cancels the jump.

In order for this example to work as expected, it should be placed in a `LocalScript`.
```lua
-- Services
local userInputService = game:GetService("UserInputService")
local players = game:GetService("Players")

-- Local player
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

-- Fires when the user tries to jump
local function Jump()
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
end

userInputService.JumpRequest:Connect(Jump)
```
 */
	readonly JumpRequest: RBXScriptSignal<() => void>;
	/** The LastInputTypeChanged event fires whenever the client changes how they are interacting via a Human-Computer Interface device. (i.e. from MouseMovement to MouseWheel or from Thumbstick1 to Thumbstick2).

To get the value of LastInputType, regardless of whether it has changed, you can use the `GetLastInputType` function.

As this event only fires locally, it can only be used in a `LocalScript`.

## Code Samples

### Hide Mouse During Keyboard Input

This example hides the mouse icon while the player beings using their keyboard, such as to chat or enter text into a `TextBox`. The mouse icon reappears when the user resumes mouse input.

This uses the `LastInputType` event to determine when the user begins keyboard input and mouse input - based on the value of the `lastInputType` argument.

In order for this example to work as expected, it should be placed in a `LocalScript`.
```lua
local UserInputService = game:GetService("UserInputService")

local mouseInput =
{
	Enum.UserInputType.MouseButton1,
	Enum.UserInputType.MouseButton2,
	Enum.UserInputType.MouseButton3,
	Enum.UserInputType.MouseMovement,
	Enum.UserInputType.MouseWheel	
}

local keyboard = Enum.UserInputType.Keyboard

local function ToggleMouse(lastInputType)
	if lastInputType == keyboard then
		UserInputService.MouseIconEnabled = false
		return
	end
	
	for i, mouse in pairs (mouseInput) do
		if lastInputType == mouse then
			UserInputService.MouseIconEnabled = true
			return
		end
	end
end

UserInputService.LastInputTypeChanged:Connect(ToggleMouse)
```
 */
	readonly LastInputTypeChanged: RBXScriptSignal<(lastInputType: Enum.UserInputType) => void>;
	/** The TextBoxFocusReleased event fires when a client loses focus on a TextBox - typically when a client stops text entry into a TextBox by pressing return or clicking/touching elsewhere on the screen.

For example, the code below prints the the name of the TextBox losing focus when the event fires.

```lua
local UserInputService = game:GetService("UserInputService")

function TextBoxFocusReleased(textbox)
	print(textbox.Name)
end

UserInputService.TextBoxFocusReleased:Connect(TextBoxFocusReleased)
```


It can be used alongside `TextBoxFocused` to track when a TextBox gains and loses focus.

As this event only fires locally, it can only be used in a `LocalScript`.

## See also
 - `GetFocusedTextBox`
 - `Focused`
 - `FocusLost`

## Code Samples

### TextBoxFocusReleased

This example prints the "The name of the released focus TextBox is " followed by the name of the TextBox which is released from focus when a client escapes text entry for a TextBox, usually by clicking/tapping elsewhere on the screen.
```lua
local UserInputService = game:GetService("UserInputService")

UserInputService.TextBoxFocusReleased:Connect(function(textbox)
	print("The name of the released focus TextBox is "..textbox.Name)
end)
```
 */
	readonly TextBoxFocusReleased: RBXScriptSignal<(textboxReleased: TextBox) => void>;
	/** The TextBoxFocused event fires when a gains focus on a `TextBox` - typically when a client clicks/taps on a text box to begin inputting text. This also fires if a text box focus is focused using `CaptureFocus`.

For example, the code below prints the the name of the TextBox focused when the event fires.

```lua
local UserInputService = game:GetService("UserInputService")

function TextBoxFocused(textbox)
	print(textbox.Name)
end)

UserInputService.TextBoxFocused:Connect(TextBoxFocused)
```


It can be used alongside `FocusReleased` to track when a text box gains and loses focus.

As this event only fires locally, it can only be used in a `LocalScript`.

## See also
 - `GetFocusedTextBox`
 - `Focused`
 - `FocusLost`

## Code Samples

### Modifying a TextBox on Focused and FocusReleased

This example adjusts the `transparency` of `TextBoxes` when they gain and lose focus using.

When a text box `gains focus`, it’s transparency deceases. When a text box `loses focus`, it’s transparency increases. This is similar to how the default chat window increases and decreases transparency when a user starts and stops interacting with it.

In order for this example to work as expected, it should be placed in a `LocalScript`.
```lua
local UserInputService = game:GetService("UserInputService")

local function TextBoxFocused(textBox)
	textBox.BackgroundTransparency = 0
end

local function TextBoxFocusReleased(textBox)
	textBox.BackgroundTransparency = 0.7
end

UserInputService.TextBoxFocused:Connect(TextBoxFocused)
UserInputService.TextBoxFocusReleased:Connect(TextBoxFocusReleased)
```
 */
	readonly TextBoxFocused: RBXScriptSignal<(textboxFocused: TextBox) => void>;
	/** The TouchEnded event fires when a user released their finger from the screen of a TouchEnabled device, ending touch input with the device.

This event can be used to determine when a user stops touching the screen of their device. It can be paired with `TouchStarted` to determine when a user starts and stops touching the screen.

For example, the code below prints the screen position where the user stops touching the screen.
```lua
local UserInputService = game:GetService("UserInputService")

function TouchEnded(touch, gameProcessedEvent)
	print("Touch ended at "..tostring(touch.Position))
end

UserInputService.TouchEnded:Connect(TouchEnded)
```


The touch input object is the same input object throughout the lifetime of the touch. So comparing `InputObjects` when they are touch objects is valid to determine if it is the same finger.

To check if a user's device is TouchEnabled, and that touch events will fire, see `TouchEnabled`. 

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

As this event only fires locally, it can only be used in a `LocalScript`.

## See also
 - `TouchTap`
 - `TouchTapInWorld`
 - `TouchLongPress`
 - `TouchMoved`
 - `TouchPan`
 - `TouchPinch`
 - `TouchRotate`
 - `TouchSwipe`
 - `TouchStarted`

## Code Samples

### The Difference Between TouchTap and TouchLongPress

The code sample below demonstrates the difference between a `TouchTap` and `TouchLongPress` by creating a `GUI` `Frame` that appears when user touches the screen of their device and disappears when the `touch ends`. When the long press event fires, the GUI doubles in size. Also, the GUI moves to stay centered under the user’s finger when the player moves their finger.

In order for the `TouchLongPress` to fire, the user touch the screen and hold their finger still for a short period of time. Once the touch moves, the long press event will not fire.

In order for the example to work as expected, it should be placed in a `LocalScript` that is parented to a `ScreenGui`.
```lua
local UserInputService = game:GetService("UserInputService")

-- The parent of this script (a ScreenGui)
local touchScreenGui = script.Parent

-- Create the GUI frame that the user interacts with through Touch
-- events
local touchGui = Instance.new("Frame")
touchGui.Name = "TouchGui"
touchGui.AnchorPoint = Vector2.new(0.5, 0.5)

-- Fires when the touches their device’s screen
local function TouchTap(touch, gameProcessedEvent)
	touchGui.Parent = touchScreenGui
	touchGui.Position = UDim2.new(0, touch.Position.X, 0, touch.Position.Y)
	touchGui.Size = UDim2.new(0,50,0,50)
end

-- Fires when a user starts touching their device's screen and does not
-- move their finger for a short period of time
local function TouchLong(touchPositions, state, gameProcessedEvent)
	touchGui.Size = UDim2.new(0,100,0,100)
end

-- Fires when the user moves their finger while touching their device's
-- screen
local function TouchMove(touch, gameProcessedEvent)
	touchGui.Position = UDim2.new(0, touch.Position.X, 0, touch.Position.Y)
end

-- Fires when the user stops touching their device's screen
local function TouchEnd(touch, gameProcessedEvent)
	touchGui.Parent = nil
	touchGui.Size = UDim2.new(0,50,0,50)
end

-- Only use the Touch events if the user is on a mobile device
if UserInputService.TouchEnabled then
	UserInputService.TouchTap:Connect(TouchTap)
	UserInputService.TouchLongPress:Connect(TouchLong)
	UserInputService.TouchMoved:Connect(TouchMove)
	UserInputService.TouchEnded:Connect(TouchEnd)
end
```
 */
	readonly TouchEnded: RBXScriptSignal<(touch: InputObject, gameProcessedEvent: boolean) => void>;
	/** Fired when a user holds at least one finger for a short amount of time on the same screen position of a TouchEnabled device.

This event can be used to determine when a user holds their finger down on an an-game `GUI` or element.

The example below prints the `state` of the long press when the user user holds at least one finger for a short amount of time on the same screen position. Possible states include: *Begin*, *Change*, *End*, *Cancel*, and *None*.

```lua
local userInputService = game:GetService("UserInputService")

function TouchLongPress(TouchPositions, state, gameProcessedEvent)
	print("Long press event fired. State of press: "..tostring(state))
end

userInputService.TouchLongPress:Connect(TouchLongPress)
```


To check if a user's device is TouchEnabled, and that touch events will fire, see`TouchEnabled`. 

It can be paired with `TouchStarted` and `TouchEnded` to determine when a user starts and stops touching the screen.

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

As this event only fires locally, it can only be used in a `LocalScript`.

## See also
 - `TouchTap`
 - `TouchTapInWorld`
 - `TouchMoved`
 - `TouchPan`
 - `TouchPinch`
 - `TouchRotate`
 - `TouchSwipe`
 - `TouchStarted`
 - `TouchEnded`

## Code Samples

### The Difference Between TouchTap and TouchLongPress

The code sample below demonstrates the difference between a `TouchTap` and `TouchLongPress` by creating a `GUI` `Frame` that appears when user touches the screen of their device and disappears when the `touch ends`. When the long press event fires, the GUI doubles in size. Also, the GUI moves to stay centered under the user’s finger when the player moves their finger.

In order for the `TouchLongPress` to fire, the user touch the screen and hold their finger still for a short period of time. Once the touch moves, the long press event will not fire.

In order for the example to work as expected, it should be placed in a `LocalScript` that is parented to a `ScreenGui`.
```lua
local UserInputService = game:GetService("UserInputService")

-- The parent of this script (a ScreenGui)
local touchScreenGui = script.Parent

-- Create the GUI frame that the user interacts with through Touch
-- events
local touchGui = Instance.new("Frame")
touchGui.Name = "TouchGui"
touchGui.AnchorPoint = Vector2.new(0.5, 0.5)

-- Fires when the touches their device’s screen
local function TouchTap(touch, gameProcessedEvent)
	touchGui.Parent = touchScreenGui
	touchGui.Position = UDim2.new(0, touch.Position.X, 0, touch.Position.Y)
	touchGui.Size = UDim2.new(0,50,0,50)
end

-- Fires when a user starts touching their device's screen and does not
-- move their finger for a short period of time
local function TouchLong(touchPositions, state, gameProcessedEvent)
	touchGui.Size = UDim2.new(0,100,0,100)
end

-- Fires when the user moves their finger while touching their device's
-- screen
local function TouchMove(touch, gameProcessedEvent)
	touchGui.Position = UDim2.new(0, touch.Position.X, 0, touch.Position.Y)
end

-- Fires when the user stops touching their device's screen
local function TouchEnd(touch, gameProcessedEvent)
	touchGui.Parent = nil
	touchGui.Size = UDim2.new(0,50,0,50)
end

-- Only use the Touch events if the user is on a mobile device
if UserInputService.TouchEnabled then
	UserInputService.TouchTap:Connect(TouchTap)
	UserInputService.TouchLongPress:Connect(TouchLong)
	UserInputService.TouchMoved:Connect(TouchMove)
	UserInputService.TouchEnded:Connect(TouchEnd)
end
```
 */
	readonly TouchLongPress: RBXScriptSignal<
		(touchPositions: Array<InputObject>, state: Enum.UserInputState, gameProcessedEvent: boolean) => void
	>;
	/** The TouchMoved event fires when a user moves their finger on a TouchEnabled device.

This event can be used to determine when a user moves their finger while touching the screen of a TouchEnabled device. It can be useful to track whether a user is moving their finger on the screen, as well as where the user is moving their finger.

The code below prints "Touch moved from" the previous Vector2 position "to " the new Vector2 position of the user's touch on a TouchEnabled device.

```lua
local userInputService = game:GetService("UserInputService")

function(touch, gameProcessedEvent)
	local oldPosition = touch.Position - touch.Delta
	print("Touch moved from "..tostring(oldPosition).."to "..tostring(touch.Position))
end

userInputService.TouchMoved:Connect(TouchMoved)
```


It can be paired with  `TouchStarted` and  `TouchEnded` to determine when a user starts touching the screen, how their finger moves while touching it, and when the they stop touching the screen.

To check if a user's device is TouchEnabled, and that touch events will fire, see `TouchEnabled`. 

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

As this event only fires locally, it can only be used in a `LocalScript`.

## See also
 - `TouchTap`
 - `TouchTapInWorld`
 - `TouchLongPress`
 - `TouchPan`
 - `TouchPinch`
 - `TouchRotate`
 - `TouchSwipe`
 - `TouchStarted`
 - `TouchEnded`

## Code Samples

### The Difference Between TouchTap and TouchLongPress

The code sample below demonstrates the difference between a `TouchTap` and `TouchLongPress` by creating a `GUI` `Frame` that appears when user touches the screen of their device and disappears when the `touch ends`. When the long press event fires, the GUI doubles in size. Also, the GUI moves to stay centered under the user’s finger when the player moves their finger.

In order for the `TouchLongPress` to fire, the user touch the screen and hold their finger still for a short period of time. Once the touch moves, the long press event will not fire.

In order for the example to work as expected, it should be placed in a `LocalScript` that is parented to a `ScreenGui`.
```lua
local UserInputService = game:GetService("UserInputService")

-- The parent of this script (a ScreenGui)
local touchScreenGui = script.Parent

-- Create the GUI frame that the user interacts with through Touch
-- events
local touchGui = Instance.new("Frame")
touchGui.Name = "TouchGui"
touchGui.AnchorPoint = Vector2.new(0.5, 0.5)

-- Fires when the touches their device’s screen
local function TouchTap(touch, gameProcessedEvent)
	touchGui.Parent = touchScreenGui
	touchGui.Position = UDim2.new(0, touch.Position.X, 0, touch.Position.Y)
	touchGui.Size = UDim2.new(0,50,0,50)
end

-- Fires when a user starts touching their device's screen and does not
-- move their finger for a short period of time
local function TouchLong(touchPositions, state, gameProcessedEvent)
	touchGui.Size = UDim2.new(0,100,0,100)
end

-- Fires when the user moves their finger while touching their device's
-- screen
local function TouchMove(touch, gameProcessedEvent)
	touchGui.Position = UDim2.new(0, touch.Position.X, 0, touch.Position.Y)
end

-- Fires when the user stops touching their device's screen
local function TouchEnd(touch, gameProcessedEvent)
	touchGui.Parent = nil
	touchGui.Size = UDim2.new(0,50,0,50)
end

-- Only use the Touch events if the user is on a mobile device
if UserInputService.TouchEnabled then
	UserInputService.TouchTap:Connect(TouchTap)
	UserInputService.TouchLongPress:Connect(TouchLong)
	UserInputService.TouchMoved:Connect(TouchMove)
	UserInputService.TouchEnded:Connect(TouchEnd)
end
```
 */
	readonly TouchMoved: RBXScriptSignal<(touch: InputObject, gameProcessedEvent: boolean) => void>;
	/** The TouchPan event fires when a user drags at least one finger on a `TouchEnabled` device.

This event can be used to determine when a user pans their finger along screen of a TouchEnabled device - such as to rotate the `Camera` in a custom camera script.

The snippet below prints "Speed of touch drag" followed by the velocity of the user's touch when the user drags their finger on the screen.

```lua
local userInputService = game:GetService("UserInputService")

userInputService.TouchPan:Connect(function(touchPositions, totalTranslation, velocity, state, gameProcessedEvent)
	print("Speed of touch drag: "..tostring(velocity))
end)
```


Take a look at another useful `UserInputService` function here `TouchRotate`.

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

As this event only fires locally, it can only be used in a `LocalScript`.

## See also
 - `TouchTap`
 - `TouchTapInWorld`
 - `TouchLongPress`
 - `TouchMoved`
 - `TouchPinch`
 - `TouchRotate`
 - `TouchSwipe`
 - `TouchStarted`
 - `TouchEnded`

## Code Samples

### Create a Custom CameraScript

By default, Roblox relies on a `LocalScript`, described [here][1], to control the user’s camera. However, this script can be overridden with a custom *CameraScript*. The example below demonstrates how to create a custom script to control the user’s camera using many of the `UserInputService` events.

The script is broken into two parts:

 1. Mobile camera events, which rely on touch events
 2. Non-mobile camera events, which rely on keyboard input and tracking the user’s movement

First, the camera script needs utility functions to setup the camera and set its `CameraType` to *Scriptable* so that the script can control the camera. It also needs a function to update the camera when it moves, rotates, and zooms.

Using touch events allows us to track user input as they interact with the touchscreen on their mobile device. These events allow us to handle camera movement, rotation, and zoom.

The second half of the code sample adds camera support for players on desktop devices. When input begans, the function Input() checks that the state of the input is `Enum.UserInputState.Begin` to ignore all keypress inputs other than when the user first presses a key down. When the user presses *I* and *O* the camera zooms in and out. When the presses down and moves their left mouse button, the script `locks` the player’s mouse by changing the `MouseBehavior` property. The camera rotates according to the mouse’s `change in screen position`. When the player moves their character, the camera moves with them.

All of the parts discussed above are combined and shown in the code sample below.
```lua
-- ========================================
-- GLOBAL VARIABLES
-- ========================================
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- The camera used by the LocalPlayer
local camera = game.Workspace.CurrentCamera

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")
local playerPosition = torso.Position

local default_CameraPosition = torso.Position
local default_CameraRotation = Vector2.new(0,math.rad(-60))
local default_CameraZoom = 15

local cameraPosition = default_CameraPosition
local cameraRotation = default_CameraRotation
local cameraZoom = default_CameraZoom

local cameraRotationBounds = {math.rad(-81),math.rad(20)}
local cameraZoomBounds = nil --{10,200}
local touchDragSpeed = 0.15
local cameraSpeed = 0.1
local cameraRotateSpeed = 10
local cameraMouseRotateSpeed = 0.25
local cameraTouchRotateSpeed = 10
-- ========================================
-- ========================================





-- ========================================
-- UTILITY FUNCTIONS
-- ========================================
local function SetCameraMode()
camera.CameraType = "Scriptable"
camera.FieldOfView = 80
camera.CameraSubject = nil
end

local function UpdateCamera()
SetCameraMode()
local cameraRotationCFrame = CFrame.Angles(0, cameraRotation.X, 0)*CFrame.Angles(cameraRotation.Y, 0, 0)
camera.CFrame = cameraRotationCFrame + cameraPosition + cameraRotationCFrame*Vector3.new(0, 0, cameraZoom)
camera.Focus = camera.CFrame - Vector3.new(0, camera.CFrame.p.Y, 0)
end
-- ========================================
-- ========================================




-- ========================================
-- MOBILE CAMERA EVENTS
-- ========================================
-- Events used to control the camera for players using a mobile device

-- ====================
-- CAMERA MOVE
-- ====================
-- Fired by UserInputService.TouchPan
local lastTouchTranslation = nil
local function TouchMove(touchPositions, totalTranslation, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = totalTranslation - lastTouchTranslation
	cameraPosition = cameraPosition + Vector3.new(difference.X, 0, difference.Y)
		UpdateCamera()
	end
	lastTouchTranslation = totalTranslation
end

-- ====================
-- CAMERA ROTATE
-- ====================
-- Fired by UserInputService.TouchRotate
local lastTouchRotation = nil
local function TouchRotate(touchPositions, rotation, velocity, state)
if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
local difference = rotation - lastTouchRotation
cameraRotation = cameraRotation + Vector2.new(-difference,0)*math.rad(cameraTouchRotateSpeed*cameraRotateSpeed)
		UpdateCamera()
	end
lastTouchRotation = rotation
end

-- ====================
-- CAMERA ZOOM
-- ====================
-- Fired by UserInputService.TouchPinch
local lastTouchScale = nil
local function TouchZoom(touchPositions, scale, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = scale - lastTouchScale
		cameraZoom = cameraZoom * (1 + difference)
		if cameraZoomBounds ~= nil then
			cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
		else
			cameraZoom = math.max(cameraZoom, 0)
end
		UpdateCamera()
	end
	lastTouchScale = scale
end

local function Input()
	UpdateCamera()
end
-- ========================================





-- ========================================
-- NON-MOBILE CAMERA EVENTS
-- ========================================

local function Input(inputObject)
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		if inputObject.UserInputState == Enum.UserInputState.Begin then						
			-- ====================
			-- CAMERA ZOOM
			-- ====================
			-- (I) Zoom In
			if inputObject.KeyCode == Enum.KeyCode.I then
			 	cameraZoom = cameraZoom - 15
			elseif inputObject.KeyCode == Enum.KeyCode.O then
				cameraZoom = cameraZoom + 15
			end
		
			-- (O) Zoom Out
			if cameraZoomBounds ~= nil then
				cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
			else
				cameraZoom = math.max(cameraZoom, 0)
			end
			
			UpdateCamera()
		end
	end
	
	-- ====================
	-- CAMERA ROTATE
	-- ====================
	local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
	if pressed then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		local rotation = userInputService:GetMouseDelta()
		cameraRotation = cameraRotation + rotation*math.rad(cameraMouseRotateSpeed)
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end

-- ====================
-- CAMERA MOVE
-- ====================
local function PlayerChanged()
	local movement = torso.Position - playerPosition
	cameraPosition = cameraPosition + movement
	playerPosition = torso.Position
		
	UpdateCamera()
end
-- ========================================
-- ========================================






-- ========================================
-- DEVICE CHECK
-- ========================================
-- Determine whether the user is on a mobile device

if UserInputService.TouchEnabled then
	-- The user is on a mobile device, use Touch events
UserInputService.TouchPan:Connect(TouchMove)
UserInputService.TouchRotate:Connect(TouchRotate)
UserInputService.TouchPinch:Connect(TouchZoom)
else
	
	-- The user is not on a mobile device use Input events
UserInputService.InputBegan:Connect(Input)
UserInputService.InputChanged:Connect(Input)
UserInputService.InputEnded:Connect(Input)

	-- Camera controlled by player movement
	wait(2)
	RunService:BindToRenderStep("PlayerChanged", Enum.RenderPriority.Camera.Value-1, PlayerChanged)
end	
-- ========================================
-- ========================================
```
 */
	readonly TouchPan: RBXScriptSignal<
		(
			touchPositions: Array<InputObject>,
			totalTranslation: Vector2,
			velocity: Vector2,
			state: Enum.UserInputState,
			gameProcessedEvent: boolean,
		) => void
	>;
	/** Fired when a user places and moves two fingers on the screen of a `TouchEnabled` device.

For instance, the snippet below prints how much the camera zoom scale has changed since the beginning of the touch pinch,
```lua
local UserInputService = game:GetService("UserInputService")

UserInputService.TouchPinch:Connect(function(touchPositions, scale, velocity, state, gameProcessedEvent)
	print("Scale difference since beginning of pinch: "..tostring(scale))
end)
```


To check if a user's device is TouchEnabled, and that touch events will fire, see `TouchEnabled`. 

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

As this event only fires locally, it can only be used in a `LocalScript`.

`Core scripts` use similar logic to zoom the user’s camera when a user pinches their fingers on a mobile device. For more info on these scripts, see [here][1]. Best practice for this event is to use it when creating a mobile camera system to override the default core script.

## See also
 - `TouchTap`
 - `TouchTapInWorld`
 - `TouchMoved`
 - `TouchLongPress`
 - `TouchPan`
 - `TouchRotate`
 - `TouchSwipe`
 - `TouchStarted`
 - `TouchEnded`

[1]: https://www.robloxdev.com/articles/Movement-and-camera-controls

## Code Samples

### Create a Custom CameraScript

By default, Roblox relies on a `LocalScript`, described [here][1], to control the user’s camera. However, this script can be overridden with a custom *CameraScript*. The example below demonstrates how to create a custom script to control the user’s camera using many of the `UserInputService` events.

The script is broken into two parts:

 1. Mobile camera events, which rely on touch events
 2. Non-mobile camera events, which rely on keyboard input and tracking the user’s movement

First, the camera script needs utility functions to setup the camera and set its `CameraType` to *Scriptable* so that the script can control the camera. It also needs a function to update the camera when it moves, rotates, and zooms.

Using touch events allows us to track user input as they interact with the touchscreen on their mobile device. These events allow us to handle camera movement, rotation, and zoom.

The second half of the code sample adds camera support for players on desktop devices. When input begans, the function Input() checks that the state of the input is `Enum.UserInputState.Begin` to ignore all keypress inputs other than when the user first presses a key down. When the user presses *I* and *O* the camera zooms in and out. When the presses down and moves their left mouse button, the script `locks` the player’s mouse by changing the `MouseBehavior` property. The camera rotates according to the mouse’s `change in screen position`. When the player moves their character, the camera moves with them.

All of the parts discussed above are combined and shown in the code sample below.
```lua
-- ========================================
-- GLOBAL VARIABLES
-- ========================================
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- The camera used by the LocalPlayer
local camera = game.Workspace.CurrentCamera

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")
local playerPosition = torso.Position

local default_CameraPosition = torso.Position
local default_CameraRotation = Vector2.new(0,math.rad(-60))
local default_CameraZoom = 15

local cameraPosition = default_CameraPosition
local cameraRotation = default_CameraRotation
local cameraZoom = default_CameraZoom

local cameraRotationBounds = {math.rad(-81),math.rad(20)}
local cameraZoomBounds = nil --{10,200}
local touchDragSpeed = 0.15
local cameraSpeed = 0.1
local cameraRotateSpeed = 10
local cameraMouseRotateSpeed = 0.25
local cameraTouchRotateSpeed = 10
-- ========================================
-- ========================================





-- ========================================
-- UTILITY FUNCTIONS
-- ========================================
local function SetCameraMode()
camera.CameraType = "Scriptable"
camera.FieldOfView = 80
camera.CameraSubject = nil
end

local function UpdateCamera()
SetCameraMode()
local cameraRotationCFrame = CFrame.Angles(0, cameraRotation.X, 0)*CFrame.Angles(cameraRotation.Y, 0, 0)
camera.CFrame = cameraRotationCFrame + cameraPosition + cameraRotationCFrame*Vector3.new(0, 0, cameraZoom)
camera.Focus = camera.CFrame - Vector3.new(0, camera.CFrame.p.Y, 0)
end
-- ========================================
-- ========================================




-- ========================================
-- MOBILE CAMERA EVENTS
-- ========================================
-- Events used to control the camera for players using a mobile device

-- ====================
-- CAMERA MOVE
-- ====================
-- Fired by UserInputService.TouchPan
local lastTouchTranslation = nil
local function TouchMove(touchPositions, totalTranslation, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = totalTranslation - lastTouchTranslation
	cameraPosition = cameraPosition + Vector3.new(difference.X, 0, difference.Y)
		UpdateCamera()
	end
	lastTouchTranslation = totalTranslation
end

-- ====================
-- CAMERA ROTATE
-- ====================
-- Fired by UserInputService.TouchRotate
local lastTouchRotation = nil
local function TouchRotate(touchPositions, rotation, velocity, state)
if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
local difference = rotation - lastTouchRotation
cameraRotation = cameraRotation + Vector2.new(-difference,0)*math.rad(cameraTouchRotateSpeed*cameraRotateSpeed)
		UpdateCamera()
	end
lastTouchRotation = rotation
end

-- ====================
-- CAMERA ZOOM
-- ====================
-- Fired by UserInputService.TouchPinch
local lastTouchScale = nil
local function TouchZoom(touchPositions, scale, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = scale - lastTouchScale
		cameraZoom = cameraZoom * (1 + difference)
		if cameraZoomBounds ~= nil then
			cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
		else
			cameraZoom = math.max(cameraZoom, 0)
end
		UpdateCamera()
	end
	lastTouchScale = scale
end

local function Input()
	UpdateCamera()
end
-- ========================================





-- ========================================
-- NON-MOBILE CAMERA EVENTS
-- ========================================

local function Input(inputObject)
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		if inputObject.UserInputState == Enum.UserInputState.Begin then						
			-- ====================
			-- CAMERA ZOOM
			-- ====================
			-- (I) Zoom In
			if inputObject.KeyCode == Enum.KeyCode.I then
			 	cameraZoom = cameraZoom - 15
			elseif inputObject.KeyCode == Enum.KeyCode.O then
				cameraZoom = cameraZoom + 15
			end
		
			-- (O) Zoom Out
			if cameraZoomBounds ~= nil then
				cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
			else
				cameraZoom = math.max(cameraZoom, 0)
			end
			
			UpdateCamera()
		end
	end
	
	-- ====================
	-- CAMERA ROTATE
	-- ====================
	local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
	if pressed then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		local rotation = userInputService:GetMouseDelta()
		cameraRotation = cameraRotation + rotation*math.rad(cameraMouseRotateSpeed)
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end

-- ====================
-- CAMERA MOVE
-- ====================
local function PlayerChanged()
	local movement = torso.Position - playerPosition
	cameraPosition = cameraPosition + movement
	playerPosition = torso.Position
		
	UpdateCamera()
end
-- ========================================
-- ========================================






-- ========================================
-- DEVICE CHECK
-- ========================================
-- Determine whether the user is on a mobile device

if UserInputService.TouchEnabled then
	-- The user is on a mobile device, use Touch events
UserInputService.TouchPan:Connect(TouchMove)
UserInputService.TouchRotate:Connect(TouchRotate)
UserInputService.TouchPinch:Connect(TouchZoom)
else
	
	-- The user is not on a mobile device use Input events
UserInputService.InputBegan:Connect(Input)
UserInputService.InputChanged:Connect(Input)
UserInputService.InputEnded:Connect(Input)

	-- Camera controlled by player movement
	wait(2)
	RunService:BindToRenderStep("PlayerChanged", Enum.RenderPriority.Camera.Value-1, PlayerChanged)
end	
-- ========================================
-- ========================================
```
 */
	readonly TouchPinch: RBXScriptSignal<
		(
			touchPositions: Array<InputObject>,
			scale: number,
			velocity: number,
			state: Enum.UserInputState,
			gameProcessedEvent: boolean,
		) => void
	>;
	/** The TouchRotate event fires when a user rotates two fingers on a `TouchEnabled` device.

For example, the following code prints  how much the camera has rotated since the beginning of the touch rotation.

```lua
local UserInputService = game:GetService("UserInputService")

UserInputService.TouchRotate:Connect(function(touchPositions, rotation, velocity, state, gameProcessedEvent)
	print("Camera has rotated "..tostring(rotation).." degrees!")
end)
```


To check if a user's device is TouchEnabled, and that touch events will fire, see `TouchEnabled`. 

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

As this event only fires locally, it can only be used in a `LocalScript`.

The core scripts that control the user's camera on a mobile device use code that functions similarly to this event. For more info on these scripts, see [here][1]. Best practice for this event is to use it when creating a mobile camera system to override the default core scripts.

## See also 
 - `TouchTap`
 - `TouchTapInWorld`
 - `TouchMoved`
 - `TouchLongPress`
 - `TouchPan`
 - `TouchPinch`
 - `TouchSwipe`
 - `TouchStarted`
 - `TouchEnded`


[1]:/articles/Movement-and-camera-controls

## Code Samples

### Create a Custom CameraScript

By default, Roblox relies on a `LocalScript`, described [here][1], to control the user’s camera. However, this script can be overridden with a custom *CameraScript*. The example below demonstrates how to create a custom script to control the user’s camera using many of the `UserInputService` events.

The script is broken into two parts:

 1. Mobile camera events, which rely on touch events
 2. Non-mobile camera events, which rely on keyboard input and tracking the user’s movement

First, the camera script needs utility functions to setup the camera and set its `CameraType` to *Scriptable* so that the script can control the camera. It also needs a function to update the camera when it moves, rotates, and zooms.

Using touch events allows us to track user input as they interact with the touchscreen on their mobile device. These events allow us to handle camera movement, rotation, and zoom.

The second half of the code sample adds camera support for players on desktop devices. When input begans, the function Input() checks that the state of the input is `Enum.UserInputState.Begin` to ignore all keypress inputs other than when the user first presses a key down. When the user presses *I* and *O* the camera zooms in and out. When the presses down and moves their left mouse button, the script `locks` the player’s mouse by changing the `MouseBehavior` property. The camera rotates according to the mouse’s `change in screen position`. When the player moves their character, the camera moves with them.

All of the parts discussed above are combined and shown in the code sample below.
```lua
-- ========================================
-- GLOBAL VARIABLES
-- ========================================
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- The camera used by the LocalPlayer
local camera = game.Workspace.CurrentCamera

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local torso = character:WaitForChild("Torso")
local playerPosition = torso.Position

local default_CameraPosition = torso.Position
local default_CameraRotation = Vector2.new(0,math.rad(-60))
local default_CameraZoom = 15

local cameraPosition = default_CameraPosition
local cameraRotation = default_CameraRotation
local cameraZoom = default_CameraZoom

local cameraRotationBounds = {math.rad(-81),math.rad(20)}
local cameraZoomBounds = nil --{10,200}
local touchDragSpeed = 0.15
local cameraSpeed = 0.1
local cameraRotateSpeed = 10
local cameraMouseRotateSpeed = 0.25
local cameraTouchRotateSpeed = 10
-- ========================================
-- ========================================





-- ========================================
-- UTILITY FUNCTIONS
-- ========================================
local function SetCameraMode()
camera.CameraType = "Scriptable"
camera.FieldOfView = 80
camera.CameraSubject = nil
end

local function UpdateCamera()
SetCameraMode()
local cameraRotationCFrame = CFrame.Angles(0, cameraRotation.X, 0)*CFrame.Angles(cameraRotation.Y, 0, 0)
camera.CFrame = cameraRotationCFrame + cameraPosition + cameraRotationCFrame*Vector3.new(0, 0, cameraZoom)
camera.Focus = camera.CFrame - Vector3.new(0, camera.CFrame.p.Y, 0)
end
-- ========================================
-- ========================================




-- ========================================
-- MOBILE CAMERA EVENTS
-- ========================================
-- Events used to control the camera for players using a mobile device

-- ====================
-- CAMERA MOVE
-- ====================
-- Fired by UserInputService.TouchPan
local lastTouchTranslation = nil
local function TouchMove(touchPositions, totalTranslation, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = totalTranslation - lastTouchTranslation
	cameraPosition = cameraPosition + Vector3.new(difference.X, 0, difference.Y)
		UpdateCamera()
	end
	lastTouchTranslation = totalTranslation
end

-- ====================
-- CAMERA ROTATE
-- ====================
-- Fired by UserInputService.TouchRotate
local lastTouchRotation = nil
local function TouchRotate(touchPositions, rotation, velocity, state)
if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
local difference = rotation - lastTouchRotation
cameraRotation = cameraRotation + Vector2.new(-difference,0)*math.rad(cameraTouchRotateSpeed*cameraRotateSpeed)
		UpdateCamera()
	end
lastTouchRotation = rotation
end

-- ====================
-- CAMERA ZOOM
-- ====================
-- Fired by UserInputService.TouchPinch
local lastTouchScale = nil
local function TouchZoom(touchPositions, scale, velocity, state)
	if state == Enum.UserInputState.Change or state == Enum.UserInputState.End then
		local difference = scale - lastTouchScale
		cameraZoom = cameraZoom * (1 + difference)
		if cameraZoomBounds ~= nil then
			cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
		else
			cameraZoom = math.max(cameraZoom, 0)
end
		UpdateCamera()
	end
	lastTouchScale = scale
end

local function Input()
	UpdateCamera()
end
-- ========================================





-- ========================================
-- NON-MOBILE CAMERA EVENTS
-- ========================================

local function Input(inputObject)
	if inputObject.UserInputType == Enum.UserInputType.Keyboard then
		if inputObject.UserInputState == Enum.UserInputState.Begin then						
			-- ====================
			-- CAMERA ZOOM
			-- ====================
			-- (I) Zoom In
			if inputObject.KeyCode == Enum.KeyCode.I then
			 	cameraZoom = cameraZoom - 15
			elseif inputObject.KeyCode == Enum.KeyCode.O then
				cameraZoom = cameraZoom + 15
			end
		
			-- (O) Zoom Out
			if cameraZoomBounds ~= nil then
				cameraZoom = math.min(math.max(cameraZoom, cameraZoomBounds[1]), cameraZoomBounds[2])
			else
				cameraZoom = math.max(cameraZoom, 0)
			end
			
			UpdateCamera()
		end
	end
	
	-- ====================
	-- CAMERA ROTATE
	-- ====================
	local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
	if pressed then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		local rotation = userInputService:GetMouseDelta()
		cameraRotation = cameraRotation + rotation*math.rad(cameraMouseRotateSpeed)
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end

-- ====================
-- CAMERA MOVE
-- ====================
local function PlayerChanged()
	local movement = torso.Position - playerPosition
	cameraPosition = cameraPosition + movement
	playerPosition = torso.Position
		
	UpdateCamera()
end
-- ========================================
-- ========================================






-- ========================================
-- DEVICE CHECK
-- ========================================
-- Determine whether the user is on a mobile device

if UserInputService.TouchEnabled then
	-- The user is on a mobile device, use Touch events
UserInputService.TouchPan:Connect(TouchMove)
UserInputService.TouchRotate:Connect(TouchRotate)
UserInputService.TouchPinch:Connect(TouchZoom)
else
	
	-- The user is not on a mobile device use Input events
UserInputService.InputBegan:Connect(Input)
UserInputService.InputChanged:Connect(Input)
UserInputService.InputEnded:Connect(Input)

	-- Camera controlled by player movement
	wait(2)
	RunService:BindToRenderStep("PlayerChanged", Enum.RenderPriority.Camera.Value-1, PlayerChanged)
end	
-- ========================================
-- ========================================
```
 */
	readonly TouchRotate: RBXScriptSignal<
		(
			touchPositions: Array<InputObject>,
			rotation: number,
			velocity: number,
			state: Enum.UserInputState,
			gameProcessedEvent: boolean,
		) => void
	>;
	/** The TouchStarted event fires when a user places their finger on a `TouchEnabled` device, beginning touch input with the device. 

This event can be used to determine when a user starts touching the screen of their device. It can be paired with `TouchEnded` to determine when a user starts and stops touching the screen.

The touch input object is the same input object throughout the lifetime of the touch. So comparing `InputObjects` when they are touch objects is valid to determine if it is the same finger.

To check if a user's device is TouchEnabled, and that touch events will fire, see `TouchEnabled`. 

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

As this event only fires locally, it can only be used in a `LocalScript`.

## See also
 - `TouchTap`
 - `TouchTapInWorld`
 - `TouchLongPress`
 - `TouchMoved`
 - `TouchPan`
 - `TouchPinch`
 - `TouchRotate`
 - `TouchSwipe`
 - `TouchEnded`

## Code Samples

### Tracking Touches

The touch `InputObject` is the same input object throughout the lifetime of the touch. So comparing input objects when they are touch objects is valid to determine if it is the same finger.

This example demonstrates how to track touch `InputObjects` to distinguish different fingers when - particularly when multiple fingers are touching the screen at the same time.

The example starts tracking a finger once the touch is registered by the `TouchStarted` event. It continues to update the finger, tracking it’s position until its `State` is *End* or *Cancel*. The example also releases all fingers when the user `minimizes` the Roblox client or `opens` the menu screen.
```lua
local touch = {}

local UserInputService = game:GetService("UserInputService")
local UuiService = game:GetService("GuiService")

local fingerTracker = {}
touch.fingers = fingerTracker

local pressed = {}
local moved = {}
local lifted = {}

local function Connect(tab, func)
	tab[func] = true
	return function()
		tab[func] = nil
	end
end

local function Fire(tab, ...)
	for func in next, tab do
		func(...)
	end
end

function touch.Pressed(func)
	return Connect(pressed, func)
end

function touch.Moved(func)
	return Connect(moved, func)
end

function touch.Lifted(func)
	return Connect(lifted, func)
end

local function DoTouchEnded(io)
	local pos = io.Position
	local posx = pos.x
	local posy = pos.y
	
	local storedFingerData = fingerTracker[io]
	if storedFingerData ~= nil then
		local deltax = posx - storedFingerData.initx
		local deltay = posy - storedFingerData.initx
		Fire(lifted, io, posx, posy, deltax, deltay)
		fingerTracker[io] = nil
	end
end

local function DoTouchMoved(io)
	local pos = io.Position
	local posx = pos.x
	local posy = pos.y
	
	local storedFingerData = fingerTracker[io]
	if storedFingerData ~= nil then
		local deltax = posx - storedFingerData.initx
		local deltay = posy - storedFingerData.initx
		Fire(moved, io, posx, posy, deltax, deltay)
	end
end

local function TouchStarted(input)
	local pos = input.Position
	local posx = pos.x
	local posy = pos.y
	
	fingerTracker[input] = {initx = posx, inity = posy}
	Fire(pressed, input, posx, posy)
	
	input.Changed:Connect(function(property)
		if property == "Position" then
			DoTouchMoved(input)
		elseif property == "UserInputState" then
			if input.UserInputState == Enum.UserInputState.End or input.UserInputState == Enum.UserInputState.Cancel then
				DoTouchEnded(input)
			end
		end
	end)
end

local function ReleaseAll()
	for finger,_ in next, fingerTracker do
		DoTouchEnded(finger)
	end
	fingerTracker = {}
end

UserInputService.TouchStarted:Connect(TouchStarted)
UserInputService.WindowFocusReleased:Connect(ReleaseAll)
GuiService.MenuOpened:Connect(ReleaseAll)

return touch
```
 */
	readonly TouchStarted: RBXScriptSignal<(touch: InputObject, gameProcessedEvent: boolean) => void>;
	/** The TouchSwipe event fires when a user swipes their fingers on a `TouchEnabled` device.

This event can be used to determine when a user swipes their fingers on the screen of their device and the direction that the user swiped.

For more precise tracking of touch input movement, use using `TouchMoved`

To check if a user's device is TouchEnabled, and that touch events will fire, see `TouchEnabled`. 

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

As this event only fires locally, it can only be used in a `LocalScript`.

## See also
 - `TouchTap`
 - `TouchTapInWorld`
 - `TouchLongPress`
 - `TouchMoved`
 - `TouchPan`
 - `TouchPinch`
 - `TouchRotate`
 - `TouchStarted`
 - `TouchEnded`

## Code Samples

### Touch Swipe a GUI

The example below demonstrates the `TouchSwipe` event by `tweening` a `GUI` element’s position 100 pixels in the direction of the swipe according to the value of the `swipeDirection` argument.

In order for this example to work as expected, it must be placed in a `LocalScript` that is parented to the gui being swiped.
```lua
local UserInputService = game:GetService("UserInputService")

local gui = script.Parent
local swipePositionY = gui.Position.Y.Offset
local swipePositionX = gui.Position.X.Offset

local camera = game.Workspace.CurrentCamera
local maxY = camera.ViewportSize.Y - gui.Size.Y.Offset
local maxX = camera.ViewportSize.X- gui.Size.X.Offset

local function TouchSwipe(swipeDirection, numberOfTouches, gameProcessedEvent)
	if swipeDirection == Enum.SwipeDirection.Up then
		swipePositionY = math.max(swipePositionY-200, 0)
	elseif swipeDirection == Enum.SwipeDirection.Down then
		swipePositionY = math.min(swipePositionY+200, maxY)
	elseif swipeDirection == Enum.SwipeDirection.Left then
		swipePositionX = math.max(swipePositionX-200, 0)
	elseif swipeDirection == Enum.SwipeDirection.Right then
		swipePositionX = math.min(swipePositionX+200, maxX)
	end
	
	gui:TweenPosition(UDim2.new(0, swipePositionX, 0, swipePositionY), "Out", "Quad", .25, true)
end

UserInputService.TouchSwipe:Connect(TouchSwipe)
```
 */
	readonly TouchSwipe: RBXScriptSignal<(swipeDirection: Enum.SwipeDirection, numberOfTouches: number, gameProcessedEvent: boolean) => void>;
	/** The TouchTap event fires when the user touches/taps their finger on the screen on a `TouchEnabled` device. 

This event will fire regardless of whether the user touches/taps the game world or a `GUI` element. If you are looking for an event that only fires when the user touches/taps the game world, use `TouchTapInWorld`.

To check if a user's device is TouchEnabled, and that touch events will fire, see `TouchEnabled`. 

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

As this event only fires locally, it can only be used in a `LocalScript`.

## See also
 - `TouchTapInWorld`
 - `TouchLongPress`
 - `TouchMoved`
 - `TouchPan`
 - `TouchPinch`
 - `TouchRotate`
 - `TouchSwipe`
 - `TouchStarted`
 - `TouchEnded`

## Code Samples

### The Difference Between TouchTap and TouchLongPress

The code sample below demonstrates the difference between a `TouchTap` and `TouchLongPress` by creating a `GUI` `Frame` that appears when user touches the screen of their device and disappears when the `touch ends`. When the long press event fires, the GUI doubles in size. Also, the GUI moves to stay centered under the user’s finger when the player moves their finger.

In order for the `TouchLongPress` to fire, the user touch the screen and hold their finger still for a short period of time. Once the touch moves, the long press event will not fire.

In order for the example to work as expected, it should be placed in a `LocalScript` that is parented to a `ScreenGui`.
```lua
local UserInputService = game:GetService("UserInputService")

-- The parent of this script (a ScreenGui)
local touchScreenGui = script.Parent

-- Create the GUI frame that the user interacts with through Touch
-- events
local touchGui = Instance.new("Frame")
touchGui.Name = "TouchGui"
touchGui.AnchorPoint = Vector2.new(0.5, 0.5)

-- Fires when the touches their device’s screen
local function TouchTap(touch, gameProcessedEvent)
	touchGui.Parent = touchScreenGui
	touchGui.Position = UDim2.new(0, touch.Position.X, 0, touch.Position.Y)
	touchGui.Size = UDim2.new(0,50,0,50)
end

-- Fires when a user starts touching their device's screen and does not
-- move their finger for a short period of time
local function TouchLong(touchPositions, state, gameProcessedEvent)
	touchGui.Size = UDim2.new(0,100,0,100)
end

-- Fires when the user moves their finger while touching their device's
-- screen
local function TouchMove(touch, gameProcessedEvent)
	touchGui.Position = UDim2.new(0, touch.Position.X, 0, touch.Position.Y)
end

-- Fires when the user stops touching their device's screen
local function TouchEnd(touch, gameProcessedEvent)
	touchGui.Parent = nil
	touchGui.Size = UDim2.new(0,50,0,50)
end

-- Only use the Touch events if the user is on a mobile device
if UserInputService.TouchEnabled then
	UserInputService.TouchTap:Connect(TouchTap)
	UserInputService.TouchLongPress:Connect(TouchLong)
	UserInputService.TouchMoved:Connect(TouchMove)
	UserInputService.TouchEnded:Connect(TouchEnd)
end
```
 */
	readonly TouchTap: RBXScriptSignal<(touchPositions: Array<InputObject>, gameProcessedEvent: boolean) => void>;
	/** The TouchTapInWorld event fires when the user touches/taps their finger on the screen on a `TouchEnabled` device. It is fired when the user taps in the game world.

This event can be used to determine when a user taps the screen and does not tap a `GUI` element. If the user taps a GUI element, `TouchTap` will fire instead of TouchTapInWorld.

To check if a user's device is TouchEnabled, and that touch events will fire, see  `TouchEnabled`. 

This event only fires when the Roblox client window is in focus. For example, inputs will not be captured when the window is minimized.

As it only fires locally, it can only be used in a `LocalScript`.

## See also
 - `TouchTap`
 - `TouchLongPress`
 - `TouchMoved`
 - `TouchPan`
 - `TouchPinch`
 - `TouchRotate`
 - `TouchSwipe`
 - `TouchStarted`
 - `TouchEnded`

## Code Samples

### Create a Part in World at Touch Position

This example uses the `Vector2` position passed by `TouchTapInWorld` to find the `Vector3` world position the user tapped. Then, the code spawns an anchored `Part` at the world position.

In order to calculate the `Vector3` world position using the viewport *position*, this example generates a `Ray` called *unitRay* originating from *position* using the `ViewportPointToRay` function. Then, since ViewportPointToRay() creates a unit ray that is only 1 stud long, the example uses it to create a longer *ray* that is *length* studs long. Using `FindPartOnRay`, the code determines where the ray first intersects a part in the world - the Vector3 world position that the user tapped.

Note that the code sample will not spawn a part if the user touches on the screen over an empty skybox. The touch must be on a part for FindPartOnRay() to return a `Vector3` position.
```lua
local UserInputService = game:GetService("UserInputService")

local camera = game.Workspace.CurrentCamera
local length = 500

local function createPart(position, processedByUI)
	-- Do not create a part if the player clicked on a GUI/UI element
	if processedByUI then return end

	-- Get Vector3 world position from the Vector2 viewport position
	local unitRay = camera:ViewportPointToRay(position.X, position.Y)
	local ray = Ray.new(unitRay.Origin, unitRay.Direction * length)
	local hitPart, worldPosition = game.Workspace:FindPartOnRay(ray)
	
	-- Create a new part at the world position if the player clicked on a part
	-- Do not create a new part if player clicks on empty skybox
	if hitPart then
		local part = Instance.new("Part")
		part.Parent = game.Workspace
		part.Anchored = true
		part.Size = Vector3.new(1, 1, 1)
		part.Position = worldPosition
	end
end

UserInputService.TouchTapInWorld:Connect(createPart)
```
 */
	readonly TouchTapInWorld: RBXScriptSignal<(position: Vector2, processedByUI: boolean) => void>;
	/** The UserCFrameChanged event fires when the `CFrame` of a VR device changes.

This event can be used to track the movement of a connected VR device. 

Using the event, you can implement features such as moving the user's in-game character limbs as the user moves their VR device. This can be done by changing the CFrame of the user's in-game limbs to match the CFrame changes of the VR device using the `UserCFrame` enum and *CFrame* value arguments passed by the event.

To retrieve the `CFrame` of a connected VR device, use `GetUserCFrame`.

As the event fires locally, it can only be used in a `LocalScript`. 

## See also
- `VRService`, used to implement support, including an identical event `UserHeadCFrameChanged`
 - `HeadLocked`, when this property is *true* the `Camera` will automatically track the head motion of a player using a VR device
 - `GetRenderCFrame`, a function which retrieves the `CFrame` the `Camera` is being orientated at, including the impact of VR devices

## Code Samples

### VR Head Tracking

This example demonstrates how to implement a head tracking script that mirrors the movement of a virtual reality (VR) headset (the user’s actual head) to their in-game `character’s` head. 

The example first check if the user is using a VR device by checking the value of the `VREnabled` property. This example only works if the user is using a VR headset.

To determine the initial `CFrame` of the character’s head, the code sample calls `GetUserCFrame` and passes `Enum.UserCFrame.Head` as the argument.

To update the head’s CFrame whenever the user’s VR headset moves, the example connects the `UserCFrameChanged` event to the *TrackHead()* function. When the event fires to indicate that a VR device moved, TrackHead() checks if the headset moved. If the headset moved, the function updates the CFrame of the character’s head to the `CFrame` *value* provided as an argument.

As the UserCFrame enum also tracks VR left and right hand devices, the concept of VR device tracking can be expanded to other character bodyparts.

In order for the example to work as expected, it must be placed in a `LocalScript`.
```lua
local UserInputService = game:GetService("UserInputService")

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local head = character:WaitForChild("Head")

local function TrackHead(inputType, value)
	if inputType == Enum.UserCFrame.Head then
		head.CFrame = value
	end
end

if UserInputService.VREnabled then
	-- Set the inital CFrame
	head.CFrame = UserInputService:GetUserCFrame(Enum.UserCFrame.Head)
	
	-- Track VR headset movement and mirror for character's head
	UserInputService.UserCFrameChanged:Connect(TrackHead)
end

```
 */
	readonly UserCFrameChanged: RBXScriptSignal<(type: Enum.UserCFrame, value: CFrame) => void>;
	/** The `UserInputService` WindowFocusReleased event fires when the window of the Roblox client loses focus - typically when the Roblox client is minimized by the user.

For example, the code below prints *"Window focus released"* whenever the Roblox client loses focus.

```lua
local UserInputService = game:GetService("UserInputService")

UserInputService.WindowFocusReleased:Connect(function()
	print("Window focus released")
end)
```


This event can be used alongside `WindowFocused` to track whether the Roblox client is actively focused on a user's screen.

Since it only fires locally, it can only be used in a `LocalScript`.

## Code Samples

### Window Focus AFK Script

This example fires a `RemoveEvent to the server` name *AfkEvent* when the `LocalPlayer`’s client gains or loses focus.

The purpose of this code sample is to fire a server-side event to indicate when the player is AFK. This is indicated by spawning a `ForceField` around the player when the client loses focus and `destroying` the forcefield when the client gains focus.

In order for this example to work as expected, the code labelled *LocalScript* must be placed in a `LocalScript` and the code labelled *Script* must be placed in a `Script`.
```lua

-- LocalScript
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local AfkEvent = ReplicatedStorage:WaitForChild("AfkEvent")

local function focusGained()
	AfkEvent:FireServer(false)
end

local function focusReleased()
	AfkEvent:FireServer(true)
end

UserInputService.WindowFocused:Connect(focusGained)
UserInputService.WindowFocusReleased:Connect(focusReleased)


-- Script
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local AfkEvent = Instance.new("RemoteEvent")
AfkEvent.Name = "AfkEvent"
AfkEvent.Parent = ReplicatedStorage

local function setAfk(player, afk)
	if afk then
		local forcefield = Instance.new("ForceField")
		forcefield.Parent = player.Character
	else
		local forcefield = player.Character:FindFirstChildOfClass("ForceField")
		if forcefield then
			forcefield:Destroy()
		end
	end
end

AfkEvent.OnServerEvent:Connect(setAfk)
```
 */
	readonly WindowFocusReleased: RBXScriptSignal<() => void>;
	/** The `UserInputService` WindowFocused event fires when the window of the Roblox client gains focus - typically when the Roblox client is maximized/actively open on the user's screen.

For example, the code below prints *"Window focused"* whenever the Roblox client gains focus.

```lua
local UserInputService = game:GetService("UserInputService")

UserInputService.WindowFocused:Connect(function()
	print("Window focused")
end)
```


This event can be used alongside `WindowFocusReleased` to track whether the Roblox client is actively focused on a user's screen.

As this event only fires locally, it can only be used in a `LocalScript`.

## Code Samples

### Window Focus AFK Script

This example fires a `RemoveEvent to the server` name *AfkEvent* when the `LocalPlayer`’s client gains or loses focus.

The purpose of this code sample is to fire a server-side event to indicate when the player is AFK. This is indicated by spawning a `ForceField` around the player when the client loses focus and `destroying` the forcefield when the client gains focus.

In order for this example to work as expected, the code labelled *LocalScript* must be placed in a `LocalScript` and the code labelled *Script* must be placed in a `Script`.
```lua

-- LocalScript
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local AfkEvent = ReplicatedStorage:WaitForChild("AfkEvent")

local function focusGained()
	AfkEvent:FireServer(false)
end

local function focusReleased()
	AfkEvent:FireServer(true)
end

UserInputService.WindowFocused:Connect(focusGained)
UserInputService.WindowFocusReleased:Connect(focusReleased)


-- Script
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local AfkEvent = Instance.new("RemoteEvent")
AfkEvent.Name = "AfkEvent"
AfkEvent.Parent = ReplicatedStorage

local function setAfk(player, afk)
	if afk then
		local forcefield = Instance.new("ForceField")
		forcefield.Parent = player.Character
	else
		local forcefield = player.Character:FindFirstChildOfClass("ForceField")
		if forcefield then
			forcefield:Destroy()
		end
	end
end

AfkEvent.OnServerEvent:Connect(setAfk)
```
 */
	readonly WindowFocused: RBXScriptSignal<() => void>;
}

/** The VRService is a service that is responsible for handling interactions between Roblox and Virtual Reality (VR). If you're interested in incorporating VR compatibility into your game, this is the service for you!

The primary purpose of this service is to allow for games to communication and cooperate with virtual reality decisions - such as VR headsets and controllers. It allows a LocalScript to perform different actions depending on the device, and in turn, helps developers provide the best experience for the end user seeking to experience Roblox using VR devices. 

Some usages of this service include detecting whether a user has any connected VR devices, tracking when those devices move, and determining how those devices interact with the user's in-game controls. In order to detect user input, the service must look for a service event. For example, the service can detect  VR device movement via events such as `UserCFrameChanged`.

Notes
----------

 1. The `UserInputService` also contains several events and functions useful for enhancing a player's VR experience in your game.
 2. Since this service is client-side only, it will only work when used in a `LocalScript`. It will not work when used within a `Script`. Client-side only means that users in the game can only detect their own input - and not the input of other users.

## Code Samples

### VRService

The following example demonstrates one of many usage examples of handling a VRService event.

​The `UserCFrameChanged` event fires when the user moves a connected VR device. When the event fires, this prints the name of the VR device type that changed, and the updated `CFrame` coordinates.
```lua
-- We must get the VRService before we can use it
local VRService = game:GetService("VRService")

-- A sample function providing one usage of UserCFrameChanged
local function userCFrameChanged(typ, value)
	print(typ.Name + " changed. Updated Frame: " + value)
end

VRService.UserCFrameChanged:Connect(userCFrameChanged)
```
 */
interface VRService extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VRService";
	/** The GuiInputUserCFrame property describes what `UserCFrame` is responsible for input in VR. For instance, if a VR headset is responsible, the value of this property will be UserCFrame.Head.

To check if Roblox detects any VR devices, which would be responsible for input in VR, you can check the `VREnabled` property.

Since `VRService` only runs client-side, this property will only work when used in a `LocalScript`.

## Code Samples

### VRService.GuiInputUserCFrame

This example checks if Roblox detects a VR device. If a VR device is detected, this prints the name of the UserCFrame responsible for VR input. If not, this example prints "No VR device detected!".
```lua
local VRService = game:GetService("VRService")

if (VRService.VREnabled) then
	print(VRService.GuiInputUserCFrame.Name)
else
	print("No VR device detected!")
end
```
 */
	GuiInputUserCFrame: Enum.UserCFrame;
	/** This property describes whether the user is using a virtual reality (VR) device. 

If a VR device is enabled, you can interact with its location and movement through functions such as `GetUserCFrame``. You can also react to VR device movement using the `UserCFrameChanged` event.

```lua
local userInputService = game:GetService("UserInputService")

local isUsingVR = userInputService.VREnabled
if (isUsingVR) then
	print("User is using a VR headset!")
else
	print("User is not using a VR headset!")
end
```


As `UserInputService` isclient-side only, this property can only be used in a `LocalScript`.

See [this][1] article for VR best practices.

## See also 
 - `VRService`
 - `HeadLocked`
 - `GetUserCFrame`
 -  `UserCFrameChanged`

 [1]: /articles/Virtual-Reality-Best-Practices

## Code Samples

### VR Head Tracking

This example demonstrates how to implement a head tracking script that mirrors the movement of a virtual reality (VR) headset (the user’s actual head) to their in-game `character’s` head. 

The example first check if the user is using a VR device by checking the value of the `VREnabled` property. This example only works if the user is using a VR headset.

To determine the initial `CFrame` of the character’s head, the code sample calls `GetUserCFrame` and passes `Enum.UserCFrame.Head` as the argument.

To update the head’s CFrame whenever the user’s VR headset moves, the example connects the `UserCFrameChanged` event to the *TrackHead()* function. When the event fires to indicate that a VR device moved, TrackHead() checks if the headset moved. If the headset moved, the function updates the CFrame of the character’s head to the `CFrame` *value* provided as an argument.

As the UserCFrame enum also tracks VR left and right hand devices, the concept of VR device tracking can be expanded to other character bodyparts.

In order for the example to work as expected, it must be placed in a `LocalScript`.
```lua
local UserInputService = game:GetService("UserInputService")

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local head = character:WaitForChild("Head")

local function TrackHead(inputType, value)
	if inputType == Enum.UserCFrame.Head then
		head.CFrame = value
	end
end

if UserInputService.VREnabled then
	-- Set the inital CFrame
	head.CFrame = UserInputService:GetUserCFrame(Enum.UserCFrame.Head)
	
	-- Track VR headset movement and mirror for character's head
	UserInputService.UserCFrameChanged:Connect(TrackHead)
end

```
This property describes whether the user is using a virtual reality (VR) device. 

If a VR device is enabled, you can interact with its location and movement through functions such as `GetUserCFrame``. You can also react to VR device movement using the `UserCFrameChanged` event.

```lua
local userInputService = game:GetService("UserInputService")

local isUsingVR = userInputService.VREnabled
if (isUsingVR) then
	print("User is using a VR headset!")
else
	print("User is not using a VR headset!")
end
```


As `UserInputService` isclient-side only, this property can only be used in a `LocalScript`.

See [this][1] article for VR best practices.

## See also 
 - `VRService`
 - `HeadLocked`
 - `GetUserCFrame`
 -  `UserCFrameChanged`

 [1]: /articles/Virtual-Reality-Best-Practices

## Code Samples

### VR Head Tracking

This example demonstrates how to implement a head tracking script that mirrors the movement of a virtual reality (VR) headset (the user’s actual head) to their in-game `character’s` head. 

The example first check if the user is using a VR device by checking the value of the `VREnabled` property. This example only works if the user is using a VR headset.

To determine the initial `CFrame` of the character’s head, the code sample calls `GetUserCFrame` and passes `Enum.UserCFrame.Head` as the argument.

To update the head’s CFrame whenever the user’s VR headset moves, the example connects the `UserCFrameChanged` event to the *TrackHead()* function. When the event fires to indicate that a VR device moved, TrackHead() checks if the headset moved. If the headset moved, the function updates the CFrame of the character’s head to the `CFrame` *value* provided as an argument.

As the UserCFrame enum also tracks VR left and right hand devices, the concept of VR device tracking can be expanded to other character bodyparts.

In order for the example to work as expected, it must be placed in a `LocalScript`.
```lua
local UserInputService = game:GetService("UserInputService")

local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.CharacterAdded:Wait()
local head = character:WaitForChild("Head")

local function TrackHead(inputType, value)
	if inputType == Enum.UserCFrame.Head then
		head.CFrame = value
	end
end

if UserInputService.VREnabled then
	-- Set the inital CFrame
	head.CFrame = UserInputService:GetUserCFrame(Enum.UserCFrame.Head)
	
	-- Track VR headset movement and mirror for character's head
	UserInputService.UserCFrameChanged:Connect(TrackHead)
end

```


Tags: ReadOnly, NotReplicated */
	readonly VREnabled: boolean;
	/** The GetTouchpadMode function returns the `VRTouchpadMode` indicating the mode of a specified `VRTouchpad`.

The returned mode indicates how the user interacts with their touchpad to play the game. For more information about the different types of modes, see the `VRTouchpadMode` page.

This can also be used alongside the several `/UserInputService` VR functions and events.

Since `/VRService` only runs client-side, this function will only work when used in a `/LocalScript`.

## Code Samples

### VRService:GetTouchpadMode

This example retrieves and prints the name of the user's current VRTouchpad.Left touchpad mode.
```lua
local VRService = game:GetService("VRService")

VRService:GetTouchpadMode(VRTouchpad.Left)
```

@param pad The specified VRTouchpad.
@returns The mode of the specified VRTouchpad. */
	GetTouchpadMode(pad: CastsToEnum<Enum.VRTouchpad>): Enum.VRTouchpadMode;
	/** The GetUserCFrame function returns a `CFrame` describing the position &amp; orientation of a specified virtual reality (VR) device.

This function should be used when implementing VR compatibility into a game to obtain and track the movement of a connected VR device. 

By using the function, players can implement features such as re-positioning the user's in-game character corresponding to the location of a connected VR device. This can be done by changing the *CFrame* of the user's in-game character to match the *CFrame* of the specified VR device using the UserCFrame enum and *CFrame* value arguments passed by the event.

The `VRService` service also provides an event `/VRService/UserCFrameChanged` that automatically fires when the *CFrame* of connected VR device changes - so long it is used in a LocalScript.

This can also be used alongside the several `/UserInputService` VR functions and events.

Since `/VRService` only runs client-side, this function will only work when used in a `/LocalScript`.

## Code Samples

### VRService:GetUserCFrame

This example prints the specified Enum and its current CFrame value when Enum.UserCFrame.Head is the specified VR device.
```lua
local VRService = game:GetService("VRService")

local cf = VR:GetUserCFrame(Enum.UserCFrame.Head)
print("Enum.UserCFrame.Head:\t", cf)
```

@param type The specified UserCFrame. */
	GetUserCFrame(type: CastsToEnum<Enum.UserCFrame>): CFrame;
	/** The GetUserCFrameEnabled function returns true if the specified `UserCFrame` virtual reality device (VR) is available to be listened to.

This can be used to determine whether a specified VR device, *(e.g. UserCFrame.Head)*, is connected to the user's game. If the specified VR device is connected, is it enabled (*true*). Otherwise, it is disabled (*false*).

This can also be used alongside the several `/UserInputService` VR functions and events.

Since `/VRService` only runs client-side, this function will only work when used in a `/LocalScript`.

## Code Samples

### VRService:GetUserCFrameEnabled

​​This example indicates whether the UserCFrame.Head VR device is enabled or disabled for the user. If the device is enabled, this prints "VR device is enabled!". If the device is disabled, this prints "VR device is disabled!".
```lua
local VRService = game:GetService("VRService")

local isEnabled = VRService:GetUserCFrameEnabled(UserCFrame.Head)
if (isEnabled) then
	print("VR device is enabled!")
else
	print("VR device is disabled!")
end)
```

@param type The specified type of VR device.
@returns A boolean indicating whether the specified VR device is enabled (*true*) or disabled (*false*). */
	GetUserCFrameEnabled(type: CastsToEnum<Enum.UserCFrame>): boolean;
	/** The RecentUserHeadCFrame function recenters the `CFrame` of the user's head to the current location of the VR headset being worn by the user.

This function can be used to ensure that the user's in-game head is positioned according to the location of the user's VR headset.

This is similar to the `UserInputService` function, `RecenterUserHeadCFrame`.

Since `/VRServiceService` only runs client-side, this function will only work when used in a `/LocalScript`.

## Code Samples

### VRService:RecenterUserHeadCFrame

This example fires the function to recenter the CFrame of the user's head to the current location of the VR headset being worn by the user.
```lua
local VRService = game:GetService("VRService")

VRService:RecenterUserHeadCFrame()
```

@returns No return. */
	RecenterUserHeadCFrame(): void;
	/** The RequestNavigation function requests navigation to the specified `CFrame`, using the specified `/Enum/UserCFrame` as the origin for the visualizer parabola.

This can be used to incorporate virtual reality (VR) into your game by providing a means to visualize a navigation path from the user's VR device to a destination.

The `VRService` has a similar event, `NavigationRequested`, used to detect such requests. This can also be used alongside the several `/UserInputService` VR functions and events.

Since VRService only runs client-side, this function will only work when used in a `/LocalScript`.

## Code Samples

### VRService:RequestNavigation

This example requests navigation from the user's **UserCFrame.Head** coordinates to the CFrame coordinates of a `Part` named *NavigationDestination*. 

*Note:* In order for this to work, a Part named *NavigationDestination* must exist in the game's Workspace.
```lua
local VRService = game:GetService("VRService")
local NavDest = game.Workspace:FindFirstChild("NavigationDestination")

VRService:RequestNavigation(UserCFrame.Head, NavDest.CFrame)
```

@param cframe The specified CFrame coordinates.
@param inputUserCFrame The VR device for which the navigation is requested.
@returns No return. */
	RequestNavigation(cframe: CFrame, inputUserCFrame: CastsToEnum<Enum.UserCFrame>): void;
	/** The SetTouchpadMode function sets the mode of the specified `VRTouchpad` to the specified `VRTouchpadMode`.

This can be used to change the user's virtual reality (VR) touchpad mode so that the user interacts with the game different using the touchpad. For more information about the different types of modes, see the `VRTouchpadMode` page.

This can also be used alongside the several `/UserInputService` VR functions and events.

Since `/VRService` only runs client-side, this function will only work when used in a `/LocalScript`.

## Code Samples

### VRService:SetTouchpadMode

​This example sets the user's VRTouchpad.Left touchpad mode to TouchMode.Touch. This means that the left touchpad is treated as ButtonB.
```lua
local VRService = game:GetService("VRService")

VRService:SetTouchpadMode(VRTouchpad.Left, TouchpadMode.Touch)
```

@param pad The specified VRTouchpad you want to set the mode of.
@param mode The mode you want to set the specified VRTouchpad to.
@returns No return. */
	SetTouchpadMode(pad: CastsToEnum<Enum.VRTouchpad>, mode: CastsToEnum<Enum.VRTouchpadMode>): void;
	/** The NavigationRequested event fires when navigation is requested from the VRService for a specified `UserCFrame` VR device. 

This is fired with a `CFrame` coordinate and specified UserCFrame indicating the device requesting the navigation.

This `/VRService` event can be used alongside `/UserInputService` service events and functions.

Since the event fires locally, it can only be used in a `/LocalScript`.

## Code Samples

### VRService.NavigationRequested

This example prints the name of the UserCFrame VR device making the request, and the CFrame coordinates passed.
```lua
local VRService = game:GetService("VRService")

VRService.TouchpadModeChanged:Connect(function(cframe, inputUserCFrame)
	print(inputUserCFrame.Name + " made request with CFrame: " + cframe)
end)
```
 */
	readonly NavigationRequested: RBXScriptSignal<(cframe: CFrame, inputUserCFrame: Enum.UserCFrame) => void>;
	/** The TouchpadModeChanged event fires if the `VRTouchpadMode` of a `VRTouchpad` is changed. This event indicates the VRTouchpad that changes, and its new state.

You can use this event to track the states of VRTouchpads connected via the user's client.

This `/VRService` event can be used alongside `/UserInputService` service events and functions.

Since the event fires locally, it can only be used in a `/LocalScript`.

## Code Samples

### VRService.TouchpadModeChanged

​This example fires when the state of a VRTouchpad changes. It prints the name of the Touchpad that changed, and the state that it changed to.
```lua
local VRService = game:GetService("VRService")

VRService.NavigationRequested:Connect(function(pad, mode)
	print(pad.Name + "Touchpad changed to state: " + mode.Name)
end)
```
 */
	readonly TouchpadModeChanged: RBXScriptSignal<(pad: Enum.VRTouchpad, mode: Enum.VRTouchpadMode) => void>;
	/** The UserCFrameChanged even fires when a `UserCFrame` is changed. For instance, this event fires when the user moves a connected VR device.

This can be used alongside `VRService\GetUserCFrame` to track the `CFrame` coordinates of a VR devices, and when it changes/moves. It can also be used alongside `/UserInputService` service events and functions.

Since the event fires locally, it can only be used in a `/LocalScript`.

## Code Samples

### VRService.UserCFrameChanged

​This event fires when the user moves a connected VR device. When the event fires, this prints the name of the VR device type that changed, and the updated CFrame coordinates.
```lua
local VRService = game:GetService("VRService")

VRService.UserCFrameChanged(function(type, value)
	print(type.Name + " changed. Updated Frame: " + value)
end
```
 */
	readonly UserCFrameChanged: RBXScriptSignal<(type: Enum.UserCFrame, value: CFrame) => void>;
	/** The UserCFrameEnabled event fires when a `UserCFrame` gets enabled or disabled. 

This can be used alongside `VRService\GetUserCFrameEnabled` to track whether a specified UserCFrame is enabled, and when its state changes. It can also be used alongside `/UserInputService` service events and functions.

Since the event fires locally, it can only be used in a `/LocalScript`.

## Code Samples

### VRService.UserCFrameEnabled

​This example fires when a UserCFrame changes state, printing the name of the changed UserCFrame and whether it changed got enabled or disabled.
```lua
local VRService = game:GetService("VRService")

VRService.UserCFrameEnabled:Connect(function(type, enabled)
	if (enabled) then
		print(type.Name + " got enabled!")
	else
		print(type.Name + " got disabled!")
end)
```
 */
	readonly UserCFrameEnabled: RBXScriptSignal<(type: Enum.UserCFrame, enabled: boolean) => void>;
}

interface RbxInternalValueBase extends RbxInternalInstance {}
type ValueBase = BinaryStringValue | BoolValue | BrickColorValue | CFrameValue | Color3Value | DoubleConstrainedValue | IntConstrainedValue | IntValue | NumberValue | ObjectValue | RayValue | StringValue | Vector3Value;

/** An internal type of `StringValue` object, that stores a `BinaryString` value. */
interface BinaryStringValue extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BinaryStringValue";
}

/** An instance which is used to hold a boolean value. The value can be used for many things, including to communicate between scripts. */
interface BoolValue extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BoolValue";
	/** Used to hold a boolean
 value. */
	Value: boolean;
}

/** An instance which is used to store a BrickColor value. */
interface BrickColorValue extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "BrickColorValue";
	/** Used to hold a [BrickColor](https://developer.roblox.com/api-reference/datatype/BrickColor "BrickColor")
 value. */
	Value: BrickColor;
}

/** A container object for a single `CFrame` value.

## Code Samples

### Store the Camera's CFrame

This code sample creates a CFrameValue whose Value is set to the camera's current CFrame. This CFrame can be later recalled back into the camera's CFrame.
```lua
-- Create a CFrame that stores the camera's current position/orientation
local vSnapshot = Instance.new("CFrameValue")
vSnapshot.Value = workspace.CurrentCamera.CFrame
vSnapshot.Name = "Snapshot"
vSnapshot.Parent = workspace

-- Later, we can load the CFrame back into the camera
workspace.CurrentCamera.CFrame = vSnapshot.Value

```
 */
interface CFrameValue extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "CFrameValue";
	/** Used to hold a [CFrame](https://developer.roblox.com/api-reference/datatype/CFrame "CFrame")
 value. */
	Value: CFrame;
}

/** A container object for a single `Color3` value.

## Code Samples

### Set Color3Value

This code sample sets the Value property of a Color3Value to Red.
```lua
local myColor3Value = script.Parent
myColor3Value.Value = Color3.new(1, 0, 0) -- Red

-- You can also store the color of a BrickColor value by accessing BrickColor's Color property, which is a Color3:
local someBrickColor = BrickColor.new("Really red")
myColor3Value.Value = someBrickColor.Color
```
 */
interface Color3Value extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Color3Value";
	/** The stored [Color3](https://developer.roblox.com/api-reference/datatype/Color3 "Color3")
. */
	Value: Color3;
}

/** An instance which is used to create a number value which can never be less than the MinValue or more than the MaxValue. */
	/** An instance which is used to create a number value which can never be less than the MinValue or more than the MaxValue. */
interface DoubleConstrainedValue extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "DoubleConstrainedValue";

	ConstrainedValue: number;
	/** The highest number that the `Value` property can be. */
	MaxValue: number;
	/** The lowest number that the `Value` property can be. */
	MinValue: number;
	/** Used to hold a number value between `MinValue` and `MaxValue`. */
	Value: number;
}

/** An IntConstrainedValue is used to store a value which can never be less than MinValue and can never be more than MaxValue. */
interface IntConstrainedValue extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "IntConstrainedValue";
	/** Hold a `Integer` value between `/IntConstrainedValue/MinValue` and `/IntConstrainedValue/MaxValue`. Replaced by `/IntConstrainedValue/Value`, but still functional.Hold a `Integer` value between `/IntConstrainedValue/MinValue` and `/IntConstrainedValue/MaxValue`. Replaced by `/IntConstrainedValue/Value`, but still functional.

Tags: Hidden, NotReplicated */
	ConstrainedValue: number;
	/** The highest number that the `/IntConstrainedValue/Value` property can be. */
	MaxValue: number;
	/** The lowest number that the `/IntConstrainedValue/Value` property can be. */
	MinValue: number;
	/** Used to hold a integer value between `/IntConstrainedValue/MinValue` and `/IntConstrainedValue/MaxValue`.Used to hold a integer value between `/IntConstrainedValue/MinValue` and `/IntConstrainedValue/MaxValue`.

Tags: NotReplicated */
	Value: number;
}

/** An IntValue is an object that stores a single signed 32-bit integer. Integers do not include decimal points. The highest value that can be stored is 2^31 - 1, or 2,147,483,647. Attempting to store numbers larger than this may cause [integer overflow][1]. The lowest value that can be stored is -(2^31), or -2,147,483,648. For values outside of this range, use a NumberValue instead. Like all "-Value" objects, this single value is stored in the Value property. The `Changed` event for this (and other objects like it) will run with the new value being stored in the object, instead of a string representing the property being changed.


  [1]: https://en.wikipedia.org/wiki/Integer_overflow

## Code Samples

### IntValue Limits and Integer Overflow

This code sample demonstrates the constraints of IntValues, as well as the integer overflow phenomenon.
```lua
-- These are the constraints for a 32-bit signed integer
local INT_MAX = 2 ^ 31 - 1
local INT_MIN = -(2 ^ 31)

local vInteger = Instance.new("IntValue")
vInteger.Changed:connect(print)
-- Some small values
vInteger.Value = 5
vInteger.Value = 0
vInteger.Value = -0 -- No change - same as 0
-- Min value
vInteger.Value = INT_MIN
-- Max value
vInteger.Value = INT_MAX
-- Max value plus one; this causes integer overflow!
-- The IntValue changes to INT_MIN!
vInteger.Value = INT_MAX + 1

```
 */
interface IntValue extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "IntValue";
	/** Used to hold an [Integer](https://developer.roblox.com/articles/Integers "Integer")
. */
	Value: number;
}

/** A NumberValue is an object whose purpose is to store a single [Lua number][1], defined to be [double-precision floating point number][2], or more commonly known as a **double**. This stores a number in 64 bits (8 bytes) using the IEEE 754 representation (1 sign bit, 11 exponent bits and 52 fractional bits). The maximum numerical value that may be stored is 2^53, or 9,007,199,254,740,992, and the minimum is -9,007,199,254,740,992. It stores up to 15 digits of precision.

Like all "-Value" objects, this single value is stored in the Value property. The Changed event for this (and other objects like it) will fire with the new value being stored in the object, instead of a string representing the property being changed.


  [1]: https://www.lua.org/pil/2.3.html
  [2]: https://en.wikipedia.org/wiki/Double-precision_floating-point_format

## Code Samples

### Changed Event

This sample demonstrates the subtleties of the Changed event on normal objects and "-Value" objects.
```lua
-- Demonstrate the Changed event by creating a Part
local part = Instance.new("Part")
part.Changed:Connect(print)
-- This fires Changed with "Transparency"
part.Transparency = .5
-- Similarly, this fires Changed with "Number"
part.Name = "SomePart"
-- Since changing BrickColor will also change other
-- properties at the same time, this line fires Changed
-- with "BrickColor", "Color3" and "Color3uint16".
part.BrickColor = BrickColor.Red()

-- A NumberValue holds a double-precision floating-point number 
local vNumber = Instance.new("NumberValue")
vNumber.Changed:Connect(print)
-- This fires Changed with 123.456 (not "Value")
vNumber.Value = 123.456
-- This does not fire Changed
vNumber.Name = "SomeNumber"

-- A StringValue stores one string
local vString = Instance.new("StringValue")
vString.Changed:Connect(print)
-- This fires Changed with "Hello" (not "Value")
vString.Value = "Hello"
```
 */
interface NumberValue extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "NumberValue";
	/** Used to hold a double value. */
	Value: number;
}

/** A ObjectValue is an object whose purpose is to store a single reference to another object. If this object is duplicated within studio and the value refers to an object also being copied, then the new ObjectValue will point to the copied object instead of the original. Otherwise, the same value is kept. Copying and pasting this object will clear the value field.

The value of this can be set within studio like other reference-type fields (such as `PrimaryPart`): click the field within the Properties window, then click the object you wish to set it to within the game view or Explorer window. You can clear the field (set it to `nil`) by clicking the X that appears when you click the field.

Like all "-Value" objects, this single value is stored in the Value property. The Changed event for this (and other objects like it) will fire with the new value being stored in the object, instead of a string representing the property being changed.

## Code Samples

### ObjectValue Example

This code sample creates an ObjectValue in the Workspace which holds a reference to an object in the workspace named "Baseplate".
```lua
local objectValue = Instance.new("ObjectValue")
objectValue.Name = "MyBaseplateReference"
objectValue.Value = workspace:FindFirstChild("Baseplate")
objectValue.Parent = workspace
```
 */
interface ObjectValue extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "ObjectValue";
	/** Holds a reference to an instance. */
	Value?: Instance;
}

/** A RayValue is an object whose purpose is to store a single Ray. Similar to CFrameValue, a RayValue's stored ray cannot be viewed or edited within the Properties window within studio. Instead, use the Command bar to get and set the value of these objects. For example, you can use a line like the one below to create a new RayValue named "Value" within the `Workspace`. It creates a ray at (0, 50, 0) and it faces in the positive-X direction.

`Instance.new("RayValue").Value = Ray.new(Vector3.new(0, 50, 0), Vector3.new(10, 0, 0))`

Since there is no trivial way to edit rays within Studio, sometimes it is better to use a CFrameValue instead (which can be changed through a part or the camera). You can reconstruct a ray from a CFrame using `Ray.new(cf.p, cf.lookVector * dist)`, where `cf` is a given CFrame and `dist` is the length of the Ray you want to construct.

Like all "-Value" objects, this single value is stored in the Value property. The Changed event for this (and other objects like it) will fire with the new value being stored in the object, instead of a string representing the property being changed.

## Code Samples

### Rays, RayValue and Raycasting

This code sample demonstrates constructing a Ray, storing the Ray within a RayValue and Raycasting to find other parts between two parts named "PartA" and "PartB".
```lua
local partA = workspace.PartA
local partB = workspace.PartB

-- Construct the Ray object
local origin = partA.Position
local direction = partB.Position - partA.Position
local ray = Ray.new(origin, direction)

-- Construct a RayValue to hold our new Ray
local rayValue = Instance.new("RayValue")
rayValue.Value = ray
rayValue.Name = "PartA-to-PartB Ray"
rayValue.Parent = workspace

-- Raycast to find any parts in between PartA and PartB
local part = workspace:FindPartOnRay(ray)
if part then
	print("Hit part: " .. part:GetFullName())
else
	-- This ought to never happen, as our ray starts at PartA
	-- and points towards PartB, so we should always hit PartB
	-- or some other part.
	print("No part hit!")
end

```
 */
interface RayValue extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "RayValue";
	/** The stored Ray. */
	Value: Ray;
}

/** A StringValue is an object whose purpose is to store a single [Lua string][1]. The length of the string can't be more than 200,000 characters (this will cause a  "String too long" error). Like all "-Value" objects, this single value is stored in the Value property. The Changed event for this (and other objects like it) will fire with the new value being stored in the object, instead of a string representing the property being changed.

If the string is too long to be displayed in the Value field within Properties window, it will partially show the string contents followed by an ellipsis (...).


  [1]: https://www.lua.org/pil/2.4.html

## Code Samples

### Changed Event

This sample demonstrates the subtleties of the Changed event on normal objects and "-Value" objects.
```lua
-- Demonstrate the Changed event by creating a Part
local part = Instance.new("Part")
part.Changed:Connect(print)
-- This fires Changed with "Transparency"
part.Transparency = .5
-- Similarly, this fires Changed with "Number"
part.Name = "SomePart"
-- Since changing BrickColor will also change other
-- properties at the same time, this line fires Changed
-- with "BrickColor", "Color3" and "Color3uint16".
part.BrickColor = BrickColor.Red()

-- A NumberValue holds a double-precision floating-point number 
local vNumber = Instance.new("NumberValue")
vNumber.Changed:Connect(print)
-- This fires Changed with 123.456 (not "Value")
vNumber.Value = 123.456
-- This does not fire Changed
vNumber.Name = "SomeNumber"

-- A StringValue stores one string
local vString = Instance.new("StringValue")
vString.Changed:Connect(print)
-- This fires Changed with "Hello" (not "Value")
vString.Value = "Hello"
```
 */
interface StringValue extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "StringValue";
	/** The stored [string](https://developer.roblox.com/articles/String "API:Type/string")
. */
	Value: string;
}

/** A Vector3Value simply holds a Vector3 as a value. This value can be used for scripts to communicate, for objects to move to a preset location, etc.

## Code Samples

### Storing Vector2 inside Vector3Value

This code sample demonstrates how it is possible to store a Vector2 within a Vector3Value by converting a Vector2 into a Vector3 with a dummy Z value. Similarly, you can load it by reconstructing the Vector2 from the X and Y axes.
```lua
local vector3Value = Instance.new("Vector3Value")

-- Store a Vector2 in a Vector3
local vector2 = Vector2.new(42, 70)
vector3Value.Value = Vector3.new(vector2.X, vector2.Y, 0) -- The Z value is ignored 

-- Load a Vector2 from a Vector3
local vector2 = Vector2.new(vector3Value.Value.X, vector3Value.Value.Y)

```

### Teleporter Part

This code sample causes a Part to teleport any players that touch it to a specific position defined by a "TeleportPosition" Vector3Value.
```lua
-- Paste me in a Script inside a Part
local part = script.Parent
-- A Vector3Value to hold the Teleport target position
-- Tip: Prefix variables of "Value-" objects with "v"
local vTeleportPosition = part.TeleportPosition 

local function onTouch(otherPart)
	-- First, find the HumanoidRootPart. If we can't find it, exit.
	local hrp = otherPart.Parent:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	
	-- Now teleport by setting the CFrame to one created from
	-- the stored in TeleportPosition
	hrp.CFrame = CFrame.new(vTeleportPosition.Value)
end

part.Touched:connect(onTouch)

```
 */
interface Vector3Value extends RbxInternalValueBase {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Vector3Value";
	/** The stored [Vector3](https://developer.roblox.com/api-reference/datatype/Vector3 "Vector3")
. */
	Value: Vector3;
}

/** VirtualInputManager is an internal service used by Roblox to record inputs and play them back during performance benchmarking tests.

This service's API can only be used by `CoreScript`. */
interface VirtualInputManager extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VirtualInputManager";
}

/** VirtualUser is a service that allows you to record the inputs of a user, and then play it back to a limited extent.
This service hasn't been maintained in several years, so it doesn't work very well anymore. */
interface VirtualUser extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "VirtualUser";
}

/** The Visit service is a backend service used by Roblox. Its functions are not accessible to developers in any form. */
interface Visit extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "Visit";
}

/** **WeldConstraints** are used to attach two `parts` together. The constraint makes sure that the parts stay in the same relative position and orientation to one another, meaning that if one part moves, the other will move the same amount. Even if the two parts are not touching one another, they can be welded together with a weld constraint.

The most common way to create a weld constraint is through the Studio **Create** menu in the **Model** tab (select&nbsp;**Weld**). This tool will act differently based on how many parts are selected when the tool is activated:

* If no parts are selected when the **Weld** tool is clicked, the next two parts that are clicked on will be welded together. If the same part is clicked twice, no weld will be created.
* If one part is selected when the **Weld** tool is clicked, the next part that is clicked on will be welded to the selected part.
* If several parts are selected when the **Weld** tool is clicked, any parts in that selection that are touching or overlapping will be welded together.

## Repositioning Welded Parts

Roblox handles moving a welded part differently depending on whether the part was moved using its `Position` or with its `CFrame`.

If a welded part's `Position` is updated, the part will move but none of the connected parts will move with it. The weld will recalculate the offset from the other part based on the part's new position.

```lua
-- Create two parts and position them at the same height
local partA = Instance.new("Part")
local partB = Instance.new("Part")
partA.Position = Vector3.new(0, 10, 0)
partB.Position = Vector3.new(0, 10, 10)
partA.Parent = workspace
partB.Parent = workspace

-- Weld the two parts together
local weld = Instance.new("WeldConstraint")
weld.Parent = workspace
weld.Part0 = partA
weld.Part1 = partB

-- Update the position of the first part; the first part will move but the second will stay where it started
partA.Position = Vector3.new(0, 20, 0)
```

In contrast, if a part's `CFrame` is updated, that part will move and any part welded to that part will also move. These other parts will be moved to make sure they maintain the same offset as when the weld was created.

```lua
-- Create two parts and position them at the same height
local partA = Instance.new("Part")
local partB = Instance.new("Part")
partA.Position = Vector3.new(0, 10, 0)
partB.Position = Vector3.new(0, 10, 10)
partA.Parent = workspace
partB.Parent = workspace

-- Weld the two parts together
local weld = Instance.new("WeldConstraint")
weld.Parent = workspace
weld.Part0 = partA
weld.Part1 = partB

-- Update the CFrame of the first part; the second part will also move to maintain the offset of the weld
partA.CFrame = CFrame.new(0, 20, 0)
``` */
interface WeldConstraint extends RbxInternalInstance {
	/** The string name of this Instance's most derived class. */
	readonly ClassName: "WeldConstraint";
	/** True if the WeldConstraint is currently active in the world.

If the WeldConstraint or one of its parts is not in `Workspace` the weld will be inactive.

Rigid joints like `Weld`, `Snap`, `WeldConstraint`, `Motor`, or `Motor6D` may also be disabled due to conflicts with other rigid joints, such as joints between the same two parts or indirect cycles in the weld graph. Joints disabled this way may be re-enabled later when another joint or part is added or removed.

Duplicate WeldConstraints do not conflict because WeldConstraints derive their internal CFrames from the relative positions of their parts when they are enabled and all update when `Position` or `Orientation` is set on a part. The spanning tree may still disable them if they are redundant or form a cycle.True if the WeldConstraint is currently active in the world.

If the WeldConstraint or one of its parts is not in `Workspace` the weld will be inactive.

Rigid joints like `Weld`, `Snap`, `WeldConstraint`, `Motor`, or `Motor6D` may also be disabled due to conflicts with other rigid joints, such as joints between the same two parts or indirect cycles in the weld graph. Joints disabled this way may be re-enabled later when another joint or part is added or removed.

Duplicate WeldConstraints do not conflict because WeldConstraints derive their internal CFrames from the relative positions of their parts when they are enabled and all update when `Position` or `Orientation` is set on a part. The spanning tree may still disable them if they are redundant or form a cycle.

Tags: ReadOnly, NotReplicated */
	readonly Active: boolean;
	/** The **Enabled**
 property of a `WeldConstraint` sets whether the constraint is active or not. When this property is set to true
, if the constraint’s `Part0` and `Part1` properties are set, then the constraint will ensure that its two connected parts will be locked together. */
	Enabled: boolean;
	/** The **Part0**
 and `Part1` properties of a `WeldConstraint` set which two `BasePart` the weld connects. As soon as both properties are set and the weld is `Enabled`, the weld will lock the two parts together.


If Part0 or Part1 are ever set to new parts, then the WeldConstraint will instantly link the new part. The old part will no longer be constrained.The first part connected by the constraint.

## Example

```lua
local partA = Instance.new("Part")
local partB = Instance.new("Part")

partA.Position = Vector3.new(0, 10, 0)
partA.Parent = game.Workspace

partB.Position = Vector3.new(0, 10, 10)
partB.Parent = game.Workspace

local weld = Instance.new("WeldConstraint")
weld.Parent = partA
weld.Part0 = partAweld.Part1 = partB
```The **Part0**
 and `Part1` properties of a `WeldConstraint` set which two `BasePart` the weld connects. As soon as both properties are set and the weld is `Enabled`, the weld will lock the two parts together.


If Part0 or Part1 are ever set to new parts, then the WeldConstraint will instantly link the new part. The old part will no longer be constrained.The first part connected by the constraint.

## Example

```lua
local partA = Instance.new("Part")
local partB = Instance.new("Part")

partA.Position = Vector3.new(0, 10, 0)
partA.Parent = game.Workspace

partB.Position = Vector3.new(0, 10, 10)
partB.Parent = game.Workspace

local weld = Instance.new("WeldConstraint")
weld.Parent = partA
weld.Part0 = partAweld.Part1 = partB
```

Tags: NotReplicated */
	Part0?: BasePart;
	/** The `Part0` and **Part1**
 properties of a `WeldConstraint` set which two `BasePart` the weld connects. As soon as both properties are set and the weld is `Enabled`, the weld will lock the two parts together.


If Part0 or Part1 are ever set to new parts, then the WeldConstraint will instantly link the new part. The old part will no longer be constrained.The second part connected by the constraint.

## Example

```lua
local partA = Instance.new("Part")
local partB = Instance.new("Part")

partA.Position = Vector3.new(0, 10, 0)
partA.Parent = game.Workspace

partB.Position = Vector3.new(0, 10, 10)
partB.Parent = game.Workspace

local weld = Instance.new("WeldConstraint")
weld.Parent = partA
weld.Part0 = partA
weld.Part1 = partB
```The `Part0` and **Part1**
 properties of a `WeldConstraint` set which two `BasePart` the weld connects. As soon as both properties are set and the weld is `Enabled`, the weld will lock the two parts together.


If Part0 or Part1 are ever set to new parts, then the WeldConstraint will instantly link the new part. The old part will no longer be constrained.The second part connected by the constraint.

## Example

```lua
local partA = Instance.new("Part")
local partB = Instance.new("Part")

partA.Position = Vector3.new(0, 10, 0)
partA.Parent = game.Workspace

partB.Position = Vector3.new(0, 10, 10)
partB.Parent = game.Workspace

local weld = Instance.new("WeldConstraint")
weld.Parent = partA
weld.Part0 = partA
weld.Part1 = partB
```

Tags: NotReplicated */
	Part1?: BasePart;
}

