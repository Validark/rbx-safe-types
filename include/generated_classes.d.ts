// THIS FILE IS GENERATED AUTOMATICALLY AND SHOULD NOT BE EDITED BY HAND!

/// <reference no-default-lib="true"/>
/// <reference path="roblox.d.ts" />
/// <reference path="manual.d.ts" />
/// <reference path="generated_enums.d.ts" />

// CREATABLE INSTANCES TABLE

interface CreatableInstances {
	Accoutrement: Accoutrement;
	Accessory: Accessory;
	Hat: Hat;
	AdvancedDragger: AdvancedDragger;
	Animation: Animation;
	AnimationController: AnimationController;
	Animator: Animator;
	Attachment: Attachment;
	Beam: Beam;
	BindableEvent: BindableEvent;
	BindableFunction: BindableFunction;
	BodyAngularVelocity: BodyAngularVelocity;
	BodyForce: BodyForce;
	BodyGyro: BodyGyro;
	BodyPosition: BodyPosition;
	BodyThrust: BodyThrust;
	BodyVelocity: BodyVelocity;
	RocketPropulsion: RocketPropulsion;
	Camera: Camera;
	BodyColors: BodyColors;
	CharacterMesh: CharacterMesh;
	Pants: Pants;
	Shirt: Shirt;
	ShirtGraphic: ShirtGraphic;
	Skin: Skin;
	ClickDetector: ClickDetector;
	Configuration: Configuration;
	AlignOrientation: AlignOrientation;
	AlignPosition: AlignPosition;
	BallSocketConstraint: BallSocketConstraint;
	HingeConstraint: HingeConstraint;
	LineForce: LineForce;
	RodConstraint: RodConstraint;
	RopeConstraint: RopeConstraint;
	CylindricalConstraint: CylindricalConstraint;
	PrismaticConstraint: PrismaticConstraint;
	SpringConstraint: SpringConstraint;
	Torque: Torque;
	VectorForce: VectorForce;
	HumanoidController: HumanoidController;
	SkateboardController: SkateboardController;
	VehicleController: VehicleController;
	CustomEvent: CustomEvent;
	CustomEventReceiver: CustomEventReceiver;
	BlockMesh: BlockMesh;
	CylinderMesh: CylinderMesh;
	FileMesh: FileMesh;
	SpecialMesh: SpecialMesh;
	DebuggerWatch: DebuggerWatch;
	Dialog: Dialog;
	DialogChoice: DialogChoice;
	Dragger: Dragger;
	Explosion: Explosion;
	Decal: Decal;
	Texture: Texture;
	Hole: Hole;
	MotorFeature: MotorFeature;
	Fire: Fire;
	Folder: Folder;
	ForceField: ForceField;
	FunctionalTest: FunctionalTest;
	GameSettings: GameSettings;
	Frame: Frame;
	ImageButton: ImageButton;
	TextButton: TextButton;
	ImageLabel: ImageLabel;
	TextLabel: TextLabel;
	ScrollingFrame: ScrollingFrame;
	TextBox: TextBox;
	ViewportFrame: ViewportFrame;
	BillboardGui: BillboardGui;
	ScreenGui: ScreenGui;
	GuiMain: GuiMain;
	SurfaceGui: SurfaceGui;
	FloorWire: FloorWire;
	BoxHandleAdornment: BoxHandleAdornment;
	ConeHandleAdornment: ConeHandleAdornment;
	CylinderHandleAdornment: CylinderHandleAdornment;
	ImageHandleAdornment: ImageHandleAdornment;
	LineHandleAdornment: LineHandleAdornment;
	SphereHandleAdornment: SphereHandleAdornment;
	ParabolaAdornment: ParabolaAdornment;
	SelectionBox: SelectionBox;
	SelectionSphere: SelectionSphere;
	ArcHandles: ArcHandles;
	Handles: Handles;
	SurfaceSelection: SurfaceSelection;
	SelectionPartLasso: SelectionPartLasso;
	SelectionPointLasso: SelectionPointLasso;
	Backpack: Backpack;
	HopperBin: HopperBin;
	Tool: Tool;
	Flag: Flag;
	Humanoid: Humanoid;
	HumanoidDescription: HumanoidDescription;
	RotateP: RotateP;
	RotateV: RotateV;
	Glue: Glue;
	ManualGlue: ManualGlue;
	ManualWeld: ManualWeld;
	Motor: Motor;
	Motor6D: Motor6D;
	Rotate: Rotate;
	Snap: Snap;
	VelocityMotor: VelocityMotor;
	Weld: Weld;
	Keyframe: Keyframe;
	KeyframeMarker: KeyframeMarker;
	KeyframeSequence: KeyframeSequence;
	PointLight: PointLight;
	SpotLight: SpotLight;
	SurfaceLight: SurfaceLight;
	LocalizationTable: LocalizationTable;
	LuaSettings: LuaSettings;
	Script: Script;
	LocalScript: LocalScript;
	ModuleScript: ModuleScript;
	Message: Message;
	Hint: Hint;
	CornerWedgePart: CornerWedgePart;
	Part: Part;
	FlagStand: FlagStand;
	Seat: Seat;
	SkateboardPlatform: SkateboardPlatform;
	SpawnLocation: SpawnLocation;
	WedgePart: WedgePart;
	MeshPart: MeshPart;
	PartOperation: PartOperation;
	NegateOperation: NegateOperation;
	UnionOperation: UnionOperation;
	TrussPart: TrussPart;
	VehicleSeat: VehicleSeat;
	Model: Model;
	PartOperationAsset: PartOperationAsset;
	ParticleEmitter: ParticleEmitter;
	PhysicsSettings: PhysicsSettings;
	Player: Player;
	PluginAction: PluginAction;
	Pose: Pose;
	BloomEffect: BloomEffect;
	BlurEffect: BlurEffect;
	ColorCorrectionEffect: ColorCorrectionEffect;
	SunRaysEffect: SunRaysEffect;
	ReflectionMetadata: ReflectionMetadata;
	ReflectionMetadataCallbacks: ReflectionMetadataCallbacks;
	ReflectionMetadataClasses: ReflectionMetadataClasses;
	ReflectionMetadataEnums: ReflectionMetadataEnums;
	ReflectionMetadataEvents: ReflectionMetadataEvents;
	ReflectionMetadataFunctions: ReflectionMetadataFunctions;
	ReflectionMetadataClass: ReflectionMetadataClass;
	ReflectionMetadataEnum: ReflectionMetadataEnum;
	ReflectionMetadataEnumItem: ReflectionMetadataEnumItem;
	ReflectionMetadataMember: ReflectionMetadataMember;
	ReflectionMetadataProperties: ReflectionMetadataProperties;
	ReflectionMetadataYieldFunctions: ReflectionMetadataYieldFunctions;
	RemoteEvent: RemoteEvent;
	RemoteFunction: RemoteFunction;
	RenderingTest: RenderingTest;
	Sky: Sky;
	Smoke: Smoke;
	Sound: Sound;
	ChorusSoundEffect: ChorusSoundEffect;
	CompressorSoundEffect: CompressorSoundEffect;
	DistortionSoundEffect: DistortionSoundEffect;
	EchoSoundEffect: EchoSoundEffect;
	EqualizerSoundEffect: EqualizerSoundEffect;
	FlangeSoundEffect: FlangeSoundEffect;
	PitchShiftSoundEffect: PitchShiftSoundEffect;
	ReverbSoundEffect: ReverbSoundEffect;
	TremoloSoundEffect: TremoloSoundEffect;
	SoundGroup: SoundGroup;
	Sparkles: Sparkles;
	StarterGear: StarterGear;
	StarterPlayerScripts: StarterPlayerScripts;
	StarterCharacterScripts: StarterCharacterScripts;
	Team: Team;
	TerrainRegion: TerrainRegion;
	Trail: Trail;
	Tween: Tween;
	UIAspectRatioConstraint: UIAspectRatioConstraint;
	UISizeConstraint: UISizeConstraint;
	UITextSizeConstraint: UITextSizeConstraint;
	UIGridLayout: UIGridLayout;
	UIListLayout: UIListLayout;
	UIPageLayout: UIPageLayout;
	UITableLayout: UITableLayout;
	UIPadding: UIPadding;
	UIScale: UIScale;
	BinaryStringValue: BinaryStringValue;
	BoolValue: BoolValue;
	BrickColorValue: BrickColorValue;
	CFrameValue: CFrameValue;
	Color3Value: Color3Value;
	DoubleConstrainedValue: DoubleConstrainedValue;
	IntConstrainedValue: IntConstrainedValue;
	IntValue: IntValue;
	NumberValue: NumberValue;
	ObjectValue: ObjectValue;
	RayValue: RayValue;
	StringValue: StringValue;
	Vector3Value: Vector3Value;
	WeldConstraint: WeldConstraint;
}

// INSTANCES TABLE

interface Instances {
	Instance: Instance;
	ABTestService: ABTestService;
	Accoutrement: Accoutrement;
	Accessory: Accessory;
	Hat: Hat;
	AdService: AdService;
	AdvancedDragger: AdvancedDragger;
	AnalyticsService: AnalyticsService;
	Animation: Animation;
	AnimationController: AnimationController;
	AnimationTrack: AnimationTrack;
	Animator: Animator;
	AssetService: AssetService;
	Attachment: Attachment;
	BadgeService: BadgeService;
	BasePlayerGui: BasePlayerGui;
	CoreGui: CoreGui;
	PlayerGui: PlayerGui;
	StarterGui: StarterGui;
	Beam: Beam;
	BindableEvent: BindableEvent;
	BindableFunction: BindableFunction;
	BodyMover: BodyMover;
	BodyAngularVelocity: BodyAngularVelocity;
	BodyForce: BodyForce;
	BodyGyro: BodyGyro;
	BodyPosition: BodyPosition;
	BodyThrust: BodyThrust;
	BodyVelocity: BodyVelocity;
	RocketPropulsion: RocketPropulsion;
	BrowserService: BrowserService;
	CacheableContentProvider: CacheableContentProvider;
	MeshContentProvider: MeshContentProvider;
	SolidModelContentProvider: SolidModelContentProvider;
	Camera: Camera;
	ChangeHistoryService: ChangeHistoryService;
	CharacterAppearance: CharacterAppearance;
	BodyColors: BodyColors;
	CharacterMesh: CharacterMesh;
	Clothing: Clothing;
	Pants: Pants;
	Shirt: Shirt;
	ShirtGraphic: ShirtGraphic;
	Skin: Skin;
	Chat: Chat;
	ClickDetector: ClickDetector;
	ClusterPacketCache: ClusterPacketCache;
	CollectionService: CollectionService;
	Configuration: Configuration;
	Constraint: Constraint;
	AlignOrientation: AlignOrientation;
	AlignPosition: AlignPosition;
	BallSocketConstraint: BallSocketConstraint;
	HingeConstraint: HingeConstraint;
	LineForce: LineForce;
	RodConstraint: RodConstraint;
	RopeConstraint: RopeConstraint;
	SlidingBallConstraint: SlidingBallConstraint;
	CylindricalConstraint: CylindricalConstraint;
	PrismaticConstraint: PrismaticConstraint;
	SpringConstraint: SpringConstraint;
	Torque: Torque;
	VectorForce: VectorForce;
	ContentProvider: ContentProvider;
	ContextActionService: ContextActionService;
	Controller: Controller;
	HumanoidController: HumanoidController;
	SkateboardController: SkateboardController;
	VehicleController: VehicleController;
	ControllerService: ControllerService;
	CookiesService: CookiesService;
	CorePackages: CorePackages;
	CoreScriptSyncService: CoreScriptSyncService;
	CustomEvent: CustomEvent;
	CustomEventReceiver: CustomEventReceiver;
	DataModelMesh: DataModelMesh;
	BevelMesh: BevelMesh;
	BlockMesh: BlockMesh;
	CylinderMesh: CylinderMesh;
	FileMesh: FileMesh;
	SpecialMesh: SpecialMesh;
	DataStoreService: DataStoreService;
	Debris: Debris;
	DebugSettings: DebugSettings;
	DebuggerBreakpoint: DebuggerBreakpoint;
	DebuggerManager: DebuggerManager;
	DebuggerWatch: DebuggerWatch;
	Dialog: Dialog;
	DialogChoice: DialogChoice;
	Dragger: Dragger;
	Explosion: Explosion;
	FaceInstance: FaceInstance;
	Decal: Decal;
	Texture: Texture;
	Feature: Feature;
	Hole: Hole;
	MotorFeature: MotorFeature;
	File: File;
	Fire: Fire;
	FlagStandService: FlagStandService;
	FlyweightService: FlyweightService;
	CSGDictionaryService: CSGDictionaryService;
	NonReplicatedCSGDictionaryService: NonReplicatedCSGDictionaryService;
	Folder: Folder;
	ForceField: ForceField;
	FriendService: FriendService;
	FunctionalTest: FunctionalTest;
	GamePassService: GamePassService;
	GameSettings: GameSettings;
	GamepadService: GamepadService;
	Geometry: Geometry;
	GlobalDataStore: GlobalDataStore;
	OrderedDataStore: OrderedDataStore;
	GoogleAnalyticsConfiguration: GoogleAnalyticsConfiguration;
	GroupService: GroupService;
	GuiBase: GuiBase;
	GuiBase2d: GuiBase2d;
	GuiObject: GuiObject;
	Frame: Frame;
	GuiButton: GuiButton;
	ImageButton: ImageButton;
	TextButton: TextButton;
	GuiLabel: GuiLabel;
	ImageLabel: ImageLabel;
	TextLabel: TextLabel;
	ScrollingFrame: ScrollingFrame;
	TextBox: TextBox;
	ViewportFrame: ViewportFrame;
	LayerCollector: LayerCollector;
	BillboardGui: BillboardGui;
	PluginGui: PluginGui;
	DockWidgetPluginGui: DockWidgetPluginGui;
	QWidgetPluginGui: QWidgetPluginGui;
	ScreenGui: ScreenGui;
	GuiMain: GuiMain;
	SurfaceGui: SurfaceGui;
	GuiBase3d: GuiBase3d;
	FloorWire: FloorWire;
	PVAdornment: PVAdornment;
	HandleAdornment: HandleAdornment;
	BoxHandleAdornment: BoxHandleAdornment;
	ConeHandleAdornment: ConeHandleAdornment;
	CylinderHandleAdornment: CylinderHandleAdornment;
	ImageHandleAdornment: ImageHandleAdornment;
	LineHandleAdornment: LineHandleAdornment;
	SphereHandleAdornment: SphereHandleAdornment;
	ParabolaAdornment: ParabolaAdornment;
	SelectionBox: SelectionBox;
	SelectionSphere: SelectionSphere;
	PartAdornment: PartAdornment;
	HandlesBase: HandlesBase;
	ArcHandles: ArcHandles;
	Handles: Handles;
	SurfaceSelection: SurfaceSelection;
	SelectionLasso: SelectionLasso;
	SelectionPartLasso: SelectionPartLasso;
	SelectionPointLasso: SelectionPointLasso;
	GuiItem: GuiItem;
	Backpack: Backpack;
	BackpackItem: BackpackItem;
	HopperBin: HopperBin;
	Tool: Tool;
	Flag: Flag;
	ButtonBindingWidget: ButtonBindingWidget;
	GuiRoot: GuiRoot;
	Hopper: Hopper;
	StarterPack: StarterPack;
	GuiService: GuiService;
	GuidRegistryService: GuidRegistryService;
	HapticService: HapticService;
	HttpRbxApiService: HttpRbxApiService;
	HttpRequest: HttpRequest;
	HttpService: HttpService;
	Humanoid: Humanoid;
	HumanoidDescription: HumanoidDescription;
	InputObject: InputObject;
	InsertService: InsertService;
	JointInstance: JointInstance;
	DynamicRotate: DynamicRotate;
	RotateP: RotateP;
	RotateV: RotateV;
	Glue: Glue;
	ManualSurfaceJointInstance: ManualSurfaceJointInstance;
	ManualGlue: ManualGlue;
	ManualWeld: ManualWeld;
	Motor: Motor;
	Motor6D: Motor6D;
	Rotate: Rotate;
	Snap: Snap;
	VelocityMotor: VelocityMotor;
	Weld: Weld;
	JointsService: JointsService;
	KeyboardService: KeyboardService;
	Keyframe: Keyframe;
	KeyframeMarker: KeyframeMarker;
	KeyframeSequence: KeyframeSequence;
	KeyframeSequenceProvider: KeyframeSequenceProvider;
	Light: Light;
	PointLight: PointLight;
	SpotLight: SpotLight;
	SurfaceLight: SurfaceLight;
	Lighting: Lighting;
	LocalStorageService: LocalStorageService;
	AppStorageService: AppStorageService;
	UserStorageService: UserStorageService;
	LocalizationService: LocalizationService;
	LocalizationTable: LocalizationTable;
	LogService: LogService;
	LoginService: LoginService;
	LuaSettings: LuaSettings;
	LuaSourceContainer: LuaSourceContainer;
	BaseScript: BaseScript;
	CoreScript: CoreScript;
	Script: Script;
	LocalScript: LocalScript;
	ModuleScript: ModuleScript;
	LuaWebService: LuaWebService;
	MarketplaceService: MarketplaceService;
	Message: Message;
	Hint: Hint;
	MessagingService: MessagingService;
	Mouse: Mouse;
	PlayerMouse: PlayerMouse;
	PluginMouse: PluginMouse;
	MouseService: MouseService;
	NetworkMarker: NetworkMarker;
	NetworkPeer: NetworkPeer;
	NetworkClient: NetworkClient;
	NetworkServer: NetworkServer;
	NetworkReplicator: NetworkReplicator;
	ClientReplicator: ClientReplicator;
	ServerReplicator: ServerReplicator;
	NetworkSettings: NetworkSettings;
	NotificationService: NotificationService;
	PVInstance: PVInstance;
	BasePart: BasePart;
	CornerWedgePart: CornerWedgePart;
	FormFactorPart: FormFactorPart;
	Part: Part;
	FlagStand: FlagStand;
	Platform: Platform;
	Seat: Seat;
	SkateboardPlatform: SkateboardPlatform;
	SpawnLocation: SpawnLocation;
	WedgePart: WedgePart;
	MeshPart: MeshPart;
	PartOperation: PartOperation;
	NegateOperation: NegateOperation;
	UnionOperation: UnionOperation;
	Terrain: Terrain;
	TrussPart: TrussPart;
	VehicleSeat: VehicleSeat;
	Model: Model;
	Status: Status;
	Workspace: Workspace;
	PackageLink: PackageLink;
	Pages: Pages;
	DataStorePages: DataStorePages;
	FriendPages: FriendPages;
	InventoryPages: InventoryPages;
	StandardPages: StandardPages;
	PartOperationAsset: PartOperationAsset;
	ParticleEmitter: ParticleEmitter;
	Path: Path;
	PathfindingService: PathfindingService;
	PhysicsPacketCache: PhysicsPacketCache;
	PhysicsService: PhysicsService;
	PhysicsSettings: PhysicsSettings;
	Player: Player;
	PlayerScripts: PlayerScripts;
	Players: Players;
	Plugin: Plugin;
	PluginAction: PluginAction;
	PluginDragEvent: PluginDragEvent;
	PluginGuiService: PluginGuiService;
	PluginManager: PluginManager;
	PluginMenu: PluginMenu;
	PluginToolbar: PluginToolbar;
	PluginToolbarButton: PluginToolbarButton;
	PointsService: PointsService;
	Pose: Pose;
	PostEffect: PostEffect;
	BloomEffect: BloomEffect;
	BlurEffect: BlurEffect;
	ColorCorrectionEffect: ColorCorrectionEffect;
	SunRaysEffect: SunRaysEffect;
	ReflectionMetadata: ReflectionMetadata;
	ReflectionMetadataCallbacks: ReflectionMetadataCallbacks;
	ReflectionMetadataClasses: ReflectionMetadataClasses;
	ReflectionMetadataEnums: ReflectionMetadataEnums;
	ReflectionMetadataEvents: ReflectionMetadataEvents;
	ReflectionMetadataFunctions: ReflectionMetadataFunctions;
	ReflectionMetadataItem: ReflectionMetadataItem;
	ReflectionMetadataClass: ReflectionMetadataClass;
	ReflectionMetadataEnum: ReflectionMetadataEnum;
	ReflectionMetadataEnumItem: ReflectionMetadataEnumItem;
	ReflectionMetadataMember: ReflectionMetadataMember;
	ReflectionMetadataProperties: ReflectionMetadataProperties;
	ReflectionMetadataYieldFunctions: ReflectionMetadataYieldFunctions;
	RemoteEvent: RemoteEvent;
	RemoteFunction: RemoteFunction;
	RenderSettings: RenderSettings;
	RenderingTest: RenderingTest;
	ReplicatedFirst: ReplicatedFirst;
	ReplicatedStorage: ReplicatedStorage;
	RobloxReplicatedStorage: RobloxReplicatedStorage;
	RunService: RunService;
	RuntimeScriptService: RuntimeScriptService;
	ScriptContext: ScriptContext;
	ScriptDebugger: ScriptDebugger;
	ScriptService: ScriptService;
	Selection: Selection;
	ServerScriptService: ServerScriptService;
	ServerStorage: ServerStorage;
	ServiceProvider: ServiceProvider;
	DataModel: DataModel;
	GenericSettings: GenericSettings;
	AnalysticsSettings: AnalysticsSettings;
	GlobalSettings: GlobalSettings;
	UserSettings: UserSettings;
	Sky: Sky;
	Smoke: Smoke;
	SocialService: SocialService;
	Sound: Sound;
	SoundEffect: SoundEffect;
	ChorusSoundEffect: ChorusSoundEffect;
	CompressorSoundEffect: CompressorSoundEffect;
	DistortionSoundEffect: DistortionSoundEffect;
	EchoSoundEffect: EchoSoundEffect;
	EqualizerSoundEffect: EqualizerSoundEffect;
	FlangeSoundEffect: FlangeSoundEffect;
	PitchShiftSoundEffect: PitchShiftSoundEffect;
	ReverbSoundEffect: ReverbSoundEffect;
	TremoloSoundEffect: TremoloSoundEffect;
	SoundGroup: SoundGroup;
	SoundService: SoundService;
	Sparkles: Sparkles;
	SpawnerService: SpawnerService;
	StarterGear: StarterGear;
	StarterPlayer: StarterPlayer;
	StarterPlayerScripts: StarterPlayerScripts;
	StarterCharacterScripts: StarterCharacterScripts;
	Stats: Stats;
	StatsItem: StatsItem;
	RunningAverageItemDouble: RunningAverageItemDouble;
	RunningAverageItemInt: RunningAverageItemInt;
	RunningAverageTimeIntervalItem: RunningAverageTimeIntervalItem;
	TotalCountTimeIntervalItem: TotalCountTimeIntervalItem;
	StopWatchReporter: StopWatchReporter;
	Studio: Studio;
	StudioService: StudioService;
	StudioTheme: StudioTheme;
	TaskScheduler: TaskScheduler;
	Team: Team;
	Teams: Teams;
	TeleportService: TeleportService;
	TerrainRegion: TerrainRegion;
	TestService: TestService;
	TextFilterResult: TextFilterResult;
	TextService: TextService;
	ThirdPartyUserService: ThirdPartyUserService;
	TimerService: TimerService;
	TouchInputService: TouchInputService;
	TouchTransmitter: TouchTransmitter;
	Trail: Trail;
	Translator: Translator;
	TweenBase: TweenBase;
	Tween: Tween;
	TweenService: TweenService;
	UIBase: UIBase;
	UIComponent: UIComponent;
	UIConstraint: UIConstraint;
	UIAspectRatioConstraint: UIAspectRatioConstraint;
	UISizeConstraint: UISizeConstraint;
	UITextSizeConstraint: UITextSizeConstraint;
	UILayout: UILayout;
	UIGridStyleLayout: UIGridStyleLayout;
	UIGridLayout: UIGridLayout;
	UIListLayout: UIListLayout;
	UIPageLayout: UIPageLayout;
	UITableLayout: UITableLayout;
	UIPadding: UIPadding;
	UIScale: UIScale;
	UserGameSettings: UserGameSettings;
	UserInputService: UserInputService;
	VRService: VRService;
	ValueBase: ValueBase;
	BinaryStringValue: BinaryStringValue;
	BoolValue: BoolValue;
	BrickColorValue: BrickColorValue;
	CFrameValue: CFrameValue;
	Color3Value: Color3Value;
	DoubleConstrainedValue: DoubleConstrainedValue;
	IntConstrainedValue: IntConstrainedValue;
	IntValue: IntValue;
	NumberValue: NumberValue;
	ObjectValue: ObjectValue;
	RayValue: RayValue;
	StringValue: StringValue;
	Vector3Value: Vector3Value;
	VirtualInputManager: VirtualInputManager;
	VirtualUser: VirtualUser;
	Visit: Visit;
	WeldConstraint: WeldConstraint;
}

// GENERATED ROBLOX INSTANCE CLASSES

// Instance
interface Rbx_Instance {
	/** Determines whether or not an Instance can be saved when the game closes/attempts to save the game. Note: this only applies to games that use Data Persistence, or SavePlaceAsync. */
	Archivable: boolean;
	/** The string name of this Instance's most derived class. */
	readonly ClassName: string;
	Name: string;
	/** The Instance that is directly above this Instance in the tree. */
	Parent: Instance | undefined;
	/** Removes all children (but not this object) from the workspace. */
	ClearAllChildren(): void;
	/** Removes object and all of its children from the workspace. Disconnects object and all children from open connections. Object and children may not be usable after calling Destroy. */
	Destroy(): void;
	/** Returns the first child of this Instance that :IsA(className).  The second argument 'recursive' is an optional boolean (defaults to false) that will force the call to traverse down thru all of this Instance's descendants until it finds an object with a name that matches the 'className' argument.  The function will return nil if no Instance is found. */
	FindFirstChildWhichIsA(className: string, recursive?: boolean): Instance | undefined;
	/** Returns a string that shows the path from the root node (DataModel) to this Instance.  This string does not include the root node (DataModel). */
	GetFullName(): string;
	GetPropertyChangedSignal(property: string): RBXScriptSignal;
	IsAncestorOf(descendant: Instance): boolean;
	IsDescendantOf(ancestor: Instance): boolean;
	/** Fired when any of this object's ancestors change.  First argument 'child' is the object whose parent changed.  Second argument 'parent' is the first argument's new parent. */
	readonly AncestryChanged: RBXScriptSignal<(child: Instance, parent: Instance) => void>;
	/** Fired after a property changes value.  The property argument is the name of the property */
	readonly Changed: RBXScriptSignal<(property: string) => void>;
	readonly ChildAdded: RBXScriptSignal<(child: Instance) => void>;
	readonly ChildRemoved: RBXScriptSignal<(child: Instance) => void>;
	/** Fired after an Instance is parented to this object, or any of this object's descendants.  The 'descendant' argument is the Instance that is being added. */
	readonly DescendantAdded: RBXScriptSignal<(descendant: Instance) => void>;
	/** Fired after an Instance is unparented from this object, or any of this object's descendants.  The 'descendant' argument is the Instance that is being added. */
	readonly DescendantRemoving: RBXScriptSignal<(descendant: Instance) => void>;
}
type Instance = Rbx_Instance & Base<Rbx_Instance> & Indexable<Rbx_Instance>;

// ABTestService
interface Rbx_ABTestService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__0: never;
}
type ABTestService = Rbx_ABTestService & Base<Rbx_ABTestService> & Indexable<Rbx_ABTestService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ABTestService"): ABTestService;
}

// Accoutrement
interface Rbx_Accoutrement extends Rbx_Instance {
	AttachmentForward: Vector3;
	AttachmentPoint: CFrame;
	AttachmentPos: Vector3;
	AttachmentRight: Vector3;
	AttachmentUp: Vector3;
}
type Accoutrement = Rbx_Accoutrement & Base<Rbx_Accoutrement> & Indexable<Rbx_Accoutrement>;

// Accessory
interface Rbx_Accessory extends Rbx_Accoutrement {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__1: never;
}
type Accessory = Rbx_Accessory & Base<Rbx_Accessory> & Indexable<Rbx_Accessory>;

// Hat
interface Rbx_Hat extends Rbx_Accoutrement {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__2: never;
}
type Hat = Rbx_Hat & Base<Rbx_Hat> & Indexable<Rbx_Hat>;

// AdService
interface Rbx_AdService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__3: never;
}
type AdService = Rbx_AdService & Base<Rbx_AdService> & Indexable<Rbx_AdService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "AdService"): AdService;
}

// AdvancedDragger
interface Rbx_AdvancedDragger extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__4: never;
}
type AdvancedDragger = Rbx_AdvancedDragger & Base<Rbx_AdvancedDragger> & Indexable<Rbx_AdvancedDragger>;

// AnalyticsService
interface Rbx_AnalyticsService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__5: never;
}
type AnalyticsService = Rbx_AnalyticsService & Base<Rbx_AnalyticsService> & Indexable<Rbx_AnalyticsService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "AnalyticsService"): AnalyticsService;
}

// Animation
interface Rbx_Animation extends Rbx_Instance {
	AnimationId: string;
}
type Animation = Rbx_Animation & Base<Rbx_Animation> & Indexable<Rbx_Animation>;

// AnimationController
interface Rbx_AnimationController extends Rbx_Instance {
}
type AnimationController = Rbx_AnimationController & Base<Rbx_AnimationController> & Indexable<Rbx_AnimationController>;

// AnimationTrack
interface Rbx_AnimationTrack extends Rbx_Instance {
	readonly Animation: Animation;
	readonly IsPlaying: boolean;
	readonly Length: number;
	Looped: boolean;
	Priority: Enum.AnimationPriority;
	readonly Speed: number;
	TimePosition: number;
	readonly WeightCurrent: number;
	readonly WeightTarget: number;
	AdjustSpeed(speed?: number): void;
	AdjustWeight(weight?: number, fadeTime?: number): void;
	GetMarkerReachedSignal(name: string): RBXScriptSignal;
	GetTimeOfKeyframe(keyframeName: string): number;
	Play(fadeTime?: number, weight?: number, speed?: number): void;
	Stop(fadeTime?: number): void;
	readonly DidLoop: RBXScriptSignal<() => void>;
	readonly KeyframeReached: RBXScriptSignal<(keyframeName: string) => void>;
	readonly Stopped: RBXScriptSignal<() => void>;
}
type AnimationTrack = Rbx_AnimationTrack & Base<Rbx_AnimationTrack> & Indexable<Rbx_AnimationTrack>;

// Animator
interface Rbx_Animator extends Rbx_Instance {
}
type Animator = Rbx_Animator & Base<Rbx_Animator> & Indexable<Rbx_Animator>;

// AssetService
interface Rbx_AssetService extends Rbx_Instance {
	CreatePlaceAsync(placeName: string, templatePlaceID: number, description?: string): number;
	GetBundleDetailsAsync(bundleId: number): object;
	SavePlaceAsync(): void;
}
type AssetService = Rbx_AssetService & Base<Rbx_AssetService> & Indexable<Rbx_AssetService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "AssetService"): AssetService;
}

// Attachment
interface Rbx_Attachment extends Rbx_Instance {
	/** Primary axis. Corresponds to the LookVector, or the first column in the part-local Attachment CFrame rotation matrix */
	Axis: Vector3;
	CFrame: CFrame;
	/** Euler angles applied in YXZ order */
	Orientation: Vector3;
	Position: Vector3;
	/** Secondary axis. Corresponds to the UpVector, or the second column in the part-local Attachment CFrame rotation matrix */
	SecondaryAxis: Vector3;
	Visible: boolean;
	/** Primary axis in world space. Corresponds to the LookVector, or the first column in the world space Attachment CFrame rotation matrix. */
	WorldAxis: Vector3;
	WorldCFrame: CFrame;
	/** Euler angles applied in YXZ order */
	WorldOrientation: Vector3;
	WorldPosition: Vector3;
	WorldSecondaryAxis: Vector3;
}
type Attachment = Rbx_Attachment & Base<Rbx_Attachment> & Indexable<Rbx_Attachment>;

// BadgeService
interface Rbx_BadgeService extends Rbx_Instance {
	AwardBadge(userId: number, badgeId: number): boolean;
	GetBadgeInfoAsync(badgeId: number): object;
	UserHasBadgeAsync(userId: number, badgeId: number): boolean;
}
type BadgeService = Rbx_BadgeService & Base<Rbx_BadgeService> & Indexable<Rbx_BadgeService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "BadgeService"): BadgeService;
}

// BasePlayerGui
interface Rbx_BasePlayerGui extends Rbx_Instance {
	GetGuiObjectsAtPosition(x: number, y: number): Array<Instance>;
}
type BasePlayerGui = Rbx_BasePlayerGui & Base<Rbx_BasePlayerGui> & Indexable<Rbx_BasePlayerGui>;

// CoreGui
interface Rbx_CoreGui extends Rbx_BasePlayerGui {
	readonly Version: number;
}
type CoreGui = Rbx_CoreGui & Base<Rbx_CoreGui> & Indexable<Rbx_CoreGui>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "CoreGui"): CoreGui;
}

// PlayerGui
interface Rbx_PlayerGui extends Rbx_BasePlayerGui {
	readonly CurrentScreenOrientation: Enum.ScreenOrientation;
	ScreenOrientation: Enum.ScreenOrientation;
	/** Overrides the default selection adornment (used for gamepads). For best results, this should point to a GuiObject. */
	SelectionImageObject: GuiObject;
	GetTopbarTransparency(): number;
	SetTopbarTransparency(transparency: number): void;
	readonly TopbarTransparencyChangedSignal: RBXScriptSignal<(transparency: number) => void>;
}
type PlayerGui = Rbx_PlayerGui & Base<Rbx_PlayerGui> & Indexable<Rbx_PlayerGui>;

// StarterGui
interface Rbx_StarterGui extends Rbx_BasePlayerGui {
	ScreenOrientation: Enum.ScreenOrientation;
	ShowDevelopmentGui: boolean;
	/** Returns a boolean describing whether a CoreGuiType is currently being rendered. */
	GetCoreGuiEnabled(coreGuiType: Enum.CoreGuiType): boolean;
	/** Will stop/begin certain core gui elements being rendered. See CoreGuiType for core guis that can be modified. */
	SetCoreGuiEnabled(coreGuiType: Enum.CoreGuiType, enabled: boolean): void;
}
type StarterGui = Rbx_StarterGui & Base<Rbx_StarterGui> & Indexable<Rbx_StarterGui>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "StarterGui"): StarterGui;
}

// Beam
interface Rbx_Beam extends Rbx_Instance {
	Attachment0: Attachment;
	Attachment1: Attachment;
	Color: ColorSequence;
	CurveSize0: number;
	CurveSize1: number;
	Enabled: boolean;
	FaceCamera: boolean;
	LightEmission: number;
	LightInfluence: number;
	Segments: number;
	Texture: string;
	TextureLength: number;
	TextureMode: Enum.TextureMode;
	TextureSpeed: number;
	Transparency: NumberSequence;
	Width0: number;
	Width1: number;
	ZOffset: number;
	SetTextureOffset(offset?: number): void;
}
type Beam = Rbx_Beam & Base<Rbx_Beam> & Indexable<Rbx_Beam>;

// BindableEvent
interface Rbx_BindableEvent extends Rbx_Instance {
}
type BindableEvent = Rbx_BindableEvent & Base<Rbx_BindableEvent> & Indexable<Rbx_BindableEvent>;

// BindableFunction
interface Rbx_BindableFunction extends Rbx_Instance {
}
type BindableFunction = Rbx_BindableFunction & Base<Rbx_BindableFunction> & Indexable<Rbx_BindableFunction>;

// BodyMover
interface Rbx_BodyMover extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__6: never;
}
type BodyMover = Rbx_BodyMover & Base<Rbx_BodyMover> & Indexable<Rbx_BodyMover>;

// BodyAngularVelocity
interface Rbx_BodyAngularVelocity extends Rbx_BodyMover {
	AngularVelocity: Vector3;
	MaxTorque: Vector3;
	P: number;
}
type BodyAngularVelocity = Rbx_BodyAngularVelocity & Base<Rbx_BodyAngularVelocity> & Indexable<Rbx_BodyAngularVelocity>;

// BodyForce
interface Rbx_BodyForce extends Rbx_BodyMover {
	Force: Vector3;
}
type BodyForce = Rbx_BodyForce & Base<Rbx_BodyForce> & Indexable<Rbx_BodyForce>;

// BodyGyro
interface Rbx_BodyGyro extends Rbx_BodyMover {
	/** The cframe that this force is trying to orient its parent Part to.  Note: this force only uses the rotation of the cframe, not the position. */
	CFrame: CFrame;
	/** The dampening factor applied to this force */
	D: number;
	/** The maximum torque that will be exerted on the Part */
	MaxTorque: Vector3;
	/** The power continually applied to this force */
	P: number;
}
type BodyGyro = Rbx_BodyGyro & Base<Rbx_BodyGyro> & Indexable<Rbx_BodyGyro>;

// BodyPosition
interface Rbx_BodyPosition extends Rbx_BodyMover {
	/** The dampening factor applied to this force */
	D: number;
	/** The maximum force that will be exerted on the Part */
	MaxForce: Vector3;
	/** The power factor continually applied to this force */
	P: number;
	/** The Vector3 that this force is trying to position its parent Part to. */
	Position: Vector3;
	GetLastForce(): Vector3;
	readonly ReachedTarget: RBXScriptSignal<() => void>;
}
type BodyPosition = Rbx_BodyPosition & Base<Rbx_BodyPosition> & Indexable<Rbx_BodyPosition>;

// BodyThrust
interface Rbx_BodyThrust extends Rbx_BodyMover {
	/** The power continually applied to this force */
	Force: Vector3;
	/** The Vector3 location of where to apply the force to.  */
	Location: Vector3;
}
type BodyThrust = Rbx_BodyThrust & Base<Rbx_BodyThrust> & Indexable<Rbx_BodyThrust>;

// BodyVelocity
interface Rbx_BodyVelocity extends Rbx_BodyMover {
	/** The maximum force that will be exerted on the Part in each axis */
	MaxForce: Vector3;
	/** The amount of power we add to the system.  The higher the power, the quicker the force will achieve its goal. */
	P: number;
	/** The velocity this system tries to achieve.  How quickly the system reaches this velocity (if ever) is defined by P. */
	Velocity: Vector3;
	GetLastForce(): Vector3;
	lastForce(): Vector3;
}
type BodyVelocity = Rbx_BodyVelocity & Base<Rbx_BodyVelocity> & Indexable<Rbx_BodyVelocity>;

// RocketPropulsion
interface Rbx_RocketPropulsion extends Rbx_BodyMover {
	CartoonFactor: number;
	MaxSpeed: number;
	MaxThrust: number;
	MaxTorque: Vector3;
	Target: BasePart;
	TargetOffset: Vector3;
	TargetRadius: number;
	ThrustD: number;
	ThrustP: number;
	TurnD: number;
	TurnP: number;
	Abort(): void;
	Fire(): void;
	readonly ReachedTarget: RBXScriptSignal<() => void>;
}
type RocketPropulsion = Rbx_RocketPropulsion & Base<Rbx_RocketPropulsion> & Indexable<Rbx_RocketPropulsion>;

// BrowserService
interface Rbx_BrowserService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__7: never;
}
type BrowserService = Rbx_BrowserService & Base<Rbx_BrowserService> & Indexable<Rbx_BrowserService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "BrowserService"): BrowserService;
}

// CacheableContentProvider
interface Rbx_CacheableContentProvider extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__8: never;
}
type CacheableContentProvider = Rbx_CacheableContentProvider & Base<Rbx_CacheableContentProvider> & Indexable<Rbx_CacheableContentProvider>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "CacheableContentProvider"): CacheableContentProvider;
}

// MeshContentProvider
interface Rbx_MeshContentProvider extends Rbx_CacheableContentProvider {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__9: never;
}
type MeshContentProvider = Rbx_MeshContentProvider & Base<Rbx_MeshContentProvider> & Indexable<Rbx_MeshContentProvider>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "MeshContentProvider"): MeshContentProvider;
}

// SolidModelContentProvider
interface Rbx_SolidModelContentProvider extends Rbx_CacheableContentProvider {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__10: never;
}
type SolidModelContentProvider = Rbx_SolidModelContentProvider & Base<Rbx_SolidModelContentProvider> & Indexable<Rbx_SolidModelContentProvider>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "SolidModelContentProvider"): SolidModelContentProvider;
}

// Camera
interface Rbx_Camera extends Rbx_Instance {
	/** The current position and rotation of the Camera.  For most CameraTypes, the rotation is set such that the CoordinateFrame lookVector is pointing at the Focus. */
	CFrame: CFrame;
	/** Defines how the camera will behave. [More info](http://wiki.roblox.com/index.php/CameraType) */
	CameraType: Enum.CameraType;
	/** The current angle, or width, of what the camera can see.  Current acceptable values are from 20 degrees to 80. */
	FieldOfView: number;
	/** The current CoordinateFrame that the camera is looking at.  Note: it is not always guaranteed that the camera is always looking here. */
	Focus: CFrame;
	HeadLocked: boolean;
	HeadScale: number;
	/** The negative z-offset of the view frustum's near clipping plane. */
	readonly NearPlaneZ: number;
	/** Holds the x,y screen resolution of the viewport the camera is presenting (note: this can differ from the AbsoluteSize property of a full screen gui). */
	readonly ViewportSize: Vector2;
	GetLargestCutoffDistance(ignoreList: Array<Instance>): number;
	GetPanSpeed(): number;
	GetRenderCFrame(): CFrame;
	/** Returns the camera's current roll. Roll is defined in radians, and is stored as the delta from the camera's y axis default normal vector. */
	GetRoll(): number;
	GetTiltSpeed(): number;
	Interpolate(endPos: CFrame, endFocus: CFrame, duration: number): void;
	PanUnits(units: number): void;
	/** Takes a 2D screen position and produces a Ray object to be used for 3D raycasting. Input is x,y screen coordinates, and a (optional, defaults to 0) z position which sets how far in the camera look vector to start the ray origin. */
	ScreenPointToRay(x: number, y: number, depth?: number): Ray;
	SetCameraPanMode(mode?: Enum.CameraPanMode): void;
	/** Sets the camera's current roll. Roll is defined in radians, and is stored as the delta from the camera's y axis default normal vector. */
	SetRoll(rollAngle: number): void;
	TiltUnits(units: number): boolean;
	/** Same as ScreenPointToRay, except no GUI offsets are taken into account. Useful for things like casting a ray from the middle of the Camera.ViewportSize */
	ViewportPointToRay(x: number, y: number, depth?: number): Ray;
	readonly InterpolationFinished: RBXScriptSignal<() => void>;
}
type Camera = Rbx_Camera & Base<Rbx_Camera> & Indexable<Rbx_Camera>;

// ChangeHistoryService
interface Rbx_ChangeHistoryService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__11: never;
}
type ChangeHistoryService = Rbx_ChangeHistoryService & Base<Rbx_ChangeHistoryService> & Indexable<Rbx_ChangeHistoryService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ChangeHistoryService"): ChangeHistoryService;
}

// CharacterAppearance
interface Rbx_CharacterAppearance extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__12: never;
}
type CharacterAppearance = Rbx_CharacterAppearance & Base<Rbx_CharacterAppearance> & Indexable<Rbx_CharacterAppearance>;

// BodyColors
interface Rbx_BodyColors extends Rbx_CharacterAppearance {
	HeadColor: BrickColor;
	HeadColor3: Color3;
	LeftArmColor: BrickColor;
	LeftArmColor3: Color3;
	LeftLegColor: BrickColor;
	LeftLegColor3: Color3;
	RightArmColor: BrickColor;
	RightArmColor3: Color3;
	RightLegColor: BrickColor;
	RightLegColor3: Color3;
	TorsoColor: BrickColor;
	TorsoColor3: Color3;
}
type BodyColors = Rbx_BodyColors & Base<Rbx_BodyColors> & Indexable<Rbx_BodyColors>;

// CharacterMesh
interface Rbx_CharacterMesh extends Rbx_CharacterAppearance {
	BaseTextureId: number;
	BodyPart: Enum.BodyPart;
	MeshId: number;
	OverlayTextureId: number;
}
type CharacterMesh = Rbx_CharacterMesh & Base<Rbx_CharacterMesh> & Indexable<Rbx_CharacterMesh>;

// Clothing
interface Rbx_Clothing extends Rbx_CharacterAppearance {
	Color3: Color3;
}
type Clothing = Rbx_Clothing & Base<Rbx_Clothing> & Indexable<Rbx_Clothing>;

// Pants
interface Rbx_Pants extends Rbx_Clothing {
	PantsTemplate: string;
}
type Pants = Rbx_Pants & Base<Rbx_Pants> & Indexable<Rbx_Pants>;

// Shirt
interface Rbx_Shirt extends Rbx_Clothing {
	ShirtTemplate: string;
}
type Shirt = Rbx_Shirt & Base<Rbx_Shirt> & Indexable<Rbx_Shirt>;

// ShirtGraphic
interface Rbx_ShirtGraphic extends Rbx_CharacterAppearance {
	Color3: Color3;
	Graphic: string;
}
type ShirtGraphic = Rbx_ShirtGraphic & Base<Rbx_ShirtGraphic> & Indexable<Rbx_ShirtGraphic>;

// Skin
interface Rbx_Skin extends Rbx_CharacterAppearance {
	SkinColor: BrickColor;
}
type Skin = Rbx_Skin & Base<Rbx_Skin> & Indexable<Rbx_Skin>;

// Chat
interface Rbx_Chat extends Rbx_Instance {
	BubbleChatEnabled: boolean;
	readonly LoadDefaultChat: boolean;
	InvokeChatCallback(callbackType: Enum.ChatCallbackType, callbackArguments: Array<any>): unknown;
	RegisterChatCallback(callbackType: Enum.ChatCallbackType, callbackFunction: Function): void;
	CanUserChatAsync(userId: number): boolean;
	CanUsersChatAsync(userIdFrom: number, userIdTo: number): boolean;
}
type Chat = Rbx_Chat & Base<Rbx_Chat> & Indexable<Rbx_Chat>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "Chat"): Chat;
}

// ClickDetector
interface Rbx_ClickDetector extends Rbx_Instance {
	CursorIcon: string;
	/** The maximum distance a Player's character can be from the ClickDetector's parent Part that will allow the Player's mouse to fire events on this object. */
	MaxActivationDistance: number;
}
type ClickDetector = Rbx_ClickDetector & Base<Rbx_ClickDetector> & Indexable<Rbx_ClickDetector>;

// ClusterPacketCache
interface Rbx_ClusterPacketCache extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__13: never;
}
type ClusterPacketCache = Rbx_ClusterPacketCache & Base<Rbx_ClusterPacketCache> & Indexable<Rbx_ClusterPacketCache>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ClusterPacketCache"): ClusterPacketCache;
}

// CollectionService
interface Rbx_CollectionService extends Rbx_Instance {
	/** Adds a tag to an instance. */
	AddTag(instance: Instance, tag: string): void;
	/** Returns whether the given instance has the given tag. */
	HasTag(instance: Instance, tag: string): boolean;
	/** Removes a tag to an instance. */
	RemoveTag(instance: Instance, tag: string): void;
}
type CollectionService = Rbx_CollectionService & Base<Rbx_CollectionService> & Indexable<Rbx_CollectionService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "CollectionService"): CollectionService;
}

// Configuration
interface Rbx_Configuration extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__14: never;
}
type Configuration = Rbx_Configuration & Base<Rbx_Configuration> & Indexable<Rbx_Configuration>;

// Constraint
interface Rbx_Constraint extends Rbx_Instance {
	/** Read-only boolean, true if the Constraint is active in world. */
	readonly Active: boolean;
	Attachment0: Attachment;
	Attachment1: Attachment;
	/** The color of the in-game visual. */
	Color: BrickColor;
	/** Toggles whether or not this constraint is enabled. Disabled constraints will not render in game. */
	Enabled: boolean;
	/** Toggles the in-game visual associated with this constraint. */
	Visible: boolean;
}
type Constraint = Rbx_Constraint & Base<Rbx_Constraint> & Indexable<Rbx_Constraint>;

// AlignOrientation
interface Rbx_AlignOrientation extends Rbx_Constraint {
	AlignType: Enum.AlignType;
	MaxAngularVelocity: number;
	MaxTorque: number;
	PrimaryAxisOnly: boolean;
	ReactionTorqueEnabled: boolean;
	Responsiveness: number;
	RigidityEnabled: boolean;
}
type AlignOrientation = Rbx_AlignOrientation & Base<Rbx_AlignOrientation> & Indexable<Rbx_AlignOrientation>;

// AlignPosition
interface Rbx_AlignPosition extends Rbx_Constraint {
	ApplyAtCenterOfMass: boolean;
	MaxForce: number;
	MaxVelocity: number;
	ReactionForceEnabled: boolean;
	Responsiveness: number;
	RigidityEnabled: boolean;
}
type AlignPosition = Rbx_AlignPosition & Base<Rbx_AlignPosition> & Indexable<Rbx_AlignPosition>;

// BallSocketConstraint
interface Rbx_BallSocketConstraint extends Rbx_Constraint {
	/** Enables the angular limit between the axis of Attachment0 and the axis of Attachment1. */
	LimitsEnabled: boolean;
	/** Radius of the in-game visual. Value in [0, inf). */
	Radius: number;
	/** Restitution of the limit, or how elastic it is. Value in [0, 1]. */
	Restitution: number;
	/** Enables the angular limits around the main axis of Attachment1. */
	TwistLimitsEnabled: boolean;
	/** Lower angular limit around the axis of Attachment1. Value in [-180, 180]. */
	TwistLowerAngle: number;
	/** Upper angular limit around the axis of Attachment1. Value in [-180, 180]. */
	TwistUpperAngle: number;
	/** Maximum angle between the two main axes. Value in [0, 180]. */
	UpperAngle: number;
}
type BallSocketConstraint = Rbx_BallSocketConstraint & Base<Rbx_BallSocketConstraint> & Indexable<Rbx_BallSocketConstraint>;

// HingeConstraint
interface Rbx_HingeConstraint extends Rbx_Constraint {
	/** Type of the rotational actuator: None, Motor, or Servo.  */
	ActuatorType: Enum.ActuatorType;
	/** Target angular speed. This value is unsigned as the servo will always move toward its target. Value in [0, inf). */
	AngularSpeed: number;
	/** The target angular velocity of the motor in radians per second around the rotation axis. Value in [0, inf). */
	AngularVelocity: number;
	/** Signed angle between the SecondaryAxis of Attchement0 and the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	readonly CurrentAngle: number;
	/** Enables the angular limits on rotations around the main axis of Attachment0. */
	LimitsEnabled: boolean;
	/** Lower limit for the angle from the SecondaryAxis of Attachment0 to the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	LowerAngle: number;
	/** The maximum angular acceleration of the motor in radians per second square. Value in [0, inf). */
	MotorMaxAcceleration: number;
	/** The maximum torque the motor can apply to achieve the target angular velocity. Value in [0, inf). */
	MotorMaxTorque: number;
	/** Radius of the in-game visual. Value in [0, inf). */
	Radius: number;
	Restitution: number;
	/** Maximum torque the servo motor can apply. Value in [0, inf). */
	ServoMaxTorque: number;
	/** Target angle for the SecondaryAxis of Attachment1 from the SecondaryAxis of Attachment0 around the rotation axis. Value in [-180, 180]. */
	TargetAngle: number;
	/** Upper limit for the angle from the SecondaryAxis of Attachment0 to the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	UpperAngle: number;
}
type HingeConstraint = Rbx_HingeConstraint & Base<Rbx_HingeConstraint> & Indexable<Rbx_HingeConstraint>;

// LineForce
interface Rbx_LineForce extends Rbx_Constraint {
	ApplyAtCenterOfMass: boolean;
	InverseSquareLaw: boolean;
	Magnitude: number;
	MaxForce: number;
	ReactionForceEnabled: boolean;
}
type LineForce = Rbx_LineForce & Base<Rbx_LineForce> & Indexable<Rbx_LineForce>;

// RodConstraint
interface Rbx_RodConstraint extends Rbx_Constraint {
	/** Current distance between the two attachments. Value in [0, inf). */
	readonly CurrentDistance: number;
	/** The length of the rod or the distance to be maintained between the two attachments. Value in [0, inf). */
	Length: number;
	/** The thickness of the in-game visual (diameter). Value in [0, inf). */
	Thickness: number;
}
type RodConstraint = Rbx_RodConstraint & Base<Rbx_RodConstraint> & Indexable<Rbx_RodConstraint>;

// RopeConstraint
interface Rbx_RopeConstraint extends Rbx_Constraint {
	/** Current distance between the two attachments. Value in [0, inf). */
	readonly CurrentDistance: number;
	/** The length of the rope or the maximum distance between the two attachments. Value in [0, inf). */
	Length: number;
	/** Restitution of the rope, or how elastic it is. Value in [0, 1]. */
	Restitution: number;
	/** The thickness of the in-game visual (diameter). Value in [0, inf). */
	Thickness: number;
}
type RopeConstraint = Rbx_RopeConstraint & Base<Rbx_RopeConstraint> & Indexable<Rbx_RopeConstraint>;

// SlidingBallConstraint
interface Rbx_SlidingBallConstraint extends Rbx_Constraint {
	/** Type of linear actuator (along the axis of the slider): None, Motor, or Servo. */
	ActuatorType: Enum.ActuatorType;
	/** Current position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf). */
	readonly CurrentPosition: number;
	/** Enables the limits on the linear motion along the axis of the slider. */
	LimitsEnabled: boolean;
	/** Lower limit for the position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf). */
	LowerLimit: number;
	/** The maximum acceleration of the motor in studs per second squared. Value in [0, inf). */
	MotorMaxAcceleration: number;
	/** The maximum force the motor can apply to achieve the target velocity. Units are mass * studs / seconds^2. Value in [0, inf). */
	MotorMaxForce: number;
	/** Restitution of the two limits, or how elastic they are. Value in [0, 1]. */
	Restitution: number;
	/** Maximum force the servo motor can apply. Units are mass * studs / seconds^2. Value in [0, inf). */
	ServoMaxForce: number;
	/** Size of the in-game visual associated with this constraint. Value in [0, inf). */
	Size: number;
	/** Target speed in studs per second. This value is unsigned as the servo will always move toward its target. Value in [0, inf). */
	Speed: number;
	/** Target position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf). */
	TargetPosition: number;
	/** Upper limit for the position of Attachment1 with respect to Attachment0 along the slider axis. Value in (-inf, inf). */
	UpperLimit: number;
	/** The target linear velocity of the motor in studs per second along the slider axis. Value in (-inf, inf). */
	Velocity: number;
}
type SlidingBallConstraint = Rbx_SlidingBallConstraint & Base<Rbx_SlidingBallConstraint> & Indexable<Rbx_SlidingBallConstraint>;

// CylindricalConstraint
interface Rbx_CylindricalConstraint extends Rbx_SlidingBallConstraint {
	/** Type of angular actuator: None, Motor, or Servo.  */
	AngularActuatorType: Enum.ActuatorType;
	/** Enables the angular limits around the rotation axis. */
	AngularLimitsEnabled: boolean;
	/** Restitution of the two limits, or how elastic they are. Value in [0, 1].  */
	AngularRestitution: number;
	/** Target angular speed. This value is unsigned as the servo will always move toward its target. In radians per second. Value in [0, inf).  */
	AngularSpeed: number;
	/** The target angular velocity of the motor in radians per second around the rotation axis. Value in [0, inf). */
	AngularVelocity: number;
	/** Signed angle (in degrees) between the reference axis and the secondary axis of Attachment1 around the rotation axis. Value in [-180, 180].  */
	readonly CurrentAngle: number;
	/** Direction of the rotation axis as an angle from the x-axis in the xy-plane of Attachment0. Value in [-180, 180].  */
	InclinationAngle: number;
	/** Lower limit for the angle (in degrees) between the reference axis and the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	LowerAngle: number;
	/** The maximum angular acceleration of the motor in radians per second squared. Value in [0, inf). */
	MotorMaxAngularAcceleration: number;
	/** The maximum torque the motor can apply to achieve the target angular velocity. The units are mass * studs^2 / second^2. Value in [0, inf). */
	MotorMaxTorque: number;
	/** Enable the visibility of the rotation axis. */
	RotationAxisVisible: boolean;
	/** Maximum torque the servo motor can apply. The units are mass * studs^2 / second^2. Value in [0, inf).  */
	ServoMaxTorque: number;
	/**  Target angle (in degrees) between the reference axis and the secondary axis of Attachment1 around the rotation axis. Value in [-180, 180]. */
	TargetAngle: number;
	/** Upper limit for the angle (in degrees) between the reference axis and the SecondaryAxis of Attachment1 around the rotation axis. Value in [-180, 180].  */
	UpperAngle: number;
	/** The unit vector direction of the rotation axis in world coordinates. */
	readonly WorldRotationAxis: Vector3;
}
type CylindricalConstraint = Rbx_CylindricalConstraint & Base<Rbx_CylindricalConstraint> & Indexable<Rbx_CylindricalConstraint>;

// PrismaticConstraint
interface Rbx_PrismaticConstraint extends Rbx_SlidingBallConstraint {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__15: never;
}
type PrismaticConstraint = Rbx_PrismaticConstraint & Base<Rbx_PrismaticConstraint> & Indexable<Rbx_PrismaticConstraint>;

// SpringConstraint
interface Rbx_SpringConstraint extends Rbx_Constraint {
	/** The number of coils in the in-game visual. Value in [0, 8]. */
	Coils: number;
	/** Current distance between the two attachments. Value in [0, inf). */
	readonly CurrentLength: number;
	/** The damping parameter of the spring. The force is scaled with respect to relative velocity. The units of this property are force / velocity. Value in [0, inf). */
	Damping: number;
	/** The distance (in studs) between the two attachments at which the spring exerts no stiffness force. Value in [0, inf). */
	FreeLength: number;
	/** Enables limits on the length of the spring. */
	LimitsEnabled: boolean;
	/** The maximum force that the spring can apply. Useful to prevent instabilities. The units are mass * studs / seconds^2. Value in [0, inf). */
	MaxForce: number;
	/** Maximum spring length, or the maxium distance between the two attachments. Value in [0, inf). */
	MaxLength: number;
	/** Minimum spring length, or the minimum distance between the two attachments. Value in [0, inf). */
	MinLength: number;
	/** The radius of the in-game spring coil visual. Value in [0, inf). */
	Radius: number;
	/** The stiffness parameter of the spring. Force is scaled based on distance from the free length. The units of this property are force / distance. Value in [0, inf). */
	Stiffness: number;
	/** The thickness of the spring wire (diameter) in the in-game visual. Value in [0, inf). */
	Thickness: number;
}
type SpringConstraint = Rbx_SpringConstraint & Base<Rbx_SpringConstraint> & Indexable<Rbx_SpringConstraint>;

// Torque
interface Rbx_Torque extends Rbx_Constraint {
	RelativeTo: Enum.ActuatorRelativeTo;
	Torque: Vector3;
}
type Torque = Rbx_Torque & Base<Rbx_Torque> & Indexable<Rbx_Torque>;

// VectorForce
interface Rbx_VectorForce extends Rbx_Constraint {
	ApplyAtCenterOfMass: boolean;
	Force: Vector3;
	RelativeTo: Enum.ActuatorRelativeTo;
}
type VectorForce = Rbx_VectorForce & Base<Rbx_VectorForce> & Indexable<Rbx_VectorForce>;

// ContentProvider
interface Rbx_ContentProvider extends Rbx_Instance {
	readonly BaseUrl: string;
	readonly RequestQueueSize: number;
}
type ContentProvider = Rbx_ContentProvider & Base<Rbx_ContentProvider> & Indexable<Rbx_ContentProvider>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ContentProvider"): ContentProvider;
}

// ContextActionService
interface Rbx_ContextActionService extends Rbx_Instance {
	BindActivate(userInputTypeForActivation: Enum.UserInputType, keyCodeForActivation?: Enum.KeyCode): void;
	/** Returns a table with all bound action info. Each entry is a key with 'actionName' and value being the same table you would get from ContextActionService:GetBoundActionInfo('actionName'). */
	GetAllBoundActionInfo(): object;
	/** Returns a table with info regarding the function bound with 'actionName'. Table has the keys 'title' (current title that was set with SetTitle) 'image' (image set with SetImage) 'description' (description set with SetDescription) 'inputTypes' (tuple containing all input bound for this 'actionName') 'createTouchButton' (whether or not we created a touch button for this 'actionName').  */
	GetBoundActionInfo(actionName: string): object;
	GetCurrentLocalToolIcon(): string;
	/** If 'actionName' key contains a bound action, then 'description' is set as the description of the bound action. This description will appear for users in a listing of current actions availables. */
	SetDescription(actionName: string, description: string): void;
	/** If 'actionName' key contains a bound action, then 'image' is set as the image of the touch button. Does nothing if a touch button was not created. No guarantees are made whether image will be set when button is manipulated. */
	SetImage(actionName: string, image: string): void;
	/** If 'actionName' key contains a bound action, then 'position' is set as the position of the touch button. Does nothing if a touch button was not created. No guarantees are made whether position will be set when button is manipulated. */
	SetPosition(actionName: string, position: UDim2): void;
	/** If 'actionName' key contains a bound action, then 'title' is set as the title of the touch button. Does nothing if a touch button was not created. No guarantees are made whether title will be set when button is manipulated. */
	SetTitle(actionName: string, title: string): void;
	/** If 'actionName' key contains a bound action, removes function from being called by all input that it was bound by (if function was also bound by a different action name as well, those bound input are still active). Will also remove any touch button created (if button was manipulated manually there is no guarantee it will be cleaned up). */
	UnbindAction(actionName: string): void;
	UnbindActivate(userInputTypeForActivation: Enum.UserInputType, keyCodeForActivation?: Enum.KeyCode): void;
	/** Removes all functions bound. No actionNames will remain. All touch buttons will be removed. If button was manipulated manually there is no guarantee it will be cleaned up. */
	UnbindAllActions(): void;
}
type ContextActionService = Rbx_ContextActionService & Base<Rbx_ContextActionService> & Indexable<Rbx_ContextActionService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ContextActionService"): ContextActionService;
}

// Controller
interface Rbx_Controller extends Rbx_Instance {
	BindButton(button: Enum.Button, caption: string): void;
	GetButton(button: Enum.Button): boolean;
	UnbindButton(button: Enum.Button): void;
	readonly ButtonChanged: RBXScriptSignal<(button: Enum.Button) => void>;
}
type Controller = Rbx_Controller & Base<Rbx_Controller> & Indexable<Rbx_Controller>;

// HumanoidController
interface Rbx_HumanoidController extends Rbx_Controller {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__16: never;
}
type HumanoidController = Rbx_HumanoidController & Base<Rbx_HumanoidController> & Indexable<Rbx_HumanoidController>;

// SkateboardController
interface Rbx_SkateboardController extends Rbx_Controller {
	readonly Steer: number;
	readonly Throttle: number;
	readonly AxisChanged: RBXScriptSignal<(axis: string) => void>;
}
type SkateboardController = Rbx_SkateboardController & Base<Rbx_SkateboardController> & Indexable<Rbx_SkateboardController>;

// VehicleController
interface Rbx_VehicleController extends Rbx_Controller {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__17: never;
}
type VehicleController = Rbx_VehicleController & Base<Rbx_VehicleController> & Indexable<Rbx_VehicleController>;

// ControllerService
interface Rbx_ControllerService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__18: never;
}
type ControllerService = Rbx_ControllerService & Base<Rbx_ControllerService> & Indexable<Rbx_ControllerService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ControllerService"): ControllerService;
}

// CookiesService
interface Rbx_CookiesService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__19: never;
}
type CookiesService = Rbx_CookiesService & Base<Rbx_CookiesService> & Indexable<Rbx_CookiesService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "CookiesService"): CookiesService;
}

// CorePackages
interface Rbx_CorePackages extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__20: never;
}
type CorePackages = Rbx_CorePackages & Base<Rbx_CorePackages> & Indexable<Rbx_CorePackages>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "CorePackages"): CorePackages;
}

// CoreScriptSyncService
interface Rbx_CoreScriptSyncService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__21: never;
}
type CoreScriptSyncService = Rbx_CoreScriptSyncService & Base<Rbx_CoreScriptSyncService> & Indexable<Rbx_CoreScriptSyncService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "CoreScriptSyncService"): CoreScriptSyncService;
}

// CustomEvent
interface Rbx_CustomEvent extends Rbx_Instance {
	GetAttachedReceivers(): Array<Instance>;
	SetValue(newValue: number): void;
	readonly ReceiverConnected: RBXScriptSignal<(receiver: Instance) => void>;
	readonly ReceiverDisconnected: RBXScriptSignal<(receiver: Instance) => void>;
}
type CustomEvent = Rbx_CustomEvent & Base<Rbx_CustomEvent> & Indexable<Rbx_CustomEvent>;

// CustomEventReceiver
interface Rbx_CustomEventReceiver extends Rbx_Instance {
	Source: Instance | undefined;
	GetCurrentValue(): number;
	readonly EventConnected: RBXScriptSignal<(event: Instance) => void>;
	readonly EventDisconnected: RBXScriptSignal<(event: Instance) => void>;
	readonly SourceValueChanged: RBXScriptSignal<(newValue: number) => void>;
}
type CustomEventReceiver = Rbx_CustomEventReceiver & Base<Rbx_CustomEventReceiver> & Indexable<Rbx_CustomEventReceiver>;

// DataModelMesh
interface Rbx_DataModelMesh extends Rbx_Instance {
	Offset: Vector3;
	Scale: Vector3;
	VertexColor: Vector3;
}
type DataModelMesh = Rbx_DataModelMesh & Base<Rbx_DataModelMesh> & Indexable<Rbx_DataModelMesh>;

// BevelMesh
interface Rbx_BevelMesh extends Rbx_DataModelMesh {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__22: never;
}
type BevelMesh = Rbx_BevelMesh & Base<Rbx_BevelMesh> & Indexable<Rbx_BevelMesh>;

// BlockMesh
interface Rbx_BlockMesh extends Rbx_BevelMesh {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__23: never;
}
type BlockMesh = Rbx_BlockMesh & Base<Rbx_BlockMesh> & Indexable<Rbx_BlockMesh>;

// CylinderMesh
interface Rbx_CylinderMesh extends Rbx_BevelMesh {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__24: never;
}
type CylinderMesh = Rbx_CylinderMesh & Base<Rbx_CylinderMesh> & Indexable<Rbx_CylinderMesh>;

// FileMesh
interface Rbx_FileMesh extends Rbx_DataModelMesh {
	MeshId: string;
	TextureId: string;
}
type FileMesh = Rbx_FileMesh & Base<Rbx_FileMesh> & Indexable<Rbx_FileMesh>;

// SpecialMesh
interface Rbx_SpecialMesh extends Rbx_FileMesh {
	MeshType: Enum.MeshType;
}
type SpecialMesh = Rbx_SpecialMesh & Base<Rbx_SpecialMesh> & Indexable<Rbx_SpecialMesh>;

// DataStoreService
interface Rbx_DataStoreService extends Rbx_Instance {
	GetRequestBudgetForRequestType(requestType: Enum.DataStoreRequestType): number;
}
type DataStoreService = Rbx_DataStoreService & Base<Rbx_DataStoreService> & Indexable<Rbx_DataStoreService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "DataStoreService"): DataStoreService;
}

// Debris
interface Rbx_Debris extends Rbx_Instance {
	/** Adds an Instance into the debris service that will later be destroyed.  Second argument 'lifetime' is optional and specifies how long (in seconds) to wait before destroying the item. If no time is specified then the item added will automatically be destroyed in 10 seconds. */
	AddItem(item: Instance, lifetime?: number): void;
}
type Debris = Rbx_Debris & Base<Rbx_Debris> & Indexable<Rbx_Debris>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "Debris"): Debris;
}

// DebugSettings
interface Rbx_DebugSettings extends Rbx_Instance {
	readonly DataModel: number;
	ErrorReporting: Enum.ErrorReporting;
	readonly GfxCard: string;
	readonly InstanceCount: number;
	IsFmodProfilingEnabled: boolean;
	IsScriptStackTracingEnabled: boolean;
	readonly JobCount: number;
	LuaRamLimit: number;
	readonly OsIs64Bit: boolean;
	readonly OsPlatform: string;
	readonly OsPlatformId: number;
	readonly OsVer: string;
	readonly PlayerCount: number;
	ReportSoundWarnings: boolean;
	readonly RobloxProductName: string;
	readonly RobloxVersion: string;
	readonly SIMD: string;
	readonly SystemProductName: string;
	TickCountPreciseOverride: Enum.TickCountSampleMethod;
	readonly VideoMemory: number;
}
type DebugSettings = Rbx_DebugSettings & Base<Rbx_DebugSettings> & Indexable<Rbx_DebugSettings>;

// DebuggerBreakpoint
interface Rbx_DebuggerBreakpoint extends Rbx_Instance {
	Condition: string;
	IsEnabled: boolean;
	readonly Line: number;
}
type DebuggerBreakpoint = Rbx_DebuggerBreakpoint & Base<Rbx_DebuggerBreakpoint> & Indexable<Rbx_DebuggerBreakpoint>;

// DebuggerManager
interface Rbx_DebuggerManager extends Rbx_Instance {
	readonly DebuggingEnabled: boolean;
	AddDebugger(script: Instance): Instance | undefined;
	GetDebuggers(): Array<Instance>;
	Resume(): void;
	StepIn(): void;
	StepOut(): void;
	StepOver(): void;
	readonly DebuggerAdded: RBXScriptSignal<(debug: Instance) => void>;
	readonly DebuggerRemoved: RBXScriptSignal<(debug: Instance) => void>;
}
type DebuggerManager = Rbx_DebuggerManager & Base<Rbx_DebuggerManager> & Indexable<Rbx_DebuggerManager>;

// DebuggerWatch
interface Rbx_DebuggerWatch extends Rbx_Instance {
	Expression: string;
	CheckSyntax(): void;
}
type DebuggerWatch = Rbx_DebuggerWatch & Base<Rbx_DebuggerWatch> & Indexable<Rbx_DebuggerWatch>;

// Dialog
interface Rbx_Dialog extends Rbx_Instance {
	/** Indicates how the dialog may be used by players. Use Enum.DialogBehaviorType.SinglePlayer if only one player should interact with the dialog at a time, otherwise use Enum.DialogBehaviorType.MultiplePlayers. */
	BehaviorType: Enum.DialogBehaviorType;
	/** The maximum distance that the player's character can be from the dialog's parent in order to use the dialog. */
	ConversationDistance: number;
	/** Indicates whether or not an extra choice is available for the player to exit the dialog tree at this node. */
	GoodbyeChoiceActive: boolean;
	/** The prompt text for an extra choice that allows the player to exit the dialog tree at this node. */
	GoodbyeDialog: string;
	/** Indicates whether or not the dialog is currently being used by one or more players. */
	InUse: boolean;
	/** The chat message that is displayed to the player when they first activate the dialog. */
	InitialPrompt: string;
	/** Describes the purpose of the dialog, which is used to display a relevant icon on the dialog's activation button. */
	Purpose: Enum.DialogPurpose;
	/** Describes the tone of the dialog, which is used to display a relevant color in the dialog interface. */
	Tone: Enum.DialogTone;
	TriggerDistance: number;
	TriggerOffset: Vector3;
}
type Dialog = Rbx_Dialog & Base<Rbx_Dialog> & Indexable<Rbx_Dialog>;

// DialogChoice
interface Rbx_DialogChoice extends Rbx_Instance {
	GoodbyeChoiceActive: boolean;
	GoodbyeDialog: string;
	ResponseDialog: string;
	UserDialog: string;
}
type DialogChoice = Rbx_DialogChoice & Base<Rbx_DialogChoice> & Indexable<Rbx_DialogChoice>;

// Dragger
interface Rbx_Dragger extends Rbx_Instance {
	AxisRotate(axis?: Enum.Axis): void;
	MouseDown(mousePart: Instance, pointOnMousePart: Vector3, parts: Array<Instance>): void;
	MouseMove(mouseRay: Ray): void;
	MouseUp(): void;
}
type Dragger = Rbx_Dragger & Base<Rbx_Dragger> & Indexable<Rbx_Dragger>;

// Explosion
interface Rbx_Explosion extends Rbx_Instance {
	/** How much force this Explosion exerts on objects within it's BlastRadius. Setting this to 0 creates a purely graphical effect. A larger number will cause Parts to fly away at higher velocities. */
	BlastPressure: number;
	/** How big the Explosion is. This is a circle starting from the center of the Explosion's Position, the larger this property the larger the circle of destruction. */
	BlastRadius: number;
	DestroyJointRadiusPercent: number;
	/** Defines the behavior of the Explosion. [More info](http://wiki.roblox.com/index.php/ExplosionType) */
	ExplosionType: Enum.ExplosionType;
	/** Where the Explosion occurs in absolute world coordinates. */
	Position: Vector3;
	Visible: boolean;
	readonly Hit: RBXScriptSignal<(part: Instance, distance: number) => void>;
}
type Explosion = Rbx_Explosion & Base<Rbx_Explosion> & Indexable<Rbx_Explosion>;

// FaceInstance
interface Rbx_FaceInstance extends Rbx_Instance {
	Face: Enum.NormalId;
}
type FaceInstance = Rbx_FaceInstance & Base<Rbx_FaceInstance> & Indexable<Rbx_FaceInstance>;

// Decal
interface Rbx_Decal extends Rbx_FaceInstance {
	Color3: Color3;
	LocalTransparencyModifier: number;
	Texture: string;
	/** How visible the decal is.  1 is completely invisible, while 0 is completely opaque */
	Transparency: number;
}
type Decal = Rbx_Decal & Base<Rbx_Decal> & Indexable<Rbx_Decal>;

// Texture
interface Rbx_Texture extends Rbx_Decal {
	StudsPerTileU: number;
	StudsPerTileV: number;
}
type Texture = Rbx_Texture & Base<Rbx_Texture> & Indexable<Rbx_Texture>;

// Feature
interface Rbx_Feature extends Rbx_Instance {
	FaceId: Enum.NormalId;
	InOut: Enum.InOut;
	LeftRight: Enum.LeftRight;
	TopBottom: Enum.TopBottom;
}
type Feature = Rbx_Feature & Base<Rbx_Feature> & Indexable<Rbx_Feature>;

// Hole
interface Rbx_Hole extends Rbx_Feature {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__25: never;
}
type Hole = Rbx_Hole & Base<Rbx_Hole> & Indexable<Rbx_Hole>;

// MotorFeature
interface Rbx_MotorFeature extends Rbx_Feature {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__26: never;
}
type MotorFeature = Rbx_MotorFeature & Base<Rbx_MotorFeature> & Indexable<Rbx_MotorFeature>;

// File
interface Rbx_File extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__27: never;
}
type File = Rbx_File & Base<Rbx_File> & Indexable<Rbx_File>;

// Fire
interface Rbx_Fire extends Rbx_Instance {
	/** The color of the base of the fire.  See SecondaryColor for more. */
	Color: Color3;
	Enabled: boolean;
	/** How hot the fire appears to be. The flame moves quicker the higher this value is set. */
	Heat: number;
	/** The color the fire interpolates to from Color. The longer a particle exists in the fire, the close to this color it becomes. */
	SecondaryColor: Color3;
	/** How large the fire appears to be. */
	Size: number;
}
type Fire = Rbx_Fire & Base<Rbx_Fire> & Indexable<Rbx_Fire>;

// FlagStandService
interface Rbx_FlagStandService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__28: never;
}
type FlagStandService = Rbx_FlagStandService & Base<Rbx_FlagStandService> & Indexable<Rbx_FlagStandService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "FlagStandService"): FlagStandService;
}

// FlyweightService
interface Rbx_FlyweightService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__29: never;
}
type FlyweightService = Rbx_FlyweightService & Base<Rbx_FlyweightService> & Indexable<Rbx_FlyweightService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "FlyweightService"): FlyweightService;
}

// CSGDictionaryService
interface Rbx_CSGDictionaryService extends Rbx_FlyweightService {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__30: never;
}
type CSGDictionaryService = Rbx_CSGDictionaryService & Base<Rbx_CSGDictionaryService> & Indexable<Rbx_CSGDictionaryService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "CSGDictionaryService"): CSGDictionaryService;
}

// NonReplicatedCSGDictionaryService
interface Rbx_NonReplicatedCSGDictionaryService extends Rbx_FlyweightService {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__31: never;
}
type NonReplicatedCSGDictionaryService = Rbx_NonReplicatedCSGDictionaryService & Base<Rbx_NonReplicatedCSGDictionaryService> & Indexable<Rbx_NonReplicatedCSGDictionaryService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "NonReplicatedCSGDictionaryService"): NonReplicatedCSGDictionaryService;
}

// Folder
interface Rbx_Folder extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__32: never;
}
type Folder = Rbx_Folder & Base<Rbx_Folder> & Indexable<Rbx_Folder>;

// ForceField
interface Rbx_ForceField extends Rbx_Instance {
	Visible: boolean;
}
type ForceField = Rbx_ForceField & Base<Rbx_ForceField> & Indexable<Rbx_ForceField>;

// FriendService
interface Rbx_FriendService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__33: never;
}
type FriendService = Rbx_FriendService & Base<Rbx_FriendService> & Indexable<Rbx_FriendService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "FriendService"): FriendService;
}

// FunctionalTest
interface Rbx_FunctionalTest extends Rbx_Instance {
	Description: string;
	Error(message?: string): void;
	Failed(message?: string): void;
	Pass(message?: string): void;
	Passed(message?: string): void;
	Warn(message?: string): void;
}
type FunctionalTest = Rbx_FunctionalTest & Base<Rbx_FunctionalTest> & Indexable<Rbx_FunctionalTest>;

// GamePassService
interface Rbx_GamePassService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__34: never;
}
type GamePassService = Rbx_GamePassService & Base<Rbx_GamePassService> & Indexable<Rbx_GamePassService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "GamePassService"): GamePassService;
}

// GameSettings
interface Rbx_GameSettings extends Rbx_Instance {
	AdditionalCoreIncludeDirs: string;
	BubbleChatLifetime: number;
	BubbleChatMaxBubbles: number;
	ChatHistory: number;
	ChatScrollLength: number;
	HardwareMouse: boolean;
	OverrideStarterScript: string;
	ReportAbuseChatHistory: number;
	SoftwareSound: boolean;
	VideoCaptureEnabled: boolean;
	VideoQuality: Enum.VideoQualitySettings;
}
type GameSettings = Rbx_GameSettings & Base<Rbx_GameSettings> & Indexable<Rbx_GameSettings>;

// GamepadService
interface Rbx_GamepadService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__35: never;
}
type GamepadService = Rbx_GamepadService & Base<Rbx_GamepadService> & Indexable<Rbx_GamepadService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "GamepadService"): GamepadService;
}

// Geometry
interface Rbx_Geometry extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__36: never;
}
type Geometry = Rbx_Geometry & Base<Rbx_Geometry> & Indexable<Rbx_Geometry>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "Geometry"): Geometry;
}

// GlobalDataStore
interface Rbx_GlobalDataStore extends Rbx_Instance {
	/** Sets the value of the key. This overwrites any existing data stored in the key */
	SetAsync(key: string, value?: any): void;
}
type GlobalDataStore = Rbx_GlobalDataStore & Base<Rbx_GlobalDataStore> & Indexable<Rbx_GlobalDataStore>;

// OrderedDataStore
interface Rbx_OrderedDataStore extends Rbx_GlobalDataStore {
}
type OrderedDataStore = Rbx_OrderedDataStore & Base<Rbx_OrderedDataStore> & Indexable<Rbx_OrderedDataStore>;

// GoogleAnalyticsConfiguration
interface Rbx_GoogleAnalyticsConfiguration extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__37: never;
}
type GoogleAnalyticsConfiguration = Rbx_GoogleAnalyticsConfiguration & Base<Rbx_GoogleAnalyticsConfiguration> & Indexable<Rbx_GoogleAnalyticsConfiguration>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "GoogleAnalyticsConfiguration"): GoogleAnalyticsConfiguration;
}

// GroupService
interface Rbx_GroupService extends Rbx_Instance {
}
type GroupService = Rbx_GroupService & Base<Rbx_GroupService> & Indexable<Rbx_GroupService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "GroupService"): GroupService;
}

// GuiBase
interface Rbx_GuiBase extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__38: never;
}
type GuiBase = Rbx_GuiBase & Base<Rbx_GuiBase> & Indexable<Rbx_GuiBase>;

// GuiBase2d
interface Rbx_GuiBase2d extends Rbx_GuiBase {
	/** A read-only Vector2 value that is the GuiObject's current position (x,y) in pixel space, from the top left corner of the GuiObject. */
	readonly AbsolutePosition: Vector2;
	readonly AbsoluteRotation: number;
	/** A read-only Vector2 value that is the GuiObject's current size (width, height) in pixel space. */
	readonly AbsoluteSize: Vector2;
	AutoLocalize: boolean;
	RootLocalizationTable: LocalizationTable;
}
type GuiBase2d = Rbx_GuiBase2d & Base<Rbx_GuiBase2d> & Indexable<Rbx_GuiBase2d>;

// GuiObject
interface Rbx_GuiObject extends Rbx_GuiBase2d {
	/** If true, this GuiObject can fire mouse events and will pass them to any GuiObjects layered underneath, while false will do neither. */
	Active: boolean;
	AnchorPoint: Vector2;
	/** A Color3 value that specifies the background color for the GuiObject. This value is ignored if the Style property (not found on all GuiObjects) is set to something besides custom. */
	BackgroundColor3: Color3;
	/** A number value that specifies how transparent the background of the GuiObject is. This value is ignored if the Style property (not found on all GuiObjects) is set to something besides custom. */
	BackgroundTransparency: number;
	/** A Color3 value that specifies the color of the outline of the GuiObject. This value is ignored if the Style property (not found on all GuiObjects) is set to something besides custom. */
	BorderColor3: Color3;
	/** A number value that specifies the thickness (in pixels) of the outline of the GuiObject. Currently this value can only be set to either 0 or 1, any other number has no effect. This value is ignored if the Style property (not found on all GuiObjects) is set to something besides custom. */
	BorderSizePixel: number;
	/** If set to true, any descendants of this GuiObject will only render if contained within it's borders. If set to false, all descendants will render regardless of position. */
	ClipsDescendants: boolean;
	LayoutOrder: number;
	NextSelectionDown: GuiObject;
	NextSelectionLeft: GuiObject;
	NextSelectionRight: GuiObject;
	NextSelectionUp: GuiObject;
	/** A UDim2 value describing the position of the top-left corner of the GuiObject on screen. More information on UDim2 is available [here](http://wiki.roblox.com/index.php/UDim2). */
	Position: UDim2;
	Rotation: number;
	Selectable: boolean;
	/** Overrides the default selection adornment (used for gamepads). For best results, this should point to a GuiObject. */
	SelectionImageObject: GuiObject;
	/** A UDim2 value describing the size of the GuiObject on screen in both absolute and relative coordinates. More information on UDim2 is available [here](http://wiki.roblox.com/index.php/UDim2). */
	Size: UDim2;
	/** The direction(s) that an object can be resized in. [More info](http://wiki.roblox.com/index.php/SizeConstraint). */
	SizeConstraint: Enum.SizeConstraint;
	Transparency: number;
	Visible: boolean;
	/** Describes the ordering in which overlapping GuiObjects will be drawn. A value of 1 is drawn first, while higher values are drawn in ascending order (each value draws over the last). */
	ZIndex: number;
	/** Smoothly moves a GuiObject from its current position to 'endPosition'. The only required argument is 'endPosition'. [More info](http://wiki.roblox.com/index.php/TweenPosition)  */
	TweenPosition(endPosition: UDim2, easingDirection?: Enum.EasingDirection, easingStyle?: Enum.EasingStyle, time?: number, override?: boolean, callback?: Function): boolean;
	/** Smoothly translates a GuiObject's current size to 'endSize'. The only required argument is 'endSize'. [More info](http://wiki.roblox.com/index.php/TweenSize)  */
	TweenSize(endSize: UDim2, easingDirection?: Enum.EasingDirection, easingStyle?: Enum.EasingStyle, time?: number, override?: boolean, callback?: Function): boolean;
	/** Smoothly translates a GuiObject's current size to 'endSize', and also smoothly translates the GuiObject's current position to 'endPosition'. The only required arguments are 'endSize' and 'endPosition'. [More info](http://wiki.roblox.com/index.php/TweenSizeAndPosition)  */
	TweenSizeAndPosition(endSize: UDim2, endPosition: UDim2, easingDirection?: Enum.EasingDirection, easingStyle?: Enum.EasingStyle, time?: number, override?: boolean, callback?: Function): boolean;
	/** Fired when the mouse enters a GuiObject, as long as the GuiObject is active (see active property for more detail). Arguments 'x', and 'y' specify the absolute pixel position of the mouse. */
	readonly MouseEnter: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fired when the mouse leaves a GuiObject, as long as the GuiObject is active (see active property for more detail). Arguments 'x', and 'y' specify the absolute pixel position of the mouse. */
	readonly MouseLeave: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fired when the mouse is inside a GuiObject and moves, as long as the GuiObject is active (see active property for more detail). Arguments 'x', and 'y' specify the absolute pixel position of the mouse. */
	readonly MouseMoved: RBXScriptSignal<(x: number, y: number) => void>;
	readonly MouseWheelBackward: RBXScriptSignal<(x: number, y: number) => void>;
	readonly MouseWheelForward: RBXScriptSignal<(x: number, y: number) => void>;
	readonly SelectionGained: RBXScriptSignal<() => void>;
	readonly SelectionLost: RBXScriptSignal<() => void>;
	/** Fired when a user swipes their fingers on a TouchEnabled device. 'swipeDirection' is an Enum.SwipeDirection, indicating the direction the user swiped. 'numberOfTouches' is an int that indicates how many touches were involved with the gesture.  This event only fires locally. */
	readonly TouchSwipe: RBXScriptSignal<(swipeDirection: Enum.SwipeDirection, numberOfTouches: number) => void>;
}
type GuiObject = Rbx_GuiObject & Base<Rbx_GuiObject> & Indexable<Rbx_GuiObject>;

// Frame
interface Rbx_Frame extends Rbx_GuiObject {
	/** Determines how a frame will look. Uses Enum.FrameStyle. [More info](http://wiki.roblox.com/index.php?title=API:Enum/FrameStyle) */
	Style: Enum.FrameStyle;
}
type Frame = Rbx_Frame & Base<Rbx_Frame> & Indexable<Rbx_Frame>;

// GuiButton
interface Rbx_GuiButton extends Rbx_GuiObject {
	/** Determines whether a button changes color automatically when reacting to mouse events. */
	AutoButtonColor: boolean;
	/** Allows the mouse to be free in first person mode. If a button with this property set to true is visible, the mouse is 'free' in first person mode. */
	Modal: boolean;
	Selected: boolean;
	/** Determines how a button will look, including mouse event states. Uses Enum.ButtonStyle. [More info](http://wiki.roblox.com/index.php?title=API:Class/GuiButton/Style) */
	Style: Enum.ButtonStyle;
	readonly Activated: RBXScriptSignal<(inputObject: Instance) => void>;
	/** Fired when the mouse is over the button, and the mouse down and up events fire without the mouse leaving the button. */
	readonly MouseButton1Click: RBXScriptSignal<() => void>;
	/** Fired when the mouse button is pushed down on a button. */
	readonly MouseButton1Down: RBXScriptSignal<(x: number, y: number) => void>;
	/** Fired when the mouse button is released on a button. */
	readonly MouseButton1Up: RBXScriptSignal<(x: number, y: number) => void>;
	/** This function currently does not work :( */
	readonly MouseButton2Click: RBXScriptSignal<() => void>;
	/** This function currently does not work :( */
	readonly MouseButton2Down: RBXScriptSignal<(x: number, y: number) => void>;
	/** This function currently does not work :( */
	readonly MouseButton2Up: RBXScriptSignal<(x: number, y: number) => void>;
}
type GuiButton = Rbx_GuiButton & Base<Rbx_GuiButton> & Indexable<Rbx_GuiButton>;

// ImageButton
interface Rbx_ImageButton extends Rbx_GuiButton {
	HoverImage: string;
	/** Specifies the asset id of the texture to display. [More info](http://wiki.roblox.com/index.php?title=API:Class/ImageButton/Image)  */
	Image: string;
	ImageColor3: Color3;
	ImageRectOffset: Vector2;
	ImageRectSize: Vector2;
	ImageTransparency: number;
	readonly IsLoaded: boolean;
	PressedImage: string;
	/** Specifies how an image should be displayed. See ScaleType for more info. */
	ScaleType: Enum.ScaleType;
	/** If ScaleType is set to Slice, this Rect is used to specify the central part of the image. Everything outside of this is considered to be the border. */
	SliceCenter: Rect;
	SliceScale: number;
	/** If ScaleType is set to Tile, this sets the size of the tile. */
	TileSize: UDim2;
}
type ImageButton = Rbx_ImageButton & Base<Rbx_ImageButton> & Indexable<Rbx_ImageButton>;

// TextButton
interface Rbx_TextButton extends Rbx_GuiButton {
	Font: Enum.Font;
	LineHeight: number;
	readonly LocalizedText: string;
	Text: string;
	readonly TextBounds: Vector2;
	TextColor3: Color3;
	readonly TextFits: boolean;
	TextScaled: boolean;
	TextSize: number;
	TextStrokeColor3: Color3;
	TextStrokeTransparency: number;
	TextTransparency: number;
	TextTruncate: Enum.TextTruncate;
	TextWrapped: boolean;
	TextXAlignment: Enum.TextXAlignment;
	TextYAlignment: Enum.TextYAlignment;
}
type TextButton = Rbx_TextButton & Base<Rbx_TextButton> & Indexable<Rbx_TextButton>;

// GuiLabel
interface Rbx_GuiLabel extends Rbx_GuiObject {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__39: never;
}
type GuiLabel = Rbx_GuiLabel & Base<Rbx_GuiLabel> & Indexable<Rbx_GuiLabel>;

// ImageLabel
interface Rbx_ImageLabel extends Rbx_GuiLabel {
	/** Specifies the id of the texture to display. [More info](http://wiki.roblox.com/index.php?title=API:Class/ImageLabel/Image) */
	Image: string;
	ImageColor3: Color3;
	ImageRectOffset: Vector2;
	ImageRectSize: Vector2;
	ImageTransparency: number;
	readonly IsLoaded: boolean;
	/** Specifies how an image should be displayed. See ScaleType for more info. */
	ScaleType: Enum.ScaleType;
	/** If ScaleType is set to Slice, this Rect is used to specify the central part of the image. Everything outside of this is considered to be the border. */
	SliceCenter: Rect;
	SliceScale: number;
	/** If ScaleType is set to Tile, this sets the size of the tile. */
	TileSize: UDim2;
}
type ImageLabel = Rbx_ImageLabel & Base<Rbx_ImageLabel> & Indexable<Rbx_ImageLabel>;

// TextLabel
interface Rbx_TextLabel extends Rbx_GuiLabel {
	Font: Enum.Font;
	LineHeight: number;
	readonly LocalizedText: string;
	Text: string;
	readonly TextBounds: Vector2;
	TextColor3: Color3;
	readonly TextFits: boolean;
	TextScaled: boolean;
	TextSize: number;
	TextStrokeColor3: Color3;
	TextStrokeTransparency: number;
	TextTransparency: number;
	TextTruncate: Enum.TextTruncate;
	TextWrapped: boolean;
	TextXAlignment: Enum.TextXAlignment;
	TextYAlignment: Enum.TextYAlignment;
}
type TextLabel = Rbx_TextLabel & Base<Rbx_TextLabel> & Indexable<Rbx_TextLabel>;

// ScrollingFrame
interface Rbx_ScrollingFrame extends Rbx_GuiObject {
	/** The size in pixels of the frame, without the scrollbars. */
	readonly AbsoluteWindowSize: Vector2;
	/** The "Down" image on the vertical scrollbar. Size of this is always ScrollBarThickness by ScrollBarThickness. This is also used as the "right" image on the horizontal scroll bar. */
	BottomImage: string;
	/** The absolute position the scroll frame is in respect to the canvas size. The minimum this can be set to is (0,0), while the max is the absolute canvas size - AbsoluteWindowSize. */
	CanvasPosition: Vector2;
	/** Determines the size of the area that is scrollable. The UDim2 is calculated using the parent gui's size, similar to the regular Size property on gui objects. */
	CanvasSize: UDim2;
	ElasticBehavior: Enum.ElasticBehavior;
	HorizontalScrollBarInset: Enum.ScrollBarInset;
	/** The "Middle" image on the vertical scrollbar. Size of this can vary in the y direction, but is always set at ScrollBarThickness in x direction. This is also used as the "mid" image on the horizontal scroll bar. */
	MidImage: string;
	ScrollBarImageColor3: Color3;
	ScrollBarImageTransparency: number;
	/** How thick the scroll bar appears. This applies to both the horizontal and vertical scroll bars. Can be set to 0 for no bars render. */
	ScrollBarThickness: number;
	ScrollingDirection: Enum.ScrollingDirection;
	/** Determines whether or not scrolling is allowed on this frame. If turned off, no scroll bars will be rendered. */
	ScrollingEnabled: boolean;
	/** The "Up" image on the vertical scrollbar. Size of this is always ScrollBarThickness by ScrollBarThickness. This is also used as the "left" image on the horizontal scroll bar. */
	TopImage: string;
	VerticalScrollBarInset: Enum.ScrollBarInset;
	VerticalScrollBarPosition: Enum.VerticalScrollBarPosition;
}
type ScrollingFrame = Rbx_ScrollingFrame & Base<Rbx_ScrollingFrame> & Indexable<Rbx_ScrollingFrame>;

// TextBox
interface Rbx_TextBox extends Rbx_GuiObject {
	ClearTextOnFocus: boolean;
	CursorPosition: number;
	Font: Enum.Font;
	LineHeight: number;
	MultiLine: boolean;
	PlaceholderColor3: Color3;
	PlaceholderText: string;
	ShowNativeInput: boolean;
	Text: string;
	readonly TextBounds: Vector2;
	TextColor3: Color3;
	readonly TextFits: boolean;
	TextScaled: boolean;
	TextSize: number;
	TextStrokeColor3: Color3;
	TextStrokeTransparency: number;
	TextTransparency: number;
	TextTruncate: Enum.TextTruncate;
	TextWrapped: boolean;
	TextXAlignment: Enum.TextXAlignment;
	TextYAlignment: Enum.TextYAlignment;
	CaptureFocus(): void;
	IsFocused(): boolean;
	ReleaseFocus(submitted?: boolean): void;
	readonly FocusLost: RBXScriptSignal<(enterPressed: boolean, inputThatCausedFocusLoss: Instance) => void>;
	readonly Focused: RBXScriptSignal<() => void>;
}
type TextBox = Rbx_TextBox & Base<Rbx_TextBox> & Indexable<Rbx_TextBox>;

// ViewportFrame
interface Rbx_ViewportFrame extends Rbx_GuiObject {
	/** Current Camera of children objects */
	CurrentCamera: Camera;
	/** The rendered image of the ViewportFrame will be mutiplied by this color */
	ImageColor3: Color3;
	/** A number value that specifies how transparent the rendered image of the ViewportFrame is */
	ImageTransparency: number;
}
type ViewportFrame = Rbx_ViewportFrame & Base<Rbx_ViewportFrame> & Indexable<Rbx_ViewportFrame>;

// LayerCollector
interface Rbx_LayerCollector extends Rbx_GuiBase2d {
	Enabled: boolean;
	ResetOnSpawn: boolean;
	ZIndexBehavior: Enum.ZIndexBehavior;
}
type LayerCollector = Rbx_LayerCollector & Base<Rbx_LayerCollector> & Indexable<Rbx_LayerCollector>;

// BillboardGui
interface Rbx_BillboardGui extends Rbx_LayerCollector {
	/** If true, this GuiObject can fire mouse events and will pass them to any GuiObjects layered underneath, while false will do neither. */
	Active: boolean;
	/** If true, billboard gui does not get occluded by 3D objects, but always renders on the screen. */
	AlwaysOnTop: boolean;
	ClipsDescendants: boolean;
	/** A Vector3 (x,y,z) defined in studs that will offset the gui from the extents of the 3d object it is rendering from. */
	ExtentsOffset: Vector3;
	ExtentsOffsetWorldSpace: Vector3;
	/** Specifies the amount of influence lighting has on the billboard gui. A value of 0 is unlit, 1 is fully lit. Fractional values blend from unlit to lit. */
	LightInfluence: number;
	MaxDistance: number;
	/** A UDim2 value describing the size of the BillboardGui. More information on UDim2 is available [here](http://wiki.roblox.com/index.php/UDim2). Relative values are defined as one-to-one with studs. */
	Size: UDim2;
	/** A Vector2 (x,y) defined in studs that will offset the gui size from it's current size. */
	SizeOffset: Vector2;
	/** A Vector3 (x,y,z) defined in studs that will offset the gui from the centroid of the 3d object it is rendering from */
	StudsOffset: Vector3;
	StudsOffsetWorldSpace: Vector3;
}
type BillboardGui = Rbx_BillboardGui & Base<Rbx_BillboardGui> & Indexable<Rbx_BillboardGui>;

// PluginGui
interface Rbx_PluginGui extends Rbx_LayerCollector {
	Title: string;
	BindToClose(callback?: Function): void;
}
type PluginGui = Rbx_PluginGui & Base<Rbx_PluginGui> & Indexable<Rbx_PluginGui>;

// DockWidgetPluginGui
interface Rbx_DockWidgetPluginGui extends Rbx_PluginGui {
	readonly HostWidgetWasRestored: boolean;
}
type DockWidgetPluginGui = Rbx_DockWidgetPluginGui & Base<Rbx_DockWidgetPluginGui> & Indexable<Rbx_DockWidgetPluginGui>;

// QWidgetPluginGui
interface Rbx_QWidgetPluginGui extends Rbx_PluginGui {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__40: never;
}
type QWidgetPluginGui = Rbx_QWidgetPluginGui & Base<Rbx_QWidgetPluginGui> & Indexable<Rbx_QWidgetPluginGui>;

// ScreenGui
interface Rbx_ScreenGui extends Rbx_LayerCollector {
	DisplayOrder: number;
	IgnoreGuiInset: boolean;
}
type ScreenGui = Rbx_ScreenGui & Base<Rbx_ScreenGui> & Indexable<Rbx_ScreenGui>;

// GuiMain
interface Rbx_GuiMain extends Rbx_ScreenGui {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__41: never;
}
type GuiMain = Rbx_GuiMain & Base<Rbx_GuiMain> & Indexable<Rbx_GuiMain>;

// SurfaceGui
interface Rbx_SurfaceGui extends Rbx_LayerCollector {
	/** If true, this GuiObject can fire mouse events and will pass them to any GuiObjects layered underneath, while false will do neither. */
	Active: boolean;
	AlwaysOnTop: boolean;
	CanvasSize: Vector2;
	ClipsDescendants: boolean;
	Face: Enum.NormalId;
	/** Specifies the amount of influence lighting has on the surface gui. A value of 0 is unlit, 1 is fully lit. Fractional values blend from unlit to lit. */
	LightInfluence: number;
	ToolPunchThroughDistance: number;
	ZOffset: number;
}
type SurfaceGui = Rbx_SurfaceGui & Base<Rbx_SurfaceGui> & Indexable<Rbx_SurfaceGui>;

// GuiBase3d
interface Rbx_GuiBase3d extends Rbx_GuiBase {
	Color3: Color3;
	Transparency: number;
	Visible: boolean;
}
type GuiBase3d = Rbx_GuiBase3d & Base<Rbx_GuiBase3d> & Indexable<Rbx_GuiBase3d>;

// FloorWire
interface Rbx_FloorWire extends Rbx_GuiBase3d {
	/** Controls how the decals are positioned along the wire. [More info](http://wiki.roblox.com/index.php/CycleOffset) */
	CycleOffset: number;
	/** The object the FloorWire 'emits' from */
	From: BasePart;
	/** The space between two textures on the wire. Note: studs are relative depending on how far the camera is from the FloorWire. */
	StudsBetweenTextures: number;
	/** The image we use to render the textures that flow from beginning to end of the FloorWire. */
	Texture: string;
	/** The size in studs of the Texture we use to flow from one object to the next. */
	TextureSize: Vector2;
	/** The object the FloorWire 'emits' to */
	To: BasePart;
	/** The rate of travel that the textures flow along the wire. */
	Velocity: number;
	/** How thick the wire is. */
	WireRadius: number;
}
type FloorWire = Rbx_FloorWire & Base<Rbx_FloorWire> & Indexable<Rbx_FloorWire>;

// PVAdornment
interface Rbx_PVAdornment extends Rbx_GuiBase3d {
	Adornee: PVInstance;
}
type PVAdornment = Rbx_PVAdornment & Base<Rbx_PVAdornment> & Indexable<Rbx_PVAdornment>;

// HandleAdornment
interface Rbx_HandleAdornment extends Rbx_PVAdornment {
	AlwaysOnTop: boolean;
	CFrame: CFrame;
	SizeRelativeOffset: Vector3;
	ZIndex: number;
	readonly MouseButton1Down: RBXScriptSignal<() => void>;
	readonly MouseButton1Up: RBXScriptSignal<() => void>;
	readonly MouseEnter: RBXScriptSignal<() => void>;
	readonly MouseLeave: RBXScriptSignal<() => void>;
}
type HandleAdornment = Rbx_HandleAdornment & Base<Rbx_HandleAdornment> & Indexable<Rbx_HandleAdornment>;

// BoxHandleAdornment
interface Rbx_BoxHandleAdornment extends Rbx_HandleAdornment {
	Size: Vector3;
}
type BoxHandleAdornment = Rbx_BoxHandleAdornment & Base<Rbx_BoxHandleAdornment> & Indexable<Rbx_BoxHandleAdornment>;

// ConeHandleAdornment
interface Rbx_ConeHandleAdornment extends Rbx_HandleAdornment {
	Height: number;
	Radius: number;
}
type ConeHandleAdornment = Rbx_ConeHandleAdornment & Base<Rbx_ConeHandleAdornment> & Indexable<Rbx_ConeHandleAdornment>;

// CylinderHandleAdornment
interface Rbx_CylinderHandleAdornment extends Rbx_HandleAdornment {
	Height: number;
	Radius: number;
}
type CylinderHandleAdornment = Rbx_CylinderHandleAdornment & Base<Rbx_CylinderHandleAdornment> & Indexable<Rbx_CylinderHandleAdornment>;

// ImageHandleAdornment
interface Rbx_ImageHandleAdornment extends Rbx_HandleAdornment {
	Image: string;
	Size: Vector2;
}
type ImageHandleAdornment = Rbx_ImageHandleAdornment & Base<Rbx_ImageHandleAdornment> & Indexable<Rbx_ImageHandleAdornment>;

// LineHandleAdornment
interface Rbx_LineHandleAdornment extends Rbx_HandleAdornment {
	Length: number;
	Thickness: number;
}
type LineHandleAdornment = Rbx_LineHandleAdornment & Base<Rbx_LineHandleAdornment> & Indexable<Rbx_LineHandleAdornment>;

// SphereHandleAdornment
interface Rbx_SphereHandleAdornment extends Rbx_HandleAdornment {
	Radius: number;
}
type SphereHandleAdornment = Rbx_SphereHandleAdornment & Base<Rbx_SphereHandleAdornment> & Indexable<Rbx_SphereHandleAdornment>;

// ParabolaAdornment
interface Rbx_ParabolaAdornment extends Rbx_PVAdornment {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__42: never;
}
type ParabolaAdornment = Rbx_ParabolaAdornment & Base<Rbx_ParabolaAdornment> & Indexable<Rbx_ParabolaAdornment>;

// SelectionBox
interface Rbx_SelectionBox extends Rbx_PVAdornment {
	LineThickness: number;
	SurfaceColor3: Color3;
	SurfaceTransparency: number;
}
type SelectionBox = Rbx_SelectionBox & Base<Rbx_SelectionBox> & Indexable<Rbx_SelectionBox>;

// SelectionSphere
interface Rbx_SelectionSphere extends Rbx_PVAdornment {
	SurfaceColor3: Color3;
	SurfaceTransparency: number;
}
type SelectionSphere = Rbx_SelectionSphere & Base<Rbx_SelectionSphere> & Indexable<Rbx_SelectionSphere>;

// PartAdornment
interface Rbx_PartAdornment extends Rbx_GuiBase3d {
	Adornee: BasePart;
}
type PartAdornment = Rbx_PartAdornment & Base<Rbx_PartAdornment> & Indexable<Rbx_PartAdornment>;

// HandlesBase
interface Rbx_HandlesBase extends Rbx_PartAdornment {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__43: never;
}
type HandlesBase = Rbx_HandlesBase & Base<Rbx_HandlesBase> & Indexable<Rbx_HandlesBase>;

// ArcHandles
interface Rbx_ArcHandles extends Rbx_HandlesBase {
	Axes: Axes;
	readonly MouseButton1Down: RBXScriptSignal<(axis: Enum.Axis) => void>;
	readonly MouseButton1Up: RBXScriptSignal<(axis: Enum.Axis) => void>;
	readonly MouseDrag: RBXScriptSignal<(axis: Enum.Axis, relativeAngle: number, deltaRadius: number) => void>;
	readonly MouseEnter: RBXScriptSignal<(axis: Enum.Axis) => void>;
	readonly MouseLeave: RBXScriptSignal<(axis: Enum.Axis) => void>;
}
type ArcHandles = Rbx_ArcHandles & Base<Rbx_ArcHandles> & Indexable<Rbx_ArcHandles>;

// Handles
interface Rbx_Handles extends Rbx_HandlesBase {
	Faces: Faces;
	Style: Enum.HandlesStyle;
	readonly MouseButton1Down: RBXScriptSignal<(face: Enum.NormalId) => void>;
	readonly MouseButton1Up: RBXScriptSignal<(face: Enum.NormalId) => void>;
	readonly MouseDrag: RBXScriptSignal<(face: Enum.NormalId, distance: number) => void>;
	readonly MouseEnter: RBXScriptSignal<(face: Enum.NormalId) => void>;
	readonly MouseLeave: RBXScriptSignal<(face: Enum.NormalId) => void>;
}
type Handles = Rbx_Handles & Base<Rbx_Handles> & Indexable<Rbx_Handles>;

// SurfaceSelection
interface Rbx_SurfaceSelection extends Rbx_PartAdornment {
	TargetSurface: Enum.NormalId;
}
type SurfaceSelection = Rbx_SurfaceSelection & Base<Rbx_SurfaceSelection> & Indexable<Rbx_SurfaceSelection>;

// SelectionLasso
interface Rbx_SelectionLasso extends Rbx_GuiBase3d {
	Humanoid: Humanoid;
}
type SelectionLasso = Rbx_SelectionLasso & Base<Rbx_SelectionLasso> & Indexable<Rbx_SelectionLasso>;

// SelectionPartLasso
interface Rbx_SelectionPartLasso extends Rbx_SelectionLasso {
	Part: BasePart;
}
type SelectionPartLasso = Rbx_SelectionPartLasso & Base<Rbx_SelectionPartLasso> & Indexable<Rbx_SelectionPartLasso>;

// SelectionPointLasso
interface Rbx_SelectionPointLasso extends Rbx_SelectionLasso {
	Point: Vector3;
}
type SelectionPointLasso = Rbx_SelectionPointLasso & Base<Rbx_SelectionPointLasso> & Indexable<Rbx_SelectionPointLasso>;

// GuiItem
interface Rbx_GuiItem extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__44: never;
}
type GuiItem = Rbx_GuiItem & Base<Rbx_GuiItem> & Indexable<Rbx_GuiItem>;

// Backpack
interface Rbx_Backpack extends Rbx_GuiItem {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__45: never;
}
type Backpack = Rbx_Backpack & Base<Rbx_Backpack> & Indexable<Rbx_Backpack>;

// BackpackItem
interface Rbx_BackpackItem extends Rbx_GuiItem {
	TextureId: string;
}
type BackpackItem = Rbx_BackpackItem & Base<Rbx_BackpackItem> & Indexable<Rbx_BackpackItem>;

// HopperBin
interface Rbx_HopperBin extends Rbx_BackpackItem {
	Active: boolean;
	BinType: Enum.BinType;
	readonly Deselected: RBXScriptSignal<() => void>;
	readonly Selected: RBXScriptSignal<(mouse: Instance) => void>;
}
type HopperBin = Rbx_HopperBin & Base<Rbx_HopperBin> & Indexable<Rbx_HopperBin>;

// Tool
interface Rbx_Tool extends Rbx_BackpackItem {
	CanBeDropped: boolean;
	Enabled: boolean;
	Grip: CFrame;
	GripForward: Vector3;
	GripPos: Vector3;
	GripRight: Vector3;
	GripUp: Vector3;
	ManualActivationOnly: boolean;
	RequiresHandle: boolean;
	ToolTip: string;
	Activate(): void;
	Deactivate(): void;
	readonly Activated: RBXScriptSignal<() => void>;
	readonly Deactivated: RBXScriptSignal<() => void>;
	readonly Unequipped: RBXScriptSignal<() => void>;
}
type Tool = Rbx_Tool & Base<Rbx_Tool> & Indexable<Rbx_Tool>;

// Flag
interface Rbx_Flag extends Rbx_Tool {
	/** The Team this flag is for. Corresponds with the TeamColors in the Teams service. */
	TeamColor: BrickColor;
}
type Flag = Rbx_Flag & Base<Rbx_Flag> & Indexable<Rbx_Flag>;

// ButtonBindingWidget
interface Rbx_ButtonBindingWidget extends Rbx_GuiItem {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__46: never;
}
type ButtonBindingWidget = Rbx_ButtonBindingWidget & Base<Rbx_ButtonBindingWidget> & Indexable<Rbx_ButtonBindingWidget>;

// GuiRoot
interface Rbx_GuiRoot extends Rbx_GuiItem {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__47: never;
}
type GuiRoot = Rbx_GuiRoot & Base<Rbx_GuiRoot> & Indexable<Rbx_GuiRoot>;

// Hopper
interface Rbx_Hopper extends Rbx_GuiItem {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__48: never;
}
type Hopper = Rbx_Hopper & Base<Rbx_Hopper> & Indexable<Rbx_Hopper>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "Hopper"): Hopper;
}

// StarterPack
interface Rbx_StarterPack extends Rbx_GuiItem {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__49: never;
}
type StarterPack = Rbx_StarterPack & Base<Rbx_StarterPack> & Indexable<Rbx_StarterPack>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "StarterPack"): StarterPack;
}

// GuiService
interface Rbx_GuiService extends Rbx_Instance {
	AutoSelectGuiEnabled: boolean;
	CoreGuiNavigationEnabled: boolean;
	GuiNavigationEnabled: boolean;
	readonly MenuIsOpen: boolean;
	SelectedObject: GuiObject;
	IsTenFootInterface(): boolean;
	RemoveSelectionGroup(selectionName: string): void;
	readonly MenuClosed: RBXScriptSignal<() => void>;
	readonly MenuOpened: RBXScriptSignal<() => void>;
}
type GuiService = Rbx_GuiService & Base<Rbx_GuiService> & Indexable<Rbx_GuiService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "GuiService"): GuiService;
}

// GuidRegistryService
interface Rbx_GuidRegistryService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__50: never;
}
type GuidRegistryService = Rbx_GuidRegistryService & Base<Rbx_GuidRegistryService> & Indexable<Rbx_GuidRegistryService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "GuidRegistryService"): GuidRegistryService;
}

// HapticService
interface Rbx_HapticService extends Rbx_Instance {
	IsMotorSupported(inputType: Enum.UserInputType, vibrationMotor: Enum.VibrationMotor): boolean;
	IsVibrationSupported(inputType: Enum.UserInputType): boolean;
}
type HapticService = Rbx_HapticService & Base<Rbx_HapticService> & Indexable<Rbx_HapticService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "HapticService"): HapticService;
}

// HttpRbxApiService
interface Rbx_HttpRbxApiService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__51: never;
}
type HttpRbxApiService = Rbx_HttpRbxApiService & Base<Rbx_HttpRbxApiService> & Indexable<Rbx_HttpRbxApiService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "HttpRbxApiService"): HttpRbxApiService;
}

// HttpRequest
interface Rbx_HttpRequest extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__52: never;
}
type HttpRequest = Rbx_HttpRequest & Base<Rbx_HttpRequest> & Indexable<Rbx_HttpRequest>;

// HttpService
interface Rbx_HttpService extends Rbx_Instance {
	GenerateGUID(wrapInCurlyBraces?: boolean): string;
	JSONDecode(input: string): unknown;
	JSONEncode(input?: any): string;
	UrlEncode(input: string): string;
}
type HttpService = Rbx_HttpService & Base<Rbx_HttpService> & Indexable<Rbx_HttpService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "HttpService"): HttpService;
}

// Humanoid
interface Rbx_Humanoid extends Rbx_Instance {
	AutoJumpEnabled: boolean;
	AutoRotate: boolean;
	AutomaticScalingEnabled: boolean;
	BreakJointsOnDeath: boolean;
	CameraOffset: Vector3;
	DisplayDistanceType: Enum.HumanoidDisplayDistanceType;
	readonly FloorMaterial: Enum.Material;
	/** How many hit points the Humanoid has.  When this number reaches 0 or goes below 0, the Humanoid's character falls apart and will respawn. */
	Health: number;
	HealthDisplayDistance: number;
	HealthDisplayType: Enum.HumanoidHealthDisplayType;
	HipHeight: number;
	Jump: boolean;
	JumpPower: number;
	/** The maximum number of hit points a Humanoid's health can reach.  If the Humanoid's health is set over this amount, the health gets set to this value. */
	MaxHealth: number;
	MaxSlopeAngle: number;
	readonly MoveDirection: Vector3;
	NameDisplayDistance: number;
	/** Sets how to display other humanoid names to this humanoid's player. [More info](http://wiki.roblox.com/index.php/NameOcclusion) */
	NameOcclusion: Enum.NameOcclusion;
	PlatformStand: boolean;
	RigType: Enum.HumanoidRigType;
	readonly RootPart: BasePart;
	readonly SeatPart: BasePart;
	Sit: boolean;
	/** The location that the Humanoid is trying to walk to. */
	TargetPoint: Vector3;
	WalkSpeed: number;
	WalkToPart: BasePart;
	WalkToPoint: Vector3;
	BuildRigFromAttachments(): void;
	ChangeState(state?: Enum.HumanoidStateType): void;
	GetState(): Enum.HumanoidStateType;
	GetStateEnabled(state: Enum.HumanoidStateType): boolean;
	Move(moveDirection: Vector3, relativeToCamera?: boolean): void;
	RemoveAccessories(): void;
	SetStateEnabled(state: Enum.HumanoidStateType, enabled: boolean): void;
	/** Decreases health by the amount.  Use this instead of changing health directly to make sure weapons are filtered for things such as ForceField(s). */
	TakeDamage(amount: number): void;
	/** Takes any active gear/tools that the Humanoid is using and puts them into the backpack.  This function only works on Humanoids with a corresponding Player. */
	UnequipTools(): void;
	readonly Climbing: RBXScriptSignal<(speed: number) => void>;
	readonly Died: RBXScriptSignal<() => void>;
	readonly FallingDown: RBXScriptSignal<(active: boolean) => void>;
	readonly FreeFalling: RBXScriptSignal<(active: boolean) => void>;
	readonly GettingUp: RBXScriptSignal<(active: boolean) => void>;
	readonly HealthChanged: RBXScriptSignal<(health: number) => void>;
	readonly Jumping: RBXScriptSignal<(active: boolean) => void>;
	readonly MoveToFinished: RBXScriptSignal<(reached: boolean) => void>;
	readonly PlatformStanding: RBXScriptSignal<(active: boolean) => void>;
	readonly Ragdoll: RBXScriptSignal<(active: boolean) => void>;
	readonly Running: RBXScriptSignal<(speed: number) => void>;
	readonly StateChanged: RBXScriptSignal<(oldValue: Enum.HumanoidStateType, newValue: Enum.HumanoidStateType) => void>;
	readonly StateEnabledChanged: RBXScriptSignal<(state: Enum.HumanoidStateType, isEnabled: boolean) => void>;
	readonly Strafing: RBXScriptSignal<(active: boolean) => void>;
	readonly Swimming: RBXScriptSignal<(speed: number) => void>;
}
type Humanoid = Rbx_Humanoid & Base<Rbx_Humanoid> & Indexable<Rbx_Humanoid>;

// HumanoidDescription
interface Rbx_HumanoidDescription extends Rbx_Instance {
	BackAccessory: string;
	BodyTypeScale: number;
	ClimbAnimation: number;
	DepthScale: number;
	Face: number;
	FaceAccessory: string;
	FallAnimation: number;
	FrontAccessory: string;
	GraphicTShirt: number;
	HairAccessory: string;
	HatAccessory: string;
	Head: number;
	HeadColor: Color3;
	HeadScale: number;
	HeightScale: number;
	IdleAnimation: number;
	JumpAnimation: number;
	LeftArm: number;
	LeftArmColor: Color3;
	LeftLeg: number;
	LeftLegColor: Color3;
	NeckAccessory: string;
	Pants: number;
	ProportionScale: number;
	RightArm: number;
	RightArmColor: Color3;
	RightLeg: number;
	RightLegColor: Color3;
	RunAnimation: number;
	Shirt: number;
	ShouldersAccessory: string;
	SwimAnimation: number;
	Torso: number;
	TorsoColor: Color3;
	WaistAccessory: string;
	WalkAnimation: number;
	WidthScale: number;
}
type HumanoidDescription = Rbx_HumanoidDescription & Base<Rbx_HumanoidDescription> & Indexable<Rbx_HumanoidDescription>;

// InputObject
interface Rbx_InputObject extends Rbx_Instance {
	Delta: Vector3;
	/** An enum that describes what kind of input is being pressed. For types of input like Keyboard, this describes what key was pressed. For input like mousebutton, this provides no additional information. */
	KeyCode: Enum.KeyCode;
	/** A Vector3 value that describes a positional value of this input. For mouse and touch input, this is the screen position of the mouse/touch, described in the x and y components. For mouse wheel input, the z component describes whether the wheel was moved forward or backward. */
	Position: Vector3;
	/** An enum that describes what state of a particular input (touch began, touch moved, touch ended, etc.). See Enum.UserInputState for more info. */
	UserInputState: Enum.UserInputState;
	/** An enum that describes what kind of input this object is describing (mousebutton, touch, etc.).  See Enum.UserInputType for more info. */
	UserInputType: Enum.UserInputType;
}
type InputObject = Rbx_InputObject & Base<Rbx_InputObject> & Indexable<Rbx_InputObject>;

// InsertService
interface Rbx_InsertService extends Rbx_Instance {
	GetLatestAssetVersionAsync(assetId: number): number;
}
type InsertService = Rbx_InsertService & Base<Rbx_InsertService> & Indexable<Rbx_InsertService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "InsertService"): InsertService;
}

// JointInstance
interface Rbx_JointInstance extends Rbx_Instance {
	/** Read-only boolean, true if the joint is active in world. Rigid joints may be inactive if they are redundant or form cycles. */
	readonly Active: boolean;
	C0: CFrame;
	C1: CFrame;
}
type JointInstance = Rbx_JointInstance & Base<Rbx_JointInstance> & Indexable<Rbx_JointInstance>;

// DynamicRotate
interface Rbx_DynamicRotate extends Rbx_JointInstance {
	BaseAngle: number;
}
type DynamicRotate = Rbx_DynamicRotate & Base<Rbx_DynamicRotate> & Indexable<Rbx_DynamicRotate>;

// RotateP
interface Rbx_RotateP extends Rbx_DynamicRotate {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__53: never;
}
type RotateP = Rbx_RotateP & Base<Rbx_RotateP> & Indexable<Rbx_RotateP>;

// RotateV
interface Rbx_RotateV extends Rbx_DynamicRotate {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__54: never;
}
type RotateV = Rbx_RotateV & Base<Rbx_RotateV> & Indexable<Rbx_RotateV>;

// Glue
interface Rbx_Glue extends Rbx_JointInstance {
	F0: Vector3;
	F1: Vector3;
	F2: Vector3;
	F3: Vector3;
}
type Glue = Rbx_Glue & Base<Rbx_Glue> & Indexable<Rbx_Glue>;

// ManualSurfaceJointInstance
interface Rbx_ManualSurfaceJointInstance extends Rbx_JointInstance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__55: never;
}
type ManualSurfaceJointInstance = Rbx_ManualSurfaceJointInstance & Base<Rbx_ManualSurfaceJointInstance> & Indexable<Rbx_ManualSurfaceJointInstance>;

// ManualGlue
interface Rbx_ManualGlue extends Rbx_ManualSurfaceJointInstance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__56: never;
}
type ManualGlue = Rbx_ManualGlue & Base<Rbx_ManualGlue> & Indexable<Rbx_ManualGlue>;

// ManualWeld
interface Rbx_ManualWeld extends Rbx_ManualSurfaceJointInstance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__57: never;
}
type ManualWeld = Rbx_ManualWeld & Base<Rbx_ManualWeld> & Indexable<Rbx_ManualWeld>;

// Motor
interface Rbx_Motor extends Rbx_JointInstance {
	CurrentAngle: number;
	DesiredAngle: number;
	MaxVelocity: number;
	SetDesiredAngle(value: number): void;
}
type Motor = Rbx_Motor & Base<Rbx_Motor> & Indexable<Rbx_Motor>;

// Motor6D
interface Rbx_Motor6D extends Rbx_Motor {
	Transform: CFrame;
}
type Motor6D = Rbx_Motor6D & Base<Rbx_Motor6D> & Indexable<Rbx_Motor6D>;

// Rotate
interface Rbx_Rotate extends Rbx_JointInstance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__58: never;
}
type Rotate = Rbx_Rotate & Base<Rbx_Rotate> & Indexable<Rbx_Rotate>;

// Snap
interface Rbx_Snap extends Rbx_JointInstance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__59: never;
}
type Snap = Rbx_Snap & Base<Rbx_Snap> & Indexable<Rbx_Snap>;

// VelocityMotor
interface Rbx_VelocityMotor extends Rbx_JointInstance {
	CurrentAngle: number;
	DesiredAngle: number;
	Hole: Hole;
	MaxVelocity: number;
}
type VelocityMotor = Rbx_VelocityMotor & Base<Rbx_VelocityMotor> & Indexable<Rbx_VelocityMotor>;

// Weld
interface Rbx_Weld extends Rbx_JointInstance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__60: never;
}
type Weld = Rbx_Weld & Base<Rbx_Weld> & Indexable<Rbx_Weld>;

// JointsService
interface Rbx_JointsService extends Rbx_Instance {
	ClearJoinAfterMoveJoints(): void;
	CreateJoinAfterMoveJoints(): void;
	SetJoinAfterMoveInstance(joinInstance: Instance): void;
	SetJoinAfterMoveTarget(joinTarget: Instance): void;
	ShowPermissibleJoints(): void;
}
type JointsService = Rbx_JointsService & Base<Rbx_JointsService> & Indexable<Rbx_JointsService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "JointsService"): JointsService;
}

// KeyboardService
interface Rbx_KeyboardService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__61: never;
}
type KeyboardService = Rbx_KeyboardService & Base<Rbx_KeyboardService> & Indexable<Rbx_KeyboardService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "KeyboardService"): KeyboardService;
}

// Keyframe
interface Rbx_Keyframe extends Rbx_Instance {
	Time: number;
	AddMarker(marker: Instance): void;
	GetMarkers(): Array<Instance>;
	RemoveMarker(marker: Instance): void;
}
type Keyframe = Rbx_Keyframe & Base<Rbx_Keyframe> & Indexable<Rbx_Keyframe>;

// KeyframeMarker
interface Rbx_KeyframeMarker extends Rbx_Instance {
	Value: string;
}
type KeyframeMarker = Rbx_KeyframeMarker & Base<Rbx_KeyframeMarker> & Indexable<Rbx_KeyframeMarker>;

// KeyframeSequence
interface Rbx_KeyframeSequence extends Rbx_Instance {
	Loop: boolean;
	Priority: Enum.AnimationPriority;
}
type KeyframeSequence = Rbx_KeyframeSequence & Base<Rbx_KeyframeSequence> & Indexable<Rbx_KeyframeSequence>;

// KeyframeSequenceProvider
interface Rbx_KeyframeSequenceProvider extends Rbx_Instance {
}
type KeyframeSequenceProvider = Rbx_KeyframeSequenceProvider & Base<Rbx_KeyframeSequenceProvider> & Indexable<Rbx_KeyframeSequenceProvider>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "KeyframeSequenceProvider"): KeyframeSequenceProvider;
}

// Light
interface Rbx_Light extends Rbx_Instance {
	Brightness: number;
	Color: Color3;
	Enabled: boolean;
	Shadows: boolean;
}
type Light = Rbx_Light & Base<Rbx_Light> & Indexable<Rbx_Light>;

// PointLight
interface Rbx_PointLight extends Rbx_Light {
	Range: number;
}
type PointLight = Rbx_PointLight & Base<Rbx_PointLight> & Indexable<Rbx_PointLight>;

// SpotLight
interface Rbx_SpotLight extends Rbx_Light {
	Angle: number;
	Face: Enum.NormalId;
	Range: number;
}
type SpotLight = Rbx_SpotLight & Base<Rbx_SpotLight> & Indexable<Rbx_SpotLight>;

// SurfaceLight
interface Rbx_SurfaceLight extends Rbx_Light {
	Angle: number;
	Face: Enum.NormalId;
	Range: number;
}
type SurfaceLight = Rbx_SurfaceLight & Base<Rbx_SurfaceLight> & Indexable<Rbx_SurfaceLight>;

// Lighting
interface Rbx_Lighting extends Rbx_Instance {
	/** The hue of the global lighting.  Changing this changes the color tint of all objects in the Workspace. */
	Ambient: Color3;
	/** How much global light each Part in the Workspace receives. Standard range is 0 to 2 (0 being little light), but can be increased all the way to 10 (colors start to be appear very different at this value). */
	Brightness: number;
	ClockTime: number;
	/** The hue of global lighting on the bottom surfaces of an object. */
	ColorShift_Bottom: Color3;
	/** The hue of global lighting on the top surfaces of an object. */
	ColorShift_Top: Color3;
	/** Exposure compensation amount. Applies a bias to the exposure level prior to the tonemap step. +1 indicates twice as much exposure and -1 means half as much exposure. */
	ExposureCompensation: number;
	/** A Color3 value that changes the hue of distance fog. */
	FogColor: Color3;
	/** The distance at which fog completely blocks your vision. This distance is relative to the camera position. Units are in studs */
	FogEnd: number;
	/** The distance at which the fog gradient begins. This distance is relative to the camera position. Units are in studs. */
	FogStart: number;
	/** The latitude position the level is placed at.  This affects sun position. [More info](http://wiki.roblox.com/index.php/GeographicLatitude) */
	GeographicLatitude: number;
	/** Flag enabling shadows from sun and moon in the place */
	GlobalShadows: boolean;
	/** Effective ambient value for outdoors, effectively shadow color outdoors (requires GlobalShadows enabled) */
	OutdoorAmbient: Color3;
	/** Flag enabling or disabling outlines on parts and terrain */
	Outlines: boolean;
	/** A string that represent the current time of day. Time is in 24-hour clock format "XX::YY:ZZ", where X is hour, Y is minute, and Z is seconds. */
	TimeOfDay: string;
	/** The number of minutes that the current time is past midnight.  If currently at midnight, returns 0.  Will return decimal values if not at an exact minute. */
	GetMinutesAfterMidnight(): number;
	/** Returns the lookVector (Vector3) of the moon. If this lookVector was used in a CFrame, the Part would face the moon. */
	GetMoonDirection(): Vector3;
	/** Currently always returns 0.75. MoonPhase cannot be edited. */
	GetMoonPhase(): number;
	/** Returns the lookVector (Vector3) of the sun. If this lookVector was used in a CFrame, the Part would face the sun. */
	GetSunDirection(): Vector3;
	/** Sets the time to be a certain number of minutes after midnight.  This works with integer and decimal values. */
	SetMinutesAfterMidnight(minutes: number): void;
	/** Fired whenever a property of Lighting is changed, or a skybox is added or removed. Skyboxes are of type 'Sky' and should be parented directly to lighting. */
	readonly LightingChanged: RBXScriptSignal<(skyboxChanged: boolean) => void>;
}
type Lighting = Rbx_Lighting & Base<Rbx_Lighting> & Indexable<Rbx_Lighting>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "Lighting"): Lighting;
}

// LocalStorageService
interface Rbx_LocalStorageService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__62: never;
}
type LocalStorageService = Rbx_LocalStorageService & Base<Rbx_LocalStorageService> & Indexable<Rbx_LocalStorageService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "LocalStorageService"): LocalStorageService;
}

// AppStorageService
interface Rbx_AppStorageService extends Rbx_LocalStorageService {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__63: never;
}
type AppStorageService = Rbx_AppStorageService & Base<Rbx_AppStorageService> & Indexable<Rbx_AppStorageService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "AppStorageService"): AppStorageService;
}

// UserStorageService
interface Rbx_UserStorageService extends Rbx_LocalStorageService {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__64: never;
}
type UserStorageService = Rbx_UserStorageService & Base<Rbx_UserStorageService> & Indexable<Rbx_UserStorageService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "UserStorageService"): UserStorageService;
}

// LocalizationService
interface Rbx_LocalizationService extends Rbx_Instance {
	readonly RobloxLocaleId: string;
	readonly SystemLocaleId: string;
	GetCorescriptLocalizations(): Array<Instance>;
	GetTableEntries(instance?: Instance): unknown;
	GetTranslatorForLocaleAsync(locale: string): Instance | undefined;
	GetTranslatorForPlayerAsync(player: Instance): Instance | undefined;
}
type LocalizationService = Rbx_LocalizationService & Base<Rbx_LocalizationService> & Indexable<Rbx_LocalizationService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "LocalizationService"): LocalizationService;
}

// LocalizationTable
interface Rbx_LocalizationTable extends Rbx_Instance {
	SourceLocaleId: string;
	RemoveEntry(key: string, source: string, context: string): void;
	RemoveEntryValue(key: string, source: string, context: string, localeId: string): void;
	RemoveTargetLocale(localeId: string): void;
	SetEntries(entries?: any): void;
	SetEntryContext(key: string, source: string, context: string, newContext: string): void;
	SetEntryExample(key: string, source: string, context: string, example: string): void;
	SetEntryKey(key: string, source: string, context: string, newKey: string): void;
	SetEntrySource(key: string, source: string, context: string, newSource: string): void;
	SetEntryValue(key: string, source: string, context: string, localeId: string, text: string): void;
}
type LocalizationTable = Rbx_LocalizationTable & Base<Rbx_LocalizationTable> & Indexable<Rbx_LocalizationTable>;

// LogService
interface Rbx_LogService extends Rbx_Instance {
	readonly MessageOut: RBXScriptSignal<(message: string, messageType: Enum.MessageType) => void>;
}
type LogService = Rbx_LogService & Base<Rbx_LogService> & Indexable<Rbx_LogService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "LogService"): LogService;
}

// LoginService
interface Rbx_LoginService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__65: never;
}
type LoginService = Rbx_LoginService & Base<Rbx_LoginService> & Indexable<Rbx_LoginService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "LoginService"): LoginService;
}

// LuaSettings
interface Rbx_LuaSettings extends Rbx_Instance {
	AreScriptStartsReported: boolean;
	DefaultWaitTime: number;
	GcFrequency: number;
	GcLimit: number;
	GcPause: number;
	GcStepMul: number;
	WaitingThreadsBudget: number;
}
type LuaSettings = Rbx_LuaSettings & Base<Rbx_LuaSettings> & Indexable<Rbx_LuaSettings>;

// LuaSourceContainer
interface Rbx_LuaSourceContainer extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__66: never;
}
type LuaSourceContainer = Rbx_LuaSourceContainer & Base<Rbx_LuaSourceContainer> & Indexable<Rbx_LuaSourceContainer>;

// BaseScript
interface Rbx_BaseScript extends Rbx_LuaSourceContainer {
	Disabled: boolean;
	LinkedSource: string;
}
type BaseScript = Rbx_BaseScript & Base<Rbx_BaseScript> & Indexable<Rbx_BaseScript>;

// CoreScript
interface Rbx_CoreScript extends Rbx_BaseScript {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__67: never;
}
type CoreScript = Rbx_CoreScript & Base<Rbx_CoreScript> & Indexable<Rbx_CoreScript>;

// Script
interface Rbx_Script extends Rbx_BaseScript {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__68: never;
}
type Script = Rbx_Script & Base<Rbx_Script> & Indexable<Rbx_Script>;

// LocalScript
interface Rbx_LocalScript extends Rbx_Script {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__69: never;
}
type LocalScript = Rbx_LocalScript & Base<Rbx_LocalScript> & Indexable<Rbx_LocalScript>;

// ModuleScript
interface Rbx_ModuleScript extends Rbx_LuaSourceContainer {
	LinkedSource: string;
}
type ModuleScript = Rbx_ModuleScript & Base<Rbx_ModuleScript> & Indexable<Rbx_ModuleScript>;

// LuaWebService
interface Rbx_LuaWebService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__70: never;
}
type LuaWebService = Rbx_LuaWebService & Base<Rbx_LuaWebService> & Indexable<Rbx_LuaWebService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "LuaWebService"): LuaWebService;
}

// MarketplaceService
interface Rbx_MarketplaceService extends Rbx_Instance {
	GetDeveloperProductsAsync(): Instance | undefined;
	UserOwnsGamePassAsync(userId: number, gamePassId: number): boolean;
}
type MarketplaceService = Rbx_MarketplaceService & Base<Rbx_MarketplaceService> & Indexable<Rbx_MarketplaceService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "MarketplaceService"): MarketplaceService;
}

// Message
interface Rbx_Message extends Rbx_Instance {
	Text: string;
}
type Message = Rbx_Message & Base<Rbx_Message> & Indexable<Rbx_Message>;

// Hint
interface Rbx_Hint extends Rbx_Message {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__71: never;
}
type Hint = Rbx_Hint & Base<Rbx_Hint> & Indexable<Rbx_Hint>;

// MessagingService
interface Rbx_MessagingService extends Rbx_Instance {
	PublishAsync(topic: string, message?: any): void;
	SubscribeAsync(topic: string, callback: Function): RBXScriptConnection;
}
type MessagingService = Rbx_MessagingService & Base<Rbx_MessagingService> & Indexable<Rbx_MessagingService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "MessagingService"): MessagingService;
}

// Mouse
interface Rbx_Mouse extends Rbx_Instance {
	/** The CoordinateFrame of where the Mouse ray is currently hitting a 3D object in the Workspace.  If the mouse is not over any 3D objects in the Workspace, this property is nil. */
	readonly Hit: CFrame;
	/** The current Texture of the Mouse Icon. Stored as a string, for more information on how to format the string [go here](http://wiki.roblox.com/index.php/Content) */
	Icon: string;
	/** The CoordinateFrame of where the Mouse is when the mouse is not clicking. */
	readonly Origin: CFrame;
	/** The Part the mouse is currently over. If the mouse is not currently over any object (on the skybox, for example) this property is nil. */
	readonly Target: BasePart;
	/** A Part or Model that the Mouse will ignore when trying to find the Target, TargetSurface and Hit. */
	TargetFilter: Instance | undefined;
	/** The NormalId (Top, Left, Down, etc.) of the face of the part the Mouse is currently over. */
	readonly TargetSurface: Enum.NormalId;
	/** The Unit Ray from where the mouse is (Origin) to the current Mouse.Target. */
	readonly UnitRay: Ray;
	/** The viewport's (game window) width in pixels. */
	readonly ViewSizeX: number;
	/** The viewport's (game window) height in pixels. */
	readonly ViewSizeY: number;
	/** The absolute pixel position of the Mouse along the x-axis of the viewport (game window). Values start at 0 on the left hand side of the screen and increase to the right. */
	readonly X: number;
	/** The absolute pixel position of the Mouse along the y-axis of the viewport (game window). Values start at 0 on the top of the screen and increase to the bottom. */
	readonly Y: number;
	/** Fired when the first button (usually the left, but could be another) on the mouse is depressed. */
	readonly Button1Down: RBXScriptSignal<() => void>;
	/** Fired when the first button (usually the left, but could be another) on the mouse is release. */
	readonly Button1Up: RBXScriptSignal<() => void>;
	/** This event is currently non-operational. */
	readonly Button2Down: RBXScriptSignal<() => void>;
	/** This event is currently non-operational. */
	readonly Button2Up: RBXScriptSignal<() => void>;
	/** Fired constantly when the mouse is not firing any other event (i.e. the mouse isn't moving, nor any buttons being pressed or depressed). */
	readonly Idle: RBXScriptSignal<() => void>;
	/** Fired when the mouse X or Y member changes. */
	readonly Move: RBXScriptSignal<() => void>;
	/** This event is currently non-operational. */
	readonly WheelBackward: RBXScriptSignal<() => void>;
	/** This event is currently non-operational. */
	readonly WheelForward: RBXScriptSignal<() => void>;
}
type Mouse = Rbx_Mouse & Base<Rbx_Mouse> & Indexable<Rbx_Mouse>;

// PlayerMouse
interface Rbx_PlayerMouse extends Rbx_Mouse {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__72: never;
}
type PlayerMouse = Rbx_PlayerMouse & Base<Rbx_PlayerMouse> & Indexable<Rbx_PlayerMouse>;

// PluginMouse
interface Rbx_PluginMouse extends Rbx_Mouse {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__73: never;
}
type PluginMouse = Rbx_PluginMouse & Base<Rbx_PluginMouse> & Indexable<Rbx_PluginMouse>;

// MouseService
interface Rbx_MouseService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__74: never;
}
type MouseService = Rbx_MouseService & Base<Rbx_MouseService> & Indexable<Rbx_MouseService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "MouseService"): MouseService;
}

// NetworkMarker
interface Rbx_NetworkMarker extends Rbx_Instance {
	readonly Received: RBXScriptSignal<() => void>;
}
type NetworkMarker = Rbx_NetworkMarker & Base<Rbx_NetworkMarker> & Indexable<Rbx_NetworkMarker>;

// NetworkPeer
interface Rbx_NetworkPeer extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__75: never;
}
type NetworkPeer = Rbx_NetworkPeer & Base<Rbx_NetworkPeer> & Indexable<Rbx_NetworkPeer>;

// NetworkClient
interface Rbx_NetworkClient extends Rbx_NetworkPeer {
	Ticket: string;
	readonly ConnectionAccepted: RBXScriptSignal<(peer: string, replicator: Instance) => void>;
	readonly ConnectionFailed: RBXScriptSignal<(peer: string, code: number, reason: string) => void>;
	readonly ConnectionRejected: RBXScriptSignal<(peer: string) => void>;
}
type NetworkClient = Rbx_NetworkClient & Base<Rbx_NetworkClient> & Indexable<Rbx_NetworkClient>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "NetworkClient"): NetworkClient;
}

// NetworkServer
interface Rbx_NetworkServer extends Rbx_NetworkPeer {
	readonly Port: number;
}
type NetworkServer = Rbx_NetworkServer & Base<Rbx_NetworkServer> & Indexable<Rbx_NetworkServer>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "NetworkServer"): NetworkServer;
}

// NetworkReplicator
interface Rbx_NetworkReplicator extends Rbx_Instance {
	GetPlayer(): Instance | undefined;
}
type NetworkReplicator = Rbx_NetworkReplicator & Base<Rbx_NetworkReplicator> & Indexable<Rbx_NetworkReplicator>;

// ClientReplicator
interface Rbx_ClientReplicator extends Rbx_NetworkReplicator {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__76: never;
}
type ClientReplicator = Rbx_ClientReplicator & Base<Rbx_ClientReplicator> & Indexable<Rbx_ClientReplicator>;

// ServerReplicator
interface Rbx_ServerReplicator extends Rbx_NetworkReplicator {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__77: never;
}
type ServerReplicator = Rbx_ServerReplicator & Base<Rbx_ServerReplicator> & Indexable<Rbx_ServerReplicator>;

// NetworkSettings
interface Rbx_NetworkSettings extends Rbx_Instance {
	ArePhysicsRejectionsReported: boolean;
	ClientPhysicsSendRate: number;
	DataGCRate: number;
	DataMtuAdjust: number;
	DataSendPriority: Enum.PacketPriority;
	DataSendRate: number;
	IncommingReplicationLag: number;
	IsQueueErrorComputed: boolean;
	NetworkOwnerRate: number;
	PhysicsMtuAdjust: number;
	PhysicsSendPriority: Enum.PacketPriority;
	PhysicsSendRate: number;
	PreferredClientPort: number;
	PrintBits: boolean;
	PrintEvents: boolean;
	PrintFilters: boolean;
	PrintInstances: boolean;
	PrintPhysicsErrors: boolean;
	PrintProperties: boolean;
	PrintSplitMessage: boolean;
	PrintStreamInstanceQuota: boolean;
	PrintTouches: boolean;
	ProxyEnabled: boolean;
	ProxyURL: string;
	ReceiveRate: number;
	RenderStreamedRegions: boolean;
	ShowActiveAnimationAsset: boolean;
	TouchSendRate: number;
	TrackDataTypes: boolean;
	TrackPhysicsDetails: boolean;
	UsePhysicsPacketCache: boolean;
}
type NetworkSettings = Rbx_NetworkSettings & Base<Rbx_NetworkSettings> & Indexable<Rbx_NetworkSettings>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "NetworkSettings"): NetworkSettings;
}

// NotificationService
interface Rbx_NotificationService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__78: never;
}
type NotificationService = Rbx_NotificationService & Base<Rbx_NotificationService> & Indexable<Rbx_NotificationService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "NotificationService"): NotificationService;
}

// PVInstance
interface Rbx_PVInstance extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__79: never;
}
type PVInstance = Rbx_PVInstance & Base<Rbx_PVInstance> & Indexable<Rbx_PVInstance>;

// BasePart
interface Rbx_BasePart extends Rbx_PVInstance {
	/** Determines whether or not physics acts upon the Part.  If true, part stays 'Anchored' in space, not moving regardless of any collision/forces acting upon it.  If false, physics works normally on the part. */
	Anchored: boolean;
	BackParamA: number;
	BackParamB: number;
	BackSurface: Enum.SurfaceType;
	BackSurfaceInput: Enum.InputType;
	BottomParamA: number;
	BottomParamB: number;
	BottomSurface: Enum.SurfaceType;
	BottomSurfaceInput: Enum.InputType;
	BrickColor: BrickColor;
	/** Contains information regarding the Part's position and a matrix that defines the Part's rotation.  Can read/write. [More info](http://wiki.roblox.com/index.php/Cframe) */
	CFrame: CFrame;
	/** Determines whether physical interactions with other Parts are respected.  If true, will collide and react with physics to other Parts.  If false, other parts will pass thru instead of colliding */
	CanCollide: boolean;
	readonly CenterOfMass: Vector3;
	CollisionGroupId: number;
	/** Color3 of the part. */
	Color: Color3;
	CustomPhysicalProperties: PhysicalProperties;
	FrontParamA: number;
	FrontParamB: number;
	FrontSurface: Enum.SurfaceType;
	FrontSurfaceInput: Enum.InputType;
	LeftParamA: number;
	LeftParamB: number;
	LeftSurface: Enum.SurfaceType;
	LeftSurfaceInput: Enum.InputType;
	LocalTransparencyModifier: number;
	/** Determines whether building tools (in-game and studio) can manipulate this Part.  If true, no editing allowed.  If false, editing is allowed. */
	Locked: boolean;
	/** If true the part will be massless when welded to another part that is not massless. The part will still have mass like a normal part if it is an assembly root part according to GetRootPart(). */
	Massless: boolean;
	/** Specifies the look and feel the Part should have.  Note: this does not define the color the Part is, see BrickColor for that. [More info](http://wiki.roblox.com/index.php/Material) */
	Material: Enum.Material;
	/** Rotation around X, Y, and Z axis.  Rotations applied in YXZ order. */
	Orientation: Vector3;
	Position: Vector3;
	readonly ReceiveAge: number;
	/** Specifies how shiny the Part is. A value of 1 is completely reflective (chrome), while a value of 0 is no reflectance (concrete wall) */
	Reflectance: number;
	/** Sets the value for the smallest change in size allowable by the Resize(NormalId, int) function. */
	readonly ResizeIncrement: number;
	/** Sets the value for the faces allowed to be resized by the Resize(NormalId, int) function. */
	readonly ResizeableFaces: Faces;
	RightParamA: number;
	RightParamB: number;
	RightSurface: Enum.SurfaceType;
	RightSurfaceInput: Enum.InputType;
	/** An integer from -127 to 127. Compares before other all other part properties besides massless for deciding which part is the assembly root part according to GetRootPart(). */
	RootPriority: number;
	RotVelocity: Vector3;
	Rotation: Vector3;
	Size: Vector3;
	TopParamA: number;
	TopParamB: number;
	TopSurface: Enum.SurfaceType;
	TopSurfaceInput: Enum.InputType;
	/** Sets how visible an object is. A value of 1 makes the object invisible, while a value of 0 makes the object opaque. */
	Transparency: number;
	/** How fast the Part is traveling in studs/second. This property is NOT recommended to be modified directly, unless there is good reason.  Otherwise, try using a BodyForce to move a Part. */
	Velocity: Vector3;
	/** Destroys SurfaceJoints with all parts that are touching this Instance (including internal joints in the Instance, as in a Model). */
	BreakJoints(): void;
	/** Returns a number that is the mass of this Instance.  Mass of a Part is immutable, and is changed only by the size of the Part. */
	GetMass(): number;
	GetNetworkOwnershipAuto(): boolean;
	IsGrounded(): boolean;
	/** Creates the appropriate SurfaceJoints with all parts that are touching this Instance (including internal joints in the Instance, as in a Model).  This uses the SurfaceTypes defined on the surfaces of parts to create the appropriate welds. [More info](http://wiki.roblox.com/index.php/MakeJoints) */
	MakeJoints(): void;
	/** Resizes a Part in the direction of the face defined by 'NormalId', by the amount specified by 'deltaAmount'. If the operation will expand the part to intersect another Instance, the part will not resize at all.  Return true if the call is successful, false otherwise. */
	Resize(normalId: Enum.NormalId, deltaAmount: number): boolean;
	SetNetworkOwnershipAuto(): void;
}
type BasePart = Rbx_BasePart & Base<Rbx_BasePart> & Indexable<Rbx_BasePart>;

// CornerWedgePart
interface Rbx_CornerWedgePart extends Rbx_BasePart {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__80: never;
}
type CornerWedgePart = Rbx_CornerWedgePart & Base<Rbx_CornerWedgePart> & Indexable<Rbx_CornerWedgePart>;

// FormFactorPart
interface Rbx_FormFactorPart extends Rbx_BasePart {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__81: never;
}
type FormFactorPart = Rbx_FormFactorPart & Base<Rbx_FormFactorPart> & Indexable<Rbx_FormFactorPart>;

// Part
interface Rbx_Part extends Rbx_FormFactorPart {
	Shape: Enum.PartType;
}
type Part = Rbx_Part & Base<Rbx_Part> & Indexable<Rbx_Part>;

// FlagStand
interface Rbx_FlagStand extends Rbx_Part {
	TeamColor: BrickColor;
}
type FlagStand = Rbx_FlagStand & Base<Rbx_FlagStand> & Indexable<Rbx_FlagStand>;

// Platform
interface Rbx_Platform extends Rbx_Part {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__82: never;
}
type Platform = Rbx_Platform & Base<Rbx_Platform> & Indexable<Rbx_Platform>;

// Seat
interface Rbx_Seat extends Rbx_Part {
	Disabled: boolean;
	readonly Occupant: Humanoid;
	Sit(humanoid: Instance): void;
}
type Seat = Rbx_Seat & Base<Rbx_Seat> & Indexable<Rbx_Seat>;

// SkateboardPlatform
interface Rbx_SkateboardPlatform extends Rbx_Part {
	readonly Controller: SkateboardController;
	readonly ControllingHumanoid: Humanoid;
	Steer: number;
	StickyWheels: boolean;
	Throttle: number;
	ApplySpecificImpulse(impulseWorld: Vector3): void;
	readonly Equipped: RBXScriptSignal<(humanoid: Instance, skateboardController: Instance) => void>;
	readonly MoveStateChanged: RBXScriptSignal<(newState: Enum.MoveState, oldState: Enum.MoveState) => void>;
	readonly Unequipped: RBXScriptSignal<(humanoid: Instance) => void>;
}
type SkateboardPlatform = Rbx_SkateboardPlatform & Base<Rbx_SkateboardPlatform> & Indexable<Rbx_SkateboardPlatform>;

// SpawnLocation
interface Rbx_SpawnLocation extends Rbx_Part {
	AllowTeamChangeOnTouch: boolean;
	Duration: number;
	Enabled: boolean;
	Neutral: boolean;
	TeamColor: BrickColor;
}
type SpawnLocation = Rbx_SpawnLocation & Base<Rbx_SpawnLocation> & Indexable<Rbx_SpawnLocation>;

// WedgePart
interface Rbx_WedgePart extends Rbx_FormFactorPart {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__83: never;
}
type WedgePart = Rbx_WedgePart & Base<Rbx_WedgePart> & Indexable<Rbx_WedgePart>;

// MeshPart
interface Rbx_MeshPart extends Rbx_BasePart {
	readonly MeshId: string;
	TextureID: string;
}
type MeshPart = Rbx_MeshPart & Base<Rbx_MeshPart> & Indexable<Rbx_MeshPart>;

// PartOperation
interface Rbx_PartOperation extends Rbx_BasePart {
	readonly RenderFidelity: Enum.RenderFidelity;
	readonly TriangleCount: number;
	UsePartColor: boolean;
}
type PartOperation = Rbx_PartOperation & Base<Rbx_PartOperation> & Indexable<Rbx_PartOperation>;

// NegateOperation
interface Rbx_NegateOperation extends Rbx_PartOperation {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__84: never;
}
type NegateOperation = Rbx_NegateOperation & Base<Rbx_NegateOperation> & Indexable<Rbx_NegateOperation>;

// UnionOperation
interface Rbx_UnionOperation extends Rbx_PartOperation {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__85: never;
}
type UnionOperation = Rbx_UnionOperation & Base<Rbx_UnionOperation> & Indexable<Rbx_UnionOperation>;

// Terrain
interface Rbx_Terrain extends Rbx_BasePart {
	readonly MaxExtents: Region3int16;
	WaterColor: Color3;
	WaterReflectance: number;
	WaterTransparency: number;
	WaterWaveSize: number;
	WaterWaveSpeed: number;
	CellCenterToWorld(x: number, y: number, z: number): Vector3;
	CellCornerToWorld(x: number, y: number, z: number): Vector3;
	Clear(): void;
	CountCells(): number;
	FillBall(center: Vector3, radius: number, material: Enum.Material): void;
	FillBlock(cframe: CFrame, size: Vector3, material: Enum.Material): void;
	FillRegion(region: Region3, resolution: number, material: Enum.Material): void;
	GetMaterialColor(material: Enum.Material): Color3;
	SetMaterialColor(material: Enum.Material, value: Color3): void;
	WorldToCell(position: Vector3): Vector3;
	WorldToCellPreferEmpty(position: Vector3): Vector3;
	WorldToCellPreferSolid(position: Vector3): Vector3;
}
type Terrain = Rbx_Terrain & Base<Rbx_Terrain> & Indexable<Rbx_Terrain>;

// TrussPart
interface Rbx_TrussPart extends Rbx_BasePart {
	Style: Enum.Style;
}
type TrussPart = Rbx_TrussPart & Base<Rbx_TrussPart> & Indexable<Rbx_TrussPart>;

// VehicleSeat
interface Rbx_VehicleSeat extends Rbx_BasePart {
	readonly AreHingesDetected: number;
	Disabled: boolean;
	HeadsUpDisplay: boolean;
	MaxSpeed: number;
	readonly Occupant: Humanoid;
	Steer: number;
	SteerFloat: number;
	Throttle: number;
	ThrottleFloat: number;
	Torque: number;
	TurnSpeed: number;
	Sit(humanoid: Instance): void;
}
type VehicleSeat = Rbx_VehicleSeat & Base<Rbx_VehicleSeat> & Indexable<Rbx_VehicleSeat>;

// Model
interface Rbx_Model extends Rbx_PVInstance {
	/** Breaks all surface joints contained within */
	BreakJoints(): void;
	GetExtentsSize(): Vector3;
	/** Returns the cframe of the Model.PrimaryPart. If PrimaryPart is nil, then this function will throw an error. */
	GetPrimaryPartCFrame(): CFrame;
	/** Creates the appropriate SurfaceJoints between all touching Parts contrained within the model. Technically, this function calls MakeJoints() on all Parts inside the model. */
	MakeJoints(): void;
	/** Moves the centroid of the Model to the specified location, respecting all relative distances between parts in the model. */
	MoveTo(position: Vector3): void;
	/** Sets the cframe of the Model.PrimaryPart. If PrimaryPart is nil, then this function will throw an error. This also sets the cframe of all descendant Parts relative to the cframe change to PrimaryPart. */
	SetPrimaryPartCFrame(cframe: CFrame): void;
	/** Similar to MoveTo(), except instead of moving to an explicit location, we use the model's current CFrame location and offset it. */
	TranslateBy(delta: Vector3): void;
}
type Model = Rbx_Model & Base<Rbx_Model> & Indexable<Rbx_Model>;

// Status
interface Rbx_Status extends Rbx_Model {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__86: never;
}
type Status = Rbx_Status & Base<Rbx_Status> & Indexable<Rbx_Status>;

// Workspace
interface Rbx_Workspace extends Rbx_Model {
	AllowThirdPartySales: boolean;
	CurrentCamera: Camera;
	DistributedGameTime: number;
	/** Sets the height at which falling characters and parts are destroyed. This property is not scriptable and can only be set in Studio */
	readonly FallenPartsDestroyHeight: number;
	readonly FilteringEnabled: boolean;
	Gravity: number;
	StreamingEnabled: boolean;
	/** Returns parts in the area defined by the Region3, up to specified maxCount or 100, whichever is less */
	FindPartsInRegion3(region: Region3, ignoreDescendantsInstance?: Instance, maxParts?: number): Array<Instance>;
	/** Returns parts in the area defined by the Region3, up to specified maxCount or 100, whichever is less */
	FindPartsInRegion3WithIgnoreList(region: Region3, ignoreDescendantsTable: Array<Instance>, maxParts?: number): Array<Instance>;
	FindPartsInRegion3WithWhiteList(region: Region3, whitelistDescendantsTable: Array<Instance>, maxParts?: number): Array<Instance>;
	GetNumAwakeParts(): number;
	GetPhysicsThrottling(): number;
	GetRealPhysicsFPS(): number;
	IsRegion3Empty(region: Region3, ignoreDescendentsInstance?: Instance): boolean;
	IsRegion3EmptyWithIgnoreList(region: Region3, ignoreDescendentsTable: Array<Instance>): boolean;
	JoinToOutsiders(objects: Array<Instance>, jointType: Enum.JointCreationMode): void;
	PGSIsEnabled(): boolean;
	UnjoinFromOutsiders(objects: Array<Instance>): void;
}
type Workspace = Rbx_Workspace & Base<Rbx_Workspace> & Indexable<Rbx_Workspace>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "Workspace"): Workspace;
}

// PackageLink
interface Rbx_PackageLink extends Rbx_Instance {
	readonly PackageId: string;
	readonly VersionNumber: number;
}
type PackageLink = Rbx_PackageLink & Base<Rbx_PackageLink> & Indexable<Rbx_PackageLink>;

// Pages
interface Rbx_Pages extends Rbx_Instance {
	readonly IsFinished: boolean;
	GetCurrentPage(): unknown;
	AdvanceToNextPageAsync(): void;
}
type Pages = Rbx_Pages & Base<Rbx_Pages> & Indexable<Rbx_Pages>;

// DataStorePages
interface Rbx_DataStorePages extends Rbx_Pages {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__87: never;
}
type DataStorePages = Rbx_DataStorePages & Base<Rbx_DataStorePages> & Indexable<Rbx_DataStorePages>;

// FriendPages
interface Rbx_FriendPages extends Rbx_Pages {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__88: never;
}
type FriendPages = Rbx_FriendPages & Base<Rbx_FriendPages> & Indexable<Rbx_FriendPages>;

// InventoryPages
interface Rbx_InventoryPages extends Rbx_Pages {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__89: never;
}
type InventoryPages = Rbx_InventoryPages & Base<Rbx_InventoryPages> & Indexable<Rbx_InventoryPages>;

// StandardPages
interface Rbx_StandardPages extends Rbx_Pages {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__90: never;
}
type StandardPages = Rbx_StandardPages & Base<Rbx_StandardPages> & Indexable<Rbx_StandardPages>;

// PartOperationAsset
interface Rbx_PartOperationAsset extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__91: never;
}
type PartOperationAsset = Rbx_PartOperationAsset & Base<Rbx_PartOperationAsset> & Indexable<Rbx_PartOperationAsset>;

// ParticleEmitter
interface Rbx_ParticleEmitter extends Rbx_Instance {
	Acceleration: Vector3;
	Color: ColorSequence;
	Drag: number;
	EmissionDirection: Enum.NormalId;
	Enabled: boolean;
	Lifetime: NumberRange;
	LightEmission: number;
	/** Specifies the amount of influence lighting has on the particle emmitter. A value of 0 is unlit, 1 is fully lit. Fractional values blend from unlit to lit. */
	LightInfluence: number;
	LockedToPart: boolean;
	Rate: number;
	RotSpeed: NumberRange;
	Rotation: NumberRange;
	Size: NumberSequence;
	Speed: NumberRange;
	SpreadAngle: Vector2;
	Texture: string;
	Transparency: NumberSequence;
	VelocityInheritance: number;
	ZOffset: number;
	Clear(): void;
	Emit(particleCount?: number): void;
}
type ParticleEmitter = Rbx_ParticleEmitter & Base<Rbx_ParticleEmitter> & Indexable<Rbx_ParticleEmitter>;

// Path
interface Rbx_Path extends Rbx_Instance {
	readonly Status: Enum.PathStatus;
	CheckOcclusionAsync(start: number): number;
	ComputeAsync(start: Vector3, finish: Vector3): void;
	readonly Blocked: RBXScriptSignal<(blockedWaypointIdx: number) => void>;
}
type Path = Rbx_Path & Base<Rbx_Path> & Indexable<Rbx_Path>;

// PathfindingService
interface Rbx_PathfindingService extends Rbx_Instance {
}
type PathfindingService = Rbx_PathfindingService & Base<Rbx_PathfindingService> & Indexable<Rbx_PathfindingService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "PathfindingService"): PathfindingService;
}

// PhysicsPacketCache
interface Rbx_PhysicsPacketCache extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__92: never;
}
type PhysicsPacketCache = Rbx_PhysicsPacketCache & Base<Rbx_PhysicsPacketCache> & Indexable<Rbx_PhysicsPacketCache>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "PhysicsPacketCache"): PhysicsPacketCache;
}

// PhysicsService
interface Rbx_PhysicsService extends Rbx_Instance {
	CollisionGroupContainsPart(name: string, part: Instance): boolean;
	CollisionGroupSetCollidable(name1: string, name2: string, collidable: boolean): void;
	CollisionGroupsAreCollidable(name1: string, name2: string): boolean;
	CreateCollisionGroup(name: string): number;
	GetCollisionGroupId(name: string): number;
	GetCollisionGroupName(name: number): string;
	GetMaxCollisionGroups(): number;
	RemoveCollisionGroup(name: string): void;
	RenameCollisionGroup(from: string, to: string): void;
	SetPartCollisionGroup(part: Instance, name: string): void;
}
type PhysicsService = Rbx_PhysicsService & Base<Rbx_PhysicsService> & Indexable<Rbx_PhysicsService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "PhysicsService"): PhysicsService;
}

// PhysicsSettings
interface Rbx_PhysicsSettings extends Rbx_Instance {
	AllowSleep: boolean;
	AreAnchorsShown: boolean;
	AreAssembliesShown: boolean;
	AreAwakePartsHighlighted: boolean;
	AreBodyTypesShown: boolean;
	AreContactIslandsShown: boolean;
	AreContactPointsShown: boolean;
	AreJointCoordinatesShown: boolean;
	AreMechanismsShown: boolean;
	AreModelCoordsShown: boolean;
	AreOwnersShown: boolean;
	ArePartCoordsShown: boolean;
	AreRegionsShown: boolean;
	AreUnalignedPartsShown: boolean;
	AreWorldCoordsShown: boolean;
	DisableCSGv2: boolean;
	IsReceiveAgeShown: boolean;
	IsTreeShown: boolean;
	PhysicsEnvironmentalThrottle: Enum.EnviromentalPhysicsThrottle;
	ShowDecompositionGeometry: boolean;
	ThrottleAdjustTime: number;
	UseCSGv2: boolean;
}
type PhysicsSettings = Rbx_PhysicsSettings & Base<Rbx_PhysicsSettings> & Indexable<Rbx_PhysicsSettings>;

// Player
interface Rbx_Player extends Rbx_Instance {
	readonly AccountAge: number;
	AutoJumpEnabled: boolean;
	CameraMaxZoomDistance: number;
	CameraMinZoomDistance: number;
	/** An enum that describes how a Player's camera is allowed to behave. [More info](http://wiki.roblox.com/index.php/CameraMode). */
	CameraMode: Enum.CameraMode;
	CanLoadCharacterAppearance: boolean;
	CharacterAppearanceId: number;
	DevCameraOcclusionMode: Enum.DevCameraOcclusionMode;
	DevComputerCameraMode: Enum.DevComputerCameraMovementMode;
	DevComputerMovementMode: Enum.DevComputerMovementMode;
	DevEnableMouseLock: boolean;
	DevTouchCameraMode: Enum.DevTouchCameraMovementMode;
	DevTouchMovementMode: Enum.DevTouchMovementMode;
	readonly FollowUserId: number;
	HealthDisplayDistance: number;
	readonly LocaleId: string;
	readonly MembershipType: Enum.MembershipType;
	NameDisplayDistance: number;
	Neutral: boolean;
	RespawnLocation: SpawnLocation;
	Team: Team;
	TeamColor: BrickColor;
	UserId: number;
	ClearCharacterAppearance(): void;
	DistanceFromCharacter(point: Vector3): number;
	GetJoinData(): object;
	HasAppearanceLoaded(): boolean;
	Kick(message?: string): void;
	Move(walkDirection: Vector3, relativeToCamera?: boolean): void;
	GetRankInGroup(groupId: number): number;
	GetRoleInGroup(groupId: number): string;
	IsFriendsWith(userId: number): boolean;
	IsInGroup(groupId: number): boolean;
	readonly Chatted: RBXScriptSignal<(message: string, recipient: Instance) => void>;
	/** Fired periodically after the user has been AFK for a while.  Currently this event is only fired for the *local* Player.  "time" is the time in seconds that the user has been idle. */
	readonly Idled: RBXScriptSignal<(time: number) => void>;
	readonly OnTeleport: RBXScriptSignal<(teleportState: Enum.TeleportState, placeId: number, spawnName: string) => void>;
}
type Player = Rbx_Player & Base<Rbx_Player> & Indexable<Rbx_Player>;

// PlayerScripts
interface Rbx_PlayerScripts extends Rbx_Instance {
	ClearComputerCameraMovementModes(): void;
	ClearComputerMovementModes(): void;
	ClearTouchCameraMovementModes(): void;
	ClearTouchMovementModes(): void;
	RegisterComputerCameraMovementMode(cameraMovementMode: Enum.ComputerCameraMovementMode): void;
	RegisterComputerMovementMode(movementMode: Enum.ComputerMovementMode): void;
	RegisterTouchCameraMovementMode(cameraMovementMode: Enum.TouchCameraMovementMode): void;
	RegisterTouchMovementMode(movementMode: Enum.TouchMovementMode): void;
}
type PlayerScripts = Rbx_PlayerScripts & Base<Rbx_PlayerScripts> & Indexable<Rbx_PlayerScripts>;

// Players
interface Rbx_Players extends Rbx_Instance {
	readonly BubbleChat: boolean;
	/** Set to true, when a player joins a game, they get a character automatically, as well as when they die.  When set to false, characters do not auto load and will only load in using Player:LoadCharacter(). */
	CharacterAutoLoads: boolean;
	readonly ClassicChat: boolean;
	readonly MaxPlayers: number;
	readonly PreferredPlayers: number;
	RespawnTime: number;
	GetNameFromUserIdAsync(userId: number): string;
	GetUserIdFromNameAsync(userName: string): number;
}
type Players = Rbx_Players & Base<Rbx_Players> & Indexable<Rbx_Players>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "Players"): Players;
}

// Plugin
interface Rbx_Plugin extends Rbx_Instance {
	readonly CollisionEnabled: boolean;
	readonly GridSize: number;
}
type Plugin = Rbx_Plugin & Base<Rbx_Plugin> & Indexable<Rbx_Plugin>;

// PluginAction
interface Rbx_PluginAction extends Rbx_Instance {
	readonly ActionId: string;
	readonly AllowBinding: boolean;
	readonly StatusTip: string;
	readonly Text: string;
}
type PluginAction = Rbx_PluginAction & Base<Rbx_PluginAction> & Indexable<Rbx_PluginAction>;

// PluginDragEvent
interface Rbx_PluginDragEvent extends Rbx_Instance {
	readonly Data: string;
	readonly MimeType: string;
	readonly Position: Vector2;
	readonly Sender: string;
}
type PluginDragEvent = Rbx_PluginDragEvent & Base<Rbx_PluginDragEvent> & Indexable<Rbx_PluginDragEvent>;

// PluginGuiService
interface Rbx_PluginGuiService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__93: never;
}
type PluginGuiService = Rbx_PluginGuiService & Base<Rbx_PluginGuiService> & Indexable<Rbx_PluginGuiService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "PluginGuiService"): PluginGuiService;
}

// PluginManager
interface Rbx_PluginManager extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__94: never;
}
type PluginManager = Rbx_PluginManager & Base<Rbx_PluginManager> & Indexable<Rbx_PluginManager>;

// PluginMenu
interface Rbx_PluginMenu extends Rbx_Instance {
	Icon: string;
	Title: string;
}
type PluginMenu = Rbx_PluginMenu & Base<Rbx_PluginMenu> & Indexable<Rbx_PluginMenu>;

// PluginToolbar
interface Rbx_PluginToolbar extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__95: never;
}
type PluginToolbar = Rbx_PluginToolbar & Base<Rbx_PluginToolbar> & Indexable<Rbx_PluginToolbar>;

// PluginToolbarButton
interface Rbx_PluginToolbarButton extends Rbx_Instance {
	ClickableWhenViewportHidden: boolean;
	Enabled: boolean;
	Icon: string;
}
type PluginToolbarButton = Rbx_PluginToolbarButton & Base<Rbx_PluginToolbarButton> & Indexable<Rbx_PluginToolbarButton>;

// PointsService
interface Rbx_PointsService extends Rbx_Instance {
	/** Fired when points are successfully awarded 'userId'. Also returns the updated balance of points for usedId in universe via 'userBalanceInUniverse', total points via 'userTotalBalance', and the amount points that were awarded via 'pointsAwarded'. This event fires on the server and also all clients in the game that awarded the points. */
	readonly PointsAwarded: RBXScriptSignal<(userId: number, pointsAwarded: number, userBalanceInGame: number, userTotalBalance: number) => void>;
}
type PointsService = Rbx_PointsService & Base<Rbx_PointsService> & Indexable<Rbx_PointsService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "PointsService"): PointsService;
}

// Pose
interface Rbx_Pose extends Rbx_Instance {
	CFrame: CFrame;
	EasingDirection: Enum.PoseEasingDirection;
	EasingStyle: Enum.PoseEasingStyle;
	Weight: number;
	AddSubPose(pose: Instance): void;
	GetSubPoses(): Array<Instance>;
	RemoveSubPose(pose: Instance): void;
}
type Pose = Rbx_Pose & Base<Rbx_Pose> & Indexable<Rbx_Pose>;

// PostEffect
interface Rbx_PostEffect extends Rbx_Instance {
	Enabled: boolean;
}
type PostEffect = Rbx_PostEffect & Base<Rbx_PostEffect> & Indexable<Rbx_PostEffect>;

// BloomEffect
interface Rbx_BloomEffect extends Rbx_PostEffect {
	Intensity: number;
	Size: number;
	Threshold: number;
}
type BloomEffect = Rbx_BloomEffect & Base<Rbx_BloomEffect> & Indexable<Rbx_BloomEffect>;

// BlurEffect
interface Rbx_BlurEffect extends Rbx_PostEffect {
	Size: number;
}
type BlurEffect = Rbx_BlurEffect & Base<Rbx_BlurEffect> & Indexable<Rbx_BlurEffect>;

// ColorCorrectionEffect
interface Rbx_ColorCorrectionEffect extends Rbx_PostEffect {
	Brightness: number;
	Contrast: number;
	Saturation: number;
	TintColor: Color3;
}
type ColorCorrectionEffect = Rbx_ColorCorrectionEffect & Base<Rbx_ColorCorrectionEffect> & Indexable<Rbx_ColorCorrectionEffect>;

// SunRaysEffect
interface Rbx_SunRaysEffect extends Rbx_PostEffect {
	Intensity: number;
	Spread: number;
}
type SunRaysEffect = Rbx_SunRaysEffect & Base<Rbx_SunRaysEffect> & Indexable<Rbx_SunRaysEffect>;

// ReflectionMetadata
interface Rbx_ReflectionMetadata extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__96: never;
}
type ReflectionMetadata = Rbx_ReflectionMetadata & Base<Rbx_ReflectionMetadata> & Indexable<Rbx_ReflectionMetadata>;

// ReflectionMetadataCallbacks
interface Rbx_ReflectionMetadataCallbacks extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__97: never;
}
type ReflectionMetadataCallbacks = Rbx_ReflectionMetadataCallbacks & Base<Rbx_ReflectionMetadataCallbacks> & Indexable<Rbx_ReflectionMetadataCallbacks>;

// ReflectionMetadataClasses
interface Rbx_ReflectionMetadataClasses extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__98: never;
}
type ReflectionMetadataClasses = Rbx_ReflectionMetadataClasses & Base<Rbx_ReflectionMetadataClasses> & Indexable<Rbx_ReflectionMetadataClasses>;

// ReflectionMetadataEnums
interface Rbx_ReflectionMetadataEnums extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__99: never;
}
type ReflectionMetadataEnums = Rbx_ReflectionMetadataEnums & Base<Rbx_ReflectionMetadataEnums> & Indexable<Rbx_ReflectionMetadataEnums>;

// ReflectionMetadataEvents
interface Rbx_ReflectionMetadataEvents extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__100: never;
}
type ReflectionMetadataEvents = Rbx_ReflectionMetadataEvents & Base<Rbx_ReflectionMetadataEvents> & Indexable<Rbx_ReflectionMetadataEvents>;

// ReflectionMetadataFunctions
interface Rbx_ReflectionMetadataFunctions extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__101: never;
}
type ReflectionMetadataFunctions = Rbx_ReflectionMetadataFunctions & Base<Rbx_ReflectionMetadataFunctions> & Indexable<Rbx_ReflectionMetadataFunctions>;

// ReflectionMetadataItem
interface Rbx_ReflectionMetadataItem extends Rbx_Instance {
	Browsable: boolean;
	ClassCategory: string;
	ClientOnly: boolean;
	Constraint: string;
	Deprecated: boolean;
	EditingDisabled: boolean;
	IsBackend: boolean;
	ScriptContext: string;
	ServerOnly: boolean;
	UIMaximum: number;
	UIMinimum: number;
	UINumTicks: number;
	summary: string;
}
type ReflectionMetadataItem = Rbx_ReflectionMetadataItem & Base<Rbx_ReflectionMetadataItem> & Indexable<Rbx_ReflectionMetadataItem>;

// ReflectionMetadataClass
interface Rbx_ReflectionMetadataClass extends Rbx_ReflectionMetadataItem {
	ExplorerImageIndex: number;
	ExplorerOrder: number;
	Insertable: boolean;
	PreferredParent: string;
	PreferredParents: string;
}
type ReflectionMetadataClass = Rbx_ReflectionMetadataClass & Base<Rbx_ReflectionMetadataClass> & Indexable<Rbx_ReflectionMetadataClass>;

// ReflectionMetadataEnum
interface Rbx_ReflectionMetadataEnum extends Rbx_ReflectionMetadataItem {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__102: never;
}
type ReflectionMetadataEnum = Rbx_ReflectionMetadataEnum & Base<Rbx_ReflectionMetadataEnum> & Indexable<Rbx_ReflectionMetadataEnum>;

// ReflectionMetadataEnumItem
interface Rbx_ReflectionMetadataEnumItem extends Rbx_ReflectionMetadataItem {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__103: never;
}
type ReflectionMetadataEnumItem = Rbx_ReflectionMetadataEnumItem & Base<Rbx_ReflectionMetadataEnumItem> & Indexable<Rbx_ReflectionMetadataEnumItem>;

// ReflectionMetadataMember
interface Rbx_ReflectionMetadataMember extends Rbx_ReflectionMetadataItem {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__104: never;
}
type ReflectionMetadataMember = Rbx_ReflectionMetadataMember & Base<Rbx_ReflectionMetadataMember> & Indexable<Rbx_ReflectionMetadataMember>;

// ReflectionMetadataProperties
interface Rbx_ReflectionMetadataProperties extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__105: never;
}
type ReflectionMetadataProperties = Rbx_ReflectionMetadataProperties & Base<Rbx_ReflectionMetadataProperties> & Indexable<Rbx_ReflectionMetadataProperties>;

// ReflectionMetadataYieldFunctions
interface Rbx_ReflectionMetadataYieldFunctions extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__106: never;
}
type ReflectionMetadataYieldFunctions = Rbx_ReflectionMetadataYieldFunctions & Base<Rbx_ReflectionMetadataYieldFunctions> & Indexable<Rbx_ReflectionMetadataYieldFunctions>;

// RemoteEvent
interface Rbx_RemoteEvent extends Rbx_Instance {
}
type RemoteEvent = Rbx_RemoteEvent & Base<Rbx_RemoteEvent> & Indexable<Rbx_RemoteEvent>;

// RemoteFunction
interface Rbx_RemoteFunction extends Rbx_Instance {
}
type RemoteFunction = Rbx_RemoteFunction & Base<Rbx_RemoteFunction> & Indexable<Rbx_RemoteFunction>;

// RenderSettings
interface Rbx_RenderSettings extends Rbx_Instance {
	AutoFRMLevel: number;
	EagerBulkExecution: boolean;
	EditQualityLevel: Enum.QualityLevel;
	EnableFRM: boolean;
	ExportMergeByMaterial: boolean;
	FrameRateManager: Enum.FramerateManagerMode;
	GraphicsMode: Enum.GraphicsMode;
	MeshCacheSize: number;
	QualityLevel: Enum.QualityLevel;
	ReloadAssets: boolean;
	RenderCSGTrianglesDebug: boolean;
	ShowBoundingBoxes: boolean;
	GetMaxQualityLevel(): number;
}
type RenderSettings = Rbx_RenderSettings & Base<Rbx_RenderSettings> & Indexable<Rbx_RenderSettings>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "RenderSettings"): RenderSettings;
}

// RenderingTest
interface Rbx_RenderingTest extends Rbx_Instance {
	CFrame: CFrame;
	ComparisonDiffThreshold: number;
	ComparisonMethod: Enum.RenderingTestComparisonMethod;
	ComparisonPsnrThreshold: number;
	Description: string;
	FieldOfView: number;
	Orientation: Vector3;
	Position: Vector3;
	QualityLevel: number;
	ShouldSkip: boolean;
	Ticket: string;
}
type RenderingTest = Rbx_RenderingTest & Base<Rbx_RenderingTest> & Indexable<Rbx_RenderingTest>;

// ReplicatedFirst
interface Rbx_ReplicatedFirst extends Rbx_Instance {
	RemoveDefaultLoadingScreen(): void;
}
type ReplicatedFirst = Rbx_ReplicatedFirst & Base<Rbx_ReplicatedFirst> & Indexable<Rbx_ReplicatedFirst>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ReplicatedFirst"): ReplicatedFirst;
}

// ReplicatedStorage
interface Rbx_ReplicatedStorage extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__107: never;
}
type ReplicatedStorage = Rbx_ReplicatedStorage & Base<Rbx_ReplicatedStorage> & Indexable<Rbx_ReplicatedStorage>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ReplicatedStorage"): ReplicatedStorage;
}

// RobloxReplicatedStorage
interface Rbx_RobloxReplicatedStorage extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__108: never;
}
type RobloxReplicatedStorage = Rbx_RobloxReplicatedStorage & Base<Rbx_RobloxReplicatedStorage> & Indexable<Rbx_RobloxReplicatedStorage>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "RobloxReplicatedStorage"): RobloxReplicatedStorage;
}

// RunService
interface Rbx_RunService extends Rbx_Instance {
	BindToRenderStep(name: string, priority: number, callback: Function): void;
	IsClient(): boolean;
	IsRunMode(): boolean;
	IsRunning(): boolean;
	IsServer(): boolean;
	IsStudio(): boolean;
	UnbindFromRenderStep(name: string): void;
	readonly Heartbeat: RBXScriptSignal<(step: number) => void>;
	readonly RenderStepped: RBXScriptSignal<(step: number) => void>;
	readonly Stepped: RBXScriptSignal<(time: number, step: number) => void>;
}
type RunService = Rbx_RunService & Base<Rbx_RunService> & Indexable<Rbx_RunService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "RunService"): RunService;
}

// RuntimeScriptService
interface Rbx_RuntimeScriptService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__109: never;
}
type RuntimeScriptService = Rbx_RuntimeScriptService & Base<Rbx_RuntimeScriptService> & Indexable<Rbx_RuntimeScriptService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "RuntimeScriptService"): RuntimeScriptService;
}

// ScriptContext
interface Rbx_ScriptContext extends Rbx_Instance {
	readonly Error: RBXScriptSignal<(message: string, stackTrace: string, script: Instance) => void>;
}
type ScriptContext = Rbx_ScriptContext & Base<Rbx_ScriptContext> & Indexable<Rbx_ScriptContext>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ScriptContext"): ScriptContext;
}

// ScriptDebugger
interface Rbx_ScriptDebugger extends Rbx_Instance {
	readonly CurrentLine: number;
	readonly IsDebugging: boolean;
	readonly IsPaused: boolean;
	readonly Script: Instance | undefined;
	AddWatch(expression: string): Instance | undefined;
	GetBreakpoints(): Array<Instance>;
	GetGlobals(): object;
	GetLocals(stackFrame?: number): object;
	GetStack(): unknown;
	GetUpvalues(stackFrame?: number): object;
	GetWatchValue(watch: Instance): unknown;
	GetWatches(): Array<Instance>;
	SetBreakpoint(line: number): Instance | undefined;
	SetGlobal(name: string, value?: any): void;
	SetLocal(name: string, value?: any, stackFrame?: number): void;
	SetUpvalue(name: string, value?: any, stackFrame?: number): void;
	readonly BreakpointAdded: RBXScriptSignal<(breakpoint: Instance) => void>;
	readonly BreakpointRemoved: RBXScriptSignal<(breakpoint: Instance) => void>;
	readonly EncounteredBreak: RBXScriptSignal<(line: number) => void>;
	readonly Resuming: RBXScriptSignal<() => void>;
	readonly WatchAdded: RBXScriptSignal<(watch: Instance) => void>;
	readonly WatchRemoved: RBXScriptSignal<(watch: Instance) => void>;
}
type ScriptDebugger = Rbx_ScriptDebugger & Base<Rbx_ScriptDebugger> & Indexable<Rbx_ScriptDebugger>;

// ScriptService
interface Rbx_ScriptService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__110: never;
}
type ScriptService = Rbx_ScriptService & Base<Rbx_ScriptService> & Indexable<Rbx_ScriptService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ScriptService"): ScriptService;
}

// Selection
interface Rbx_Selection extends Rbx_Instance {
	readonly SelectionChanged: RBXScriptSignal<() => void>;
}
type Selection = Rbx_Selection & Base<Rbx_Selection> & Indexable<Rbx_Selection>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "Selection"): Selection;
}

// ServerScriptService
interface Rbx_ServerScriptService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__111: never;
}
type ServerScriptService = Rbx_ServerScriptService & Base<Rbx_ServerScriptService> & Indexable<Rbx_ServerScriptService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ServerScriptService"): ServerScriptService;
}

// ServerStorage
interface Rbx_ServerStorage extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__112: never;
}
type ServerStorage = Rbx_ServerStorage & Base<Rbx_ServerStorage> & Indexable<Rbx_ServerStorage>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ServerStorage"): ServerStorage;
}

// ServiceProvider
interface Rbx_ServiceProvider extends Rbx_Instance {
	FindService(className: string): Instance | undefined;
	GetService(className: string): Instance | undefined;
	readonly Close: RBXScriptSignal<() => void>;
	readonly ServiceAdded: RBXScriptSignal<(service: Instance) => void>;
	readonly ServiceRemoving: RBXScriptSignal<(service: Instance) => void>;
}
type ServiceProvider = Rbx_ServiceProvider & Base<Rbx_ServiceProvider> & Indexable<Rbx_ServiceProvider>;

// DataModel
interface Rbx_DataModel extends Rbx_ServiceProvider {
	readonly CreatorId: number;
	readonly CreatorType: Enum.CreatorType;
	readonly GameId: number;
	readonly GearGenreSetting: Enum.GearGenreSetting;
	readonly Genre: Enum.Genre;
	readonly JobId: string;
	readonly PlaceId: number;
	readonly PlaceVersion: number;
	readonly PrivateServerId: string;
	readonly PrivateServerOwnerId: number;
	readonly Workspace: Workspace;
	BindToClose(callback: Function): void;
	IsGearTypeAllowed(gearType: Enum.GearType): boolean;
	IsLoaded(): boolean;
	readonly GraphicsQualityChangeRequest: RBXScriptSignal<(betterQuality: boolean) => void>;
	/** Fires when the game finishes loading.  Use this to know when to remove your custom loading gui.  It is best to check IsLoaded() before connecting to this event, as the game may load before the event is connected to. */
	readonly Loaded: RBXScriptSignal<() => void>;
}
type DataModel = Rbx_DataModel & Base<Rbx_DataModel> & Indexable<Rbx_DataModel>;

// GenericSettings
interface Rbx_GenericSettings extends Rbx_ServiceProvider {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__113: never;
}
type GenericSettings = Rbx_GenericSettings & Base<Rbx_GenericSettings> & Indexable<Rbx_GenericSettings>;

// AnalysticsSettings
interface Rbx_AnalysticsSettings extends Rbx_GenericSettings {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__114: never;
}
type AnalysticsSettings = Rbx_AnalysticsSettings & Base<Rbx_AnalysticsSettings> & Indexable<Rbx_AnalysticsSettings>;

// GlobalSettings
interface Rbx_GlobalSettings extends Rbx_GenericSettings {
	GetFFlag(name: string): boolean;
	GetFVariable(name: string): string;
}
type GlobalSettings = Rbx_GlobalSettings & Base<Rbx_GlobalSettings> & Indexable<Rbx_GlobalSettings>;

// UserSettings
interface Rbx_UserSettings extends Rbx_GenericSettings {
	IsUserFeatureEnabled(name: string): boolean;
	Reset(): void;
}
type UserSettings = Rbx_UserSettings & Base<Rbx_UserSettings> & Indexable<Rbx_UserSettings>;

// Sky
interface Rbx_Sky extends Rbx_Instance {
	CelestialBodiesShown: boolean;
	MoonAngularSize: number;
	MoonTextureId: string;
	SkyboxBk: string;
	SkyboxDn: string;
	SkyboxFt: string;
	SkyboxLf: string;
	SkyboxRt: string;
	SkyboxUp: string;
	StarCount: number;
	SunAngularSize: number;
	SunTextureId: string;
}
type Sky = Rbx_Sky & Base<Rbx_Sky> & Indexable<Rbx_Sky>;

// Smoke
interface Rbx_Smoke extends Rbx_Instance {
	Color: Color3;
	Enabled: boolean;
	Opacity: number;
	RiseVelocity: number;
	Size: number;
}
type Smoke = Rbx_Smoke & Base<Rbx_Smoke> & Indexable<Rbx_Smoke>;

// SocialService
interface Rbx_SocialService extends Rbx_Instance {
}
type SocialService = Rbx_SocialService & Base<Rbx_SocialService> & Indexable<Rbx_SocialService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "SocialService"): SocialService;
}

// Sound
interface Rbx_Sound extends Rbx_Instance {
	EmitterSize: number;
	readonly IsLoaded: boolean;
	readonly IsPaused: boolean;
	readonly IsPlaying: boolean;
	Looped: boolean;
	MaxDistance: number;
	/** The sound will play when it is removed from the Workspace. Looped sounds don't play */
	PlayOnRemove: boolean;
	readonly PlaybackLoudness: number;
	PlaybackSpeed: number;
	Playing: boolean;
	RollOffMode: Enum.RollOffMode;
	SoundGroup: SoundGroup;
	SoundId: string;
	readonly TimeLength: number;
	TimePosition: number;
	Volume: number;
	Pause(): void;
	Play(): void;
	Resume(): void;
	Stop(): void;
	readonly DidLoop: RBXScriptSignal<(soundId: string, numOfTimesLooped: number) => void>;
	readonly Ended: RBXScriptSignal<(soundId: string) => void>;
	readonly Loaded: RBXScriptSignal<(soundId: string) => void>;
	readonly Paused: RBXScriptSignal<(soundId: string) => void>;
	readonly Played: RBXScriptSignal<(soundId: string) => void>;
	readonly Resumed: RBXScriptSignal<(soundId: string) => void>;
	readonly Stopped: RBXScriptSignal<(soundId: string) => void>;
}
type Sound = Rbx_Sound & Base<Rbx_Sound> & Indexable<Rbx_Sound>;

// SoundEffect
interface Rbx_SoundEffect extends Rbx_Instance {
	Enabled: boolean;
	Priority: number;
}
type SoundEffect = Rbx_SoundEffect & Base<Rbx_SoundEffect> & Indexable<Rbx_SoundEffect>;

// ChorusSoundEffect
interface Rbx_ChorusSoundEffect extends Rbx_SoundEffect {
	Depth: number;
	Mix: number;
	Rate: number;
}
type ChorusSoundEffect = Rbx_ChorusSoundEffect & Base<Rbx_ChorusSoundEffect> & Indexable<Rbx_ChorusSoundEffect>;

// CompressorSoundEffect
interface Rbx_CompressorSoundEffect extends Rbx_SoundEffect {
	Attack: number;
	GainMakeup: number;
	Ratio: number;
	Release: number;
	SideChain: Instance | undefined;
	Threshold: number;
}
type CompressorSoundEffect = Rbx_CompressorSoundEffect & Base<Rbx_CompressorSoundEffect> & Indexable<Rbx_CompressorSoundEffect>;

// DistortionSoundEffect
interface Rbx_DistortionSoundEffect extends Rbx_SoundEffect {
	Level: number;
}
type DistortionSoundEffect = Rbx_DistortionSoundEffect & Base<Rbx_DistortionSoundEffect> & Indexable<Rbx_DistortionSoundEffect>;

// EchoSoundEffect
interface Rbx_EchoSoundEffect extends Rbx_SoundEffect {
	Delay: number;
	DryLevel: number;
	Feedback: number;
	WetLevel: number;
}
type EchoSoundEffect = Rbx_EchoSoundEffect & Base<Rbx_EchoSoundEffect> & Indexable<Rbx_EchoSoundEffect>;

// EqualizerSoundEffect
interface Rbx_EqualizerSoundEffect extends Rbx_SoundEffect {
	HighGain: number;
	LowGain: number;
	MidGain: number;
}
type EqualizerSoundEffect = Rbx_EqualizerSoundEffect & Base<Rbx_EqualizerSoundEffect> & Indexable<Rbx_EqualizerSoundEffect>;

// FlangeSoundEffect
interface Rbx_FlangeSoundEffect extends Rbx_SoundEffect {
	Depth: number;
	Mix: number;
	Rate: number;
}
type FlangeSoundEffect = Rbx_FlangeSoundEffect & Base<Rbx_FlangeSoundEffect> & Indexable<Rbx_FlangeSoundEffect>;

// PitchShiftSoundEffect
interface Rbx_PitchShiftSoundEffect extends Rbx_SoundEffect {
	Octave: number;
}
type PitchShiftSoundEffect = Rbx_PitchShiftSoundEffect & Base<Rbx_PitchShiftSoundEffect> & Indexable<Rbx_PitchShiftSoundEffect>;

// ReverbSoundEffect
interface Rbx_ReverbSoundEffect extends Rbx_SoundEffect {
	DecayTime: number;
	Density: number;
	Diffusion: number;
	DryLevel: number;
	WetLevel: number;
}
type ReverbSoundEffect = Rbx_ReverbSoundEffect & Base<Rbx_ReverbSoundEffect> & Indexable<Rbx_ReverbSoundEffect>;

// TremoloSoundEffect
interface Rbx_TremoloSoundEffect extends Rbx_SoundEffect {
	Depth: number;
	Duty: number;
	Frequency: number;
}
type TremoloSoundEffect = Rbx_TremoloSoundEffect & Base<Rbx_TremoloSoundEffect> & Indexable<Rbx_TremoloSoundEffect>;

// SoundGroup
interface Rbx_SoundGroup extends Rbx_Instance {
	Volume: number;
}
type SoundGroup = Rbx_SoundGroup & Base<Rbx_SoundGroup> & Indexable<Rbx_SoundGroup>;

// SoundService
interface Rbx_SoundService extends Rbx_Instance {
	/** The ambient sound environment.  May not work when using hardware sound */
	AmbientReverb: Enum.ReverbType;
	/** the relative distance factor, compared to 1.0 meters. */
	DistanceFactor: number;
	/** The doppler scale is a general scaling factor for how much the pitch varies due to doppler shifting in 3D sound. Doppler is the pitch bending effect when a sound comes towards the listener or moves away from it, much like the effect you hear when a train goes past you with its horn sounding. With dopplerscale you can exaggerate or diminish the effect. */
	DopplerScale: number;
	RespectFilteringEnabled: boolean;
	/** Setting this value makes the sound drop off faster or slower. The higher the value, the faster volume will attenuate, and conversely the lower the value, the slower it will attenuate. For example a rolloff factor of 1 will simulate the real world, where as a value of 2 will make sounds attenuate 2 times quicker. */
	RolloffScale: number;
	PlayLocalSound(sound: Instance): void;
}
type SoundService = Rbx_SoundService & Base<Rbx_SoundService> & Indexable<Rbx_SoundService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "SoundService"): SoundService;
}

// Sparkles
interface Rbx_Sparkles extends Rbx_Instance {
	Color: Color3;
	Enabled: boolean;
	SparkleColor: Color3;
}
type Sparkles = Rbx_Sparkles & Base<Rbx_Sparkles> & Indexable<Rbx_Sparkles>;

// SpawnerService
interface Rbx_SpawnerService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__115: never;
}
type SpawnerService = Rbx_SpawnerService & Base<Rbx_SpawnerService> & Indexable<Rbx_SpawnerService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "SpawnerService"): SpawnerService;
}

// StarterGear
interface Rbx_StarterGear extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__116: never;
}
type StarterGear = Rbx_StarterGear & Base<Rbx_StarterGear> & Indexable<Rbx_StarterGear>;

// StarterPlayer
interface Rbx_StarterPlayer extends Rbx_Instance {
	readonly AllowCustomAnimations: boolean;
	AutoJumpEnabled: boolean;
	CameraMaxZoomDistance: number;
	CameraMinZoomDistance: number;
	CameraMode: Enum.CameraMode;
	DevCameraOcclusionMode: Enum.DevCameraOcclusionMode;
	DevComputerCameraMovementMode: Enum.DevComputerCameraMovementMode;
	DevComputerMovementMode: Enum.DevComputerMovementMode;
	DevTouchCameraMovementMode: Enum.DevTouchCameraMovementMode;
	DevTouchMovementMode: Enum.DevTouchMovementMode;
	EnableMouseLockOption: boolean;
	HealthDisplayDistance: number;
	LoadCharacterAppearance: boolean;
	NameDisplayDistance: number;
}
type StarterPlayer = Rbx_StarterPlayer & Base<Rbx_StarterPlayer> & Indexable<Rbx_StarterPlayer>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "StarterPlayer"): StarterPlayer;
}

// StarterPlayerScripts
interface Rbx_StarterPlayerScripts extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__117: never;
}
type StarterPlayerScripts = Rbx_StarterPlayerScripts & Base<Rbx_StarterPlayerScripts> & Indexable<Rbx_StarterPlayerScripts>;

// StarterCharacterScripts
interface Rbx_StarterCharacterScripts extends Rbx_StarterPlayerScripts {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__118: never;
}
type StarterCharacterScripts = Rbx_StarterCharacterScripts & Base<Rbx_StarterCharacterScripts> & Indexable<Rbx_StarterCharacterScripts>;

// Stats
interface Rbx_Stats extends Rbx_Instance {
	readonly ContactsCount: number;
	readonly DataReceiveKbps: number;
	readonly DataSendKbps: number;
	readonly HeartbeatTimeMs: number;
	readonly InstanceCount: number;
	readonly MovingPrimitivesCount: number;
	readonly PhysicsReceiveKbps: number;
	readonly PhysicsSendKbps: number;
	readonly PhysicsStepTimeMs: number;
	readonly PrimitivesCount: number;
	GetMemoryUsageMbForTag(tag: Enum.DeveloperMemoryTag): number;
	GetTotalMemoryUsageMb(): number;
}
type Stats = Rbx_Stats & Base<Rbx_Stats> & Indexable<Rbx_Stats>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "Stats"): Stats;
}

// StatsItem
interface Rbx_StatsItem extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__119: never;
}
type StatsItem = Rbx_StatsItem & Base<Rbx_StatsItem> & Indexable<Rbx_StatsItem>;

// RunningAverageItemDouble
interface Rbx_RunningAverageItemDouble extends Rbx_StatsItem {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__120: never;
}
type RunningAverageItemDouble = Rbx_RunningAverageItemDouble & Base<Rbx_RunningAverageItemDouble> & Indexable<Rbx_RunningAverageItemDouble>;

// RunningAverageItemInt
interface Rbx_RunningAverageItemInt extends Rbx_StatsItem {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__121: never;
}
type RunningAverageItemInt = Rbx_RunningAverageItemInt & Base<Rbx_RunningAverageItemInt> & Indexable<Rbx_RunningAverageItemInt>;

// RunningAverageTimeIntervalItem
interface Rbx_RunningAverageTimeIntervalItem extends Rbx_StatsItem {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__122: never;
}
type RunningAverageTimeIntervalItem = Rbx_RunningAverageTimeIntervalItem & Base<Rbx_RunningAverageTimeIntervalItem> & Indexable<Rbx_RunningAverageTimeIntervalItem>;

// TotalCountTimeIntervalItem
interface Rbx_TotalCountTimeIntervalItem extends Rbx_StatsItem {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__123: never;
}
type TotalCountTimeIntervalItem = Rbx_TotalCountTimeIntervalItem & Base<Rbx_TotalCountTimeIntervalItem> & Indexable<Rbx_TotalCountTimeIntervalItem>;

// StopWatchReporter
interface Rbx_StopWatchReporter extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__124: never;
}
type StopWatchReporter = Rbx_StopWatchReporter & Base<Rbx_StopWatchReporter> & Indexable<Rbx_StopWatchReporter>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "StopWatchReporter"): StopWatchReporter;
}

// Studio
interface Rbx_Studio extends Rbx_Instance {
	["Always Save Script Changes"]: boolean;
	["Animate Hover Over"]: boolean;
	["Attach Debugger To"]: Enum.DEPRECATED_DebuggerDataModelPreference;
	["Auto Indent"]: boolean;
	["Auto-Recovery Enabled"]: boolean;
	["Auto-Recovery Interval (Minutes)"]: number;
	["Auto-Recovery Path"]: QDir;
	["Auto-Save Enabled"]: boolean;
	["Auto-Save Interval (Minutes)"]: number;
	["Auto-Save Path"]: QDir;
	["Background Color"]: Color3;
	["Basic Objects Display Mode"]: Enum.ListDisplayMode;
	["Built-in Function Color"]: Color3;
	["Camera Mouse Wheel Speed"]: number;
	["Camera Shift Speed"]: number;
	["Camera Speed"]: number;
	["Camera Zoom to Mouse Position"]: boolean;
	["Clear Output On Start"]: boolean;
	["Comment Color"]: Color3;
	DefaultScriptFileDir: QDir;
	DeprecatedObjectsShown: boolean;
	["Device Pairing Code"]: number;
	["Disable Accurate Play Solo"]: boolean;
	["Drag Multiple Parts As Single Part"]: boolean;
	["Enable Autocomplete"]: boolean;
	["Enable CoreScript Debugger"]: boolean;
	["Error Color"]: Color3;
	["Find Selection Background Color"]: Color3;
	Font: QFont;
	["Hover Animate Speed"]: Enum.HoverAnimateSpeed;
	["Hover Over Color"]: Color3;
	["Import mesh files as single mesh"]: boolean;
	["Keyword Color"]: Color3;
	["Line Thickness"]: number;
	LuaDebuggerEnabled: boolean;
	readonly LuaDebuggerEnabledAtStartup: boolean;
	["Matching Word Background Color"]: Color3;
	["Maximum Output Lines"]: number;
	["Number Color"]: Color3;
	["Only Play Audio from Window in Focus"]: boolean;
	["Operator Color"]: Color3;
	["Output Font"]: QFont;
	["Output Layout Mode"]: Enum.OutputLayoutMode;
	OverrideCoreScripts: boolean;
	OverrideCoreScriptsDir: QDir;
	PermissionLevelShown: Enum.PermissionLevelShown;
	PluginsDir: QDir;
	["Preprocessor Color"]: Color3;
	RecentSavesDir: QDir;
	["Render Throttle Percentage"]: number;
	["Respect Studio shortcuts when game has focus"]: boolean;
	RuntimeUndoBehavior: Enum.RuntimeUndoBehavior;
	ScriptTimeoutLength: number;
	["Select Color"]: Color3;
	["Select/Hover Color"]: Color3;
	["Selection Background Color"]: Color3;
	["Selection Color"]: Color3;
	["Server Audio Behavior"]: Enum.ServerAudioBehavior;
	["Show Core GUI in Explorer while Playing"]: boolean;
	["Show Diagnostics Bar"]: boolean;
	["Show Hidden Objects in Explorer"]: boolean;
	["Show Hover Over"]: boolean;
	["Show Navigation Mesh"]: boolean;
	["Show Plugin GUI Service in Explorer"]: boolean;
	["Show QT warnings in output"]: boolean;
	["Show plus button on hover in Explorer"]: boolean;
	["String Color"]: Color3;
	["Tab Width"]: number;
	["Text Color"]: Color3;
	["Text Wrapping"]: boolean;
	Theme: Instance | undefined;
	readonly ["UI Theme"]: Enum.UITheme;
	["Warning Color"]: Color3;
}
type Studio = Rbx_Studio & Base<Rbx_Studio> & Indexable<Rbx_Studio>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "Studio"): Studio;
}

// StudioService
interface Rbx_StudioService extends Rbx_Instance {
	readonly ActiveScript: Instance | undefined;
}
type StudioService = Rbx_StudioService & Base<Rbx_StudioService> & Indexable<Rbx_StudioService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "StudioService"): StudioService;
}

// StudioTheme
interface Rbx_StudioTheme extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__125: never;
}
type StudioTheme = Rbx_StudioTheme & Base<Rbx_StudioTheme> & Indexable<Rbx_StudioTheme>;

// TaskScheduler
interface Rbx_TaskScheduler extends Rbx_Instance {
	readonly SchedulerDutyCycle: number;
	readonly SchedulerRate: number;
	ThreadPoolConfig: Enum.ThreadPoolConfig;
	readonly ThreadPoolSize: number;
}
type TaskScheduler = Rbx_TaskScheduler & Base<Rbx_TaskScheduler> & Indexable<Rbx_TaskScheduler>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "TaskScheduler"): TaskScheduler;
}

// Team
interface Rbx_Team extends Rbx_Instance {
	AutoAssignable: boolean;
	TeamColor: BrickColor;
}
type Team = Rbx_Team & Base<Rbx_Team> & Indexable<Rbx_Team>;

// Teams
interface Rbx_Teams extends Rbx_Instance {
}
type Teams = Rbx_Teams & Base<Rbx_Teams> & Indexable<Rbx_Teams>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "Teams"): Teams;
}

// TeleportService
interface Rbx_TeleportService extends Rbx_Instance {
	GetArrivingTeleportGui(): Instance | undefined;
	GetLocalPlayerTeleportData(): unknown;
	GetTeleportSetting(setting: string): unknown;
	SetTeleportGui(gui: Instance): void;
	SetTeleportSetting(setting: string, value?: any): void;
	TeleportToPlaceInstance(placeId: number, instanceId: string, player?: Instance, spawnName?: string, teleportData?: any, customLoadingScreen?: Instance): void;
	TeleportToSpawnByName(placeId: number, spawnName: string, player?: Instance, teleportData?: any, customLoadingScreen?: Instance): void;
	readonly LocalPlayerArrivedFromTeleport: RBXScriptSignal<(loadingGui: Instance, dataTable?: any) => void>;
}
type TeleportService = Rbx_TeleportService & Base<Rbx_TeleportService> & Indexable<Rbx_TeleportService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "TeleportService"): TeleportService;
}

// TerrainRegion
interface Rbx_TerrainRegion extends Rbx_Instance {
	readonly SizeInCells: Vector3;
}
type TerrainRegion = Rbx_TerrainRegion & Base<Rbx_TerrainRegion> & Indexable<Rbx_TerrainRegion>;

// TestService
interface Rbx_TestService extends Rbx_Instance {
	AutoRuns: boolean;
	Description: string;
	readonly ErrorCount: number;
	ExecuteWithStudioRun: boolean;
	Is30FpsThrottleEnabled: boolean;
	IsPhysicsEnvironmentalThrottled: boolean;
	IsSleepAllowed: boolean;
	NumberOfPlayers: number;
	SimulateSecondsLag: number;
	readonly TestCount: number;
	Timeout: number;
	readonly WarnCount: number;
	Check(condition: boolean, description: string, source?: Instance, line?: number): void;
	Checkpoint(text: string, source?: Instance, line?: number): void;
	Done(): void;
	Error(description: string, source?: Instance, line?: number): void;
	Fail(description: string, source?: Instance, line?: number): void;
	Message(text: string, source?: Instance, line?: number): void;
	Require(condition: boolean, description: string, source?: Instance, line?: number): void;
	Warn(condition: boolean, description: string, source?: Instance, line?: number): void;
	isFeatureEnabled(name: string): boolean;
	readonly ServerCollectConditionalResult: RBXScriptSignal<(condition: boolean, text: string, script: Instance, line: number) => void>;
	readonly ServerCollectResult: RBXScriptSignal<(text: string, script: Instance, line: number) => void>;
}
type TestService = Rbx_TestService & Base<Rbx_TestService> & Indexable<Rbx_TestService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "TestService"): TestService;
}

// TextFilterResult
interface Rbx_TextFilterResult extends Rbx_Instance {
	GetChatForUserAsync(toUserId: number): string;
	GetNonChatStringForBroadcastAsync(): string;
	GetNonChatStringForUserAsync(toUserId: number): string;
}
type TextFilterResult = Rbx_TextFilterResult & Base<Rbx_TextFilterResult> & Indexable<Rbx_TextFilterResult>;

// TextService
interface Rbx_TextService extends Rbx_Instance {
	GetTextSize(string: string, fontSize: number, font: Enum.Font, frameSize: Vector2): Vector2;
	FilterStringAsync(stringToFilter: string, fromUserId: number, textContext?: Enum.TextFilterContext): Instance | undefined;
}
type TextService = Rbx_TextService & Base<Rbx_TextService> & Indexable<Rbx_TextService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "TextService"): TextService;
}

// ThirdPartyUserService
interface Rbx_ThirdPartyUserService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__126: never;
}
type ThirdPartyUserService = Rbx_ThirdPartyUserService & Base<Rbx_ThirdPartyUserService> & Indexable<Rbx_ThirdPartyUserService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "ThirdPartyUserService"): ThirdPartyUserService;
}

// TimerService
interface Rbx_TimerService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__127: never;
}
type TimerService = Rbx_TimerService & Base<Rbx_TimerService> & Indexable<Rbx_TimerService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "TimerService"): TimerService;
}

// TouchInputService
interface Rbx_TouchInputService extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__128: never;
}
type TouchInputService = Rbx_TouchInputService & Base<Rbx_TouchInputService> & Indexable<Rbx_TouchInputService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "TouchInputService"): TouchInputService;
}

// TouchTransmitter
interface Rbx_TouchTransmitter extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__129: never;
}
type TouchTransmitter = Rbx_TouchTransmitter & Base<Rbx_TouchTransmitter> & Indexable<Rbx_TouchTransmitter>;

// Trail
interface Rbx_Trail extends Rbx_Instance {
	Attachment0: Attachment;
	Attachment1: Attachment;
	Color: ColorSequence;
	Enabled: boolean;
	FaceCamera: boolean;
	Lifetime: number;
	LightEmission: number;
	LightInfluence: number;
	MaxLength: number;
	MinLength: number;
	Texture: string;
	TextureLength: number;
	TextureMode: Enum.TextureMode;
	Transparency: NumberSequence;
	WidthScale: NumberSequence;
	Clear(): void;
}
type Trail = Rbx_Trail & Base<Rbx_Trail> & Indexable<Rbx_Trail>;

// Translator
interface Rbx_Translator extends Rbx_Instance {
	readonly LocaleId: string;
	FormatByKey(key: string, args?: any): string;
	Translate(context: Instance, text: string): string;
}
type Translator = Rbx_Translator & Base<Rbx_Translator> & Indexable<Rbx_Translator>;

// TweenBase
interface Rbx_TweenBase extends Rbx_Instance {
	/** The current state of how the tween is animating. Possible values are Begin, Playing, Paused, Completed and Cancelled. This property is modified by using functions such as Tween:Play(), Tween:Pause(), and Tween:Cancel(). Read-only. */
	readonly PlaybackState: Enum.PlaybackState;
	/** Stops the tween animation. Animation can be restarted by calling Play(). Animation will start from the beginning values. */
	Cancel(): void;
	/** Temporarily stops the tween animation. Animation can be resumed by calling Play(). */
	Pause(): void;
	/** Starts or resumes (if Tween.PlaybackState is Paused) the tween animation. If current PlaybackState is Cancelled, this property will reset the tween to the beginning properties and play the animations from the beginning. */
	Play(): void;
	/** Fires when the tween either reaches PlaybackState Completed or Cancelled. PlaybackState of one of these types is passed as the first arg to the function listening to this event. */
	readonly Completed: RBXScriptSignal<(playbackState: Enum.PlaybackState) => void>;
}
type TweenBase = Rbx_TweenBase & Base<Rbx_TweenBase> & Indexable<Rbx_TweenBase>;

// Tween
interface Rbx_Tween extends Rbx_TweenBase {
	readonly Instance: Instance | undefined;
	readonly TweenInfo: TweenInfo;
}
type Tween = Rbx_Tween & Base<Rbx_Tween> & Indexable<Rbx_Tween>;

// TweenService
interface Rbx_TweenService extends Rbx_Instance {
}
type TweenService = Rbx_TweenService & Base<Rbx_TweenService> & Indexable<Rbx_TweenService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "TweenService"): TweenService;
}

// UIBase
interface Rbx_UIBase extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__130: never;
}
type UIBase = Rbx_UIBase & Base<Rbx_UIBase> & Indexable<Rbx_UIBase>;

// UIComponent
interface Rbx_UIComponent extends Rbx_UIBase {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__131: never;
}
type UIComponent = Rbx_UIComponent & Base<Rbx_UIComponent> & Indexable<Rbx_UIComponent>;

// UIConstraint
interface Rbx_UIConstraint extends Rbx_UIComponent {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__132: never;
}
type UIConstraint = Rbx_UIConstraint & Base<Rbx_UIConstraint> & Indexable<Rbx_UIConstraint>;

// UIAspectRatioConstraint
interface Rbx_UIAspectRatioConstraint extends Rbx_UIConstraint {
	/** The aspect ratio to maintain. This is the width/height. Only positive numbers allowed. */
	AspectRatio: number;
	/** Describes how the aspect ratio will determine its size. Options are FitWithinMaxSize, ScaleWithParentSize. FitWithinMaxSize will make the element the maximum size it can be within the current possible AbsoluteSize of the element while maintaining the AspectRatio. ScaleWithParentSize will make the element the closest to the parent element’s maximum size while maintaining aspect ratio. */
	AspectType: Enum.AspectType;
	/** Describes which axis to use when determining the new size of the element, while keeping respect to the aspect ratio. */
	DominantAxis: Enum.DominantAxis;
}
type UIAspectRatioConstraint = Rbx_UIAspectRatioConstraint & Base<Rbx_UIAspectRatioConstraint> & Indexable<Rbx_UIAspectRatioConstraint>;

// UISizeConstraint
interface Rbx_UISizeConstraint extends Rbx_UIConstraint {
	/** The biggest size the GuiObject is allowed to be. */
	MaxSize: Vector2;
	/** The smallest size the GuiObject is allowed to be. */
	MinSize: Vector2;
}
type UISizeConstraint = Rbx_UISizeConstraint & Base<Rbx_UISizeConstraint> & Indexable<Rbx_UISizeConstraint>;

// UITextSizeConstraint
interface Rbx_UITextSizeConstraint extends Rbx_UIConstraint {
	/** The biggest size the font is allowed to be. */
	MaxTextSize: number;
	/** The smallest size the font is allowed to be. */
	MinTextSize: number;
}
type UITextSizeConstraint = Rbx_UITextSizeConstraint & Base<Rbx_UITextSizeConstraint> & Indexable<Rbx_UITextSizeConstraint>;

// UILayout
interface Rbx_UILayout extends Rbx_UIComponent {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__133: never;
}
type UILayout = Rbx_UILayout & Base<Rbx_UILayout> & Indexable<Rbx_UILayout>;

// UIGridStyleLayout
interface Rbx_UIGridStyleLayout extends Rbx_UILayout {
	readonly AbsoluteContentSize: Vector2;
	/** Determines which direction to fill the grid. Can be Horizontal or Vertical. */
	FillDirection: Enum.FillDirection;
	/** Determines how grid is placed within it's parent's container in the x direction. Can be Left, Center, or Right. */
	HorizontalAlignment: Enum.HorizontalAlignment;
	/** Determines how we decide which element to place next. Can be Name or Custom. If using Custom, make sure SetCustomSortFunction was called with an appropriate sort function. */
	SortOrder: Enum.SortOrder;
	/** Determines how grid is placed within it's parent's container in the y direction. Can be Top, Center, or Bottom. */
	VerticalAlignment: Enum.VerticalAlignment;
	/** Forces a relayout of all elements. Useful when sort is set to Custom. */
	ApplyLayout(): void;
}
type UIGridStyleLayout = Rbx_UIGridStyleLayout & Base<Rbx_UIGridStyleLayout> & Indexable<Rbx_UIGridStyleLayout>;

// UIGridLayout
interface Rbx_UIGridLayout extends Rbx_UIGridStyleLayout {
	/** How much space between elements there should be. */
	CellPadding: UDim2;
	/** Denotes what size each element should be. Can be overridden by elements using constraints on individual elements. */
	CellSize: UDim2;
	/** Determines how many cells over in the FillDirection we go before starting a new row or column. Set to 0 for max cell count.  Will be clamped if this is set higher than the parent container allows room for. */
	FillDirectionMaxCells: number;
	/** Which corner we start laying the elements out from. Can be TopLeft, TopRight, BottomLeft, BottomRight. */
	StartCorner: Enum.StartCorner;
}
type UIGridLayout = Rbx_UIGridLayout & Base<Rbx_UIGridLayout> & Indexable<Rbx_UIGridLayout>;

// UIListLayout
interface Rbx_UIListLayout extends Rbx_UIGridStyleLayout {
	/** Determines the amount of free space between each element. Can be set either using scale (Percentage of parent's size in the current direction) or offset (a static spacing value, similar to pixel size). */
	Padding: UDim;
}
type UIListLayout = Rbx_UIListLayout & Base<Rbx_UIListLayout> & Indexable<Rbx_UIListLayout>;

// UIPageLayout
interface Rbx_UIPageLayout extends Rbx_UIGridStyleLayout {
	/** Whether or not to animate transitions between pages. */
	Animated: boolean;
	/** Whether or not the page layout wraps around at the ends. */
	Circular: boolean;
	/** The page that is either currently being displayed or is the target of the current animation. */
	readonly CurrentPage: GuiObject;
	/** The easing direction to use when performing an animation. */
	EasingDirection: Enum.EasingDirection;
	/** The easing style to use when performing an animation. */
	EasingStyle: Enum.EasingStyle;
	GamepadInputEnabled: boolean;
	/** Determines the amount that pages are separated from each other by. Can be set either using scale (Percentage of parent's size in the current direction) or offset (a static spacing value, similar to pixel size). */
	Padding: UDim;
	ScrollWheelInputEnabled: boolean;
	TouchInputEnabled: boolean;
	/** The length of the animation. */
	TweenTime: number;
	/** If the instance is in the layout, then it sets CurrentPage to it and animtes to it. If circular layout is set, it will take the shortest path. */
	JumpTo(page: Instance): void;
	/** If the index is >= 0 and less than the size of the layout, acts like JumpTo. If it's out of bounds and circular is set, it will animate the full distance between the in-bounds index of CurrentPage and the new index. */
	JumpToIndex(index: number): void;
	/** Sets CurrentPage to the page after the current page and animates to it, or does nothing if there isn't a next page. */
	Next(): void;
	/** Sets CurrentPage to the page after the current page and animates to it, or does nothing if there isn't a next page. */
	Previous(): void;
	/** Fires when a page comes into view, and is going to be rendered. */
	readonly PageEnter: RBXScriptSignal<(page: Instance) => void>;
	/** Fires when a page leaves view, and will not be rendered. */
	readonly PageLeave: RBXScriptSignal<(page: Instance) => void>;
	/** Fires when an animation to CurrentPage is completed without being cancelled, and the view stops scrolling. */
	readonly Stopped: RBXScriptSignal<(currentPage: Instance) => void>;
}
type UIPageLayout = Rbx_UIPageLayout & Base<Rbx_UIPageLayout> & Indexable<Rbx_UIPageLayout>;

// UITableLayout
interface Rbx_UITableLayout extends Rbx_UIGridStyleLayout {
	/** Whether the table should expand to fill the available space of its container, column-wise. */
	FillEmptySpaceColumns: boolean;
	/** Whether the table should expand to fill the available space of its container, row-wise. */
	FillEmptySpaceRows: boolean;
	/** Whether the direct siblings are considered the rows or the columns. The children of the direct siblings are the columns or rows, respectively. */
	MajorAxis: Enum.TableMajorAxis;
	/** The amount of padding to insert in between the cells of the table. */
	Padding: UDim2;
}
type UITableLayout = Rbx_UITableLayout & Base<Rbx_UITableLayout> & Indexable<Rbx_UITableLayout>;

// UIPadding
interface Rbx_UIPadding extends Rbx_UIComponent {
	/** The padding to apply on the bottom side relative to the parent's normal size. */
	PaddingBottom: UDim;
	/** The padding to apply on the left side relative to the parent's normal size. */
	PaddingLeft: UDim;
	/** The padding to apply on the right side relative to the parent's normal size. */
	PaddingRight: UDim;
	/** The padding to apply on the top side relative to the parent's normal size. */
	PaddingTop: UDim;
}
type UIPadding = Rbx_UIPadding & Base<Rbx_UIPadding> & Indexable<Rbx_UIPadding>;

// UIScale
interface Rbx_UIScale extends Rbx_UIComponent {
	/** The scale factor to apply. */
	Scale: number;
}
type UIScale = Rbx_UIScale & Base<Rbx_UIScale> & Indexable<Rbx_UIScale>;

// UserGameSettings
interface Rbx_UserGameSettings extends Rbx_Instance {
	ComputerCameraMovementMode: Enum.ComputerCameraMovementMode;
	ComputerMovementMode: Enum.ComputerMovementMode;
	ControlMode: Enum.ControlMode;
	GamepadCameraSensitivity: number;
	MasterVolume: number;
	MouseSensitivity: number;
	RCCProfilerRecordFrameRate: number;
	RCCProfilerRecordTimeFrame: number;
	RotationType: Enum.RotationType;
	SavedQualityLevel: Enum.SavedQualitySetting;
	TouchCameraMovementMode: Enum.TouchCameraMovementMode;
	TouchMovementMode: Enum.TouchMovementMode;
	GetCameraYInvertValue(): number;
	GetOnboardingCompleted(onboardingId: string): boolean;
	InFullScreen(): boolean;
	InStudioMode(): boolean;
	SetCameraYInvertVisible(): void;
	SetGamepadCameraSensitivityVisible(): void;
	SetOnboardingCompleted(onboardingId: string): void;
	readonly FullscreenChanged: RBXScriptSignal<(isFullscreen: boolean) => void>;
	readonly StudioModeChanged: RBXScriptSignal<(isStudioMode: boolean) => void>;
}
type UserGameSettings = Rbx_UserGameSettings & Base<Rbx_UserGameSettings> & Indexable<Rbx_UserGameSettings>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "UserGameSettings"): UserGameSettings;
}

// UserInputService
interface Rbx_UserInputService extends Rbx_Instance {
	/** Returns true if the local device has an accelerometer, false otherwise. */
	readonly AccelerometerEnabled: boolean;
	readonly GamepadEnabled: boolean;
	/** Returns true if the local device has an gyroscope, false otherwise. */
	readonly GyroscopeEnabled: boolean;
	/** Returns true if the local device accepts keyboard input, false otherwise. */
	readonly KeyboardEnabled: boolean;
	ModalEnabled: boolean;
	MouseBehavior: Enum.MouseBehavior;
	MouseDeltaSensitivity: number;
	/** Returns true if the local device accepts mouse input, false otherwise. */
	readonly MouseEnabled: boolean;
	MouseIconEnabled: boolean;
	readonly OnScreenKeyboardPosition: Vector2;
	readonly OnScreenKeyboardSize: Vector2;
	readonly OnScreenKeyboardVisible: boolean;
	/** Returns true if the local device accepts touch input, false otherwise. */
	readonly TouchEnabled: boolean;
	readonly VREnabled: boolean;
	GamepadSupports(gamepadNum: Enum.UserInputType, gamepadKeyCode: Enum.KeyCode): boolean;
	/** Returns an InputObject that describes the device's current acceleration. This is fired with an InputObject, which has type Enum.InputType.Accelerometer, and position that shows the g force in each local device axis.  The delta property describes the amount of rotation that last happened. This event only fires locally. */
	GetDeviceAcceleration(): Instance | undefined;
	/** Returns an InputObject that describes the device's current gravity vector. This is fired with an InputObject, which has type Enum.InputType.Accelerometer, and position that shows the g force in each local device axis. The delta property describes the amount of rotation that last happened. This event only fires locally. */
	GetDeviceGravity(): Instance | undefined;
	GetFocusedTextBox(): Instance | undefined;
	GetGamepadConnected(gamepadNum: Enum.UserInputType): boolean;
	GetLastInputType(): Enum.UserInputType;
	GetMouseDelta(): Vector2;
	GetMouseLocation(): Vector2;
	GetUserCFrame(type: Enum.UserCFrame): CFrame;
	IsGamepadButtonDown(gamepadNum: Enum.UserInputType, gamepadKeyCode: Enum.KeyCode): boolean;
	IsKeyDown(keyCode: Enum.KeyCode): boolean;
	IsMouseButtonPressed(mouseButton: Enum.UserInputType): boolean;
	IsNavigationGamepad(gamepadEnum: Enum.UserInputType): boolean;
	RecenterUserHeadCFrame(): void;
	SetNavigationGamepad(gamepadEnum: Enum.UserInputType, enabled: boolean): void;
	/** Fired when a user moves a device that has an accelerometer. This is fired with an InputObject, which has type Enum.InputType.Accelerometer, and position that shows the g force in each local device axis. This event only fires locally. */
	readonly DeviceAccelerationChanged: RBXScriptSignal<(acceleration: Instance) => void>;
	/** Fired when the force of gravity changes on a device that has an accelerometer. This is fired with an InputObject, which has type Enum.InputType.Accelerometer, and position that shows the g force in each local device axis. This event only fires locally. */
	readonly DeviceGravityChanged: RBXScriptSignal<(gravity: Instance) => void>;
	/** Fired when a user rotates a device that has an gyroscope. This is fired with an InputObject, which has type Enum.InputType.Gyroscope, and position that shows total rotation in each local device axis.  The delta property describes the amount of rotation that last happened. A second argument of Vector4 is the device's current quaternion rotation in reference to it's default reference frame. This event only fires locally. */
	readonly DeviceRotationChanged: RBXScriptSignal<(rotation: Instance, cframe: CFrame) => void>;
	readonly GamepadConnected: RBXScriptSignal<(gamepadNum: Enum.UserInputType) => void>;
	readonly GamepadDisconnected: RBXScriptSignal<(gamepadNum: Enum.UserInputType) => void>;
	readonly JumpRequest: RBXScriptSignal<() => void>;
	readonly LastInputTypeChanged: RBXScriptSignal<(lastInputType: Enum.UserInputType) => void>;
	/** Fired when a user stops text entry into a textbox (usually by pressing return or clicking/tapping somewhere else on the screen). Argument is the textbox that was taken out of focus. This event only fires locally. */
	readonly TextBoxFocusReleased: RBXScriptSignal<(textboxReleased: Instance) => void>;
	/** Fired when a user clicks/taps on a textbox to begin text entry. Argument is the textbox that was put in focus. This also fires if a textbox forces focus on the user. This event only fires locally. */
	readonly TextBoxFocused: RBXScriptSignal<(textboxFocused: Instance) => void>;
	/** Fired when a user moves their finger on a TouchEnabled device. 'touch' is an InputObject, which contains useful data for querying user input.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchEnded: RBXScriptSignal<(touch: Instance, gameProcessedEvent: boolean) => void>;
	/** Fired when a user holds at least one finger for a short amount of time on the same screen position on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the gesture. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchLongPress: RBXScriptSignal<(touchPositions: Array<any>, state: Enum.UserInputState, gameProcessedEvent: boolean) => void>;
	/** Fired when a user moves their finger on a TouchEnabled device. 'touch' is an InputObject, which contains useful data for querying user input.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchMoved: RBXScriptSignal<(touch: Instance, gameProcessedEvent: boolean) => void>;
	/** Fired when a user drags at least one finger on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the gesture. 'totalTranslation' is a Vector2, indicating how far the pan gesture has gone from its starting point. 'velocity' is a Vector2 that indicates how quickly the gesture is being performed in each dimension. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchPan: RBXScriptSignal<(touchPositions: Array<any>, totalTranslation: Vector2, velocity: Vector2, state: Enum.UserInputState, gameProcessedEvent: boolean) => void>;
	/** Fired when a user pinches their fingers on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the pinch gesture. 'scale' is a float that indicates the difference from the beginning of the pinch gesture. 'velocity' is a float indicating how quickly the pinch gesture is happening. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchPinch: RBXScriptSignal<(touchPositions: Array<any>, scale: number, velocity: number, state: Enum.UserInputState, gameProcessedEvent: boolean) => void>;
	/** Fired when a user rotates two fingers on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the gesture. 'rotation' is a float indicating how much the rotation has gone from the start of the gesture. 'velocity' is a float that indicates how quickly the gesture is being performed. 'state' indicates the Enum.UserInputState of the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchRotate: RBXScriptSignal<(touchPositions: Array<any>, rotation: number, velocity: number, state: Enum.UserInputState, gameProcessedEvent: boolean) => void>;
	/** Fired when a user places their finger on a TouchEnabled device. 'touch' is an InputObject, which contains useful data for querying user input.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchStarted: RBXScriptSignal<(touch: Instance, gameProcessedEvent: boolean) => void>;
	/** Fired when a user swipes their fingers on a TouchEnabled device. 'swipeDirection' is an Enum.SwipeDirection, indicating the direction the user swiped. 'numberOfTouches' is an int that indicates how many touches were involved with the gesture.  This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchSwipe: RBXScriptSignal<(swipeDirection: Enum.SwipeDirection, numberOfTouches: number, gameProcessedEvent: boolean) => void>;
	/** Fired when a user taps their finger on a TouchEnabled device. 'touchPositions' is a Lua array of Vector2, each indicating the position of all the fingers involved in the tap gesture. This event only fires locally.  This event will always fire regardless of game state. */
	readonly TouchTap: RBXScriptSignal<(touchPositions: Array<any>, gameProcessedEvent: boolean) => void>;
	readonly TouchTapInWorld: RBXScriptSignal<(position: Vector2, processedByUI: boolean) => void>;
	readonly UserCFrameChanged: RBXScriptSignal<(type: Enum.UserCFrame, value: CFrame) => void>;
	readonly WindowFocusReleased: RBXScriptSignal<() => void>;
	readonly WindowFocused: RBXScriptSignal<() => void>;
}
type UserInputService = Rbx_UserInputService & Base<Rbx_UserInputService> & Indexable<Rbx_UserInputService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "UserInputService"): UserInputService;
}

// VRService
interface Rbx_VRService extends Rbx_Instance {
	GuiInputUserCFrame: Enum.UserCFrame;
	readonly VREnabled: boolean;
	GetTouchpadMode(pad: Enum.VRTouchpad): Enum.VRTouchpadMode;
	GetUserCFrame(type: Enum.UserCFrame): CFrame;
	GetUserCFrameEnabled(type: Enum.UserCFrame): boolean;
	RecenterUserHeadCFrame(): void;
	RequestNavigation(cframe: CFrame, inputUserCFrame: Enum.UserCFrame): void;
	SetTouchpadMode(pad: Enum.VRTouchpad, mode: Enum.VRTouchpadMode): void;
	readonly NavigationRequested: RBXScriptSignal<(cframe: CFrame, inputUserCFrame: Enum.UserCFrame) => void>;
	readonly TouchpadModeChanged: RBXScriptSignal<(pad: Enum.VRTouchpad, mode: Enum.VRTouchpadMode) => void>;
	readonly UserCFrameChanged: RBXScriptSignal<(type: Enum.UserCFrame, value: CFrame) => void>;
	readonly UserCFrameEnabled: RBXScriptSignal<(type: Enum.UserCFrame, enabled: boolean) => void>;
}
type VRService = Rbx_VRService & Base<Rbx_VRService> & Indexable<Rbx_VRService>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "VRService"): VRService;
}

// ValueBase
interface Rbx_ValueBase extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__134: never;
}
type ValueBase = Rbx_ValueBase & Base<Rbx_ValueBase> & Indexable<Rbx_ValueBase>;

// BinaryStringValue
interface Rbx_BinaryStringValue extends Rbx_ValueBase {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__135: never;
}
type BinaryStringValue = Rbx_BinaryStringValue & Base<Rbx_BinaryStringValue> & Indexable<Rbx_BinaryStringValue>;

// BoolValue
interface Rbx_BoolValue extends Rbx_ValueBase {
	Value: boolean;
}
type BoolValue = Rbx_BoolValue & Base<Rbx_BoolValue> & Indexable<Rbx_BoolValue>;

// BrickColorValue
interface Rbx_BrickColorValue extends Rbx_ValueBase {
	Value: BrickColor;
}
type BrickColorValue = Rbx_BrickColorValue & Base<Rbx_BrickColorValue> & Indexable<Rbx_BrickColorValue>;

// CFrameValue
interface Rbx_CFrameValue extends Rbx_ValueBase {
	Value: CFrame;
}
type CFrameValue = Rbx_CFrameValue & Base<Rbx_CFrameValue> & Indexable<Rbx_CFrameValue>;

// Color3Value
interface Rbx_Color3Value extends Rbx_ValueBase {
	Value: Color3;
}
type Color3Value = Rbx_Color3Value & Base<Rbx_Color3Value> & Indexable<Rbx_Color3Value>;

// DoubleConstrainedValue
interface Rbx_DoubleConstrainedValue extends Rbx_ValueBase {
	ConstrainedValue: number;
	/** The maximum we allow this Value to be set.  If Value is set higher than this, it automatically gets adjusted to MaxValue */
	MaxValue: number;
	/** The minimum we allow this Value to be set.  If Value is set lower than this, it automatically gets adjusted to MinValue */
	MinValue: number;
	Value: number;
}
type DoubleConstrainedValue = Rbx_DoubleConstrainedValue & Base<Rbx_DoubleConstrainedValue> & Indexable<Rbx_DoubleConstrainedValue>;

// IntConstrainedValue
interface Rbx_IntConstrainedValue extends Rbx_ValueBase {
	ConstrainedValue: number;
	MaxValue: number;
	MinValue: number;
	Value: number;
}
type IntConstrainedValue = Rbx_IntConstrainedValue & Base<Rbx_IntConstrainedValue> & Indexable<Rbx_IntConstrainedValue>;

// IntValue
interface Rbx_IntValue extends Rbx_ValueBase {
	Value: number;
}
type IntValue = Rbx_IntValue & Base<Rbx_IntValue> & Indexable<Rbx_IntValue>;

// NumberValue
interface Rbx_NumberValue extends Rbx_ValueBase {
	Value: number;
}
type NumberValue = Rbx_NumberValue & Base<Rbx_NumberValue> & Indexable<Rbx_NumberValue>;

// ObjectValue
interface Rbx_ObjectValue extends Rbx_ValueBase {
	Value: Instance | undefined;
}
type ObjectValue = Rbx_ObjectValue & Base<Rbx_ObjectValue> & Indexable<Rbx_ObjectValue>;

// RayValue
interface Rbx_RayValue extends Rbx_ValueBase {
	Value: Ray;
}
type RayValue = Rbx_RayValue & Base<Rbx_RayValue> & Indexable<Rbx_RayValue>;

// StringValue
interface Rbx_StringValue extends Rbx_ValueBase {
	Value: string;
}
type StringValue = Rbx_StringValue & Base<Rbx_StringValue> & Indexable<Rbx_StringValue>;

// Vector3Value
interface Rbx_Vector3Value extends Rbx_ValueBase {
	Value: Vector3;
}
type Vector3Value = Rbx_Vector3Value & Base<Rbx_Vector3Value> & Indexable<Rbx_Vector3Value>;

// VirtualInputManager
interface Rbx_VirtualInputManager extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__136: never;
}
type VirtualInputManager = Rbx_VirtualInputManager & Base<Rbx_VirtualInputManager> & Indexable<Rbx_VirtualInputManager>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "VirtualInputManager"): VirtualInputManager;
}

// VirtualUser
interface Rbx_VirtualUser extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__137: never;
}
type VirtualUser = Rbx_VirtualUser & Base<Rbx_VirtualUser> & Indexable<Rbx_VirtualUser>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "VirtualUser"): VirtualUser;
}

// Visit
interface Rbx_Visit extends Rbx_Instance {
	/** **INTERNAL DO NOT USE** [#32](https://github.com/roblox-ts/rbx-types/issues/32) */
	__138: never;
}
type Visit = Rbx_Visit & Base<Rbx_Visit> & Indexable<Rbx_Visit>;
interface Rbx_ServiceProvider extends Rbx_Instance {
	GetService(className: "Visit"): Visit;
}

// WeldConstraint
interface Rbx_WeldConstraint extends Rbx_Instance {
	/** Read-only boolean, true if the joint is active in world. Rigid joints may be inactive if they are redundant or form cycles. */
	readonly Active: boolean;
	Enabled: boolean;
	Part0: BasePart;
	Part1: BasePart;
}
type WeldConstraint = Rbx_WeldConstraint & Base<Rbx_WeldConstraint> & Indexable<Rbx_WeldConstraint>;

